import _require from "../0c62c2fd/653470";
import { throwTypeError } from "../figma_app/465776";
import { ServiceCategories as _$$e } from "../905/165054";
import { LogToConsoleMode, WhiteboardIntegrationType, Fullscreen, PerfResult } from "../figma_app/763686";
import { atomStoreManager } from "../figma_app/27355";
import d from "../vendor/197638";
import { trackEventAnalytics } from "../905/449184";
import { debugState } from "../905/407919";
import { Timer } from "../905/609396";
import { reportError } from "../905/11";
import { getI18nString } from "../905/303541";
import { VisualBellActions } from "../905/302958";
import { VisualBellIcon } from "../905/576487";
import { A as _$$A } from "../905/658244";
import { registerModal, createModalConfig } from "../905/102752";
import { showModalHandler, hideModalHandler } from "../905/156213";
import { D as _$$D2 } from "../905/758526";
import { P as _$$P } from "../905/813637";
import { eg as _$$eg, a4 } from "../figma_app/576669";
import { sha1Hex, sha1BytesFromHex } from "../905/125019";
import { logError, logInfo } from "../905/714362";
import { imageProcessor } from "../figma_app/291892";
let n;
let $$r1;
var c = d;
let C = "image/png";
async function T(e) {
  return new Uint8Array(await e.arrayBuffer());
}
async function k(e) {
  if (!e.startsWith("blob:")) return null;
  let t = await fetch(e);
  return t.ok ? t.blob() : null;
}
async function R(e, t, i) {
  let n = await T(e);
  if (e.type !== C) {
    logError("pdf", "PDF image type was: '" + e.type + "', expected " + C);
    return null;
  }
  let r = (await imageProcessor.decodeAsync(n, e.type, t, i, !1)).rgba;
  return r ? imageProcessor.encodeInPlace(t, i, r, !1, 1, !1) : (logError("pdf", "Decoded PDF image returned no rgba data."), null);
}
async function N(e) {
  let t = e.href.baseVal;
  let i = await k(t);
  if (!i) return null;
  let n = e.width.baseVal.value;
  let r = e.height.baseVal.value;
  let a = await R(i, n, r);
  if (!a) throw Error("Couldn't compress!!");
  let s = sha1Hex(a);
  e.removeAttribute("href");
  e.removeAttribute("xlink:href");
  e.setAttribute("imageHash", s);
  let o = sha1BytesFromHex(s);
  return {
    name: "Image",
    bytes: a,
    sha1Hash: s,
    sha1Bytes: o
  };
}
async function P(e) {
  let t = Array.from(e.querySelectorAll("image"));
  return (await Promise.all(t.map(N))).reduce((e, t) => null !== t ? {
    ...e,
    images: [...e.images, t]
  } : {
    ...e,
    hadImageError: !0
  }, {
    images: [],
    hadImageError: !1
  });
}
let O = {
  328: "\u015E",
  329: "\u015F",
  330: "\u0162",
  331: "\u0163",
  364: "f",
  365: "i",
  366: "l",
  367: "fi",
  368: "fl",
  369: "f",
  370: "g",
  371: "j"
};
let D = {
  156: "\u015E",
  163: "\u0162",
  276: "i",
  359: "\u015F",
  365: "\u0163",
  407: "a",
  408: "o",
  419: "0",
  420: "1",
  421: "2",
  422: "3",
  423: "4",
  425: "1/2",
  426: "1/4",
  446: "\xb7",
  447: "\xb7",
  550: "\u0308",
  551: "\u0307",
  552: "\u012C",
  553: "\u012D",
  554: "\u030B",
  555: "\u0302",
  556: "\u030C",
  557: "\u0306",
  558: "\u030A",
  559: "\u012F",
  560: "\u0304",
  561: "\u0135",
  562: "\u030F",
  564: "\u031B",
  565: "\u0143",
  566: "\u0324",
  567: "\u0326",
  568: "\u0327",
  569: "\u0328",
  570: "\u032E",
  571: "\u0331"
};
let L = {
  427: "f",
  428: "i",
  429: "l",
  430: "fi",
  431: "fl",
  432: "a",
  433: "b",
  434: "b",
  435: "e",
  436: "g",
  437: "h",
  438: "h",
  439: "i",
  440: "i",
  441: "l",
  442: "l",
  443: "m",
  444: "n",
  445: "p",
  446: "p",
  447: "r",
  448: "s",
  449: "t",
  450: "t",
  451: "u",
  452: "u",
  453: "v",
  454: "v",
  455: "w",
  456: "x",
  457: "x",
  458: "y",
  459: "z",
  460: "z",
  461: "j",
  462: "f",
  463: "f",
  464: "B",
  465: "C",
  466: "D",
  467: "F",
  468: "G",
  469: "H",
  470: "I",
  471: "J",
  472: "K",
  473: "P",
  474: "Q",
  475: "T",
  476: "U",
  477: "V",
  478: "W",
  479: "X",
  480: "Y",
  481: "q",
  482: "q",
  483: "c",
  484: "a",
  485: "c",
  486: "j",
  487: "w",
  488: "y",
  489: "n",
  490: "o",
  491: "o",
  492: "s",
  493: "e",
  494: "r",
  495: "d",
  496: "d",
  497: "m",
  498: "g",
  499: "k",
  500: "k",
  501: "t",
  502: "H",
  503: "C",
  504: "D",
  505: "Q",
  506: "U",
  507: "V",
  508: "X",
  509: "Y",
  510: "E",
  511: "A",
  512: "A",
  513: "B",
  514: "E",
  515: "T",
  516: "F",
  517: "G",
  518: "I",
  519: "J",
  520: "K",
  521: "L",
  522: "L",
  523: "M",
  524: "M",
  525: "N",
  526: "N",
  527: "O",
  528: "O",
  529: "P",
  530: "R",
  531: "R",
  532: "S",
  533: "S",
  534: "W",
  535: "Z",
  536: "Z"
};
let F = {
  211: "f",
  212: "i",
  213: "l",
  214: "fi",
  215: "t"
};
let M = {
  228: "i",
  240: "j",
  669: "0",
  670: "1",
  671: "2",
  672: "3",
  673: "4",
  674: "5",
  675: "6",
  676: "7",
  677: "8",
  678: "9",
  679: "0",
  680: "1",
  681: "2",
  682: "3",
  683: "4",
  684: "5",
  685: "6",
  686: "7",
  687: "8",
  688: "9",
  689: "1/2",
  690: "1/3",
  691: "1/3",
  692: "1/4",
  693: "1/4",
  694: "1/5",
  695: "1/5",
  696: "1/5",
  697: "1/5",
  698: "1/6",
  699: "1/6",
  700: "1/7",
  701: "1/8",
  702: "1/8",
  703: "1/8",
  704: "1/8",
  705: "1/9",
  764: "\u0326",
  765: "\u030C",
  771: "\u0301",
  772: "\u0300",
  773: "\u0309",
  774: "\u0303",
  775: "\u0301",
  776: "\u030C",
  777: "\u0300",
  778: "\u0301",
  779: "\u0306",
  780: "\u0300",
  781: "\u0309",
  782: "\u0304",
  783: "\u0303",
  798: "\u0309",
  799: "\u0301",
  800: "\u0300",
  801: "\u0309",
  802: "\u0303",
  803: "\u0301",
  804: "\u030C",
  805: "\u0300",
  806: "\u0301",
  807: "\u0306",
  808: "\u0300",
  809: "\u0309",
  810: "\u0304",
  811: "\u0303"
};
let j = {
  103: "/",
  228: "i",
  240: "j",
  649: "0",
  650: "1",
  651: "2",
  652: "3",
  653: "4",
  654: "5",
  655: "6",
  656: "7",
  657: "8",
  658: "9",
  659: "\u2070",
  660: "\xb9",
  661: "\xb2",
  662: "\xb3",
  663: "\u2074",
  664: "\u2075",
  665: "\u2076",
  666: "\u2077",
  667: "\u2078",
  668: "\u2079",
  744: "\u0326",
  745: "\u030C",
  751: "\u0301",
  752: "\u0300",
  753: "\u0309",
  754: "\u0303",
  755: "\u0301",
  756: "\u030C",
  757: "\u0300",
  758: "\u0301",
  759: "\u0306",
  760: "\u0300",
  761: "\u0309",
  762: "\u0304",
  763: "\u0303",
  778: "\u0309",
  779: "\u0301",
  780: "\u0300",
  781: "\u0309",
  782: "\u0303",
  783: "\u0301",
  784: "\u030C",
  785: "\u0300",
  786: "\u0301",
  787: "\u0306",
  788: "\u0300",
  789: "\u0309",
  790: "\u0304",
  791: "\u0303"
};
let U = {
  103: "1/",
  170: "i",
  171: "l",
  228: "i",
  240: "j",
  649: "0",
  650: "1",
  651: "2",
  652: "3",
  653: "4",
  654: "5",
  655: "6",
  656: "7",
  657: "8",
  658: "9",
  659: "\u2070",
  660: "\xb9",
  661: "\xb2",
  662: "\xb3",
  663: "\u2074",
  664: "\u2075",
  665: "\u2076",
  666: "\u2077",
  667: "\u2078",
  668: "\u2079",
  744: "\u0326",
  745: "\u030C",
  751: "\u0301",
  752: "\u0300",
  753: "\u0309",
  754: "\u0303",
  755: "\u0301",
  756: "\u030C",
  757: "\u0300",
  758: "\u0301",
  759: "\u0306",
  760: "\u0300",
  761: "\u0309",
  762: "\u0304",
  763: "\u0303",
  778: "\u0309",
  779: "\u0301",
  780: "\u0300",
  781: "\u0309",
  782: "\u0303",
  783: "\u0301",
  784: "\u030C",
  785: "\u0300",
  786: "\u0301",
  787: "\u0306",
  788: "\u0300",
  789: "\u0309",
  790: "\u0304",
  791: "\u0303"
};
let B = {
  108: "a",
  116: "2",
  117: "3",
  123: "1",
  124: "o",
  126: "1/4",
  127: "1/2",
  282: "\u015E",
  283: "\u015F",
  404: "4",
  419: "t",
  422: "o",
  423: "h"
};
let V = {
  243: "i",
  567: "j",
  1539: "\u0268",
  2191: "\u02E5\u02E6",
  2192: "\u02E5\u02E7",
  2193: "\u02E5\u02E8",
  2194: "\u02E5\u02E9",
  2195: "\u02E6\u02E5",
  2196: "\u02E6\u02E6",
  2197: "\u02E6\u02E7",
  2198: "\u02E6\u02E8",
  2199: "\u02E6\u02E9",
  2200: "\u02E6",
  2201: "\u02E7\u02E5",
  2202: "\u02E7\u02E6",
  2203: "\u02E7\u02E7",
  2204: "\u02E7\u02E8",
  2205: "\u02E7\u02E9",
  2206: "\u02E7",
  2207: "\u02E8\u02E5",
  2208: "\u02E8\u02E6",
  2209: "\u02E8\u02E7",
  2210: "\u02E8\u02E8",
  2211: "\u02E8\u02E9",
  2212: "\u02E8",
  2213: "\u02E9\u02E5",
  2214: "\u02E9\u02E6",
  2215: "\u02E9\u02E7",
  2216: "\u02E9\u02E8",
  2217: "\u02E9\u02E9",
  2218: "\u02E9",
  2219: "\u02E5\u02E5",
  2220: "\u02E5\u02E6",
  2221: "\u02E5\u02E7",
  2222: "\u02E5\u02E8",
  2223: "\u02E5\u02E9",
  2224: "\u02E5",
  2225: "\u02E6\u02E5",
  2226: "\u02E6\u02E7",
  2227: "\u02E6\u02E8",
  2228: "\u02E6\u02E9",
  2229: "\u02E7\u02E5",
  2230: "\u02E7\u02E6",
  2231: "\u02E7\u02E7",
  2232: "\u02E7\u02E8",
  2233: "\u02E7\u02E9",
  2234: "\u02E7",
  2235: "\u02E8\u02E5",
  2236: "\u02E8\u02E6",
  2237: "\u02E8\u02E7",
  2238: "\u02E8\u02E8",
  2239: "\u02E8\u02E9",
  2240: "\u02E8",
  2241: "\u02E9\u02E5",
  2242: "\u02E9\u02E6",
  2243: "\u02E9\u02E7",
  2244: "\u02E9\u02E8",
  2245: "\u02E9\u02E9",
  2246: "\u02E9",
  2247: "\u02E5\u02E5",
  2248: "\u02E5\u02E6",
  2249: "\u02E5\u02E7",
  2250: "\u02E5\u02E8",
  2251: "\u02E5\u02E9",
  2252: "\u02E5",
  2253: "\u02E6\u02E5",
  2254: "\u02E6\u02E6",
  2255: "\u02E6\u02E7",
  2256: "\u02E6\u02E8",
  2257: "\u02E6\u02E9",
  2258: "\u02E6",
  2259: "\u02E7\u02E5",
  2260: "\u02E7\u02E6",
  2261: "\u02E7\u02E8",
  2262: "\u02E7\u02E9",
  2263: "\u02E8\u02E5",
  2264: "\u02E8\u02E6",
  2265: "\u02E8\u02E7",
  2266: "\u02E8\u02E8",
  2267: "\u02E8\u02E9",
  2268: "\u02E8",
  2269: "\u02E9\u02E5",
  2270: "\u02E9\u02E6",
  2271: "\u02E9\u02E7",
  2272: "\u02E9\u02E8",
  2273: "\u02E9\u02E9",
  2274: "\u02E9",
  2275: "\u02E5\u02E5",
  2276: "\u02E5\u02E6",
  2277: "\u02E5\u02E7",
  2278: "\u02E5\u02E8",
  2279: "\u02E5\u02E9",
  2280: "\u02E5",
  2281: "\u02E6\u02E5",
  2282: "\u02E6\u02E6",
  2283: "\u02E6\u02E7",
  2284: "\u02E6\u02E8",
  2285: "\u02E6\u02E9",
  2286: "\u02E6",
  2287: "\u02E7\u02E5",
  2288: "\u02E7\u02E6",
  2289: "\u02E7\u02E7",
  2290: "\u02E7\u02E8",
  2291: "\u02E7\u02E9",
  2292: "\u02E7",
  2293: "\u02E8\u02E5",
  2294: "\u02E8\u02E6",
  2295: "\u02E8\u02E7",
  2296: "\u02E8\u02E9",
  2297: "\u02E9\u02E5",
  2298: "\u02E9\u02E6",
  2299: "\u02E9\u02E7",
  2300: "\u02E9\u02E8",
  2301: "\u02E9\u02E9",
  2302: "\u02E9",
  2303: "\u02E5\u02E5",
  2304: "\u02E5\u02E6",
  2305: "\u02E5\u02E7",
  2306: "\u02E5\u02E8",
  2307: "\u02E5\u02E9",
  2308: "\u02E5",
  2309: "\u02E6\u02E5",
  2310: "\u02E6\u02E6",
  2311: "\u02E6\u02E7",
  2312: "\u02E6\u02E8",
  2313: "\u02E6\u02E9",
  2314: "\u02E6",
  2315: "\u02E7\u02E5",
  2316: "\u02E7\u02E6",
  2317: "\u02E7\u02E7",
  2318: "\u02E7\u02E8",
  2319: "\u02E7\u02E9",
  2320: "\u02E7",
  2321: "\u02E8\u02E5",
  2322: "\u02E8\u02E6",
  2323: "\u02E8\u02E7",
  2324: "\u02E8\u02E8",
  2325: "\u02E8\u02E9",
  2326: "\u02E8",
  2327: "\u02E9\u02E5",
  2328: "\u02E9\u02E6",
  2329: "\u02E9\u02E7",
  2330: "\u02E9\u02E8",
  2331: "\u0304\u0313\u0300",
  2332: "\u0304\u0313\u0301",
  2333: "\u0304\u0314\u0300",
  2334: "\u0304\u0314\u0301",
  2335: "\u0306\u0313\u0300",
  2336: "\u0306\u0313\u0301",
  2337: "\u0306\u0314\u0300",
  2338: "\u0306\u0314\u0301",
  2339: "\u0304\u0313\u0300",
  2340: "\u0304\u0313\u0301",
  2341: "\u0304\u0314\u0300",
  2342: "\u0304\u0314\u0301",
  2343: "\u0306\u0313\u0300",
  2344: "\u0306\u0313\u0301",
  2345: "\u0306\u0314\u0300",
  2346: "\u0306\u0314\u0301",
  2347: "\u0304\u0313\u0300",
  2348: "\u0304\u0313\u0301",
  2349: "\u0304\u0314\u0300",
  2350: "\u0304\u0314\u0301",
  2351: "\u0306\u0313\u0300",
  2352: "\u0306\u0313\u0301",
  2353: "\u0306\u0314\u0300",
  2354: "\u0306\u0314\u0301",
  2355: "\u0308\u0304\u0300",
  2356: "\u0308\u0304\u0301",
  2357: "\u0308\u0306\u0300",
  2358: "\u0308\u0306\u0301",
  2359: "\u0308\u0304\u0300",
  2360: "\u0308\u0304\u0301",
  2361: "\u0308\u0306\u0300",
  2362: "\u0308\u0306\u0301",
  2576: "\u0942",
  2797: "\u0941",
  2798: "\u0942",
  2799: "\u0943",
  2800: "\u0944",
  2801: "\u0941",
  2802: "\u0942",
  2803: "\u0943",
  2804: "\u0944",
  2805: "\u0941",
  2806: "\u0942",
  2807: "\u0A71",
  2808: "\u0A71",
  2809: "\u0941",
  2810: "\u0942",
  2811: "\u0943",
  2812: "\u0A95",
  2813: "\u0A95",
  2814: "\u093C\u0941",
  2815: "\u093C\u0942",
  2816: "\u093C\u0943",
  2817: "\u0902",
  2818: "\u0A0F",
  2819: "\u0B1C",
  2820: "\u0902",
  2821: "\u0A0F",
  2822: "\u0B1C",
  2823: "\u0902",
  2824: "\u0A0F",
  2825: "\u0B1C",
  2826: "\u0902",
  2827: "\u0A0F",
  2828: "\u0B1C",
  2829: "\u0902",
  2830: "\u0A0F",
  2831: "\u0B1C",
  2832: "\u0902",
  2833: "\u0A0F",
  2834: "\u0B1C",
  2835: "\u0902",
  2836: "\u0A0F",
  2837: "\u0B1C",
  2838: "\u0902",
  2839: "\u0A0F",
  2840: "\u0B1C",
  2841: "\u0902",
  2842: "\u0A0F",
  2843: "\u0B1C",
  2844: "\u0902",
  2846: "\u0902",
  2856: "\u0902",
  2868: "\u091F",
  2869: "\u091F\u0942",
  2870: "\u0920",
  2871: "\u0920\u0942",
  2872: "\u092F",
  2873: "\u0920",
  2874: "\u092F",
  2875: "\u0922",
  2876: "\u0921",
  2877: "\u0921\u0942",
  2878: "\u092F",
  2879: "\u0922",
  2880: "\u092F",
  2883: "\u0918",
  2884: "\u0917",
  2885: "\u092C",
  2886: "\u092D",
  2887: "\u0935",
  2888: "\u0927",
  2889: "\u0A23\u092F",
  2890: "\u0926",
  2891: "\u092E",
  2892: "\u092F",
  2896: "\u091A",
  2897: "\u0A16",
  2898: "\u0935",
  2899: "\u0A2E",
  2900: "\u0932",
  2901: "\u0928",
  2902: "\u091F",
  2903: "\u0A61",
  2904: "\u0920",
  2905: "\u0A62",
  2906: "\u0923",
  2907: "\u0928",
  2908: "\u092E",
  2909: "\u092F",
  2910: "\u0932",
  2911: "\u0935",
  2912: "\u0932",
  2916: "\u0B60",
  2917: "\u0936",
  2933: "\u0B69",
  2934: "\u0B6A",
  2935: "\u0B6B",
  2936: "\u0B6C",
  2937: "\u0B6D",
  2938: "\u0B6E",
  2939: "\u0B6F",
  2940: "\u0B70",
  2941: "\u0B71",
  2942: "\u0B72",
  2943: "\u0B73",
  2944: "\u0B74",
  2945: "\u0B69",
  2946: "\u0B6A",
  2947: "\u0B6B",
  2948: "\u0B6C",
  2949: "\u0B6D",
  2950: "\u0B6E",
  2951: "\u0B6F",
  2952: "\u0B70",
  2953: "\u0B71",
  2954: "\u0B72",
  2955: "\u0B73",
  2956: "\u0B74",
  2957: "\u0B69",
  2958: "\u0B6A",
  2959: "\u0B6B",
  2960: "\u0B6C",
  2961: "\u0B6D",
  2962: "\u0B6E",
  2963: "\u0B6F",
  2964: "\u0B70",
  2965: "\u0B71",
  2966: "\u0B72",
  2967: "\u0B73",
  2968: "\u0B74",
  2969: "\u0902",
  2970: "\u0940",
  2971: "\u0940",
  2972: "\u0940",
  2973: "\u0B01",
  2974: "\u0B01",
  2975: "\u0B01",
  2976: "\u0B02",
  2977: "\u0B02",
  2978: "\u0B02",
  2979: "\u0B03",
  2980: "\u0B03",
  2981: "\u0B03",
  2982: "\u0941",
  2983: "\u0941",
  2985: "\u0942",
  2986: "\u0942",
  2987: "\u0943",
  2988: "\u0943",
  2989: "\u0944",
  2990: "\u0944",
  2991: "\u0962",
  2992: "\u0962",
  2993: "\u0962",
  2994: "\u0963",
  2995: "\u0963",
  2996: "\u0963",
  2997: "\u094D",
  3015: "\u0941",
  3016: "\u0941",
  3017: "\u0B99\u0941",
  3018: "\u0942",
  3019: "\u0942",
  3020: "\u0B99\u0942",
  3021: "\u0943",
  3022: "\u0943",
  3023: "\u0B99\u0943",
  3024: "\u0944",
  3025: "\u0962",
  3026: "\u0963",
  3027: "\u094D",
  3028: "\u094D",
  3029: "\u0B99\u094D",
  3030: "\u0941",
  3031: "\u0942",
  3032: "\u0943",
  3036: "\u094D",
  3040: "\u0901",
  3041: "\u0901",
  3042: "\u0901",
  3043: "\u0901",
  3044: "\u0901",
  3045: "\u0901",
  3046: "\u0901",
  3047: "\u0901",
  3048: "\u0901",
  3049: "\u0BE8",
  3050: "\u0BE8",
  3051: "\u0BE8"
};
let G = {
  19: "0",
  20: "1",
  21: "2",
  22: "3",
  23: "4",
  24: "5",
  25: "6",
  26: "7",
  27: "8",
  28: "9",
  44: "I",
  142: "\u0300",
  143: "\u0301",
  144: "\xce",
  145: "\xee",
  234: "\u0303",
  236: "\u0304",
  238: "\u0306",
  240: "\u012E",
  242: "\u0323",
  244: "IJ",
  288: "\u015E",
  289: "\u015F",
  346: "\u038A",
  359: "\u0399",
  375: "\u03CA",
  564: "i",
  565: "l",
  605: "fi",
  606: "fl",
  713: "\u04C0",
  728: "\u04CF",
  837: "\u1EC8",
  839: "\u1ECA",
  898: "1",
  899: "0",
  900: "1",
  901: "2",
  902: "3",
  903: "4",
  904: "5",
  905: "6",
  906: "7",
  907: "8",
  908: "9",
  909: "f",
  911: "\u0162",
  912: "\u0163",
  913: "g",
  915: "\u0306",
  916: "\u0323"
};
let z = {
  8: "\u22150",
  108: "a",
  116: "2",
  117: "3",
  123: "1",
  124: "o",
  126: "1\u22154",
  127: "1\u22152",
  128: "1\u22154",
  293: "s",
  297: "\u015E",
  298: "\u015F",
  299: "\u0162",
  300: "\u0163",
  609: "\u0301",
  631: "\u0498",
  632: "\u0499",
  633: "\u04AA",
  634: "\u04AB",
  681: "\u0492",
  682: "\u0493",
  683: "\u04AA",
  684: "\u04AB",
  699: '"',
  700: '"',
  701: '"',
  702: '"',
  703: "'",
  704: '"',
  715: "i",
  716: "l",
  717: "\u030C",
  718: "l",
  719: "1/"
};
let H = {
  8: "\u22150",
  108: "a",
  124: "o",
  126: "1\u22154",
  127: "1\u22152",
  128: "1\u22154",
  297: "\u015E",
  298: "\u015F",
  299: "\u0162",
  300: "\u0163",
  609: "\u0301",
  631: "\u0498",
  632: "\u0499",
  633: "\u04AA",
  634: "\u04AB",
  681: "\u0492",
  682: "\u0493",
  683: "\u04AA",
  684: "\u04AB",
  699: '"',
  700: '"',
  701: '"',
  702: '"',
  703: "'",
  704: '"',
  705: "1",
  715: "i",
  716: "l",
  717: "\u030C"
};
let W = {
  327: "f",
  328: "i",
  329: "l",
  330: "fi",
  331: "fl"
};
let K = {
  20: "\u025A",
  21: "\u025E",
  22: "\u0258",
  23: "\u0255",
  24: "\u0257",
  25: "\u0256",
  26: "\u025B",
  27: "\u0259",
  28: "\u025D",
  29: "\u025C",
  115: "2",
  116: "3",
  122: "1",
  444: "i",
  445: "l",
  446: "fi",
  447: "fl",
  453: "2",
  454: "1",
  455: "0",
  456: "9",
  457: "8",
  458: "7",
  459: "6",
  460: "5",
  461: "4",
  462: "3",
  463: "2",
  464: "1",
  465: "0",
  466: "z",
  467: "y",
  468: "x",
  469: "w",
  470: "v",
  471: "u",
  472: "t",
  473: "s",
  474: "r",
  475: "q",
  476: "p",
  477: "o",
  478: "n",
  479: "m",
  480: "l",
  481: "k",
  482: "j",
  483: "i",
  484: "h",
  485: "g",
  486: "f",
  487: "dollar",
  488: "sterling",
  489: "yen",
  490: "gamma",
  491: "delta",
  492: "theta",
  493: "lambda",
  494: "xi",
  495: "pi",
  496: "sigma1",
  497: "phi",
  498: "psi",
  499: "omega",
  500: "\u0452",
  501: "\u0454",
  502: "\u0459",
  503: "\u045A",
  504: "\u045B",
  505: "\u045F",
  506: "\u0431",
  507: "\u0434",
  508: "\u0436",
  509: "\u0437",
  510: "\u0438",
  511: "\u043A",
  512: "\u043B",
  513: "\u0443",
  514: "\u0446",
  515: "\u0447",
  516: "\u0448",
  517: "\u0449",
  518: "\u044A",
  519: "\u044B",
  520: "\u044C",
  521: "\u044D",
  522: "\u044E",
  523: "\u044F",
  524: "\u0493",
  525: "\u0497",
  526: "\u049B",
  527: "\u049D",
  528: "\u04A1",
  529: "\u04A9",
  530: "\u04B1",
  531: "\u04B3",
  532: "\u04B5",
  533: "\u04B9",
  534: "\u04BB",
  535: "\u04BD",
  536: "\u04D9",
  537: "\u04E1",
  538: "\u04E9",
  539: "lira",
  540: "Euro",
  541: "\u2116",
  542: "\u20BD",
  543: "3",
  544: "4",
  545: "5",
  546: "6",
  547: "7",
  548: "8",
  549: "9",
  552: "e",
  556: "K",
  557: "k",
  558: "K",
  559: "k",
  560: "d",
  561: "c",
  562: "b",
  563: "a",
  571: "\u0491",
  574: "0",
  575: "4",
  576: "5",
  577: "6",
  578: "7",
  579: "8",
  580: "9",
  581: "C",
  582: "G",
  583: "D",
  584: "O",
  585: "Q",
  586: "\u025E",
  587: "\u0258",
  588: "\u0255",
  589: "\u0257",
  590: "\u0256",
  591: "\u0259",
  594: "oe",
  595: "\u025C",
  597: "\u024C",
  598: "\u024E",
  599: "\u024D",
  600: "\u024B",
  601: "\u024F",
  602: "\u0265",
  603: "6",
  604: "\u0253",
  605: "8",
  606: "\u024A",
  607: "j",
  608: "\u0458",
  609: "i",
  611: "\u0456",
  613: "\u025A",
  614: "\u024F",
  615: "b",
  616: "c",
  617: "d",
  618: "g",
  619: "o",
  620: "p",
  621: "q",
  622: "e",
  623: "\u026A",
  624: "\u024A",
  625: "&",
  639: "\u0300",
  640: "\u0301",
  642: "\u0303",
  647: "\u0300",
  648: "\u0301",
  651: "\u0300",
  652: "\u0301",
  655: "\u0303",
  656: "\u0300",
  657: "\u0301",
  659: "\u0303",
  661: "\u0300",
  662: "\u0301",
  665: "\u0301",
  666: "\u0300",
  667: "\u0301",
  669: "\u0303",
  674: "\u0300",
  675: "\u0301",
  678: "\u0300",
  679: "\u0301",
  682: "\u0303",
  683: "\u0300",
  684: "\u0301",
  686: "\u0303",
  688: "\u0300",
  689: "\u0301",
  692: "\u0301",
  730: "\u0303",
  731: "\u0303",
  745: "\u0301",
  746: "\u0301",
  753: "\u0301",
  754: "\u0301",
  766: "\u0301",
  767: "\u0301",
  772: "\u0301",
  773: "\u0301",
  778: "\u015E",
  779: "\u015F",
  788: "\u0303",
  789: "\u0303",
  805: "\u0301",
  806: "\u0301",
  818: "\u0300",
  819: "\u0301",
  821: "\u0303",
  824: "\u0301",
  826: "\u0300",
  827: "\u0301",
  830: "\u0300",
  831: "\u0301",
  834: "\u0303",
  835: "\u0300",
  836: "\u0301",
  838: "\u0303",
  840: "\u0300",
  841: "\u0301",
  844: "\u0301",
  845: "\u0304",
  846: "\u0306",
  848: "\u0301",
  850: "\u0323",
  851: "\u030C",
  852: "\u030C",
  853: "\u0304",
  854: "\u0306",
  855: "\u0323",
  857: "\u030C",
  859: "\u0306",
  860: "\u0323",
  861: "\u0123",
  863: "\u0303",
  864: "\u0304",
  865: "\u0306",
  867: "\u0323",
  869: "\u0137",
  870: "\u0301",
  871: "\u013C",
  872: "\u030C",
  873: "\u0323",
  874: "\u0301",
  875: "\u0146",
  876: "\u030C",
  877: "\u0304",
  878: "\u0306",
  880: "\u0301",
  881: "\u0157",
  882: "\u030C",
  883: "\u0301",
  885: "\u015F",
  886: "\u030C",
  887: "\u021B",
  888: "\u030C",
  889: "\u0163",
  890: "\u0303",
  891: "\u0304",
  892: "\u0306",
  899: "\u0301",
  900: "\u0323",
  901: "\u030C",
  979: "\u0300",
  980: "\u0300",
  981: "\u0301",
  982: "\u0301",
  985: "\u0300",
  986: "\u0300",
  992: "\u0301",
  993: "\u0301",
  1054: "\u0323",
  1055: "\u0323",
  1056: "\u0309",
  1057: "\u0309",
  1078: "\u0323",
  1079: "\u0323",
  1080: "\u0309",
  1081: "\u0309",
  1082: "\u0303",
  1083: "\u0303",
  1094: "\u0309",
  1095: "\u0309",
  1096: "\u0323",
  1098: "\u0323",
  1099: "\u0323",
  1100: "\u0309",
  1101: "\u0309",
  1112: "\u0301",
  1113: "\u0301",
  1114: "\u0300",
  1115: "\u0300",
  1116: "\u0309",
  1117: "\u0309",
  1118: "\u0303",
  1119: "\u0303",
  1120: "\u0323",
  1121: "\u0323",
  1122: "\u0323",
  1123: "\u0323",
  1124: "\u0309",
  1125: "\u0309",
  1126: "\u0301",
  1127: "\u0301",
  1128: "\u0300",
  1129: "\u0300",
  1130: "\u0309",
  1131: "\u0309",
  1132: "\u0303",
  1133: "\u0303",
  1134: "\u0323",
  1135: "\u0323",
  1136: "\u0323",
  1137: "\u0323",
  1138: "\u0309",
  1139: "\u0309",
  1140: "\u0303",
  1141: "\u0303",
  1165: "\u024B",
  1166: "\u024C",
  1167: "\u024D",
  1168: "\u024E",
  1169: "6",
  1170: "8",
  1171: "\u0253",
  1172: "\u0265",
  1173: "\u0301",
  1175: "\u0300",
  1176: "\u0300",
  1177: "\u030F",
  1178: "\u030F",
  1179: "\u030F",
  1180: "\u030F",
  1181: "\u030F",
  1182: "\u030F",
  1183: "\u030F",
  1184: "\u030F",
  1185: "\u030F",
  1186: "\u030F",
  1187: "\u030F",
  1188: "\u030F",
  1192: "\u0323",
  1193: "\u0323",
  1194: "\uF6C3",
  1195: "\uF6C3",
  1198: "\u0301",
  1199: "\u0301",
  1200: "\u0323",
  1201: "\u0323",
  1202: "\u0323",
  1203: "\u0323",
  1204: "\u0323",
  1205: "\u0323",
  1206: "\u0323",
  1207: "\u0323",
  1208: "\u0303\u0301",
  1211: "\u0323",
  1212: "\u0323",
  1213: "\u0323",
  1214: "\u0323",
  1215: "\u0323",
  1216: "\u0323",
  1217: "\u0303\u0301",
  1218: "\u0303",
  1219: "\u0303",
  1220: "\u0323",
  1221: "\u0323",
  1222: "\u0323",
  1223: "\u0323",
  1224: "\u0323",
  1225: "\u0323",
  1234: "\u03B1",
  1235: "\u03D0",
  1236: "\u03B5",
  1237: "\u0396",
  1238: "\u0371",
  1239: "\u0196",
  1240: "\u039A",
  1241: "\u03BC",
  1242: "\u039D",
  1243: "\u039F",
  1244: "\u03C1",
  1245: "\u03C4",
  1250: "\u0451",
  1251: "\u0453",
  1252: "\u0455",
  1253: "\u0456",
  1254: "\u0457",
  1255: "\u0458",
  1256: "\u045C",
  1257: "\u045E",
  1258: "\u0430",
  1259: "\u0432",
  1260: "\u0433",
  1261: "\u0435",
  1262: "\u0439",
  1263: "\u043C",
  1264: "\u043D",
  1265: "\u043E",
  1266: "\u043F",
  1267: "\u0440",
  1268: "\u0441",
  1269: "\u0442",
  1270: "\u0445",
  1271: "\u0499",
  1272: "\u04A3",
  1273: "\u04AB",
  1274: "\u04AF",
  1275: "\u04BF",
  1276: "\u04E3",
  1277: "\u04EF",
  1278: "\u0444",
  1279: "ij",
  1280: "\u0301",
  1281: "\u0301",
  1282: "\u0219",
  1283: "\u0300",
  1284: "\u0301",
  1286: "\u0300",
  1291: "\u034F",
  1292: "\u0358",
  1293: "\u1ECB"
};
let Y = {
  413: "a",
  414: "b",
  415: "c",
  416: "d",
  417: "e",
  418: "f",
  419: "g",
  420: "h",
  421: "i",
  422: "j",
  423: "k",
  424: "l",
  425: "m",
  426: "n",
  427: "o",
  428: "q",
  429: "r",
  430: "s",
  431: "t",
  432: "u",
  433: "v",
  434: "w",
  435: "x",
  436: "y",
  437: "z",
  471: "p",
  634: "\u0163",
  668: "\u0300",
  669: "\u0301",
  671: "\u0303",
  674: "\u0301",
  676: "\u0300",
  677: "\u0301",
  680: "\u0300",
  681: "\u0301",
  684: "\u0303",
  685: "\u0300",
  686: "\u0301",
  688: "\u0303",
  690: "\u0300",
  691: "\u0301",
  694: "\u0301",
  695: "\u0304",
  696: "\u0306",
  698: "\u0301",
  701: "\u030C",
  702: "\u030C",
  703: "\u0304",
  704: "\u0306",
  705: "\u0323",
  707: "\u030C",
  709: "\u0306",
  713: "\u0303",
  714: "\u0304",
  715: "\u0306",
  720: "\u0301",
  722: "\u030C",
  723: "\u0323",
  724: "\u0301",
  726: "\u030C",
  727: "\u0304",
  728: "\u0306",
  730: "\u0301",
  732: "\u030C",
  733: "\u0301",
  735: "\u015F",
  736: "\u030C",
  738: "\u030C",
  739: "\u0303",
  740: "\u0304",
  741: "\u0306",
  748: "\u0301",
  749: "\u0323",
  750: "\u030C"
};
let q = {
  403: "i",
  404: "l",
  408: "r",
  421: "a",
  422: "b",
  423: "c",
  424: "d",
  425: "e",
  426: "f",
  427: "g",
  428: "h",
  429: "i",
  430: "j",
  431: "k",
  432: "l",
  433: "m",
  434: "n",
  435: "o",
  436: "q",
  438: "s",
  439: "t",
  440: "u",
  441: "v",
  442: "w",
  443: "x",
  444: "y",
  445: "z",
  469: "0",
  470: "1",
  471: "2",
  472: "3",
  474: "4",
  475: "5",
  476: "6",
  479: "s",
  480: "a",
  481: "c",
  482: "C",
  483: "G",
  484: "S",
  485: "O",
  486: "C",
  487: "G",
  488: "7",
  489: "8",
  490: "9",
  491: "p",
  679: "\u0300",
  680: "\u0301",
  682: "\u0303",
  685: "\u0301",
  687: "\u0300",
  688: "\u0301",
  691: "\u0300",
  692: "\u0301",
  695: "\u0303",
  696: "\u0300",
  697: "\u0301",
  699: "\u0303",
  701: "\u0300",
  702: "\u0301",
  705: "\u0301",
  706: "\u0304",
  707: "\u0306",
  709: "\u0301",
  712: "\u030C",
  713: "\u030C",
  714: "\u0304",
  715: "\u0306",
  716: "\u0323",
  718: "\u030C",
  720: "\u0306",
  724: "\u0303",
  725: "\u0304",
  726: "\u0306",
  728: "\u0323",
  731: "\u0301",
  733: "\u030C",
  734: "\u0323",
  735: "\u0301",
  737: "\u030C",
  738: "\u0304",
  739: "\u0306",
  741: "\u0301",
  743: "\u030C",
  744: "\u0301",
  746: "\u015F",
  747: "\u030C",
  748: "\u0163",
  749: "\u030C",
  750: "\u0303",
  751: "\u0304",
  752: "\u0306",
  759: "\u0301",
  760: "\u0323",
  761: "\u030C"
};
let $ = {
  282: "\u015E",
  283: "\u015F",
  284: "\u0162",
  285: "\u0163",
  394: "G",
  395: "\u0306",
  396: "\u0122",
  397: "\u0323",
  398: "Q",
  399: "a",
  400: "\u0301",
  401: "\u0306",
  404: "\u0300",
  405: "\u0304",
  408: "\u0303",
  410: "ij",
  411: "j",
  412: "eng",
  413: "t",
  415: "\u030C",
  416: "\u0163",
  417: "\u021B",
  418: "0",
  419: "2",
  420: "\u24EA",
  421: "\u2461",
  424: "at"
};
let Z = {
  7: "$",
  8: "%",
  14: "+",
  19: "0",
  20: "1",
  21: "2",
  22: "3",
  23: "4",
  24: "5",
  25: "6",
  26: "7",
  27: "8",
  28: "9",
  31: "<",
  32: "=",
  33: ">",
  101: "\xa3",
  103: "\xa5",
  113: "\xb1",
  124: "/4",
  125: "/2",
  126: "/4",
  151: "\xd7",
  183: "\xf7",
  325: "\u015E",
  326: "\u015F",
  357: "\u2030",
  361: "\u20AC",
  365: "/3",
  367: "/8",
  368: "/8",
  375: "-",
  379: "\u2245",
  380: "\u2260",
  381: "\u2264",
  382: "\u2265",
  384: "f",
  385: "i",
  386: "l",
  387: "fi",
  388: "fl",
  389: "\u0163",
  394: "a",
  395: "b",
  396: "c",
  397: "d",
  398: "e",
  399: "f",
  400: "g",
  401: "h",
  402: "i",
  403: "\u0237",
  404: "k",
  405: "l",
  406: "m",
  407: "n",
  408: "o",
  409: "p",
  410: "q",
  411: "r",
  412: "s",
  413: "t",
  414: "u",
  415: "v",
  416: "w",
  417: "x",
  418: "y",
  419: "z",
  420: "\u0301",
  421: "\u0306",
  424: "\u0300",
  425: "\u0304",
  428: "\u0301",
  429: "\u0303",
  430: "ae",
  431: "\u0301",
  432: "\u0301",
  433: "\u030C",
  436: "\u0323",
  437: "\u030C",
  439: "\u0301",
  440: "\u0306",
  441: "\u030C",
  444: "\u0323",
  445: "\u0300",
  446: "\u0304",
  449: "\u0306",
  452: "\u0323",
  455: "\u0301",
  456: "\u0306",
  459: "\u0323",
  460: "\u0300",
  461: "\u0304",
  463: "\u0303",
  464: "ij",
  467: "\u0301",
  468: "\u030C",
  470: "\u0323",
  472: "\u0301",
  473: "\u030C",
  475: "\u0303",
  477: "\u0301",
  478: "\u0306",
  481: "\u0300",
  483: "\u0304",
  485: "\u0301",
  486: "\u0303",
  487: "oe",
  488: "\u0301",
  489: "\u030C",
  491: "\u0301",
  492: "\u030C",
  493: "\u015F",
  497: "\u030C",
  499: "\u0301",
  500: "\u0306",
  503: "\u0300",
  505: "\u0304",
  508: "\u0303",
  509: "\u0301",
  511: "\u0300",
  513: "\u0301",
  516: "\u0300",
  517: "\u0301",
  518: "\u030C",
  519: "\u0323",
  520: "b",
  521: "fb",
  522: "h",
  523: "fh",
  526: "j",
  527: "fj",
  528: "k",
  529: "fk",
  530: "&",
  544: "\xa1",
  545: "\xbf",
  546: "!",
  547: "\xa1",
  548: "?",
  549: "\xbf",
  554: "/",
  555: "\\",
  558: "/",
  559: "\\",
  562: "\xb7",
  563: "\xb7",
  564: "-",
  565: "-",
  566: "-",
  567: "(",
  568: ")",
  569: "[",
  570: "]",
  571: "{",
  572: "}",
  573: "(",
  574: ")",
  575: "[",
  576: "]",
  577: "{",
  578: "}",
  579: "@",
  581: "\u20AC",
  582: "$",
  583: "\xa3",
  584: "\xa5",
  586: "\u20AC",
  587: "$",
  588: "\xa2",
  589: "\xa3",
  590: "\xa5",
  592: "\u20AC",
  593: "$",
  594: "\xa3",
  595: "\xa5",
  596: "0",
  597: "1",
  598: "2",
  599: "3",
  600: "4",
  601: "5",
  602: "6",
  603: "7",
  604: "8",
  605: "9",
  606: "0",
  607: "1",
  608: "2",
  609: "3",
  610: "4",
  611: "5",
  612: "6",
  613: "7",
  614: "8",
  615: "9",
  616: "0",
  617: "1",
  618: "2",
  619: "3",
  620: "4",
  621: "5",
  622: "6",
  623: "7",
  624: "8",
  625: "9",
  626: "%",
  627: "\u2030",
  628: "%",
  629: "\u2030",
  630: "%",
  631: "\u2030",
  632: "+",
  633: "-",
  634: "\xd7",
  635: "\xf7",
  636: "=",
  637: "<",
  638: ">",
  639: "\xb1",
  640: "\u2264",
  641: "\u2265",
  642: "\u2260",
  643: "\u2245",
  644: "+",
  645: "-",
  646: "\xd7",
  647: "\xf7",
  648: "=",
  649: "<",
  650: ">",
  651: "\xb1",
  652: "\u2264",
  653: "\u2265",
  654: "\u2260",
  655: "\u2245",
  656: "+",
  657: "-",
  658: "\xd7",
  659: "\xf7",
  660: "=",
  661: "<",
  662: ">",
  663: "\xb1",
  664: "\u2264",
  665: "\u2265",
  666: "\u2260",
  667: "\u2245",
  668: ".",
  669: ",",
  670: ":",
  671: ";",
  672: " "
};
let X = "#000000";
async function Q(e, t, i) {
  let n;
  let r = await _$$eg();
  let a = new r.SVGGraphics(e.commonObjs, e.objs);
  !function (e) {
    function t(e) {
      let t = e.message;
      return t.startsWith("Unknown RadialAxial type") || t.startsWith("Unknown IR type") || "Failed to execute 'appendChild' on 'Node': parameter 1 is not of type 'Node'." === t;
    }
    [{
      functionName: e.setStrokeColorN.name,
      isErrorOfInterest: t,
      callOnFailure: () => {
        e.current.setStrokeColorN = X;
        logInfo("pdf", `Unsupported stroke, using: ${X}`, void 0, {
          logToConsole: LogToConsoleMode.ALWAYS
        });
      }
    }, {
      functionName: e.setFillColorN.name,
      isErrorOfInterest: t,
      callOnFailure: () => {
        e.current.setFillColorN = X;
        logInfo("pdf", `Unsupported fill, using: ${X}`, void 0, {
          logToConsole: LogToConsoleMode.ALWAYS
        });
      }
    }, {
      functionName: e.paintInlineImageXObject.name,
      isErrorOfInterest: e => "invalid format" === e.message,
      callOnFailure: () => {
        logInfo("pdf", "Unsupported image", void 0, {
          logToConsole: LogToConsoleMode.ALWAYS
        });
      }
    }, {
      functionName: e.addFontStyle.name,
      isErrorOfInterest: e => e.message.startsWith("addFontStyle: No font data available"),
      callOnFailure: () => {
        logInfo("pdf", "Unsupported font", void 0, {
          logToConsole: LogToConsoleMode.ALWAYS
        });
      }
    }].forEach(t => {
      !function (e, t) {
        let {
          functionName,
          isErrorOfInterest,
          callOnFailure
        } = t;
        let a = e[functionName].bind(e);
        e[functionName] = (...e) => {
          try {
            a(...e);
          } catch (e) {
            if (isErrorOfInterest(e)) callOnFailure();else throw e;
          }
        };
      }(e, t);
    });
  }(a);
  let s = await e.getOperatorList();
  let l = new Set();
  if (s.fnArray.forEach((e, t) => {
    if (e === r.OPS.setFont) {
      let e = s.argsArray[t][0];
      let r = a.commonObjs.get(e);
      if (!r?.name) return;
      if (n = function (e) {
        let t = e.toLowerCase();
        return t.includes("abril") ? O : t.includes("bangers") ? D : t.includes("caveat") ? L : t.includes("fredoka") ? F : t.includes("ibm-plex-mono") ? M : t.includes("ibm-plex-sans") ? j : t.includes("ibm-plex-serif") ? U : t.includes("lemon-tuesday") ? B : t.includes("noto-sans") ? V : t.includes("open-sans") ? G : t.includes("ptsans") || t.includes("pt-sans") ? z : t.includes("ptserif") || t.includes("pt-serif") ? H : t.includes("rammetto") ? W : t.includes("roboto-mono") ? Y : t.includes("roboto-slab") ? q : t.includes("roboto") ? K : t.includes("spoof") ? $ : t.includes("tiempos") ? Z : void 0;
      }(r.name), i.findFontIdsToBold) {
        var o;
        o = r.name;
        /(bold|700)/i.test(o) && l.add(r.loadedName);
      }
    }
    e === r.OPS.showText && s.argsArray[t][0].forEach(e => {
      "object" == typeof e && ("\0" !== e.unicode ? e.fontChar = e.unicode : n?.[e.originalCharCode] ? e.fontChar = n[e.originalCharCode] : e.fontChar = "\u25A1", " " === e.fontChar && (e.isInFont = !0));
    });
  }), !i.preserveClipPaths) {
    let e = e => e !== r.OPS.clip && e !== r.OPS.eoClip;
    s.argsArray = s.argsArray.filter((t, i) => e(s.fnArray[i]));
    s.fnArray = s.fnArray.filter(t => e(t));
  }
  return {
    svgElement: await a.getSVG(s, t),
    additionalData: {
      fontIdsToBold: l
    }
  };
}
function J(e, t) {
  t.pendingRemovals ??= new Set();
  t.pendingRemovals.add(e);
}
function ee(e) {
  let t = e.pendingRemovals;
  t && (e.children = e.children.filter(e => !t.has(e)), e.pendingRemovals = void 0);
}
function et(e, t) {
  return [e[0] * t[0] + e[2] * t[1], e[1] * t[0] + e[3] * t[1], e[0] * t[2] + e[2] * t[3], e[1] * t[2] + e[3] * t[3], e[0] * t[4] + e[2] * t[5] + e[4], e[1] * t[4] + e[3] * t[5] + e[5]];
}
function ei(e, t) {
  return {
    x: e[0] * t.x + e[2] * t.y + e[4],
    y: e[1] * t.x + e[3] * t.y + e[5]
  };
}
let en = {
  name: "removeInvisibleElements",
  fn: () => ({
    element: {
      exit: (e, t) => {
        ee(e);
        "path" !== e.name || e.attributes.fill && "none" !== e.attributes.fill || e.attributes.stroke && "none" !== e.attributes.stroke || J(e, t);
      }
    }
  })
};
let er = {
  name: "removeTSpanGlyphPositions",
  fn: () => ({
    element: {
      enter: (e, t) => {
        "tspan" === e.name && e.attributes.x && e.attributes.x.startsWith("0 ") && delete e.attributes.x;
      }
    }
  })
};
let ea = {
  name: "combineOutlineAndFill",
  fn: () => ({
    element: {
      enter: e => {
        let t = e.children.reduce((e, t) => {
          if ("element" === t.type && "path" === t.name) {
            let i = t.attributes.d || "";
            e[i] ??= [];
            e[i].push(t);
          }
          return e;
        }, {});
        let i = new Set();
        Object.values(t).forEach(e => {
          if (e.length > 1) {
            let t = {};
            e.forEach((e, n) => {
              Object.entries(e.attributes).forEach(([e, i]) => {
                i && "none" !== i && (t[e] = i);
              });
              n > 0 && i.add(e);
            });
            e[0].attributes = t;
          }
        });
        i.size > 0 && (e.children = e.children.filter(e => !i.has(e)));
      }
    }
  })
};
let es = {
  name: "combineLucidGroupedOutlineAndFill",
  fn: () => ({
    element: {
      enter: e => {
        if ("element" !== e.type || "g" !== e.name) return;
        let t = e.children.reduce((e, t) => {
          if ("element" === t.type && "g" === t.name) {
            let i = t.children[0];
            if (i && "element" === i.type && "path" === i.name) {
              let n = JSON.stringify([t.attributes.transform, i.attributes.d]);
              e[n] ??= [];
              e[n].push(t);
            }
          }
          return e;
        }, {});
        let i = new Set();
        Object.values(t).forEach(e => {
          if (e.length > 1) {
            let t = {};
            e.forEach((e, n) => {
              Object.entries(e.children[0].attributes).forEach(([e, i]) => {
                i && "none" !== i && (t[e] = i);
              });
              n > 0 && i.add(e);
            });
            e[0].children[0].attributes = t;
          }
        });
        i.size > 0 && (e.children = e.children.filter(e => !i.has(e)));
      }
    }
  })
};
let eo = e => {
  let t = /url\((.+)\)/.exec(e);
  if (!t) return;
  let i = t[1];
  return "'\"".includes(i[0]) ? i.slice(1, -1) : i;
};
let el = {
  name: "replaceRectGradientFillsWithLastStopColor",
  fn: () => {
    let e = {};
    return {
      element: {
        enter: t => {
          if ("linearGradient" === t.name) {
            let i = t.children[t.children.length - 1];
            if (i && "element" === i.type && "stop" === i.name) {
              let n = i.attributes["stop-color"];
              n && (e["#" + t.attributes.id] = n);
            }
          } else if ("rect" === t.name && t.attributes.fill) {
            let i = eo(t.attributes.fill);
            i && e.hasOwnProperty(i) && (t.attributes.fill = e[i]);
          }
        }
      }
    };
  }
};
let ed = {
  name: "addWhitespaceToTspans",
  fn: () => ({
    element: {
      enter: e => {
        "tspan" === e.name && (e.attributes["white-space"] = "pre");
      }
    }
  })
};
let ec = {
  name: "removeWhiteMiroBackground",
  fn: () => {
    let e = 0;
    let t = 0;
    let i = [];
    return {
      element: {
        enter: (n, r) => {
          if ("svg" === n.name) {
            e = parseFloat(n.attributes.height || "0");
            t = parseFloat(n.attributes.width || "0");
          } else {
            if (n.attributes.transform) {
              let e = function (e) {
                let t = [1, 0, 0, 1, 0, 0];
                if (!e || "" === e.trim()) return t;
                let i = e.match(/(matrix|translate|scale|rotate|skewX|skewY)\s*\(([-\d\s.,e]+)\)/g);
                i && i.forEach(e => {
                  let [i, n] = e.split(/\s*\(\s*|\s*\)\s*/);
                  if (void 0 === n) return;
                  let r = n.split(/[\s,]+/).map(Number);
                  switch (i) {
                    case "matrix":
                      6 === r.length && (t = et(t, r));
                      break;
                    case "translate":
                      let a = r[0] || 0;
                      let s = r[1] || 0;
                      t = et(t, [1, 0, 0, 1, a, s]);
                      break;
                    case "scale":
                      let o = r[0] || 1;
                      let l = r.length > 1 ? r[1] : o;
                      t = et(t, [o, 0, 0, l, 0, 0]);
                      break;
                    case "rotate":
                      let d = (r[0] || 0) * Math.PI / 180;
                      let c = Math.cos(d);
                      let u = Math.sin(d);
                      let p = r[1] || 0;
                      let m = r[2] || 0;
                      0 === p && 0 === m ? t = et(t, [c, u, -u, c, 0, 0]) : (t = et(t, [1, 0, 0, 1, p, m]), t = et(t, [c, u, -u, c, 0, 0]), t = et(t, [1, 0, 0, 1, -p, -m]));
                      break;
                    case "skewX":
                      let h = (r[0] || 0) * Math.PI / 180;
                      t = et(t, [1, 0, Math.tan(h), 1, 0, 0]);
                      break;
                    case "skewY":
                      let g = (r[0] || 0) * Math.PI / 180;
                      t = et(t, [1, Math.tan(g), 0, 1, 0, 0]);
                  }
                });
                return t;
              }(n.attributes.transform);
              i.push(e);
            }
            (function (e, t, i, n, r) {
              if (i && n && "element" === t.type && "path" === e.name && ("#fff" === e.attributes.fill || "#f2f2f2" === e.attributes.fill)) {
                let t = parseFloat(/v(\d+)/.exec(e.attributes.d || "")?.[1] || "0");
                let {
                  height,
                  width
                } = function (e, t, i) {
                  let n = e.reduce((e, t) => et(e, t), [1, 0, 0, 1, 0, 0]);
                  let {
                    x,
                    y
                  } = ei(n, {
                    x: 0,
                    y: 0
                  });
                  let {
                    x: _x,
                    y: _y
                  } = ei(n, {
                    x: t,
                    y: 0
                  });
                  let {
                    x: _x2,
                    y: _y2
                  } = ei(n, {
                    x: t,
                    y: i
                  });
                  let {
                    x: _x3,
                    y: _y3
                  } = ei(n, {
                    x: 0,
                    y: i
                  });
                  return {
                    height: Math.max(y, _y, _y2, _y3) - Math.min(y, _y, _y2, _y3),
                    width: Math.max(x, _x, _x2, _x3) - Math.min(x, _x, _x2, _x3)
                  };
                }(r, parseFloat(/h(\d+)/.exec(e.attributes.d || "")?.[1] || "0"), t);
                if (height > .9 * i && width > .9 * n) return !0;
              }
              return !1;
            })(n, r, e, t, i) && J(n, r);
          }
        },
        exit: (e, t) => {
          ee(e);
          e.attributes.transform && i.pop();
        }
      }
    };
  }
};
let eu = {
  name: "removeWhiteMuralBackground",
  fn: () => {
    let e = 0;
    let t = 0;
    return {
      element: {
        enter: (i, n) => {
          "svg" === i.name ? (e = parseFloat(i.attributes.height || "0"), t = parseFloat(i.attributes.width || "0")) : function (e, t, i, n) {
            if (i && n && "element" === t.type && "path" === e.name && "#fafafa" === e.attributes.fill) {
              let t = parseFloat(/v(\d+)/.exec(e.attributes.d || "")?.[1] || "0");
              let r = Math.abs(n - parseFloat(/h(\d+)/.exec(e.attributes.d || "")?.[1] || "0") / .75);
              if (10 > Math.abs(i - t / .75) && r < 10) return !0;
            }
            return !1;
          }(i, n, e, t) && J(i, n);
        },
        exit: (e, t) => {
          ee(e);
        }
      }
    };
  }
};
let ep = {
  name: "repairAndBoldVectorizedTextFromMiro",
  fn: () => ({
    element: {
      enter: (e, t) => {
        if ("path" !== e.name || "element" !== t.type || "g" !== t.name) return;
        let i = t.children[1];
        if (!i || "element" !== i.type || "text" !== i.name) return;
        let n = i.children[0];
        if (n && "element" === n.type && "tspan" === n.name && "0" === n.attributes["fill-opacity"]) for (let n of (J(e, t), i.children)) "element" === n.type && "tspan" === n.name && (n.attributes["fill-opacity"] = "1", n.attributes["font-weight"] = "bold");
      },
      exit: (e, t) => {
        ee(e);
      }
    }
  })
};
let em = e => {
  let t = {
    makeArcs: !1,
    curveSmoothShorthands: !1
  };
  switch (e) {
    case WhiteboardIntegrationType.LUCID:
      return {
        name: "preset-default",
        params: {
          overrides: {
            removeUnknownsAndDefaults: !1,
            mergePaths: !1,
            convertPathData: t
          }
        }
      };
    case WhiteboardIntegrationType.MIRO:
    case WhiteboardIntegrationType.MURAL:
    case WhiteboardIntegrationType.JAMBOARD:
    case WhiteboardIntegrationType.UNKNOWN:
    default:
      return {
        name: "preset-default",
        params: {
          overrides: {
            removeUnknownsAndDefaults: !1,
            moveGroupAttrsToElems: !1,
            collapseGroups: !1,
            convertPathData: t
          }
        }
      };
  }
};
let eh = "PDF import progress";
let eg = "PDF import failure";
async function ef(e) {
  let t = await _$$eg();
  let i = t.getDocument({
    data: e,
    verbosity: t.VerbosityLevel.ERRORS,
    isEvalSupported: !1
  });
  let n = null;
  try {
    n = await i.promise;
  } catch (e) {
    if (e instanceof t.InvalidPDFException) ;else throw e;
  }
  return n;
}
function e_(e, t, i = 1e-4) {
  return Math.abs(e.top - t.top) < i && Math.abs(e.left - t.left) < i && Math.abs(e.bottom - t.bottom) < i && Math.abs(e.right - t.right) < i;
}
function eA(e, t, i) {
  let n = i * Math.abs(e.right - e.left);
  let r = i * Math.abs(e.bottom - e.top);
  return e.top - r < t.top && e.left - n < t.left && e.right + n > t.right && e.bottom + r > t.bottom;
}
let ey = e => {
  let t = (e, t, i = 1) => Math.abs(e - t) < i;
  let i = e.element.parentElement;
  let n = i?.parentElement;
  if (!n) return;
  let r = Array.from(n.children).indexOf(i);
  if (r <= 1) return;
  let a = n.children[r - 1];
  if (2 !== a.children.length) return;
  let s = a.children[0].getBoundingClientRect().width;
  let o = a.children[0].getBoundingClientRect().width;
  let l = e.rect.width;
  if (t(l, s) && t(l, o)) return a;
};
async function eb(e, t) {
  let [i, n] = await Promise.all([_$$eg(), a4()]);
  let r = await ef(e);
  if (!r) return {
    svgStrings: [],
    extractedImages: {
      images: [],
      hadImageError: !1
    }
  };
  let a = r.numPages;
  if (a < 1) return {
    svgStrings: [],
    extractedImages: {
      images: [],
      hadImageError: !1
    }
  };
  async function s(e, t) {
    let a = await r.getPage(e + 1);
    let s = i.PixelsPerInch.PDF_TO_CSS_UNITS;
    let l = a.getViewport({
      scale: s
    });
    let d = t === WhiteboardIntegrationType.LUCID;
    let {
      svgElement,
      additionalData: {
        fontIdsToBold
      }
    } = await Q(a, l, {
      preserveClipPaths: d,
      findFontIdsToBold: !d
    });
    d ? function (e) {
      e.querySelectorAll("image").forEach(e => {
        if ("154px" === e.getAttribute("width") && "142px" === e.getAttribute("height") && "0" === e.getAttribute("x") && "-142" === e.getAttribute("y") && "scale(0.0064935065 -0.0070422535)" === e.getAttribute("transform")) {
          let t = document.createElement("rect");
          t.setAttribute("fill", "#fff");
          e.replaceWith(t);
        }
      });
    }(svgElement) : t === WhiteboardIntegrationType.MIRO && function (e) {
      e.querySelectorAll("image").forEach(e => {
        let t = e.parentElement;
        let i = t?.nextElementSibling;
        let n = i?.children ? i.children[0] : null;
        t?.nodeName === "svg:g" && i?.nodeName === "svg:g" && n && n.getAttribute("fill") && n.getAttribute("fill-rule") && n.getAttribute("fill-opacity") && (e.remove(), t?.remove(), n.setAttribute("nodeType", "sticky"));
      });
    }(svgElement);
    let m = await P(svgElement);
    document.body.prepend(svgElement);
    let h = Array.from(svgElement.querySelectorAll("text")).map(e => ({
      element: e,
      rect: e.getBoundingClientRect(),
      matched: !1
    }));
    document.body.removeChild(svgElement);
    d && function (e) {
      Array.from(e.querySelectorAll("text")).forEach(e => {
        let t = Array.from(e.querySelectorAll("tspan"));
        if (t.length > 0) {
          let i = t[t.length - 1];
          e.setAttribute("font-size", i.getAttribute("font-size") || "");
          e.setAttribute("fill", "none");
          "bold" === i.getAttribute("font-weight") && e.setAttribute("font-style", "italic");
          "italic" === i.getAttribute("font-style") && e.setAttribute("font-weight", "bold");
          let n = t.reduce((e, t) => e + (t.textContent || ""), "");
          e.textContent = n;
        }
      });
    }(svgElement);
    let g = function (e, t, i, n) {
      if (!t.length) return [];
      document.body.prepend(e);
      let r = [];
      let a = Array.from(e.querySelectorAll("path"));
      let s = Array.from(e.querySelectorAll("image")).concat(a).map(e => ({
        element: e,
        rect: e.getBoundingClientRect()
      }));
      t.forEach(({
        url: e,
        rect: t
      }) => {
        let a = n.find(e => {
          let n = i ? Math.min(Math.max(e.rect.height, e.rect.width) / 3, 15) : 15;
          return function (e, t, i = 15) {
            return e.top - i < t.top && e.left - i < t.left && e.right + i > t.right && e.bottom + i > t.bottom;
          }(e.rect, t, n);
        });
        if (a) {
          let t = document.createElementNS("http://www.w3.org/2000/svg", "a");
          for (t.setAttribute("href", e); a.element.childNodes.length > 0;) t.appendChild(a.element.childNodes[0]);
          a.element.appendChild(t);
          return;
        }
        let o = s.find(e => e_(t, e.rect, 5));
        if (o) {
          let t = ey(o);
          if (t) {
            let i = document.createElement("a");
            i.setAttribute("href", e);
            i.innerText = e;
            let n = document.createElement("text");
            n.appendChild(i);
            t.appendChild(n);
            return;
          }
        }
        r.push({
          url: e,
          rect: t
        });
      });
      document.body.removeChild(e);
      return r;
    }(svgElement, function (e, t, i) {
      let n = [];
      e.filter(e => 2 === e.annotationType).map(e => ({
        url: e.url,
        rect: function (e, t, i) {
          let n = [e[0], t[3] - e[1] + t[1], e[2], t[3] - e[3] + t[1]].map(e => e * i);
          return {
            top: Math.min(n[1], n[3]),
            left: Math.min(n[0], n[2]),
            right: Math.max(n[0], n[2]),
            bottom: Math.max(n[1], n[3])
          };
        }(e.rect, t, i)
      })).forEach(e => {
        n.some(t => e.url === t.url && e_(e.rect, t.rect)) || n.push(e);
      });
      return n;
    }(await a.getAnnotations(), l.viewBox, s), d, h);
    d && (!function (e, t) {
      document.body.prepend(e);
      let i = Array.from(e.querySelectorAll("path")).map(e => ({
        element: e,
        rect: e.getBoundingClientRect()
      }));
      document.body.removeChild(e);
      let n = 0;
      for (; n < i.length;) {
        let e = i[n];
        let r = t.find(({
          rect: t,
          matched: i
        }) => !i && eA(t, e.rect, .2));
        if (r) {
          let t = 1;
          let a = r?.element.textContent?.replace(" ", "")?.length || 0;
          for (let e = 1; e < a && n + e < i.length && eA(r.rect, i[n + e].rect, .2); e++) t++;
          if (t !== a) {
            n++;
            continue;
          }
          r.matched = !0;
          let s = e => {
            let t = document.createElement("tspan");
            t.textContent = " ";
            e.appendChild(t);
          };
          let o = r.element.parentElement?.getAttribute("transform") || "";
          if (r.element.children[0]?.nodeName === "a" && r.element.textContent?.endsWith(" ") && s(r.element), r.element.nextSibling?.textContent === " " && (s(r.element), r.element.nextSibling?.remove()), r.element.childElementCount) {
            let t = document.createElement("g");
            t.appendChild(r.element);
            t.setAttribute("transform", o);
            let i = document.createElement("a");
            i.setAttribute("href", "#");
            t.appendChild(i);
            e.element.parentElement?.insertAdjacentElement("beforebegin", t);
          } else {
            r.element.setAttribute("transform", `${o} ${r.element.getAttribute("transform") || ""}`);
            e.element.parentElement?.insertAdjacentElement("beforebegin", r.element);
          }
          let l = e.element.getAttribute("fill");
          r.element.setAttribute("fill", l && "none" !== l ? l : "#000000");
          for (let e = 0; e < a; e++) {
            let {
              element
            } = i[n + e];
            let r = element.parentElement;
            r && r.parentElement?.removeChild(r);
          }
          n += a;
        } else n++;
      }
    }(svgElement, h), function (e) {
      document.body.prepend(e);
      let t = Array.from(e.querySelectorAll("path")).map(e => ({
        element: e,
        rect: e.getBoundingClientRect()
      }));
      let i = e.getBoundingClientRect();
      document.body.removeChild(e);
      t.forEach(({
        element: e,
        rect: t
      }) => {
        "none" !== e.getAttribute("fill") && !e.hasAttribute("stroke") && eA(t, i, .01) && eA(i, t, .01) && e.parentElement?.removeChild(e);
      });
    }(svgElement));
    let {
      data
    } = n(ev(svgElement.outerHTML), {
      plugins: function (e, t) {
        let i = e === WhiteboardIntegrationType.LUCID;
        let n = e === WhiteboardIntegrationType.MIRO;
        let r = e === WhiteboardIntegrationType.MURAL;
        let a = e === WhiteboardIntegrationType.JAMBOARD;
        let s = !i && !n && !r && !a;
        let l = (n || a || s ? [ec] : []).concat(r || s ? [eu] : []);
        let d = i ? [] : [{
          name: "repairBoldText",
          fn: () => ({
            element: {
              enter: e => {
                if ("tspan" !== e.name) return;
                let i = e.attributes["font-family"];
                i && t.has(i) && (e.attributes["font-weight"] = "bold");
              }
            }
          })
        }];
        return [...(i ? [] : [en]), er, i ? es : ea, ...(i ? [el] : []), em(e), ed, ...l, ...d, ...(n || a || s ? [ep] : [])];
      }(t, fontIdsToBold)
    });
    if (t === WhiteboardIntegrationType.MURAL && g.length > 0) {
      var _;
      let e = document.createElement("div");
      _ = data;
      e.innerHTML = c().sanitize(_, {
        ADD_ATTR: ["imageHash"]
      });
      e.querySelectorAll("image").forEach(e => {
        let t = e.getAttribute("imagehash");
        t && (e.setAttribute("imageHash", t), e.removeAttribute("imagehash"));
      });
      let t = e.firstChild;
      !function (e, t) {
        let i = e.querySelector("g");
        if (!i) return;
        let n = i.transform.baseVal.consolidate()?.matrix;
        let r = n ? n.a : 1;
        let a = n ? n.d : 1;
        let s = n ? n.f : 0;
        for (let e of t) {
          let t = document.createElement("a");
          t.setAttribute("href", e.url);
          t.innerText = e.url;
          let n = document.createElement("text");
          n.setAttribute("fill", "#0d99ff");
          n.appendChild(t);
          a < 0 && n.setAttribute("transform", "scale(1 -1)");
          let o = document.createElement("g");
          let l = "translate(" + e.rect.left / r + ", " + (s / Math.abs(a) + e.rect.top / a) + ")";
          o.setAttribute("transform", l);
          o.appendChild(n);
          i.appendChild(o);
        }
      }(t, g);
      f = ev(t.outerHTML);
    }
    return {
      optimizedSVG: data,
      extractedImages: m
    };
  }
  return function (e) {
    let t = [];
    let i = new Map();
    let n = !1;
    e.forEach(({
      optimizedSVG: e,
      extractedImages: {
        images: r,
        hadImageError: a
      }
    }) => {
      t.push(e);
      n = n || a;
      r.forEach(e => {
        i.has(e.sha1Hash) || i.set(e.sha1Hash, e);
      });
    });
    return {
      svgStrings: t,
      extractedImages: {
        images: [...i.values()],
        hadImageError: n
      }
    };
  }(await Promise.all(Array.from(Array(a)).map((e, i) => s(i, t))));
}
function ev(e) {
  return e.replace(/<svg:/g, "<").replace(/<\/svg:/g, "</").replace(/xlink:/g, "");
}
class eI {
  constructor() {
    this.getPdfSourcePromise = null;
  }
  shouldBlockPdfImports() {
    return atomStoreManager.get(_$$D2);
  }
  getPdfSource(e) {
    this.getPdfSourcePromise || (this.getPdfSourcePromise = new Promise(t => {
      debugState.dispatch(showModalHandler({
        type: n ??= registerModal(_$$A.createLazyComponent(() => Promise.all([]).then(_require).then(e => e.PdfConfirmationModal), createModalConfig("PdfConfirmationModal"))),
        data: {
          fileImportDescription: getI18nString("file_browser.file_import_view.select_pdf_source_description_within_figjam", {
            pdfCount: e
          }),
          onConfirm: e => {
            debugState.dispatch(hideModalHandler());
            t({
              pdfType: e
            });
          },
          onCancel: () => {
            debugState.dispatch(hideModalHandler());
            t({
              pdfType: WhiteboardIntegrationType.UNKNOWN,
              isCanceled: !0
            });
          }
        }
      }));
    }));
    return this.getPdfSourcePromise;
  }
  resetPdfSource() {
    this.getPdfSourcePromise = null;
  }
  populatePdfImagesWithImageBytes(e) {
    let t = e.map(e => e.nodeIds.map(t => ({
      nodeId: t,
      bytes: e.bytes
    }))).reduce((e, t) => e.concat(t), []);
    Fullscreen.populatePdfImagesWithImageBytes(t);
  }
  async convertPdfToScene(e, t, i, n) {
    let r;
    debugState.dispatch(VisualBellActions.enqueue({
      type: eh,
      message: getI18nString("visual_bell.import_pdf"),
      icon: VisualBellIcon.IMAGE_BACKED_SPINNER
    }));
    let l = await this.convertPdf({
      pdfBytes: e,
      pdfType: t,
      cursorX: i,
      cursorY: n
    });
    let d = l.status;
    if (debugState.dispatch(VisualBellActions.dequeue({
      matchType: eh
    })), d === PerfResult.SUCCESS) {
      let {
        images,
        hadImageExtractError
      } = l;
      let i = !1;
      try {
        this.populatePdfImagesWithImageBytes(images);
      } catch (e) {
        i = !0;
        reportError(_$$e.FIGJAM, e);
      }
      (hadImageExtractError || i) && debugState.dispatch(VisualBellActions.enqueue({
        type: eg,
        message: getI18nString("fullscreen.file_import.import_pdf_images_not_imported")
      }));
      return d;
    }
    switch (d) {
      case PerfResult.ERROR_TEXT_SIZE:
        r = getI18nString("fullscreen.file_import.file_contains_text_either_too_big_or_too_small");
        break;
      case PerfResult.TIMEOUT:
        r = getI18nString("fullscreen.file_import.file_timed_out");
        break;
      case PerfResult.ERROR_OTHER:
        r = _$$P(t);
        break;
      default:
        throwTypeError(d);
    }
    debugState.dispatch(VisualBellActions.enqueue({
      type: eg,
      message: r
    }));
    return d;
  }
  async convertPdf(e) {
    let {
      pdfBytes,
      pdfType,
      cursorX,
      cursorY
    } = e;
    let a = new Timer();
    a.start();
    try {
      let {
        svgStrings,
        extractedImages: {
          images,
          hadImageError
        }
      } = await eb(pdfBytes, pdfType);
      if (svgStrings) {
        let {
          status,
          imagesToImport
        } = Fullscreen.createSceneFromSVG(svgStrings, pdfType, cursorX ?? 0, cursorY ?? 0);
        if (status !== PerfResult.SUCCESS) return {
          status
        };
        let c = images && imagesToImport ? function (e, t) {
          let i = new Map();
          t.forEach(({
            nodeId: e,
            imageHash: t
          }) => {
            i.has(t) || i.set(t, []);
            i.get(t)?.push(e);
          });
          return e.map(e => ({
            ...e,
            nodeIds: i.get(e.sha1Hash) ?? []
          }));
        }(images, imagesToImport) : [];
        let p = a.getElapsedTime();
        trackEventAnalytics("PDF Import Elapsed Time", {
          elapsedTimeMs: p
        }, {
          forwardToDatadog: !0
        });
        return {
          status,
          images: c,
          hadImageExtractError: hadImageError
        };
      }
    } catch (t) {
      let e = `PDF Import Error: ${t.message}`;
      try {
        t.message = e;
        reportError(_$$e.FIGJAM, t);
      } catch {
        reportError(_$$e.FIGJAM, Error(e));
      }
    }
    let l = Error("PDF Import Error: unknown issue inside convertPDFToScene");
    reportError(_$$e.FIGJAM, l);
    return {
      status: PerfResult.ERROR_OTHER
    };
  }
}
export function $$eE0() {
  $$r1 = new eI();
}
export const G_ = $$eE0;
export const IY = $$r1;