const a =  'class PropertyNotFoundError extends Error {\n  constructor(message, propertyName) {\n    super(message);\n    this.message = message;\n    this.propertyName = propertyName;\n    this.errorObject = { type: "PROPERTY_NOT_FOUND", propertyName };\n  }\n  errorObject;\n}\nclass ChildLayerNotFoundError extends Error {\n  constructor(message, layerName) {\n    super(message);\n    this.message = message;\n    this.layerName = layerName;\n    this.errorObject = { type: "CHILD_LAYER_NOT_FOUND", layerName };\n  }\n  errorObject;\n}\nclass ChildLayerIdNotFoundError extends Error {\n  constructor(message, codeConnectId) {\n    super(message);\n    this.message = message;\n    this.codeConnectId = codeConnectId;\n    this.errorObject = { type: "CHILD_LAYER_ID_NOT_FOUND", codeConnectId };\n  }\n  errorObject;\n}\nclass TemplateExecutionError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.errorObject = { type: "TEMPLATE_EXECUTION_ERROR" };\n  }\n  errorObject;\n}\nconst __FIGMA_CODE_CONNECT_REQUIRE = (name) => {\n  const __FIGMA_CODE_CONNECT_INLINE_INSTANCES_ENABLED = false;\n  const __FIGMA_CODE_CONNECT_SCENE_GRAPH = null;\n  const __FIGMA_CODE_CONNECT_INSTANCE_TEMPLATES = {};\n  const inlineInstancesEnabled = __FIGMA_CODE_CONNECT_INLINE_INSTANCES_ENABLED;\n  const sceneGraph = __FIGMA_CODE_CONNECT_SCENE_GRAPH;\n  const instanceTemplates = __FIGMA_CODE_CONNECT_INSTANCE_TEMPLATES;\n  const currentLayer = createInstanceHandle(sceneGraph);\n  function bfsFindNode(node, callback) {\n    const queue = [node];\n    while (queue.length > 0) {\n      const node2 = queue.pop();\n      if (node2) {\n        if (callback(node2)) {\n          return node2;\n        }\n        if (node2.type === "INSTANCE") {\n          for (const child of node2.children) {\n            queue.push(child);\n          }\n        }\n      }\n    }\n    return null;\n  }\n  function bfsFindAllNodes(inputNode, callback) {\n    const queue = [inputNode];\n    const ret = [];\n    while (queue.length > 0) {\n      const node = queue.pop();\n      if (node) {\n        if (callback(node) && inputNode !== node) {\n          ret.push(node);\n        }\n        if (node.type === "INSTANCE") {\n          for (const child of node.children) {\n            queue.push(child);\n          }\n        }\n      }\n    }\n    return ret;\n  }\n  function createNodeHandle(layer) {\n    switch (layer.type) {\n      case "TEXT":\n        return createTextHandle(layer);\n      case "INSTANCE":\n        return createInstanceHandle(layer);\n      default:\n        return createErrorHandle(\n          new Error("Internal error: Unknown layer type: " + layer.type)\n        );\n    }\n  }\n  function createTextHandle(node) {\n    return Object.freeze({\n      get name() {\n        return node.name;\n      },\n      get type() {\n        return node.type;\n      },\n      get textContent() {\n        return node.textContent;\n      },\n      __render__() {\n        return node.textContent;\n      }\n    });\n  }\n  function getRenderedTemplateMetadata(node) {\n    const { guid } = node;\n    if (!instanceTemplates[guid]) {\n      return createErrorHandle(\n        new TemplateExecutionError("Instance does not have a template associated with it")\n      );\n    }\n    const result = instanceTemplates[guid](node, instanceTemplates);\n    if (result.result === "ERROR") {\n      return createErrorHandle(new TemplateExecutionError("Nested template could not be executed"));\n    }\n    if (!("metadata" in result.data)) {\n      return createErrorHandle(new TemplateExecutionError("Instance does not expose any props"));\n    }\n    return result.data.metadata;\n  }\n  function isErrorHandle(obj) {\n    return obj.type === "ERROR";\n  }\n  function createInstanceHandle(node) {\n    const handle = Object.freeze({\n      properties: node.properties,\n      get name() {\n        return node.name;\n      },\n      get children() {\n        return node.children.map(createNodeHandle);\n      },\n      get type() {\n        return node.type;\n      },\n      get symbolId() {\n        return node.symbolId;\n      },\n      get path() {\n        return node.path;\n      },\n      codeConnectId() {\n        const { guid } = node;\n        if (!instanceTemplates[guid]) {\n          return null;\n        }\n        const result = instanceTemplates[guid](node, instanceTemplates);\n        if (result.result === "ERROR") {\n          return null;\n        }\n        if (!("id" in result.data)) {\n          return null;\n        }\n        return result.data.id;\n      },\n      __findChildWithCriteria__({ type, name: name2 }) {\n        const child = node.children.find((child2) => child2.type === type && child2.name === name2);\n        if (!child) {\n          return createErrorHandle(\n            new ChildLayerNotFoundError(`Child layer not found: ${name2}`, name2)\n          );\n        }\n        return createNodeHandle(child);\n      },\n      __find__(name2) {\n        const child = bfsFindNode(node, (node2) => node2.name === name2 && node2.type === "INSTANCE");\n        if (!child) {\n          return createErrorHandle(\n            new ChildLayerNotFoundError(\n              `Child layer named \'${name2}\' not found in selected component/variant`,\n              name2\n            )\n          );\n        }\n        return createNodeHandle(child);\n      },\n      __getPropertyValue__(name2) {\n        if (!node.properties[name2]) {\n          return createErrorHandle(new PropertyNotFoundError(`Property not found: ${name2}`, name2));\n        }\n        return node.properties[name2].value;\n      },\n      __renderWithFn__(renderFn) {\n        const metadata = getRenderedTemplateMetadata(node);\n        if (isErrorHandle(metadata)) {\n          return metadata.__render__();\n        }\n        if (!metadata) {\n          return metadata;\n        }\n        const res = renderFn(metadata.__props);\n        if (!res.sections) {\n          return createErrorHandle(new TemplateExecutionError("Failed to render nested template"));\n        }\n        return res.sections;\n      },\n      __getProps__() {\n        const metadata = getRenderedTemplateMetadata(node);\n        if (isErrorHandle(metadata)) {\n          return metadata.__render__();\n        }\n        if (!metadata) {\n          return metadata;\n        }\n        return metadata.__props;\n      },\n      __render__() {\n        const { guid, symbolId } = node;\n        if (!inlineInstancesEnabled || !instanceTemplates[guid]) {\n          return [\n            {\n              type: "INSTANCE",\n              guid,\n              symbolId\n            }\n          ];\n        }\n        const result = instanceTemplates[guid](node, instanceTemplates);\n        if (result.result === "ERROR") {\n          return [\n            {\n              type: "INSTANCE",\n              guid,\n              symbolId\n            }\n          ];\n        }\n        if (`example` in result.data) {\n          return result.data.example.sections;\n        }\n        if (result.data.type === "VALUE") {\n          return result.data.value;\n        }\n        return result.data.sections;\n      },\n      executeTemplate() {\n        const { guid, symbolId } = node;\n        let metadata = getRenderedTemplateMetadata(node);\n        if (isErrorHandle(metadata)) {\n          metadata = void 0;\n        }\n        if (!inlineInstancesEnabled || !instanceTemplates[guid] || metadata && "nestable" in metadata && !metadata["nestable"]) {\n          return {\n            example: [\n              {\n                type: "INSTANCE",\n                guid,\n                symbolId\n              }\n            ],\n            metadata\n          };\n        }\n        const result = instanceTemplates[guid](node, instanceTemplates);\n        if (result.result === "ERROR") {\n          return {\n            example: [\n              {\n                type: "INSTANCE",\n                guid,\n                symbolId\n              }\n            ],\n            metadata\n          };\n        }\n        if (`example` in result.data) {\n          return { example: result.data.example.sections, metadata };\n        }\n        if (result.data.type === "VALUE") {\n          return { example: result.data.value, metadata };\n        }\n        return { example: result.data.sections, metadata };\n      },\n      getString: function(propertyName) {\n        return getStringProperty(propertyName, this);\n      },\n      getBoolean: function(propertyName, options) {\n        return getBooleanProperty(propertyName, options, this);\n      },\n      getEnum: function(propertyName, options) {\n        const value = this.__getPropertyValue__(propertyName);\n        if (!value) {\n          return void 0;\n        }\n        if (typeof value === "object" && value.type === "ERROR") {\n          return value.__render__();\n        }\n        let key = value;\n        if (typeof key === "boolean") {\n          key = key.toString();\n        }\n        return Object.keys(options).includes(key) ? options[key] : void 0;\n      },\n      getInstanceSwap: function(instanceSwapProp) {\n        const symbolId = this.__getPropertyValue__(instanceSwapProp);\n        if (typeof symbolId === "object" && symbolId.type === "ERROR") {\n          return symbolId.__render__();\n        }\n        if (!symbolId || typeof symbolId !== "string") {\n          return void 0;\n        }\n        const child = this.children.find(\n          (node2) => node2.type === "INSTANCE" && node2.symbolId === symbolId\n        );\n        return child;\n      },\n      hasCodeConnect: function() {\n        const { guid } = node;\n        return !!instanceTemplates[guid];\n      },\n      getPropertyValue: function(name2) {\n        return this.__getPropertyValue__(name2);\n      },\n      findInstance(layerName, opts) {\n        const filterFunction = (node2) => node2.name === layerName && node2.type === "INSTANCE" && (opts && opts.path ? startsWithArray(node2.path, opts.path) : true);\n        let child;\n        if (opts?.traverseInstances) {\n          child = bfsFindNode(node, filterFunction);\n        } else {\n          child = node.children.find(filterFunction);\n        }\n        if (!child) {\n          return createErrorHandle(\n            new ChildLayerNotFoundError(\n              `Child layer named \'${layerName}\' not found in selected component/variant`,\n              layerName\n            )\n          );\n        }\n        return createNodeHandle(child);\n      },\n      findText(layerName, opts) {\n        const filterFunction = (node2) => node2.name === layerName && node2.type === "TEXT" && (opts && opts.path ? startsWithArray(node2.path, opts.path) : true);\n        let child;\n        if (opts?.traverseInstances) {\n          child = bfsFindNode(node, filterFunction);\n        } else {\n          child = node.children.find(filterFunction);\n        }\n        if (!child) {\n          return createErrorHandle(\n            new ChildLayerNotFoundError(\n              `Text layer named \'${layerName}\' not found in selected component/variant`,\n              layerName\n            )\n          );\n        }\n        return createNodeHandle(child);\n      },\n      findConnectedInstance(codeConnectId, opts) {\n        const filterFunction = (node2) => node2.type === "INSTANCE" && node2.codeConnectId() === codeConnectId && (opts && opts.path ? startsWithArray(node2.path, opts.path) : true);\n        let child;\n        if (opts?.traverseInstances) {\n          child = bfsFindNode(this, filterFunction);\n        } else {\n          child = this.children.find(filterFunction);\n        }\n        if (!child) {\n          return createErrorHandle(\n            new ChildLayerIdNotFoundError(\n              `No layer with id \'${codeConnectId}\' found in selected component/variant`,\n              codeConnectId\n            )\n          );\n        }\n        return child;\n      },\n      findConnectedInstances(selectorFn, opts) {\n        const filterFunction = (node2) => node2.type === "INSTANCE" && node2.hasCodeConnect() && selectorFn(node2) && (opts && opts.path ? startsWithArray(node2.path, opts.path) : true);\n        let foundComponents;\n        if (opts?.traverseInstances) {\n          foundComponents = bfsFindAllNodes(this, filterFunction);\n        } else {\n          foundComponents = this.children.filter(filterFunction);\n        }\n        return foundComponents;\n      },\n      findLayers(selectorFn, opts) {\n        const filterFunction = (node2) => selectorFn(node2) && (opts && opts.path ? startsWithArray(node2.path, opts.path) : true);\n        let foundComponents;\n        if (opts?.traverseInstances) {\n          foundComponents = bfsFindAllNodes(this, filterFunction);\n        } else {\n          foundComponents = this.children.filter(filterFunction);\n        }\n        return foundComponents;\n      }\n    });\n    return {\n      ...handle,\n      __properties__: propertiesAPI(handle)\n    };\n  }\n  function startsWithArray(A, B) {\n    if (B.length > A.length) return false;\n    return B.every((value, index) => A[index] === value);\n  }\n  function createErrorHandle(error) {\n    return Object.freeze({\n      type: "ERROR",\n      __render__() {\n        return [\n          {\n            type: "ERROR",\n            message: error.message,\n            errorObject: error instanceof ChildLayerNotFoundError || error instanceof ChildLayerIdNotFoundError || error instanceof PropertyNotFoundError ? error.errorObject : void 0\n          }\n        ];\n      },\n      executeTemplate() {\n        return {\n          example: [\n            {\n              type: "ERROR",\n              message: error.message,\n              errorObject: error instanceof ChildLayerNotFoundError || error instanceof ChildLayerIdNotFoundError || error instanceof PropertyNotFoundError ? error.errorObject : void 0\n            }\n          ]\n        };\n      }\n    });\n  }\n  if (name !== "figma") {\n    throw new Error(\n      \'`require` called with a module other than "figma". You cannot use other modules in templates.\'\n    );\n  }\n  function normalizeFigmaPropValue(value) {\n    if (typeof value === "boolean") {\n      return value.toString();\n    }\n    const lowercase = value.toLowerCase();\n    if (lowercase === "true" || lowercase === "yes" || lowercase === "on") {\n      return "true";\n    } else if (lowercase === "false" || lowercase === "no" || lowercase === "off") {\n      return "false";\n    }\n    return value;\n  }\n  function templateString(language) {\n    return function(strings, ...values) {\n      const sections = [];\n      for (let i = 0; i < strings.length; i++) {\n        let addString2 = function(value) {\n          const stringToAdd = value.toString();\n          const lastSection = sections[sections.length - 1];\n          if (!lastSection || lastSection.type !== "CODE") {\n            sections.push({ type: "CODE", code: stringToAdd });\n          } else {\n            lastSection.code += stringToAdd;\n          }\n        }, addSections2 = function(sectionsToAdd) {\n          for (const section of sectionsToAdd) {\n            if (section.type === "CODE") {\n              addString2(section.code);\n            } else {\n              sections.push(section);\n            }\n          }\n        };\n        var addString = addString2, addSections = addSections2;\n        const string = strings[i];\n        const isLastString = i === strings.length - 1;\n        if (string) {\n          addString2(string);\n        }\n        if (!isLastString) {\n          const item = values[i];\n          if (typeof item === "string" || typeof item === "boolean" || typeof item === "number") {\n            addString2(item);\n          } else if (itemIsTemplateStringResult(item)) {\n            addSections2(item.sections);\n          } else if (item) {\n            addSections2(item);\n          }\n        }\n      }\n      return { sections, language, type: "SECTIONS" };\n    };\n  }\n  function renderValue(raw, preview) {\n    return {\n      type: "VALUE",\n      value: raw,\n      preview: preview ?? raw\n    };\n  }\n  function getBooleanProperty(propertyName, options, instanceHandle) {\n    const value = instanceHandle.__getPropertyValue__(propertyName);\n    if (typeof value === "object" && value.type === "ERROR") {\n      return value.__render__();\n    }\n    const valueAsString = normalizeFigmaPropValue(value);\n    if (!value && !(options && Object.keys(options).includes(valueAsString))) {\n      return void 0;\n    }\n    if (options) {\n      return Object.keys(options).includes(valueAsString) ? options[valueAsString] : void 0;\n    } else {\n      return valueAsString === "true";\n    }\n  }\n  function getStringProperty(propertyName, instanceHandle) {\n    const value = instanceHandle.__getPropertyValue__(propertyName);\n    if (typeof value === "object" && value.type === "ERROR") {\n      return value.__render__();\n    }\n    return value;\n  }\n  function itemIsTemplateStringResult(item) {\n    return !Array.isArray(item) && item?.sections;\n  }\n  function propertiesAPI(node) {\n    return Object.freeze({\n      // Templates V2 uses getString defined above\n      string: function(propertyName) {\n        return getStringProperty(propertyName, node);\n      },\n      // Templates V2 uses getBoolean defined above\n      boolean: function(propertyName, options) {\n        return getBooleanProperty(propertyName, options, node);\n      },\n      // Templates V2 uses getEnum defined above\n      enum: function(propertyName, options) {\n        const value = node.__getPropertyValue__(propertyName);\n        if (!value) {\n          return void 0;\n        }\n        if (typeof value === "object" && value.type === "ERROR") {\n          return value.__render__();\n        }\n        let key = value;\n        if (typeof key === "boolean") {\n          key = key.toString();\n        }\n        return Object.keys(options).includes(key) ? options[key] : void 0;\n      },\n      instance: function(propertyName) {\n        const symbolId = node.__getPropertyValue__(propertyName);\n        if (typeof symbolId === "object" && symbolId.type === "ERROR") {\n          return symbolId.__render__();\n        }\n        if (!symbolId || typeof symbolId !== "string") {\n          return void 0;\n        }\n        const child = node.children.find(\n          (node2) => node2.type === "INSTANCE" && node2.symbolId === symbolId\n        );\n        return child && child.__render__();\n      },\n      __instance__(instanceSwapProp) {\n        const symbolId = node.__getPropertyValue__(instanceSwapProp);\n        if (typeof symbolId === "object" && symbolId.type === "ERROR") {\n          return symbolId.__render__();\n        }\n        if (!symbolId || typeof symbolId !== "string") {\n          return void 0;\n        }\n        const child = node.children.find(\n          (node2) => node2.type === "INSTANCE" && node2.symbolId === symbolId\n        );\n        return child;\n      },\n      children: function(layerNames) {\n        let filterFunction = (node2) => node2.type === "INSTANCE" && layerNames.includes(node2.name);\n        if (layerNames.length === 1 && layerNames[0].includes("*")) {\n          const regex = new RegExp("^" + layerNames[0].replace("*", ".*"));\n          filterFunction = (node2) => node2.type === "INSTANCE" && regex.test(node2.name);\n        }\n        return node.children.filter(filterFunction).map((node2) => {\n          return node2.__render__();\n        }).flat();\n      }\n    });\n  }\n  return Object.freeze({\n    currentLayer,\n    selectedInstance: currentLayer,\n    // expose this to be backwards compatible with the old API\n    properties: currentLayer.__properties__,\n    // \'jsx\' seems to give slightly better highlighting\n    html: templateString("html"),\n    tsx: templateString("jsx"),\n    swift: templateString("swift"),\n    kotlin: templateString("kotlin"),\n    value: renderValue,\n    code: templateString("custom")\n  });\n};\n';
export default a
