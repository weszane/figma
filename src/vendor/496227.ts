!function (e, n) {
  n(exports);
}(0, function (e) {
  "use strict";

  var r = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  var n = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
  var i = "\u200C\u200D\xb7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
  var s = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
  var o = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments"
  };
  var a = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
  var h = {
    5: a,
    "5module": a + " export import",
    6: a + " const class extends export import super"
  };
  var d = /^in(stanceof)?$/;
  var p = RegExp("[" + s + "]");
  var g = RegExp("[" + s + i + "]");
  function m(e, r) {
    for (n = 65536, i = 0, void 0; i < r.length && !((n += r[i]) > e); i += 2) {
      var n;
      var i;
      if ((n += r[i + 1]) >= e) return !0;
    }
    return !1;
  }
  function v(e, r) {
    return e < 65 ? 36 === e : e < 91 || (e < 97 ? 95 === e : e < 123 || (e <= 65535 ? e >= 170 && p.test(String.fromCharCode(e)) : !1 !== r && m(e, n)));
  }
  function y(e, i) {
    return e < 48 ? 36 === e : e < 58 || !(e < 65) && (e < 91 || (e < 97 ? 95 === e : e < 123 || (e <= 65535 ? e >= 170 && g.test(String.fromCharCode(e)) : !1 !== i && (m(e, n) || m(e, r)))));
  }
  var b = function (e, r) {
    void 0 === r && (r = {});
    this.label = e;
    this.keyword = r.keyword;
    this.beforeExpr = !!r.beforeExpr;
    this.startsExpr = !!r.startsExpr;
    this.isLoop = !!r.isLoop;
    this.isAssign = !!r.isAssign;
    this.prefix = !!r.prefix;
    this.postfix = !!r.postfix;
    this.binop = r.binop || null;
    this.updateContext = null;
  };
  function O(e, r) {
    return new b(e, {
      beforeExpr: !0,
      binop: r
    });
  }
  var x = {
    beforeExpr: !0
  };
  var w = {
    startsExpr: !0
  };
  var k = {};
  function _(e, r) {
    void 0 === r && (r = {});
    r.keyword = e;
    return k[e] = new b(e, r);
  }
  var S = {
    num: new b("num", w),
    regexp: new b("regexp", w),
    string: new b("string", w),
    name: new b("name", w),
    privateId: new b("privateId", w),
    eof: new b("eof"),
    bracketL: new b("[", {
      beforeExpr: !0,
      startsExpr: !0
    }),
    bracketR: new b("]"),
    braceL: new b("{", {
      beforeExpr: !0,
      startsExpr: !0
    }),
    braceR: new b("}"),
    parenL: new b("(", {
      beforeExpr: !0,
      startsExpr: !0
    }),
    parenR: new b(")"),
    comma: new b(",", x),
    semi: new b(";", x),
    colon: new b(":", x),
    dot: new b("."),
    question: new b("?", x),
    questionDot: new b("?."),
    arrow: new b("=>", x),
    template: new b("template"),
    invalidTemplate: new b("invalidTemplate"),
    ellipsis: new b("...", x),
    backQuote: new b("`", w),
    dollarBraceL: new b("${", {
      beforeExpr: !0,
      startsExpr: !0
    }),
    eq: new b("=", {
      beforeExpr: !0,
      isAssign: !0
    }),
    assign: new b("_=", {
      beforeExpr: !0,
      isAssign: !0
    }),
    incDec: new b("++/--", {
      prefix: !0,
      postfix: !0,
      startsExpr: !0
    }),
    prefix: new b("!/~", {
      beforeExpr: !0,
      prefix: !0,
      startsExpr: !0
    }),
    logicalOR: O("||", 1),
    logicalAND: O("&&", 2),
    bitwiseOR: O("|", 3),
    bitwiseXOR: O("^", 4),
    bitwiseAND: O("&", 5),
    equality: O("==/!=/===/!==", 6),
    relational: O("</>/<=/>=", 7),
    bitShift: O("<</>>/>>>", 8),
    plusMin: new b("+/-", {
      beforeExpr: !0,
      binop: 9,
      prefix: !0,
      startsExpr: !0
    }),
    modulo: O("%", 10),
    star: O("*", 10),
    slash: O("/", 10),
    starstar: new b("**", {
      beforeExpr: !0
    }),
    coalesce: O("??", 1),
    _break: _("break"),
    _case: _("case", x),
    _catch: _("catch"),
    _continue: _("continue"),
    _debugger: _("debugger"),
    _default: _("default", x),
    _do: _("do", {
      isLoop: !0,
      beforeExpr: !0
    }),
    _else: _("else", x),
    _finally: _("finally"),
    _for: _("for", {
      isLoop: !0
    }),
    _function: _("function", w),
    _if: _("if"),
    _return: _("return", x),
    _switch: _("switch"),
    _throw: _("throw", x),
    _try: _("try"),
    _var: _("var"),
    _const: _("const"),
    _while: _("while", {
      isLoop: !0
    }),
    _with: _("with"),
    _new: _("new", {
      beforeExpr: !0,
      startsExpr: !0
    }),
    _this: _("this", w),
    _super: _("super", w),
    _class: _("class", w),
    _extends: _("extends", x),
    _export: _("export"),
    _import: _("import", w),
    _null: _("null", w),
    _true: _("true", w),
    _false: _("false", w),
    _in: _("in", {
      beforeExpr: !0,
      binop: 7
    }),
    _instanceof: _("instanceof", {
      beforeExpr: !0,
      binop: 7
    }),
    _typeof: _("typeof", {
      beforeExpr: !0,
      prefix: !0,
      startsExpr: !0
    }),
    _void: _("void", {
      beforeExpr: !0,
      prefix: !0,
      startsExpr: !0
    }),
    _delete: _("delete", {
      beforeExpr: !0,
      prefix: !0,
      startsExpr: !0
    })
  };
  var E = /\r\n?|\n|\u2028|\u2029/;
  var A = RegExp(E.source, "g");
  function C(e) {
    return 10 === e || 13 === e || 8232 === e || 8233 === e;
  }
  function T(e, r, n) {
    void 0 === n && (n = e.length);
    for (var i = r; i < n; i++) {
      var s = e.charCodeAt(i);
      if (C(s)) return i < n - 1 && 13 === s && 10 === e.charCodeAt(i + 1) ? i + 2 : i + 1;
    }
    return -1;
  }
  var I = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
  var P = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
  var R = Object.prototype;
  var M = R.hasOwnProperty;
  var D = R.toString;
  var N = Object.hasOwn || function (e, r) {
    return M.call(e, r);
  };
  var $ = Array.isArray || function (e) {
    return "[object Array]" === D.call(e);
  };
  var L = Object.create(null);
  function j(e) {
    return L[e] || (L[e] = RegExp("^(?:" + e.replace(/ /g, "|") + ")$"));
  }
  function z(e) {
    return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(((e -= 65536) >> 10) + 55296, (1023 & e) + 56320);
  }
  var Z = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
  var F = function (e, r) {
    this.line = e;
    this.column = r;
  };
  F.prototype.offset = function (e) {
    return new F(this.line, this.column + e);
  };
  var U = function (e, r, n) {
    this.start = r;
    this.end = n;
    null !== e.sourceFile && (this.source = e.sourceFile);
  };
  function Q(e, r) {
    for (n = 1, i = 0, void 0;;) {
      var n;
      var i;
      var s = T(e, i, r);
      if (s < 0) return new F(n, r - i);
      ++n;
      i = s;
    }
  }
  var V = {
    ecmaVersion: null,
    sourceType: "script",
    onInsertedSemicolon: null,
    onTrailingComma: null,
    allowReserved: null,
    allowReturnOutsideFunction: !1,
    allowImportExportEverywhere: !1,
    allowAwaitOutsideFunction: null,
    allowSuperOutsideMethod: null,
    allowHashBang: !1,
    checkPrivateFields: !0,
    locations: !1,
    onToken: null,
    onComment: null,
    ranges: !1,
    program: null,
    sourceFile: null,
    directSourceFile: null,
    preserveParens: !1
  };
  var B = !1;
  function q(e) {
    var r = {};
    for (var n in V) r[n] = e && N(e, n) ? e[n] : V[n];
    if ("latest" === r.ecmaVersion ? r.ecmaVersion = 1e8 : null == r.ecmaVersion ? (!B && "object" == typeof console && console.warn && (B = !0, console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.")), r.ecmaVersion = 11) : r.ecmaVersion >= 2015 && (r.ecmaVersion -= 2009), null == r.allowReserved && (r.allowReserved = r.ecmaVersion < 5), e && null != e.allowHashBang || (r.allowHashBang = r.ecmaVersion >= 14), $(r.onToken)) {
      var i = r.onToken;
      r.onToken = function (e) {
        return i.push(e);
      };
    }
    $(r.onComment) && (r.onComment = W(r, r.onComment));
    return r;
  }
  function W(e, r) {
    return function (n, i, s, o, a, h) {
      var d = {
        type: n ? "Block" : "Line",
        value: i,
        start: s,
        end: o
      };
      e.locations && (d.loc = new U(this, a, h));
      e.ranges && (d.range = [s, o]);
      r.push(d);
    };
  }
  var Y = 1;
  var G = 2;
  var X = 4;
  var H = 8;
  var K = 16;
  var J = 32;
  var ee = 64;
  var et = 128;
  var er = 256;
  var en = 512;
  var ei = 259;
  function es(e, r) {
    return G | (e ? X : 0) | (r ? H : 0);
  }
  var eo = 0;
  var ea = 1;
  var el = 2;
  var eu = 3;
  var ec = 4;
  var eh = 5;
  var ed = function (e, r, n) {
    this.options = e = q(e);
    this.sourceFile = e.sourceFile;
    this.keywords = j(h[e.ecmaVersion >= 6 ? 6 : "module" === e.sourceType ? "5module" : 5]);
    var i = "";
    !0 !== e.allowReserved && (i = o[e.ecmaVersion >= 6 ? 6 : 5 === e.ecmaVersion ? 5 : 3], "module" === e.sourceType && (i += " await"));
    this.reservedWords = j(i);
    var s = (i ? i + " " : "") + o.strict;
    this.reservedWordsStrict = j(s);
    this.reservedWordsStrictBind = j(s + " " + o.strictBind);
    this.input = String(r);
    this.containsEsc = !1;
    n ? (this.pos = n, this.lineStart = this.input.lastIndexOf("\n", n - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(E).length) : (this.pos = this.lineStart = 0, this.curLine = 1);
    this.type = S.eof;
    this.value = null;
    this.start = this.end = this.pos;
    this.startLoc = this.endLoc = this.curPosition();
    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;
    this.context = this.initialContext();
    this.exprAllowed = !0;
    this.inModule = "module" === e.sourceType;
    this.strict = this.inModule || this.strictDirective(this.pos);
    this.potentialArrowAt = -1;
    this.potentialArrowInForAwait = !1;
    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
    this.labels = [];
    this.undefinedExports = Object.create(null);
    0 === this.pos && e.allowHashBang && "#!" === this.input.slice(0, 2) && this.skipLineComment(2);
    this.scopeStack = [];
    this.enterScope(Y);
    this.regexpState = null;
    this.privateNameStack = [];
  };
  var ef = {
    inFunction: {
      configurable: !0
    },
    inGenerator: {
      configurable: !0
    },
    inAsync: {
      configurable: !0
    },
    canAwait: {
      configurable: !0
    },
    allowSuper: {
      configurable: !0
    },
    allowDirectSuper: {
      configurable: !0
    },
    treatFunctionsAsVar: {
      configurable: !0
    },
    allowNewDotTarget: {
      configurable: !0
    },
    inClassStaticBlock: {
      configurable: !0
    }
  };
  ed.prototype.parse = function () {
    var e = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(e);
  };
  ef.inFunction.get = function () {
    return (this.currentVarScope().flags & G) > 0;
  };
  ef.inGenerator.get = function () {
    return (this.currentVarScope().flags & H) > 0;
  };
  ef.inAsync.get = function () {
    return (this.currentVarScope().flags & X) > 0;
  };
  ef.canAwait.get = function () {
    for (var e = this.scopeStack.length - 1; e >= 0; e--) {
      var r = this.scopeStack[e].flags;
      if (r & (er | en)) return !1;
      if (r & G) return (r & X) > 0;
    }
    return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
  };
  ef.allowSuper.get = function () {
    return (this.currentThisScope().flags & ee) > 0 || this.options.allowSuperOutsideMethod;
  };
  ef.allowDirectSuper.get = function () {
    return (this.currentThisScope().flags & et) > 0;
  };
  ef.treatFunctionsAsVar.get = function () {
    return this.treatFunctionsAsVarInScope(this.currentScope());
  };
  ef.allowNewDotTarget.get = function () {
    for (var e = this.scopeStack.length - 1; e >= 0; e--) {
      var r = this.scopeStack[e].flags;
      if (r & (er | en) || r & G && !(r & K)) return !0;
    }
    return !1;
  };
  ef.inClassStaticBlock.get = function () {
    return (this.currentVarScope().flags & er) > 0;
  };
  ed.extend = function () {
    for (e = [], r = $$arguments.length, void 0; r--;) {
      var e;
      var r;
      e[r] = $$arguments[r];
    }
    for (n = this, i = 0, void 0; i < e.length; i++) {
      var n;
      var i;
      n = e[i](n);
    }
    return n;
  };
  ed.parse = function (e, r) {
    return new this(r, e).parse();
  };
  ed.parseExpressionAt = function (e, r, n) {
    var i = new this(n, e, r);
    i.nextToken();
    return i.parseExpression();
  };
  ed.tokenizer = function (e, r) {
    return new this(r, e);
  };
  Object.defineProperties(ed.prototype, ef);
  var ep = ed.prototype;
  var eg = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
  ep.strictDirective = function (e) {
    if (this.options.ecmaVersion < 5) return !1;
    for (;;) {
      P.lastIndex = e;
      e += P.exec(this.input)[0].length;
      var r = eg.exec(this.input.slice(e));
      if (!r) return !1;
      if ("use strict" === (r[1] || r[2])) {
        P.lastIndex = e + r[0].length;
        var n = P.exec(this.input);
        var i = n.index + n[0].length;
        var s = this.input.charAt(i);
        return ";" === s || "}" === s || E.test(n[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(s) || "!" === s && "=" === this.input.charAt(i + 1));
      }
      e += r[0].length;
      P.lastIndex = e;
      e += P.exec(this.input)[0].length;
      ";" === this.input[e] && e++;
    }
  };
  ep.eat = function (e) {
    return this.type === e && (this.next(), !0);
  };
  ep.isContextual = function (e) {
    return this.type === S.name && this.value === e && !this.containsEsc;
  };
  ep.eatContextual = function (e) {
    return !!this.isContextual(e) && (this.next(), !0);
  };
  ep.expectContextual = function (e) {
    this.eatContextual(e) || this.unexpected();
  };
  ep.canInsertSemicolon = function () {
    return this.type === S.eof || this.type === S.braceR || E.test(this.input.slice(this.lastTokEnd, this.start));
  };
  ep.insertSemicolon = function () {
    if (this.canInsertSemicolon()) {
      this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
      return !0;
    }
  };
  ep.semicolon = function () {
    this.eat(S.semi) || this.insertSemicolon() || this.unexpected();
  };
  ep.afterTrailingComma = function (e, r) {
    if (this.type === e) {
      this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
      r || this.next();
      return !0;
    }
  };
  ep.expect = function (e) {
    this.eat(e) || this.unexpected();
  };
  ep.unexpected = function (e) {
    this.raise(null != e ? e : this.start, "Unexpected token");
  };
  var em = function () {
    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
  };
  ep.checkPatternErrors = function (e, r) {
    if (e) {
      e.trailingComma > -1 && this.raiseRecoverable(e.trailingComma, "Comma is not permitted after the rest element");
      var n = r ? e.parenthesizedAssign : e.parenthesizedBind;
      n > -1 && this.raiseRecoverable(n, r ? "Assigning to rvalue" : "Parenthesized pattern");
    }
  };
  ep.checkExpressionErrors = function (e, r) {
    if (!e) return !1;
    var n = e.shorthandAssign;
    var i = e.doubleProto;
    if (!r) return n >= 0 || i >= 0;
    n >= 0 && this.raise(n, "Shorthand property assignments are valid only in destructuring patterns");
    i >= 0 && this.raiseRecoverable(i, "Redefinition of __proto__ property");
  };
  ep.checkYieldAwaitInDefaultParams = function () {
    this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value");
    this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
  };
  ep.isSimpleAssignTarget = function (e) {
    return "ParenthesizedExpression" === e.type ? this.isSimpleAssignTarget(e.expression) : "Identifier" === e.type || "MemberExpression" === e.type;
  };
  var ev = ed.prototype;
  ev.parseTopLevel = function (e) {
    var r = Object.create(null);
    for (e.body || (e.body = []); this.type !== S.eof;) {
      var n = this.parseStatement(null, !0, r);
      e.body.push(n);
    }
    if (this.inModule) for (i = 0, s = Object.keys(this.undefinedExports), void 0; i < s.length; i += 1) {
      var i;
      var s;
      var o = s[i];
      this.raiseRecoverable(this.undefinedExports[o].start, "Export '" + o + "' is not defined");
    }
    this.adaptDirectivePrologue(e.body);
    this.next();
    e.sourceType = this.options.sourceType;
    return this.finishNode(e, "Program");
  };
  var ey = {
    kind: "loop"
  };
  var eb = {
    kind: "switch"
  };
  ev.isLet = function (e) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return !1;
    P.lastIndex = this.pos;
    var r = P.exec(this.input);
    var n = this.pos + r[0].length;
    var i = this.input.charCodeAt(n);
    if (91 === i || 92 === i) return !0;
    if (e) return !1;
    if (123 === i || i > 55295 && i < 56320) return !0;
    if (v(i, !0)) {
      for (var s = n + 1; y(i = this.input.charCodeAt(s), !0);) ++s;
      if (92 === i || i > 55295 && i < 56320) return !0;
      var o = this.input.slice(n, s);
      if (!d.test(o)) return !0;
    }
    return !1;
  };
  ev.isAsyncFunction = function () {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return !1;
    P.lastIndex = this.pos;
    var e;
    var r = P.exec(this.input);
    var n = this.pos + r[0].length;
    return !E.test(this.input.slice(this.pos, n)) && "function" === this.input.slice(n, n + 8) && (n + 8 === this.input.length || !(y(e = this.input.charCodeAt(n + 8)) || e > 55295 && e < 56320));
  };
  ev.isUsingKeyword = function (e, r) {
    if (this.options.ecmaVersion < 17 || !this.isContextual(e ? "await" : "using")) return !1;
    P.lastIndex = this.pos;
    var n = P.exec(this.input);
    var i = this.pos + n[0].length;
    if (E.test(this.input.slice(this.pos, i))) return !1;
    if (e) {
      var s;
      var o = i + 5;
      if ("using" !== this.input.slice(i, o) || o === this.input.length || y(s = this.input.charCodeAt(o)) || s > 55295 && s < 56320) return !1;
      P.lastIndex = o;
      var a = P.exec(this.input);
      if (a && E.test(this.input.slice(o, o + a[0].length))) return !1;
    }
    if (r) {
      var h;
      var d = i + 2;
      if ("of" === this.input.slice(i, d) && (d === this.input.length || !y(h = this.input.charCodeAt(d)) && !(h > 55295 && h < 56320))) return !1;
    }
    var p = this.input.charCodeAt(i);
    return v(p, !0) || 92 === p;
  };
  ev.isAwaitUsing = function (e) {
    return this.isUsingKeyword(!0, e);
  };
  ev.isUsing = function (e) {
    return this.isUsingKeyword(!1, e);
  };
  ev.parseStatement = function (e, r, n) {
    var i;
    var s = this.type;
    var o = this.startNode();
    switch (this.isLet(e) && (s = S._var, i = "let"), s) {
      case S._break:
      case S._continue:
        return this.parseBreakContinueStatement(o, s.keyword);
      case S._debugger:
        return this.parseDebuggerStatement(o);
      case S._do:
        return this.parseDoStatement(o);
      case S._for:
        return this.parseForStatement(o);
      case S._function:
        e && (this.strict || "if" !== e && "label" !== e) && this.options.ecmaVersion >= 6 && this.unexpected();
        return this.parseFunctionStatement(o, !1, !e);
      case S._class:
        e && this.unexpected();
        return this.parseClass(o, !0);
      case S._if:
        return this.parseIfStatement(o);
      case S._return:
        return this.parseReturnStatement(o);
      case S._switch:
        return this.parseSwitchStatement(o);
      case S._throw:
        return this.parseThrowStatement(o);
      case S._try:
        return this.parseTryStatement(o);
      case S._const:
      case S._var:
        i = i || this.value;
        e && "var" !== i && this.unexpected();
        return this.parseVarStatement(o, i);
      case S._while:
        return this.parseWhileStatement(o);
      case S._with:
        return this.parseWithStatement(o);
      case S.braceL:
        return this.parseBlock(!0, o);
      case S.semi:
        return this.parseEmptyStatement(o);
      case S._export:
      case S._import:
        if (this.options.ecmaVersion > 10 && s === S._import) {
          P.lastIndex = this.pos;
          var a = P.exec(this.input);
          var h = this.pos + a[0].length;
          var d = this.input.charCodeAt(h);
          if (40 === d || 46 === d) return this.parseExpressionStatement(o, this.parseExpression());
        }
        this.options.allowImportExportEverywhere || (r || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"));
        return s === S._import ? this.parseImport(o) : this.parseExport(o, n);
      default:
        if (this.isAsyncFunction()) {
          e && this.unexpected();
          this.next();
          return this.parseFunctionStatement(o, !0, !e);
        }
        var p = this.isAwaitUsing(!1) ? "await using" : this.isUsing(!1) ? "using" : null;
        if (p) {
          r && "script" === this.options.sourceType && this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`");
          "await using" === p && (this.canAwait || this.raise(this.start, "Await using cannot appear outside of async function"), this.next());
          this.next();
          this.parseVar(o, !1, p);
          this.semicolon();
          return this.finishNode(o, "VariableDeclaration");
        }
        var g = this.value;
        var m = this.parseExpression();
        if (s === S.name && "Identifier" === m.type && this.eat(S.colon)) return this.parseLabeledStatement(o, g, m, e);
        return this.parseExpressionStatement(o, m);
    }
  };
  ev.parseBreakContinueStatement = function (e, r) {
    var n = "break" === r;
    this.next();
    this.eat(S.semi) || this.insertSemicolon() ? e.label = null : this.type !== S.name ? this.unexpected() : (e.label = this.parseIdent(), this.semicolon());
    for (var i = 0; i < this.labels.length; ++i) {
      var s = this.labels[i];
      if ((null == e.label || s.name === e.label.name) && (null != s.kind && (n || "loop" === s.kind) || e.label && n)) break;
    }
    i === this.labels.length && this.raise(e.start, "Unsyntactic " + r);
    return this.finishNode(e, n ? "BreakStatement" : "ContinueStatement");
  };
  ev.parseDebuggerStatement = function (e) {
    this.next();
    this.semicolon();
    return this.finishNode(e, "DebuggerStatement");
  };
  ev.parseDoStatement = function (e) {
    this.next();
    this.labels.push(ey);
    e.body = this.parseStatement("do");
    this.labels.pop();
    this.expect(S._while);
    e.test = this.parseParenExpression();
    this.options.ecmaVersion >= 6 ? this.eat(S.semi) : this.semicolon();
    return this.finishNode(e, "DoWhileStatement");
  };
  ev.parseForStatement = function (e) {
    this.next();
    var r = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
    if (this.labels.push(ey), this.enterScope(0), this.expect(S.parenL), this.type === S.semi) {
      r > -1 && this.unexpected(r);
      return this.parseFor(e, null);
    }
    var n = this.isLet();
    if (this.type === S._var || this.type === S._const || n) {
      var i = this.startNode();
      var s = n ? "let" : this.value;
      this.next();
      this.parseVar(i, !0, s);
      this.finishNode(i, "VariableDeclaration");
      return this.parseForAfterInit(e, i, r);
    }
    var o = this.isContextual("let");
    var a = !1;
    var h = this.isUsing(!0) ? "using" : this.isAwaitUsing(!0) ? "await using" : null;
    if (h) {
      var d = this.startNode();
      this.next();
      "await using" === h && this.next();
      this.parseVar(d, !0, h);
      this.finishNode(d, "VariableDeclaration");
      return this.parseForAfterInit(e, d, r);
    }
    var p = this.containsEsc;
    var g = new em();
    var m = this.start;
    var v = r > -1 ? this.parseExprSubscripts(g, "await") : this.parseExpression(!0, g);
    return this.type === S._in || (a = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (r > -1 ? (this.type === S._in && this.unexpected(r), e.await = !0) : a && this.options.ecmaVersion >= 8 && (v.start !== m || p || "Identifier" !== v.type || "async" !== v.name ? this.options.ecmaVersion >= 9 && (e.await = !1) : this.unexpected()), o && a && this.raise(v.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(v, !1, g), this.checkLValPattern(v), this.parseForIn(e, v)) : (this.checkExpressionErrors(g, !0), r > -1 && this.unexpected(r), this.parseFor(e, v));
  };
  ev.parseForAfterInit = function (e, r, n) {
    return (this.type === S._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && 1 === r.declarations.length ? (this.options.ecmaVersion >= 9 && (this.type === S._in ? n > -1 && this.unexpected(n) : e.await = n > -1), this.parseForIn(e, r)) : (n > -1 && this.unexpected(n), this.parseFor(e, r));
  };
  ev.parseFunctionStatement = function (e, r, n) {
    this.next();
    return this.parseFunction(e, ex | (n ? 0 : ew), !1, r);
  };
  ev.parseIfStatement = function (e) {
    this.next();
    e.test = this.parseParenExpression();
    e.consequent = this.parseStatement("if");
    e.alternate = this.eat(S._else) ? this.parseStatement("if") : null;
    return this.finishNode(e, "IfStatement");
  };
  ev.parseReturnStatement = function (e) {
    this.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.start, "'return' outside of function");
    this.next();
    this.eat(S.semi) || this.insertSemicolon() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon());
    return this.finishNode(e, "ReturnStatement");
  };
  ev.parseSwitchStatement = function (e) {
    this.next();
    e.discriminant = this.parseParenExpression();
    e.cases = [];
    this.expect(S.braceL);
    this.labels.push(eb);
    this.enterScope(0);
    for (n = !1, void 0; this.type !== S.braceR;) {
      var r;
      var n;
      if (this.type === S._case || this.type === S._default) {
        var i = this.type === S._case;
        r && this.finishNode(r, "SwitchCase");
        e.cases.push(r = this.startNode());
        r.consequent = [];
        this.next();
        i ? r.test = this.parseExpression() : (n && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), n = !0, r.test = null);
        this.expect(S.colon);
      } else {
        r || this.unexpected();
        r.consequent.push(this.parseStatement(null));
      }
    }
    this.exitScope();
    r && this.finishNode(r, "SwitchCase");
    this.next();
    this.labels.pop();
    return this.finishNode(e, "SwitchStatement");
  };
  ev.parseThrowStatement = function (e) {
    this.next();
    E.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw");
    e.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(e, "ThrowStatement");
  };
  var eO = [];
  ev.parseCatchClauseParam = function () {
    var e = this.parseBindingAtom();
    var r = "Identifier" === e.type;
    this.enterScope(r ? J : 0);
    this.checkLValPattern(e, r ? ec : el);
    this.expect(S.parenR);
    return e;
  };
  ev.parseTryStatement = function (e) {
    if (this.next(), e.block = this.parseBlock(), e.handler = null, this.type === S._catch) {
      var r = this.startNode();
      this.next();
      this.eat(S.parenL) ? r.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), r.param = null, this.enterScope(0));
      r.body = this.parseBlock(!1);
      this.exitScope();
      e.handler = this.finishNode(r, "CatchClause");
    }
    e.finalizer = this.eat(S._finally) ? this.parseBlock() : null;
    e.handler || e.finalizer || this.raise(e.start, "Missing catch or finally clause");
    return this.finishNode(e, "TryStatement");
  };
  ev.parseVarStatement = function (e, r, n) {
    this.next();
    this.parseVar(e, !1, r, n);
    this.semicolon();
    return this.finishNode(e, "VariableDeclaration");
  };
  ev.parseWhileStatement = function (e) {
    this.next();
    e.test = this.parseParenExpression();
    this.labels.push(ey);
    e.body = this.parseStatement("while");
    this.labels.pop();
    return this.finishNode(e, "WhileStatement");
  };
  ev.parseWithStatement = function (e) {
    this.strict && this.raise(this.start, "'with' in strict mode");
    this.next();
    e.object = this.parseParenExpression();
    e.body = this.parseStatement("with");
    return this.finishNode(e, "WithStatement");
  };
  ev.parseEmptyStatement = function (e) {
    this.next();
    return this.finishNode(e, "EmptyStatement");
  };
  ev.parseLabeledStatement = function (e, r, n, i) {
    for (s = 0, o = this.labels, void 0; s < o.length; s += 1) {
      var s;
      var o;
      o[s].name === r && this.raise(n.start, "Label '" + r + "' is already declared");
    }
    for (a = this.type.isLoop ? "loop" : this.type === S._switch ? "switch" : null, h = this.labels.length - 1, void 0; h >= 0; h--) {
      var a;
      var h;
      var d = this.labels[h];
      if (d.statementStart === e.start) {
        d.statementStart = this.start;
        d.kind = a;
      } else break;
    }
    this.labels.push({
      name: r,
      kind: a,
      statementStart: this.start
    });
    e.body = this.parseStatement(i ? -1 === i.indexOf("label") ? i + "label" : i : "label");
    this.labels.pop();
    e.label = n;
    return this.finishNode(e, "LabeledStatement");
  };
  ev.parseExpressionStatement = function (e, r) {
    e.expression = r;
    this.semicolon();
    return this.finishNode(e, "ExpressionStatement");
  };
  ev.parseBlock = function (e, r, n) {
    for (void 0 === e && (e = !0), void 0 === r && (r = this.startNode()), r.body = [], this.expect(S.braceL), e && this.enterScope(0); this.type !== S.braceR;) {
      var i = this.parseStatement(null);
      r.body.push(i);
    }
    n && (this.strict = !1);
    this.next();
    e && this.exitScope();
    return this.finishNode(r, "BlockStatement");
  };
  ev.parseFor = function (e, r) {
    e.init = r;
    this.expect(S.semi);
    e.test = this.type === S.semi ? null : this.parseExpression();
    this.expect(S.semi);
    e.update = this.type === S.parenR ? null : this.parseExpression();
    this.expect(S.parenR);
    e.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(e, "ForStatement");
  };
  ev.parseForIn = function (e, r) {
    var n = this.type === S._in;
    this.next();
    "VariableDeclaration" === r.type && null != r.declarations[0].init && (!n || this.options.ecmaVersion < 8 || this.strict || "var" !== r.kind || "Identifier" !== r.declarations[0].id.type) && this.raise(r.start, (n ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
    e.left = r;
    e.right = n ? this.parseExpression() : this.parseMaybeAssign();
    this.expect(S.parenR);
    e.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(e, n ? "ForInStatement" : "ForOfStatement");
  };
  ev.parseVar = function (e, r, n, i) {
    for (e.declarations = [], e.kind = n;;) {
      var s = this.startNode();
      if (this.parseVarId(s, n), this.eat(S.eq) ? s.init = this.parseMaybeAssign(r) : i || "const" !== n || this.type === S._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? i || "using" !== n && "await using" !== n || !(this.options.ecmaVersion >= 17) || this.type === S._in || this.isContextual("of") ? i || "Identifier" === s.id.type || r && (this.type === S._in || this.isContextual("of")) ? s.init = null : this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : this.raise(this.lastTokEnd, "Missing initializer in " + n + " declaration") : this.unexpected(), e.declarations.push(this.finishNode(s, "VariableDeclarator")), !this.eat(S.comma)) break;
    }
    return e;
  };
  ev.parseVarId = function (e, r) {
    e.id = "using" === r || "await using" === r ? this.parseIdent() : this.parseBindingAtom();
    this.checkLValPattern(e.id, "var" === r ? ea : el, !1);
  };
  var ex = 1;
  var ew = 2;
  var ek = 4;
  function e_(e, r) {
    var n = r.key.name;
    var i = e[n];
    var s = "true";
    return ("MethodDefinition" === r.type && ("get" === r.kind || "set" === r.kind) && (s = (r.$$static ? "s" : "i") + r.kind), "iget" === i && "iset" === s || "iset" === i && "iget" === s || "sget" === i && "sset" === s || "sset" === i && "sget" === s) ? (e[n] = "true", !1) : !!i || (e[n] = s, !1);
  }
  function eS(e, r) {
    var n = e.computed;
    var i = e.key;
    return !n && ("Identifier" === i.type && i.name === r || "Literal" === i.type && i.value === r);
  }
  ev.parseFunction = function (e, r, n, i, s) {
    this.initFunction(e);
    (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !i) && (this.type === S.star && r & ew && this.unexpected(), e.generator = this.eat(S.star));
    this.options.ecmaVersion >= 8 && (e.async = !!i);
    r & ex && (e.id = r & ek && this.type !== S.name ? null : this.parseIdent(), e.id && !(r & ew) && this.checkLValSimple(e.id, this.strict || e.generator || e.async ? this.treatFunctionsAsVar ? ea : el : eu));
    var o = this.yieldPos;
    var a = this.awaitPos;
    var h = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(es(e.async, e.generator));
    r & ex || (e.id = this.type === S.name ? this.parseIdent() : null);
    this.parseFunctionParams(e);
    this.parseFunctionBody(e, n, !1, s);
    this.yieldPos = o;
    this.awaitPos = a;
    this.awaitIdentPos = h;
    return this.finishNode(e, r & ex ? "FunctionDeclaration" : "FunctionExpression");
  };
  ev.parseFunctionParams = function (e) {
    this.expect(S.parenL);
    e.params = this.parseBindingList(S.parenR, !1, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
  };
  ev.parseClass = function (e, r) {
    this.next();
    var n = this.strict;
    this.strict = !0;
    this.parseClassId(e, r);
    this.parseClassSuper(e);
    var i = this.enterClassBody();
    var s = this.startNode();
    var o = !1;
    for (s.body = [], this.expect(S.braceL); this.type !== S.braceR;) {
      var a = this.parseClassElement(null !== e.superClass);
      a && (s.body.push(a), "MethodDefinition" === a.type && "constructor" === a.kind ? (o && this.raiseRecoverable(a.start, "Duplicate constructor in the same class"), o = !0) : a.key && "PrivateIdentifier" === a.key.type && e_(i, a) && this.raiseRecoverable(a.key.start, "Identifier '#" + a.key.name + "' has already been declared"));
    }
    this.strict = n;
    this.next();
    e.body = this.finishNode(s, "ClassBody");
    this.exitClassBody();
    return this.finishNode(e, r ? "ClassDeclaration" : "ClassExpression");
  };
  ev.parseClassElement = function (e) {
    if (this.eat(S.semi)) return null;
    var r = this.options.ecmaVersion;
    var n = this.startNode();
    var i = "";
    var s = !1;
    var o = !1;
    var a = "method";
    var h = !1;
    if (this.eatContextual("static")) {
      if (r >= 13 && this.eat(S.braceL)) {
        this.parseClassStaticBlock(n);
        return n;
      }
      this.isClassElementNameStart() || this.type === S.star ? h = !0 : i = "static";
    }
    if (n.$$static = h, !i && r >= 8 && this.eatContextual("async") && ((this.isClassElementNameStart() || this.type === S.star) && !this.canInsertSemicolon() ? o = !0 : i = "async"), !i && (r >= 9 || !o) && this.eat(S.star) && (s = !0), !i && !o && !s) {
      var d = this.value;
      (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? a = d : i = d);
    }
    if (i ? (n.computed = !1, n.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), n.key.name = i, this.finishNode(n.key, "Identifier")) : this.parseClassElementName(n), r < 13 || this.type === S.parenL || "method" !== a || s || o) {
      var p = !n.$$static && eS(n, "constructor");
      var g = p && e;
      p && "method" !== a && this.raise(n.key.start, "Constructor can't have get/set modifier");
      n.kind = p ? "constructor" : a;
      this.parseClassMethod(n, s, o, g);
    } else this.parseClassField(n);
    return n;
  };
  ev.isClassElementNameStart = function () {
    return this.type === S.name || this.type === S.privateId || this.type === S.num || this.type === S.string || this.type === S.bracketL || this.type.keyword;
  };
  ev.parseClassElementName = function (e) {
    this.type === S.privateId ? ("constructor" === this.value && this.raise(this.start, "Classes can't have an element named '#constructor'"), e.computed = !1, e.key = this.parsePrivateIdent()) : this.parsePropertyName(e);
  };
  ev.parseClassMethod = function (e, r, n, i) {
    var s = e.key;
    "constructor" === e.kind ? (r && this.raise(s.start, "Constructor can't be a generator"), n && this.raise(s.start, "Constructor can't be an async method")) : e.$$static && eS(e, "prototype") && this.raise(s.start, "Classes may not have a static property named prototype");
    var o = e.value = this.parseMethod(r, n, i);
    "get" === e.kind && 0 !== o.params.length && this.raiseRecoverable(o.start, "getter should have no params");
    "set" === e.kind && 1 !== o.params.length && this.raiseRecoverable(o.start, "setter should have exactly one param");
    "set" === e.kind && "RestElement" === o.params[0].type && this.raiseRecoverable(o.params[0].start, "Setter cannot use rest params");
    return this.finishNode(e, "MethodDefinition");
  };
  ev.parseClassField = function (e) {
    eS(e, "constructor") ? this.raise(e.key.start, "Classes can't have a field named 'constructor'") : e.$$static && eS(e, "prototype") && this.raise(e.key.start, "Classes can't have a static field named 'prototype'");
    this.eat(S.eq) ? (this.enterScope(en | ee), e.value = this.parseMaybeAssign(), this.exitScope()) : e.value = null;
    this.semicolon();
    return this.finishNode(e, "PropertyDefinition");
  };
  ev.parseClassStaticBlock = function (e) {
    e.body = [];
    var r = this.labels;
    for (this.labels = [], this.enterScope(er | ee); this.type !== S.braceR;) {
      var n = this.parseStatement(null);
      e.body.push(n);
    }
    this.next();
    this.exitScope();
    this.labels = r;
    return this.finishNode(e, "StaticBlock");
  };
  ev.parseClassId = function (e, r) {
    this.type === S.name ? (e.id = this.parseIdent(), r && this.checkLValSimple(e.id, el, !1)) : (!0 === r && this.unexpected(), e.id = null);
  };
  ev.parseClassSuper = function (e) {
    e.superClass = this.eat(S._extends) ? this.parseExprSubscripts(null, !1) : null;
  };
  ev.enterClassBody = function () {
    var e = {
      declared: Object.create(null),
      used: []
    };
    this.privateNameStack.push(e);
    return e.declared;
  };
  ev.exitClassBody = function () {
    var e = this.privateNameStack.pop();
    var r = e.declared;
    var n = e.used;
    if (this.options.checkPrivateFields) for (i = this.privateNameStack.length, s = 0 === i ? null : this.privateNameStack[i - 1], o = 0, void 0; o < n.length; ++o) {
      var i;
      var s;
      var o;
      var a = n[o];
      N(r, a.name) || (s ? s.used.push(a) : this.raiseRecoverable(a.start, "Private field '#" + a.name + "' must be declared in an enclosing class"));
    }
  };
  ev.parseExportAllDeclaration = function (e, r) {
    this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (e.exported = this.parseModuleExportName(), this.checkExport(r, e.exported, this.lastTokStart)) : e.exported = null);
    this.expectContextual("from");
    this.type !== S.string && this.unexpected();
    e.source = this.parseExprAtom();
    this.options.ecmaVersion >= 16 && (e.attributes = this.parseWithClause());
    this.semicolon();
    return this.finishNode(e, "ExportAllDeclaration");
  };
  ev.parseExport = function (e, r) {
    if (this.next(), this.eat(S.star)) return this.parseExportAllDeclaration(e, r);
    if (this.eat(S._default)) {
      this.checkExport(r, "default", this.lastTokStart);
      e.declaration = this.parseExportDefaultDeclaration();
      return this.finishNode(e, "ExportDefaultDeclaration");
    }
    if (this.shouldParseExportStatement()) {
      e.declaration = this.parseExportDeclaration(e);
      "VariableDeclaration" === e.declaration.type ? this.checkVariableExport(r, e.declaration.declarations) : this.checkExport(r, e.declaration.id, e.declaration.id.start);
      e.specifiers = [];
      e.source = null;
      this.options.ecmaVersion >= 16 && (e.attributes = []);
    } else {
      if (e.declaration = null, e.specifiers = this.parseExportSpecifiers(r), this.eatContextual("from")) {
        this.type !== S.string && this.unexpected();
        e.source = this.parseExprAtom();
        this.options.ecmaVersion >= 16 && (e.attributes = this.parseWithClause());
      } else {
        for (n = 0, i = e.specifiers, void 0; n < i.length; n += 1) {
          var n;
          var i;
          var s = i[n];
          this.checkUnreserved(s.local);
          this.checkLocalExport(s.local);
          "Literal" === s.local.type && this.raise(s.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
        e.source = null;
        this.options.ecmaVersion >= 16 && (e.attributes = []);
      }
      this.semicolon();
    }
    return this.finishNode(e, "ExportNamedDeclaration");
  };
  ev.parseExportDeclaration = function (e) {
    return this.parseStatement(null);
  };
  ev.parseExportDefaultDeclaration = function () {
    if (this.type === S._function || (e = this.isAsyncFunction())) {
      var e;
      var r = this.startNode();
      this.next();
      e && this.next();
      return this.parseFunction(r, ex | ek, !1, e);
    }
    if (this.type === S._class) {
      var n = this.startNode();
      return this.parseClass(n, "nullableID");
    }
    var i = this.parseMaybeAssign();
    this.semicolon();
    return i;
  };
  ev.checkExport = function (e, r, n) {
    e && ("string" != typeof r && (r = "Identifier" === r.type ? r.name : r.value), N(e, r) && this.raiseRecoverable(n, "Duplicate export '" + r + "'"), e[r] = !0);
  };
  ev.checkPatternExport = function (e, r) {
    var n = r.type;
    if ("Identifier" === n) this.checkExport(e, r, r.start);else if ("ObjectPattern" === n) for (i = 0, s = r.properties, void 0; i < s.length; i += 1) {
      var i;
      var s;
      var o = s[i];
      this.checkPatternExport(e, o);
    } else if ("ArrayPattern" === n) for (a = 0, h = r.elements, void 0; a < h.length; a += 1) {
      var a;
      var h;
      var d = h[a];
      d && this.checkPatternExport(e, d);
    } else "Property" === n ? this.checkPatternExport(e, r.value) : "AssignmentPattern" === n ? this.checkPatternExport(e, r.left) : "RestElement" === n && this.checkPatternExport(e, r.argument);
  };
  ev.checkVariableExport = function (e, r) {
    if (e) for (n = 0, i = r, void 0; n < i.length; n += 1) {
      var n;
      var i;
      var s = i[n];
      this.checkPatternExport(e, s.id);
    }
  };
  ev.shouldParseExportStatement = function () {
    return "var" === this.type.keyword || "const" === this.type.keyword || "class" === this.type.keyword || "function" === this.type.keyword || this.isLet() || this.isAsyncFunction();
  };
  ev.parseExportSpecifier = function (e) {
    var r = this.startNode();
    r.local = this.parseModuleExportName();
    r.exported = this.eatContextual("as") ? this.parseModuleExportName() : r.local;
    this.checkExport(e, r.exported, r.exported.start);
    return this.finishNode(r, "ExportSpecifier");
  };
  ev.parseExportSpecifiers = function (e) {
    var r = [];
    var n = !0;
    for (this.expect(S.braceL); !this.eat(S.braceR);) {
      if (n) n = !1;else if (this.expect(S.comma), this.afterTrailingComma(S.braceR)) break;
      r.push(this.parseExportSpecifier(e));
    }
    return r;
  };
  ev.parseImport = function (e) {
    this.next();
    this.type === S.string ? (e.specifiers = eO, e.source = this.parseExprAtom()) : (e.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), e.source = this.type === S.string ? this.parseExprAtom() : this.unexpected());
    this.options.ecmaVersion >= 16 && (e.attributes = this.parseWithClause());
    this.semicolon();
    return this.finishNode(e, "ImportDeclaration");
  };
  ev.parseImportSpecifier = function () {
    var e = this.startNode();
    e.imported = this.parseModuleExportName();
    this.eatContextual("as") ? e.local = this.parseIdent() : (this.checkUnreserved(e.imported), e.local = e.imported);
    this.checkLValSimple(e.local, el);
    return this.finishNode(e, "ImportSpecifier");
  };
  ev.parseImportDefaultSpecifier = function () {
    var e = this.startNode();
    e.local = this.parseIdent();
    this.checkLValSimple(e.local, el);
    return this.finishNode(e, "ImportDefaultSpecifier");
  };
  ev.parseImportNamespaceSpecifier = function () {
    var e = this.startNode();
    this.next();
    this.expectContextual("as");
    e.local = this.parseIdent();
    this.checkLValSimple(e.local, el);
    return this.finishNode(e, "ImportNamespaceSpecifier");
  };
  ev.parseImportSpecifiers = function () {
    var e = [];
    var r = !0;
    if (this.type === S.name && (e.push(this.parseImportDefaultSpecifier()), !this.eat(S.comma))) return e;
    if (this.type === S.star) {
      e.push(this.parseImportNamespaceSpecifier());
      return e;
    }
    for (this.expect(S.braceL); !this.eat(S.braceR);) {
      if (r) r = !1;else if (this.expect(S.comma), this.afterTrailingComma(S.braceR)) break;
      e.push(this.parseImportSpecifier());
    }
    return e;
  };
  ev.parseWithClause = function () {
    var e = [];
    if (!this.eat(S._with)) return e;
    this.expect(S.braceL);
    for (r = {}, n = !0, void 0; !this.eat(S.braceR);) {
      var r;
      var n;
      if (n) n = !1;else if (this.expect(S.comma), this.afterTrailingComma(S.braceR)) break;
      var i = this.parseImportAttribute();
      var s = "Identifier" === i.key.type ? i.key.name : i.key.value;
      N(r, s) && this.raiseRecoverable(i.key.start, "Duplicate attribute key '" + s + "'");
      r[s] = !0;
      e.push(i);
    }
    return e;
  };
  ev.parseImportAttribute = function () {
    var e = this.startNode();
    e.key = this.type === S.string ? this.parseExprAtom() : this.parseIdent("never" !== this.options.allowReserved);
    this.expect(S.colon);
    this.type !== S.string && this.unexpected();
    e.value = this.parseExprAtom();
    return this.finishNode(e, "ImportAttribute");
  };
  ev.parseModuleExportName = function () {
    if (this.options.ecmaVersion >= 13 && this.type === S.string) {
      var e = this.parseLiteral(this.value);
      Z.test(e.value) && this.raise(e.start, "An export name cannot include a lone surrogate.");
      return e;
    }
    return this.parseIdent(!0);
  };
  ev.adaptDirectivePrologue = function (e) {
    for (var r = 0; r < e.length && this.isDirectiveCandidate(e[r]); ++r) e[r].directive = e[r].expression.raw.slice(1, -1);
  };
  ev.isDirectiveCandidate = function (e) {
    return this.options.ecmaVersion >= 5 && "ExpressionStatement" === e.type && "Literal" === e.expression.type && "string" == typeof e.expression.value && ('"' === this.input[e.start] || "'" === this.input[e.start]);
  };
  var eE = ed.prototype;
  eE.toAssignable = function (e, r, n) {
    if (this.options.ecmaVersion >= 6 && e) switch (e.type) {
      case "Identifier":
        this.inAsync && "await" === e.name && this.raise(e.start, "Cannot use 'await' as identifier inside an async function");
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        e.type = "ObjectPattern";
        n && this.checkPatternErrors(n, !0);
        for (i = 0, s = e.properties, void 0; i < s.length; i += 1) {
          var i;
          var s;
          var o = s[i];
          this.toAssignable(o, r);
          "RestElement" === o.type && ("ArrayPattern" === o.argument.type || "ObjectPattern" === o.argument.type) && this.raise(o.argument.start, "Unexpected token");
        }
        break;
      case "Property":
        "init" !== e.kind && this.raise(e.key.start, "Object pattern can't contain getter or setter");
        this.toAssignable(e.value, r);
        break;
      case "ArrayExpression":
        e.type = "ArrayPattern";
        n && this.checkPatternErrors(n, !0);
        this.toAssignableList(e.elements, r);
        break;
      case "SpreadElement":
        e.type = "RestElement";
        this.toAssignable(e.argument, r);
        "AssignmentPattern" === e.argument.type && this.raise(e.argument.start, "Rest elements cannot have a default value");
        break;
      case "AssignmentExpression":
        "=" !== e.operator && this.raise(e.left.end, "Only '=' operator can be used for specifying default value.");
        e.type = "AssignmentPattern";
        delete e.operator;
        this.toAssignable(e.left, r);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(e.expression, r, n);
        break;
      case "ChainExpression":
        this.raiseRecoverable(e.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!r) break;
      default:
        this.raise(e.start, "Assigning to rvalue");
    } else n && this.checkPatternErrors(n, !0);
    return e;
  };
  eE.toAssignableList = function (e, r) {
    for (n = e.length, i = 0, void 0; i < n; i++) {
      var n;
      var i;
      var s = e[i];
      s && this.toAssignable(s, r);
    }
    if (n) {
      var o = e[n - 1];
      6 === this.options.ecmaVersion && r && o && "RestElement" === o.type && "Identifier" !== o.argument.type && this.unexpected(o.argument.start);
    }
    return e;
  };
  eE.parseSpread = function (e) {
    var r = this.startNode();
    this.next();
    r.argument = this.parseMaybeAssign(!1, e);
    return this.finishNode(r, "SpreadElement");
  };
  eE.parseRestBinding = function () {
    var e = this.startNode();
    this.next();
    6 === this.options.ecmaVersion && this.type !== S.name && this.unexpected();
    e.argument = this.parseBindingAtom();
    return this.finishNode(e, "RestElement");
  };
  eE.parseBindingAtom = function () {
    if (this.options.ecmaVersion >= 6) switch (this.type) {
      case S.bracketL:
        var e = this.startNode();
        this.next();
        e.elements = this.parseBindingList(S.bracketR, !0, !0);
        return this.finishNode(e, "ArrayPattern");
      case S.braceL:
        return this.parseObj(!0);
    }
    return this.parseIdent();
  };
  eE.parseBindingList = function (e, r, n, i) {
    for (s = [], o = !0, void 0; !this.eat(e);) {
      var s;
      var o;
      if (o ? o = !1 : this.expect(S.comma), r && this.type === S.comma) s.push(null);else if (n && this.afterTrailingComma(e)) break;else if (this.type === S.ellipsis) {
        var a = this.parseRestBinding();
        this.parseBindingListItem(a);
        s.push(a);
        this.type === S.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
        this.expect(e);
        break;
      } else s.push(this.parseAssignableListItem(i));
    }
    return s;
  };
  eE.parseAssignableListItem = function (e) {
    var r = this.parseMaybeDefault(this.start, this.startLoc);
    this.parseBindingListItem(r);
    return r;
  };
  eE.parseBindingListItem = function (e) {
    return e;
  };
  eE.parseMaybeDefault = function (e, r, n) {
    if (n = n || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(S.eq)) return n;
    var i = this.startNodeAt(e, r);
    i.left = n;
    i.right = this.parseMaybeAssign();
    return this.finishNode(i, "AssignmentPattern");
  };
  eE.checkLValSimple = function (e, r, n) {
    void 0 === r && (r = eo);
    var i = r !== eo;
    switch (e.type) {
      case "Identifier":
        this.strict && this.reservedWordsStrictBind.test(e.name) && this.raiseRecoverable(e.start, (i ? "Binding " : "Assigning to ") + e.name + " in strict mode");
        i && (r === el && "let" === e.name && this.raiseRecoverable(e.start, "let is disallowed as a lexically bound name"), n && (N(n, e.name) && this.raiseRecoverable(e.start, "Argument name clash"), n[e.name] = !0), r !== eh && this.declareName(e.name, r, e.start));
        break;
      case "ChainExpression":
        this.raiseRecoverable(e.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        i && this.raiseRecoverable(e.start, "Binding member expression");
        break;
      case "ParenthesizedExpression":
        i && this.raiseRecoverable(e.start, "Binding parenthesized expression");
        return this.checkLValSimple(e.expression, r, n);
      default:
        this.raise(e.start, (i ? "Binding" : "Assigning to") + " rvalue");
    }
  };
  eE.checkLValPattern = function (e, r, n) {
    switch (void 0 === r && (r = eo), e.type) {
      case "ObjectPattern":
        for (i = 0, s = e.properties, void 0; i < s.length; i += 1) {
          var i;
          var s;
          var o = s[i];
          this.checkLValInnerPattern(o, r, n);
        }
        break;
      case "ArrayPattern":
        for (a = 0, h = e.elements, void 0; a < h.length; a += 1) {
          var a;
          var h;
          var d = h[a];
          d && this.checkLValInnerPattern(d, r, n);
        }
        break;
      default:
        this.checkLValSimple(e, r, n);
    }
  };
  eE.checkLValInnerPattern = function (e, r, n) {
    switch (void 0 === r && (r = eo), e.type) {
      case "Property":
        this.checkLValInnerPattern(e.value, r, n);
        break;
      case "AssignmentPattern":
        this.checkLValPattern(e.left, r, n);
        break;
      case "RestElement":
        this.checkLValPattern(e.argument, r, n);
        break;
      default:
        this.checkLValPattern(e, r, n);
    }
  };
  var eA = function (e, r, n, i, s) {
    this.token = e;
    this.isExpr = !!r;
    this.preserveSpace = !!n;
    this.override = i;
    this.generator = !!s;
  };
  var eC = {
    b_stat: new eA("{", !1),
    b_expr: new eA("{", !0),
    b_tmpl: new eA("${", !1),
    p_stat: new eA("(", !1),
    p_expr: new eA("(", !0),
    q_tmpl: new eA("`", !0, !0, function (e) {
      return e.tryReadTemplateToken();
    }),
    f_stat: new eA("function", !1),
    f_expr: new eA("function", !0),
    f_expr_gen: new eA("function", !0, !1, null, !0),
    f_gen: new eA("function", !1, !1, null, !0)
  };
  var eT = ed.prototype;
  eT.initialContext = function () {
    return [eC.b_stat];
  };
  eT.curContext = function () {
    return this.context[this.context.length - 1];
  };
  eT.braceIsBlock = function (e) {
    var r = this.curContext();
    return r === eC.f_expr || r === eC.f_stat || (e === S.colon && (r === eC.b_stat || r === eC.b_expr) ? !r.isExpr : e === S._return || e === S.name && this.exprAllowed ? E.test(this.input.slice(this.lastTokEnd, this.start)) : e === S._else || e === S.semi || e === S.eof || e === S.parenR || e === S.arrow || (e === S.braceL ? r === eC.b_stat : e !== S._var && e !== S._const && e !== S.name && !this.exprAllowed));
  };
  eT.inGeneratorContext = function () {
    for (var e = this.context.length - 1; e >= 1; e--) {
      var r = this.context[e];
      if ("function" === r.token) return r.generator;
    }
    return !1;
  };
  eT.updateContext = function (e) {
    var r;
    var n = this.type;
    n.keyword && e === S.dot ? this.exprAllowed = !1 : (r = n.updateContext) ? r.call(this, e) : this.exprAllowed = n.beforeExpr;
  };
  eT.overrideContext = function (e) {
    this.curContext() !== e && (this.context[this.context.length - 1] = e);
  };
  S.parenR.updateContext = S.braceR.updateContext = function () {
    if (1 === this.context.length) {
      this.exprAllowed = !0;
      return;
    }
    var e = this.context.pop();
    e === eC.b_stat && "function" === this.curContext().token && (e = this.context.pop());
    this.exprAllowed = !e.isExpr;
  };
  S.braceL.updateContext = function (e) {
    this.context.push(this.braceIsBlock(e) ? eC.b_stat : eC.b_expr);
    this.exprAllowed = !0;
  };
  S.dollarBraceL.updateContext = function () {
    this.context.push(eC.b_tmpl);
    this.exprAllowed = !0;
  };
  S.parenL.updateContext = function (e) {
    var r = e === S._if || e === S._for || e === S._with || e === S._while;
    this.context.push(r ? eC.p_stat : eC.p_expr);
    this.exprAllowed = !0;
  };
  S.incDec.updateContext = function () {};
  S._function.updateContext = S._class.updateContext = function (e) {
    !e.beforeExpr || e === S._else || e === S.semi && this.curContext() !== eC.p_stat || e === S._return && E.test(this.input.slice(this.lastTokEnd, this.start)) || (e === S.colon || e === S.braceL) && this.curContext() === eC.b_stat ? this.context.push(eC.f_stat) : this.context.push(eC.f_expr);
    this.exprAllowed = !1;
  };
  S.colon.updateContext = function () {
    "function" === this.curContext().token && this.context.pop();
    this.exprAllowed = !0;
  };
  S.backQuote.updateContext = function () {
    this.curContext() === eC.q_tmpl ? this.context.pop() : this.context.push(eC.q_tmpl);
    this.exprAllowed = !1;
  };
  S.star.updateContext = function (e) {
    if (e === S._function) {
      var r = this.context.length - 1;
      this.context[r] === eC.f_expr ? this.context[r] = eC.f_expr_gen : this.context[r] = eC.f_gen;
    }
    this.exprAllowed = !0;
  };
  S.name.updateContext = function (e) {
    var r = !1;
    this.options.ecmaVersion >= 6 && e !== S.dot && ("of" === this.value && !this.exprAllowed || "yield" === this.value && this.inGeneratorContext()) && (r = !0);
    this.exprAllowed = r;
  };
  var eI = ed.prototype;
  function eP(e) {
    return "Identifier" === e.type || "ParenthesizedExpression" === e.type && eP(e.expression);
  }
  function eR(e) {
    return "MemberExpression" === e.type && "PrivateIdentifier" === e.property.type || "ChainExpression" === e.type && eR(e.expression) || "ParenthesizedExpression" === e.type && eR(e.expression);
  }
  eI.checkPropClash = function (e, r, n) {
    if ((!(this.options.ecmaVersion >= 9) || "SpreadElement" !== e.type) && (!(this.options.ecmaVersion >= 6) || !e.computed && !e.method && !e.shorthand)) {
      var i;
      var s;
      var o = e.key;
      switch (o.type) {
        case "Identifier":
          i = o.name;
          break;
        case "Literal":
          i = String(o.value);
          break;
        default:
          return;
      }
      var a = e.kind;
      if (this.options.ecmaVersion >= 6) {
        "__proto__" === i && "init" === a && (r.proto && (n ? n.doubleProto < 0 && (n.doubleProto = o.start) : this.raiseRecoverable(o.start, "Redefinition of __proto__ property")), r.proto = !0);
        return;
      }
      var h = r[i = "$" + i];
      h ? (s = "init" === a ? this.strict && h.init || h.get || h.set : h.init || h[a]) && this.raiseRecoverable(o.start, "Redefinition of property") : h = r[i] = {
        init: !1,
        get: !1,
        set: !1
      };
      h[a] = !0;
    }
  };
  eI.parseExpression = function (e, r) {
    var n = this.start;
    var i = this.startLoc;
    var s = this.parseMaybeAssign(e, r);
    if (this.type === S.comma) {
      var o = this.startNodeAt(n, i);
      for (o.expressions = [s]; this.eat(S.comma);) o.expressions.push(this.parseMaybeAssign(e, r));
      return this.finishNode(o, "SequenceExpression");
    }
    return s;
  };
  eI.parseMaybeAssign = function (e, r, n) {
    if (this.isContextual("yield")) {
      if (this.inGenerator) return this.parseYield(e);
      this.exprAllowed = !1;
    }
    var i = !1;
    var s = -1;
    var o = -1;
    var a = -1;
    r ? (s = r.parenthesizedAssign, o = r.trailingComma, a = r.doubleProto, r.parenthesizedAssign = r.trailingComma = -1) : (r = new em(), i = !0);
    var h = this.start;
    var d = this.startLoc;
    (this.type === S.parenL || this.type === S.name) && (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = "await" === e);
    var p = this.parseMaybeConditional(e, r);
    if (n && (p = n.call(this, p, h, d)), this.type.isAssign) {
      var g = this.startNodeAt(h, d);
      g.operator = this.value;
      this.type === S.eq && (p = this.toAssignable(p, !1, r));
      i || (r.parenthesizedAssign = r.trailingComma = r.doubleProto = -1);
      r.shorthandAssign >= p.start && (r.shorthandAssign = -1);
      this.type === S.eq ? this.checkLValPattern(p) : this.checkLValSimple(p);
      g.left = p;
      this.next();
      g.right = this.parseMaybeAssign(e);
      a > -1 && (r.doubleProto = a);
      return this.finishNode(g, "AssignmentExpression");
    }
    i && this.checkExpressionErrors(r, !0);
    s > -1 && (r.parenthesizedAssign = s);
    o > -1 && (r.trailingComma = o);
    return p;
  };
  eI.parseMaybeConditional = function (e, r) {
    var n = this.start;
    var i = this.startLoc;
    var s = this.parseExprOps(e, r);
    if (this.checkExpressionErrors(r)) return s;
    if (this.eat(S.question)) {
      var o = this.startNodeAt(n, i);
      o.test = s;
      o.consequent = this.parseMaybeAssign();
      this.expect(S.colon);
      o.alternate = this.parseMaybeAssign(e);
      return this.finishNode(o, "ConditionalExpression");
    }
    return s;
  };
  eI.parseExprOps = function (e, r) {
    var n = this.start;
    var i = this.startLoc;
    var s = this.parseMaybeUnary(r, !1, !1, e);
    return this.checkExpressionErrors(r) ? s : s.start === n && "ArrowFunctionExpression" === s.type ? s : this.parseExprOp(s, n, i, -1, e);
  };
  eI.parseExprOp = function (e, r, n, i, s) {
    var o = this.type.binop;
    if (null != o && (!s || this.type !== S._in) && o > i) {
      var a = this.type === S.logicalOR || this.type === S.logicalAND;
      var h = this.type === S.coalesce;
      h && (o = S.logicalAND.binop);
      var d = this.value;
      this.next();
      var p = this.start;
      var g = this.startLoc;
      var m = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, s), p, g, o, s);
      var v = this.buildBinary(r, n, e, m, d, a || h);
      (a && this.type === S.coalesce || h && (this.type === S.logicalOR || this.type === S.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      return this.parseExprOp(v, r, n, i, s);
    }
    return e;
  };
  eI.buildBinary = function (e, r, n, i, s, o) {
    "PrivateIdentifier" === i.type && this.raise(i.start, "Private identifier can only be left side of binary expression");
    var a = this.startNodeAt(e, r);
    a.left = n;
    a.operator = s;
    a.right = i;
    return this.finishNode(a, o ? "LogicalExpression" : "BinaryExpression");
  };
  eI.parseMaybeUnary = function (e, r, n, i) {
    var s;
    var o = this.start;
    var a = this.startLoc;
    if (this.isContextual("await") && this.canAwait) {
      s = this.parseAwait(i);
      r = !0;
    } else if (this.type.prefix) {
      var h = this.startNode();
      var d = this.type === S.incDec;
      h.operator = this.value;
      h.prefix = !0;
      this.next();
      h.argument = this.parseMaybeUnary(null, !0, d, i);
      this.checkExpressionErrors(e, !0);
      d ? this.checkLValSimple(h.argument) : this.strict && "delete" === h.operator && eP(h.argument) ? this.raiseRecoverable(h.start, "Deleting local variable in strict mode") : "delete" === h.operator && eR(h.argument) ? this.raiseRecoverable(h.start, "Private fields can not be deleted") : r = !0;
      s = this.finishNode(h, d ? "UpdateExpression" : "UnaryExpression");
    } else if (r || this.type !== S.privateId) {
      if (s = this.parseExprSubscripts(e, i), this.checkExpressionErrors(e)) return s;
      for (; this.type.postfix && !this.canInsertSemicolon();) {
        var p = this.startNodeAt(o, a);
        p.operator = this.value;
        p.prefix = !1;
        p.argument = s;
        this.checkLValSimple(s);
        this.next();
        s = this.finishNode(p, "UpdateExpression");
      }
    } else {
      (i || 0 === this.privateNameStack.length) && this.options.checkPrivateFields && this.unexpected();
      s = this.parsePrivateIdent();
      this.type !== S._in && this.unexpected();
    }
    return !n && this.eat(S.starstar) ? r ? void this.unexpected(this.lastTokStart) : this.buildBinary(o, a, s, this.parseMaybeUnary(null, !1, !1, i), "**", !1) : s;
  };
  eI.parseExprSubscripts = function (e, r) {
    var n = this.start;
    var i = this.startLoc;
    var s = this.parseExprAtom(e, r);
    if ("ArrowFunctionExpression" === s.type && ")" !== this.input.slice(this.lastTokStart, this.lastTokEnd)) return s;
    var o = this.parseSubscripts(s, n, i, !1, r);
    e && "MemberExpression" === o.type && (e.parenthesizedAssign >= o.start && (e.parenthesizedAssign = -1), e.parenthesizedBind >= o.start && (e.parenthesizedBind = -1), e.trailingComma >= o.start && (e.trailingComma = -1));
    return o;
  };
  eI.parseSubscripts = function (e, r, n, i, s) {
    for (o = this.options.ecmaVersion >= 8 && "Identifier" === e.type && "async" === e.name && this.lastTokEnd === e.end && !this.canInsertSemicolon() && e.end - e.start == 5 && this.potentialArrowAt === e.start, a = !1, void 0;;) {
      var o;
      var a;
      var h = this.parseSubscript(e, r, n, i, o, a, s);
      if (h.optional && (a = !0), h === e || "ArrowFunctionExpression" === h.type) {
        if (a) {
          var d = this.startNodeAt(r, n);
          d.expression = h;
          h = this.finishNode(d, "ChainExpression");
        }
        return h;
      }
      e = h;
    }
  };
  eI.shouldParseAsyncArrow = function () {
    return !this.canInsertSemicolon() && this.eat(S.arrow);
  };
  eI.parseSubscriptAsyncArrow = function (e, r, n, i) {
    return this.parseArrowExpression(this.startNodeAt(e, r), n, !0, i);
  };
  eI.parseSubscript = function (e, r, n, i, s, o, a) {
    var h = this.options.ecmaVersion >= 11;
    var d = h && this.eat(S.questionDot);
    i && d && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
    var p = this.eat(S.bracketL);
    if (p || d && this.type !== S.parenL && this.type !== S.backQuote || this.eat(S.dot)) {
      var g = this.startNodeAt(r, n);
      g.object = e;
      p ? (g.property = this.parseExpression(), this.expect(S.bracketR)) : this.type === S.privateId && "Super" !== e.type ? g.property = this.parsePrivateIdent() : g.property = this.parseIdent("never" !== this.options.allowReserved);
      g.computed = !!p;
      h && (g.optional = d);
      e = this.finishNode(g, "MemberExpression");
    } else if (!i && this.eat(S.parenL)) {
      var m = new em();
      var v = this.yieldPos;
      var y = this.awaitPos;
      var b = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      var O = this.parseExprList(S.parenR, this.options.ecmaVersion >= 8, !1, m);
      if (s && !d && this.shouldParseAsyncArrow()) {
        this.checkPatternErrors(m, !1);
        this.checkYieldAwaitInDefaultParams();
        this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
        this.yieldPos = v;
        this.awaitPos = y;
        this.awaitIdentPos = b;
        return this.parseSubscriptAsyncArrow(r, n, O, a);
      }
      this.checkExpressionErrors(m, !0);
      this.yieldPos = v || this.yieldPos;
      this.awaitPos = y || this.awaitPos;
      this.awaitIdentPos = b || this.awaitIdentPos;
      var x = this.startNodeAt(r, n);
      x.callee = e;
      x.$$arguments = O;
      h && (x.optional = d);
      e = this.finishNode(x, "CallExpression");
    } else if (this.type === S.backQuote) {
      (d || o) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
      var w = this.startNodeAt(r, n);
      w.tag = e;
      w.quasi = this.parseTemplate({
        isTagged: !0
      });
      e = this.finishNode(w, "TaggedTemplateExpression");
    }
    return e;
  };
  eI.parseExprAtom = function (e, r, n) {
    this.type === S.slash && this.readRegexp();
    var i;
    var s = this.potentialArrowAt === this.start;
    switch (this.type) {
      case S._super:
        this.allowSuper || this.raise(this.start, "'super' keyword outside a method");
        i = this.startNode();
        this.next();
        this.type !== S.parenL || this.allowDirectSuper || this.raise(i.start, "super() call outside constructor of a subclass");
        this.type !== S.dot && this.type !== S.bracketL && this.type !== S.parenL && this.unexpected();
        return this.finishNode(i, "Super");
      case S._this:
        i = this.startNode();
        this.next();
        return this.finishNode(i, "ThisExpression");
      case S.name:
        var o = this.start;
        var a = this.startLoc;
        var h = this.containsEsc;
        var d = this.parseIdent(!1);
        if (this.options.ecmaVersion >= 8 && !h && "async" === d.name && !this.canInsertSemicolon() && this.eat(S._function)) {
          this.overrideContext(eC.f_expr);
          return this.parseFunction(this.startNodeAt(o, a), 0, !1, !0, r);
        }
        if (s && !this.canInsertSemicolon()) {
          if (this.eat(S.arrow)) return this.parseArrowExpression(this.startNodeAt(o, a), [d], !1, r);
          if (this.options.ecmaVersion >= 8 && "async" === d.name && this.type === S.name && !h && (!this.potentialArrowInForAwait || "of" !== this.value || this.containsEsc)) {
            d = this.parseIdent(!1);
            (this.canInsertSemicolon() || !this.eat(S.arrow)) && this.unexpected();
            return this.parseArrowExpression(this.startNodeAt(o, a), [d], !0, r);
          }
        }
        return d;
      case S.regexp:
        var p = this.value;
        (i = this.parseLiteral(p.value)).regex = {
          pattern: p.pattern,
          flags: p.flags
        };
        return i;
      case S.num:
      case S.string:
        return this.parseLiteral(this.value);
      case S._null:
      case S._true:
      case S._false:
        (i = this.startNode()).value = this.type === S._null ? null : this.type === S._true;
        i.raw = this.type.keyword;
        this.next();
        return this.finishNode(i, "Literal");
      case S.parenL:
        var g = this.start;
        var m = this.parseParenAndDistinguishExpression(s, r);
        e && (e.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(m) && (e.parenthesizedAssign = g), e.parenthesizedBind < 0 && (e.parenthesizedBind = g));
        return m;
      case S.bracketL:
        i = this.startNode();
        this.next();
        i.elements = this.parseExprList(S.bracketR, !0, !0, e);
        return this.finishNode(i, "ArrayExpression");
      case S.braceL:
        this.overrideContext(eC.b_expr);
        return this.parseObj(!1, e);
      case S._function:
        i = this.startNode();
        this.next();
        return this.parseFunction(i, 0);
      case S._class:
        return this.parseClass(this.startNode(), !1);
      case S._new:
        return this.parseNew();
      case S.backQuote:
        return this.parseTemplate();
      case S._import:
        if (this.options.ecmaVersion >= 11) return this.parseExprImport(n);
        return this.unexpected();
      default:
        return this.parseExprAtomDefault();
    }
  };
  eI.parseExprAtomDefault = function () {
    this.unexpected();
  };
  eI.parseExprImport = function (e) {
    var r = this.startNode();
    if (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"), this.next(), this.type === S.parenL && !e) return this.parseDynamicImport(r);
    if (this.type === S.dot) {
      var n = this.startNodeAt(r.start, r.loc && r.loc.start);
      n.name = "import";
      r.meta = this.finishNode(n, "Identifier");
      return this.parseImportMeta(r);
    }
    this.unexpected();
  };
  eI.parseDynamicImport = function (e) {
    if (this.next(), e.source = this.parseMaybeAssign(), this.options.ecmaVersion >= 16) this.eat(S.parenR) ? e.options = null : (this.expect(S.comma), this.afterTrailingComma(S.parenR) ? e.options = null : (e.options = this.parseMaybeAssign(), this.eat(S.parenR) || (this.expect(S.comma), this.afterTrailingComma(S.parenR) || this.unexpected())));else if (!this.eat(S.parenR)) {
      var r = this.start;
      this.eat(S.comma) && this.eat(S.parenR) ? this.raiseRecoverable(r, "Trailing comma is not allowed in import()") : this.unexpected(r);
    }
    return this.finishNode(e, "ImportExpression");
  };
  eI.parseImportMeta = function (e) {
    this.next();
    var r = this.containsEsc;
    e.property = this.parseIdent(!0);
    "meta" !== e.property.name && this.raiseRecoverable(e.property.start, "The only valid meta property for import is 'import.meta'");
    r && this.raiseRecoverable(e.start, "'import.meta' must not contain escaped characters");
    "module" === this.options.sourceType || this.options.allowImportExportEverywhere || this.raiseRecoverable(e.start, "Cannot use 'import.meta' outside a module");
    return this.finishNode(e, "MetaProperty");
  };
  eI.parseLiteral = function (e) {
    var r = this.startNode();
    r.value = e;
    r.raw = this.input.slice(this.start, this.end);
    110 === r.raw.charCodeAt(r.raw.length - 1) && (r.bigint = null != r.value ? r.value.toString() : r.raw.slice(0, -1).replace(/_/g, ""));
    this.next();
    return this.finishNode(r, "Literal");
  };
  eI.parseParenExpression = function () {
    this.expect(S.parenL);
    var e = this.parseExpression();
    this.expect(S.parenR);
    return e;
  };
  eI.shouldParseArrow = function (e) {
    return !this.canInsertSemicolon();
  };
  eI.parseParenAndDistinguishExpression = function (e, r) {
    var n;
    var i = this.start;
    var s = this.startLoc;
    var o = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
      this.next();
      var a;
      var h = this.start;
      var d = this.startLoc;
      var p = [];
      var g = !0;
      var m = !1;
      var v = new em();
      var y = this.yieldPos;
      var b = this.awaitPos;
      for (this.yieldPos = 0, this.awaitPos = 0; this.type !== S.parenR;) {
        if (g ? g = !1 : this.expect(S.comma), o && this.afterTrailingComma(S.parenR, !0)) {
          m = !0;
          break;
        }
        if (this.type === S.ellipsis) {
          a = this.start;
          p.push(this.parseParenItem(this.parseRestBinding()));
          this.type === S.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
          break;
        }
        p.push(this.parseMaybeAssign(!1, v, this.parseParenItem));
      }
      var O = this.lastTokEnd;
      var x = this.lastTokEndLoc;
      if (this.expect(S.parenR), e && this.shouldParseArrow(p) && this.eat(S.arrow)) {
        this.checkPatternErrors(v, !1);
        this.checkYieldAwaitInDefaultParams();
        this.yieldPos = y;
        this.awaitPos = b;
        return this.parseParenArrowList(i, s, p, r);
      }
      (!p.length || m) && this.unexpected(this.lastTokStart);
      a && this.unexpected(a);
      this.checkExpressionErrors(v, !0);
      this.yieldPos = y || this.yieldPos;
      this.awaitPos = b || this.awaitPos;
      p.length > 1 ? ((n = this.startNodeAt(h, d)).expressions = p, this.finishNodeAt(n, "SequenceExpression", O, x)) : n = p[0];
    } else n = this.parseParenExpression();
    if (!this.options.preserveParens) return n;
    var w = this.startNodeAt(i, s);
    w.expression = n;
    return this.finishNode(w, "ParenthesizedExpression");
  };
  eI.parseParenItem = function (e) {
    return e;
  };
  eI.parseParenArrowList = function (e, r, n, i) {
    return this.parseArrowExpression(this.startNodeAt(e, r), n, !1, i);
  };
  var eM = [];
  eI.parseNew = function () {
    this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
    var e = this.startNode();
    if (this.next(), this.options.ecmaVersion >= 6 && this.type === S.dot) {
      var r = this.startNodeAt(e.start, e.loc && e.loc.start);
      r.name = "new";
      e.meta = this.finishNode(r, "Identifier");
      this.next();
      var n = this.containsEsc;
      e.property = this.parseIdent(!0);
      "target" !== e.property.name && this.raiseRecoverable(e.property.start, "The only valid meta property for new is 'new.target'");
      n && this.raiseRecoverable(e.start, "'new.target' must not contain escaped characters");
      this.allowNewDotTarget || this.raiseRecoverable(e.start, "'new.target' can only be used in functions and class static block");
      return this.finishNode(e, "MetaProperty");
    }
    var i = this.start;
    var s = this.startLoc;
    e.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), i, s, !0, !1);
    this.eat(S.parenL) ? e.$$arguments = this.parseExprList(S.parenR, this.options.ecmaVersion >= 8, !1) : e.$$arguments = eM;
    return this.finishNode(e, "NewExpression");
  };
  eI.parseTemplateElement = function (e) {
    var r = e.isTagged;
    var n = this.startNode();
    this.type === S.invalidTemplate ? (r || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), n.value = {
      raw: this.value.replace(/\r\n?/g, "\n"),
      cooked: null
    }) : n.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
    this.next();
    n.tail = this.type === S.backQuote;
    return this.finishNode(n, "TemplateElement");
  };
  eI.parseTemplate = function (e) {
    void 0 === e && (e = {});
    var r = e.isTagged;
    void 0 === r && (r = !1);
    var n = this.startNode();
    this.next();
    n.expressions = [];
    var i = this.parseTemplateElement({
      isTagged: r
    });
    for (n.quasis = [i]; !i.tail;) {
      this.type === S.eof && this.raise(this.pos, "Unterminated template literal");
      this.expect(S.dollarBraceL);
      n.expressions.push(this.parseExpression());
      this.expect(S.braceR);
      n.quasis.push(i = this.parseTemplateElement({
        isTagged: r
      }));
    }
    this.next();
    return this.finishNode(n, "TemplateLiteral");
  };
  eI.isAsyncProp = function (e) {
    return !e.computed && "Identifier" === e.key.type && "async" === e.key.name && (this.type === S.name || this.type === S.num || this.type === S.string || this.type === S.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === S.star) && !E.test(this.input.slice(this.lastTokEnd, this.start));
  };
  eI.parseObj = function (e, r) {
    var n = this.startNode();
    var i = !0;
    var s = {};
    for (n.properties = [], this.next(); !this.eat(S.braceR);) {
      if (i) i = !1;else if (this.expect(S.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(S.braceR)) break;
      var o = this.parseProperty(e, r);
      e || this.checkPropClash(o, s, r);
      n.properties.push(o);
    }
    return this.finishNode(n, e ? "ObjectPattern" : "ObjectExpression");
  };
  eI.parseProperty = function (e, r) {
    var n;
    var i;
    var s;
    var o;
    var a = this.startNode();
    if (this.options.ecmaVersion >= 9 && this.eat(S.ellipsis)) return e ? (a.argument = this.parseIdent(!1), this.type === S.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(a, "RestElement")) : (a.argument = this.parseMaybeAssign(!1, r), this.type === S.comma && r && r.trailingComma < 0 && (r.trailingComma = this.start), this.finishNode(a, "SpreadElement"));
    this.options.ecmaVersion >= 6 && (a.method = !1, a.shorthand = !1, (e || r) && (s = this.start, o = this.startLoc), e || (n = this.eat(S.star)));
    var h = this.containsEsc;
    this.parsePropertyName(a);
    !e && !h && this.options.ecmaVersion >= 8 && !n && this.isAsyncProp(a) ? (i = !0, n = this.options.ecmaVersion >= 9 && this.eat(S.star), this.parsePropertyName(a)) : i = !1;
    this.parsePropertyValue(a, e, n, i, s, o, r, h);
    return this.finishNode(a, "Property");
  };
  eI.parseGetterSetter = function (e) {
    var r = e.key.name;
    this.parsePropertyName(e);
    e.value = this.parseMethod(!1);
    e.kind = r;
    var n = "get" === e.kind ? 0 : 1;
    if (e.value.params.length !== n) {
      var i = e.value.start;
      "get" === e.kind ? this.raiseRecoverable(i, "getter should have no params") : this.raiseRecoverable(i, "setter should have exactly one param");
    } else "set" === e.kind && "RestElement" === e.value.params[0].type && this.raiseRecoverable(e.value.params[0].start, "Setter cannot use rest params");
  };
  eI.parsePropertyValue = function (e, r, n, i, s, o, a, h) {
    (n || i) && this.type === S.colon && this.unexpected();
    this.eat(S.colon) ? (e.value = r ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, a), e.kind = "init") : this.options.ecmaVersion >= 6 && this.type === S.parenL ? (r && this.unexpected(), e.method = !0, e.value = this.parseMethod(n, i), e.kind = "init") : r || h || !(this.options.ecmaVersion >= 5) || e.computed || "Identifier" !== e.key.type || "get" !== e.key.name && "set" !== e.key.name || this.type === S.comma || this.type === S.braceR || this.type === S.eq ? this.options.ecmaVersion >= 6 && !e.computed && "Identifier" === e.key.type ? ((n || i) && this.unexpected(), this.checkUnreserved(e.key), "await" !== e.key.name || this.awaitIdentPos || (this.awaitIdentPos = s), r ? e.value = this.parseMaybeDefault(s, o, this.copyNode(e.key)) : this.type === S.eq && a ? (a.shorthandAssign < 0 && (a.shorthandAssign = this.start), e.value = this.parseMaybeDefault(s, o, this.copyNode(e.key))) : e.value = this.copyNode(e.key), e.kind = "init", e.shorthand = !0) : this.unexpected() : ((n || i) && this.unexpected(), this.parseGetterSetter(e));
  };
  eI.parsePropertyName = function (e) {
    if (this.options.ecmaVersion >= 6) {
      if (this.eat(S.bracketL)) {
        e.computed = !0;
        e.key = this.parseMaybeAssign();
        this.expect(S.bracketR);
        return e.key;
      }
      e.computed = !1;
    }
    return e.key = this.type === S.num || this.type === S.string ? this.parseExprAtom() : this.parseIdent("never" !== this.options.allowReserved);
  };
  eI.initFunction = function (e) {
    e.id = null;
    this.options.ecmaVersion >= 6 && (e.generator = e.expression = !1);
    this.options.ecmaVersion >= 8 && (e.async = !1);
  };
  eI.parseMethod = function (e, r, n) {
    var i = this.startNode();
    var s = this.yieldPos;
    var o = this.awaitPos;
    var a = this.awaitIdentPos;
    this.initFunction(i);
    this.options.ecmaVersion >= 6 && (i.generator = e);
    this.options.ecmaVersion >= 8 && (i.async = !!r);
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(es(r, i.generator) | ee | (n ? et : 0));
    this.expect(S.parenL);
    i.params = this.parseBindingList(S.parenR, !1, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
    this.parseFunctionBody(i, !1, !0, !1);
    this.yieldPos = s;
    this.awaitPos = o;
    this.awaitIdentPos = a;
    return this.finishNode(i, "FunctionExpression");
  };
  eI.parseArrowExpression = function (e, r, n, i) {
    var s = this.yieldPos;
    var o = this.awaitPos;
    var a = this.awaitIdentPos;
    this.enterScope(es(n, !1) | K);
    this.initFunction(e);
    this.options.ecmaVersion >= 8 && (e.async = !!n);
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    e.params = this.toAssignableList(r, !0);
    this.parseFunctionBody(e, !0, !1, i);
    this.yieldPos = s;
    this.awaitPos = o;
    this.awaitIdentPos = a;
    return this.finishNode(e, "ArrowFunctionExpression");
  };
  eI.parseFunctionBody = function (e, r, n, i) {
    var s = r && this.type !== S.braceL;
    var o = this.strict;
    var a = !1;
    if (s) {
      e.body = this.parseMaybeAssign(i);
      e.expression = !0;
      this.checkParams(e, !1);
    } else {
      var h = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e.params);
      (!o || h) && (a = this.strictDirective(this.end)) && h && this.raiseRecoverable(e.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      var d = this.labels;
      this.labels = [];
      a && (this.strict = !0);
      this.checkParams(e, !o && !a && !r && !n && this.isSimpleParamList(e.params));
      this.strict && e.id && this.checkLValSimple(e.id, eh);
      e.body = this.parseBlock(!1, void 0, a && !o);
      e.expression = !1;
      this.adaptDirectivePrologue(e.body.body);
      this.labels = d;
    }
    this.exitScope();
  };
  eI.isSimpleParamList = function (e) {
    for (r = 0, n = e, void 0; r < n.length; r += 1) {
      var r;
      var n;
      if ("Identifier" !== n[r].type) return !1;
    }
    return !0;
  };
  eI.checkParams = function (e, r) {
    for (n = Object.create(null), i = 0, s = e.params, void 0; i < s.length; i += 1) {
      var n;
      var i;
      var s;
      var o = s[i];
      this.checkLValInnerPattern(o, ea, r ? null : n);
    }
  };
  eI.parseExprList = function (e, r, n, i) {
    for (s = [], o = !0, void 0; !this.eat(e);) {
      var s;
      var o;
      if (o) o = !1;else if (this.expect(S.comma), r && this.afterTrailingComma(e)) break;
      var a = void 0;
      n && this.type === S.comma ? a = null : this.type === S.ellipsis ? (a = this.parseSpread(i), i && this.type === S.comma && i.trailingComma < 0 && (i.trailingComma = this.start)) : a = this.parseMaybeAssign(!1, i);
      s.push(a);
    }
    return s;
  };
  eI.checkUnreserved = function (e) {
    var r = e.start;
    var n = e.end;
    var i = e.name;
    this.inGenerator && "yield" === i && this.raiseRecoverable(r, "Cannot use 'yield' as identifier inside a generator");
    this.inAsync && "await" === i && this.raiseRecoverable(r, "Cannot use 'await' as identifier inside an async function");
    this.currentThisScope().flags & ei || "arguments" !== i || this.raiseRecoverable(r, "Cannot use 'arguments' in class field initializer");
    this.inClassStaticBlock && ("arguments" === i || "await" === i) && this.raise(r, "Cannot use " + i + " in class static initialization block");
    this.keywords.test(i) && this.raise(r, "Unexpected keyword '" + i + "'");
    (!(this.options.ecmaVersion < 6) || -1 === this.input.slice(r, n).indexOf("\\")) && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(i) && (this.inAsync || "await" !== i || this.raiseRecoverable(r, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(r, "The keyword '" + i + "' is reserved"));
  };
  eI.parseIdent = function (e) {
    var r = this.parseIdentNode();
    this.next(!!e);
    this.finishNode(r, "Identifier");
    e || (this.checkUnreserved(r), "await" !== r.name || this.awaitIdentPos || (this.awaitIdentPos = r.start));
    return r;
  };
  eI.parseIdentNode = function () {
    var e = this.startNode();
    this.type === S.name ? e.name = this.value : this.type.keyword ? (e.name = this.type.keyword, ("class" === e.name || "function" === e.name) && (this.lastTokEnd !== this.lastTokStart + 1 || 46 !== this.input.charCodeAt(this.lastTokStart)) && this.context.pop(), this.type = S.name) : this.unexpected();
    return e;
  };
  eI.parsePrivateIdent = function () {
    var e = this.startNode();
    this.type === S.privateId ? e.name = this.value : this.unexpected();
    this.next();
    this.finishNode(e, "PrivateIdentifier");
    this.options.checkPrivateFields && (0 === this.privateNameStack.length ? this.raise(e.start, "Private field '#" + e.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(e));
    return e;
  };
  eI.parseYield = function (e) {
    this.yieldPos || (this.yieldPos = this.start);
    var r = this.startNode();
    this.next();
    this.type === S.semi || this.canInsertSemicolon() || this.type !== S.star && !this.type.startsExpr ? (r.delegate = !1, r.argument = null) : (r.delegate = this.eat(S.star), r.argument = this.parseMaybeAssign(e));
    return this.finishNode(r, "YieldExpression");
  };
  eI.parseAwait = function (e) {
    this.awaitPos || (this.awaitPos = this.start);
    var r = this.startNode();
    this.next();
    r.argument = this.parseMaybeUnary(null, !0, !1, e);
    return this.finishNode(r, "AwaitExpression");
  };
  var eD = ed.prototype;
  eD.raise = function (e, r) {
    var n = Q(this.input, e);
    r += " (" + n.line + ":" + n.column + ")";
    this.sourceFile && (r += " in " + this.sourceFile);
    var i = SyntaxError(r);
    i.pos = e;
    i.loc = n;
    i.raisedAt = this.pos;
    return i;
  };
  eD.raiseRecoverable = eD.raise;
  eD.curPosition = function () {
    if (this.options.locations) return new F(this.curLine, this.pos - this.lineStart);
  };
  var eN = ed.prototype;
  var e$ = function (e) {
    this.flags = e;
    this.$$var = [];
    this.lexical = [];
    this.functions = [];
  };
  eN.enterScope = function (e) {
    this.scopeStack.push(new e$(e));
  };
  eN.exitScope = function () {
    this.scopeStack.pop();
  };
  eN.treatFunctionsAsVarInScope = function (e) {
    return e.flags & G || !this.inModule && e.flags & Y;
  };
  eN.declareName = function (e, r, n) {
    var i = !1;
    if (r === el) {
      var s = this.currentScope();
      i = s.lexical.indexOf(e) > -1 || s.functions.indexOf(e) > -1 || s.$$var.indexOf(e) > -1;
      s.lexical.push(e);
      this.inModule && s.flags & Y && delete this.undefinedExports[e];
    } else if (r === ec) this.currentScope().lexical.push(e);else if (r === eu) {
      var o = this.currentScope();
      i = this.treatFunctionsAsVar ? o.lexical.indexOf(e) > -1 : o.lexical.indexOf(e) > -1 || o.$$var.indexOf(e) > -1;
      o.functions.push(e);
    } else for (var a = this.scopeStack.length - 1; a >= 0; --a) {
      var h = this.scopeStack[a];
      if (h.lexical.indexOf(e) > -1 && !(h.flags & J && h.lexical[0] === e) || !this.treatFunctionsAsVarInScope(h) && h.functions.indexOf(e) > -1) {
        i = !0;
        break;
      }
      if (h.$$var.push(e), this.inModule && h.flags & Y && delete this.undefinedExports[e], h.flags & ei) break;
    }
    i && this.raiseRecoverable(n, "Identifier '" + e + "' has already been declared");
  };
  eN.checkLocalExport = function (e) {
    -1 === this.scopeStack[0].lexical.indexOf(e.name) && -1 === this.scopeStack[0].$$var.indexOf(e.name) && (this.undefinedExports[e.name] = e);
  };
  eN.currentScope = function () {
    return this.scopeStack[this.scopeStack.length - 1];
  };
  eN.currentVarScope = function () {
    for (var e = this.scopeStack.length - 1;; e--) {
      var r = this.scopeStack[e];
      if (r.flags & (ei | en | er)) return r;
    }
  };
  eN.currentThisScope = function () {
    for (var e = this.scopeStack.length - 1;; e--) {
      var r = this.scopeStack[e];
      if (r.flags & (ei | en | er) && !(r.flags & K)) return r;
    }
  };
  var eL = function (e, r, n) {
    this.type = "";
    this.start = r;
    this.end = 0;
    e.options.locations && (this.loc = new U(e, n));
    e.options.directSourceFile && (this.sourceFile = e.options.directSourceFile);
    e.options.ranges && (this.range = [r, 0]);
  };
  var ej = ed.prototype;
  function ez(e, r, n, i) {
    e.type = r;
    e.end = n;
    this.options.locations && (e.loc.end = i);
    this.options.ranges && (e.range[1] = n);
    return e;
  }
  ej.startNode = function () {
    return new eL(this, this.start, this.startLoc);
  };
  ej.startNodeAt = function (e, r) {
    return new eL(this, e, r);
  };
  ej.finishNode = function (e, r) {
    return ez.call(this, e, r, this.lastTokEnd, this.lastTokEndLoc);
  };
  ej.finishNodeAt = function (e, r, n, i) {
    return ez.call(this, e, r, n, i);
  };
  ej.copyNode = function (e) {
    var r = new eL(this, e.start, this.startLoc);
    for (var n in e) r[n] = e[n];
    return r;
  };
  var eZ = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
  var eF = eZ + " Extended_Pictographic";
  var eU = eF;
  var eQ = eU + " EBase EComp EMod EPres ExtPict";
  var eV = eQ;
  var eB = eV;
  var eq = {
    9: eZ,
    10: eF,
    11: eU,
    12: eQ,
    13: eV,
    14: eB
  };
  var eW = {
    9: "",
    10: "",
    11: "",
    12: "",
    13: "",
    14: "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji"
  };
  var eY = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
  var eG = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
  var eX = eG + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
  var eH = eX + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
  var eK = eH + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
  var eJ = eK + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
  var e0 = eJ + " Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
  var e1 = {
    9: eG,
    10: eX,
    11: eH,
    12: eK,
    13: eJ,
    14: e0
  };
  var e2 = {};
  function e5(e) {
    var r = e2[e] = {
      binary: j(eq[e] + " " + eY),
      binaryOfStrings: j(eW[e]),
      nonBinary: {
        General_Category: j(eY),
        Script: j(e1[e])
      }
    };
    r.nonBinary.Script_Extensions = r.nonBinary.Script;
    r.nonBinary.gc = r.nonBinary.General_Category;
    r.nonBinary.sc = r.nonBinary.Script;
    r.nonBinary.scx = r.nonBinary.Script_Extensions;
  }
  for (e3 = 0, e6 = [9, 10, 11, 12, 13, 14], void 0; e3 < e6.length; e3 += 1) {
    var e3;
    var e6;
    e5(e6[e3]);
  }
  var e4 = ed.prototype;
  var e8 = function (e, r) {
    this.parent = e;
    this.base = r || this;
  };
  e8.prototype.separatedFrom = function (e) {
    for (var r = this; r; r = r.parent) for (var n = e; n; n = n.parent) if (r.base === n.base && r !== n) return !0;
    return !1;
  };
  e8.prototype.sibling = function () {
    return new e8(this.parent, this.base);
  };
  var e7 = function (e) {
    this.parser = e;
    this.validFlags = "gim" + (e.options.ecmaVersion >= 6 ? "uy" : "") + (e.options.ecmaVersion >= 9 ? "s" : "") + (e.options.ecmaVersion >= 13 ? "d" : "") + (e.options.ecmaVersion >= 15 ? "v" : "");
    this.unicodeProperties = e2[e.options.ecmaVersion >= 14 ? 14 : e.options.ecmaVersion];
    this.source = "";
    this.flags = "";
    this.start = 0;
    this.switchU = !1;
    this.switchV = !1;
    this.switchN = !1;
    this.pos = 0;
    this.lastIntValue = 0;
    this.lastStringValue = "";
    this.lastAssertionIsQuantifiable = !1;
    this.numCapturingParens = 0;
    this.maxBackReference = 0;
    this.groupNames = Object.create(null);
    this.backReferenceNames = [];
    this.branchID = null;
  };
  function e9(e) {
    for (var r in e) return !0;
    return !1;
  }
  function te(e) {
    return 105 === e || 109 === e || 115 === e;
  }
  function tt(e) {
    return 36 === e || e >= 40 && e <= 43 || 46 === e || 63 === e || e >= 91 && e <= 94 || e >= 123 && e <= 125;
  }
  function tr(e) {
    return v(e, !0) || 36 === e || 95 === e;
  }
  function tn(e) {
    return y(e, !0) || 36 === e || 95 === e || 8204 === e || 8205 === e;
  }
  function ti(e) {
    return e >= 65 && e <= 90 || e >= 97 && e <= 122;
  }
  function ts(e) {
    return e >= 0 && e <= 1114111;
  }
  e7.prototype.reset = function (e, r, n) {
    var i = -1 !== n.indexOf("v");
    var s = -1 !== n.indexOf("u");
    this.start = 0 | e;
    this.source = r + "";
    this.flags = n;
    i && this.parser.options.ecmaVersion >= 15 ? (this.switchU = !0, this.switchV = !0, this.switchN = !0) : (this.switchU = s && this.parser.options.ecmaVersion >= 6, this.switchV = !1, this.switchN = s && this.parser.options.ecmaVersion >= 9);
  };
  e7.prototype.raise = function (e) {
    this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + e);
  };
  e7.prototype.at = function (e, r) {
    void 0 === r && (r = !1);
    var n = this.source;
    var i = n.length;
    if (e >= i) return -1;
    var s = n.charCodeAt(e);
    if (!(r || this.switchU) || s <= 55295 || s >= 57344 || e + 1 >= i) return s;
    var o = n.charCodeAt(e + 1);
    return o >= 56320 && o <= 57343 ? (s << 10) + o - 0x35fdc00 : s;
  };
  e7.prototype.nextIndex = function (e, r) {
    void 0 === r && (r = !1);
    var n = this.source;
    var i = n.length;
    if (e >= i) return i;
    var s;
    var o = n.charCodeAt(e);
    return !(r || this.switchU) || o <= 55295 || o >= 57344 || e + 1 >= i || (s = n.charCodeAt(e + 1)) < 56320 || s > 57343 ? e + 1 : e + 2;
  };
  e7.prototype.current = function (e) {
    void 0 === e && (e = !1);
    return this.at(this.pos, e);
  };
  e7.prototype.lookahead = function (e) {
    void 0 === e && (e = !1);
    return this.at(this.nextIndex(this.pos, e), e);
  };
  e7.prototype.advance = function (e) {
    void 0 === e && (e = !1);
    this.pos = this.nextIndex(this.pos, e);
  };
  e7.prototype.eat = function (e, r) {
    void 0 === r && (r = !1);
    return this.current(r) === e && (this.advance(r), !0);
  };
  e7.prototype.eatChars = function (e, r) {
    void 0 === r && (r = !1);
    for (n = this.pos, i = 0, s = e, void 0; i < s.length; i += 1) {
      var n;
      var i;
      var s;
      var o = s[i];
      var a = this.at(n, r);
      if (-1 === a || a !== o) return !1;
      n = this.nextIndex(n, r);
    }
    this.pos = n;
    return !0;
  };
  e4.validateRegExpFlags = function (e) {
    for (r = e.validFlags, n = e.flags, i = !1, s = !1, o = 0, void 0; o < n.length; o++) {
      var r;
      var n;
      var i;
      var s;
      var o;
      var a = n.charAt(o);
      -1 === r.indexOf(a) && this.raise(e.start, "Invalid regular expression flag");
      n.indexOf(a, o + 1) > -1 && this.raise(e.start, "Duplicate regular expression flag");
      "u" === a && (i = !0);
      "v" === a && (s = !0);
    }
    this.options.ecmaVersion >= 15 && i && s && this.raise(e.start, "Invalid regular expression flag");
  };
  e4.validateRegExpPattern = function (e) {
    this.regexp_pattern(e);
    !e.switchN && this.options.ecmaVersion >= 9 && e9(e.groupNames) && (e.switchN = !0, this.regexp_pattern(e));
  };
  e4.regexp_pattern = function (e) {
    e.pos = 0;
    e.lastIntValue = 0;
    e.lastStringValue = "";
    e.lastAssertionIsQuantifiable = !1;
    e.numCapturingParens = 0;
    e.maxBackReference = 0;
    e.groupNames = Object.create(null);
    e.backReferenceNames.length = 0;
    e.branchID = null;
    this.regexp_disjunction(e);
    e.pos !== e.source.length && (e.eat(41) && e.raise("Unmatched ')'"), (e.eat(93) || e.eat(125)) && e.raise("Lone quantifier brackets"));
    e.maxBackReference > e.numCapturingParens && e.raise("Invalid escape");
    for (r = 0, n = e.backReferenceNames, void 0; r < n.length; r += 1) {
      var r;
      var n;
      var i = n[r];
      e.groupNames[i] || e.raise("Invalid named capture referenced");
    }
  };
  e4.regexp_disjunction = function (e) {
    var r = this.options.ecmaVersion >= 16;
    for (r && (e.branchID = new e8(e.branchID, null)), this.regexp_alternative(e); e.eat(124);) {
      r && (e.branchID = e.branchID.sibling());
      this.regexp_alternative(e);
    }
    r && (e.branchID = e.branchID.parent);
    this.regexp_eatQuantifier(e, !0) && e.raise("Nothing to repeat");
    e.eat(123) && e.raise("Lone quantifier brackets");
  };
  e4.regexp_alternative = function (e) {
    for (; e.pos < e.source.length && this.regexp_eatTerm(e););
  };
  e4.regexp_eatTerm = function (e) {
    return this.regexp_eatAssertion(e) ? (e.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(e) && e.switchU && e.raise("Invalid quantifier"), !0) : (e.switchU ? !!this.regexp_eatAtom(e) : !!this.regexp_eatExtendedAtom(e)) && (this.regexp_eatQuantifier(e), !0);
  };
  e4.regexp_eatAssertion = function (e) {
    var r = e.pos;
    if (e.lastAssertionIsQuantifiable = !1, e.eat(94) || e.eat(36)) return !0;
    if (e.eat(92)) {
      if (e.eat(66) || e.eat(98)) return !0;
      e.pos = r;
    }
    if (e.eat(40) && e.eat(63)) {
      var n = !1;
      if (this.options.ecmaVersion >= 9 && (n = e.eat(60)), e.eat(61) || e.eat(33)) {
        this.regexp_disjunction(e);
        e.eat(41) || e.raise("Unterminated group");
        e.lastAssertionIsQuantifiable = !n;
        return !0;
      }
    }
    e.pos = r;
    return !1;
  };
  e4.regexp_eatQuantifier = function (e, r) {
    void 0 === r && (r = !1);
    return !!this.regexp_eatQuantifierPrefix(e, r) && (e.eat(63), !0);
  };
  e4.regexp_eatQuantifierPrefix = function (e, r) {
    return e.eat(42) || e.eat(43) || e.eat(63) || this.regexp_eatBracedQuantifier(e, r);
  };
  e4.regexp_eatBracedQuantifier = function (e, r) {
    var n = e.pos;
    if (e.eat(123)) {
      var i = 0;
      var s = -1;
      if (this.regexp_eatDecimalDigits(e) && (i = e.lastIntValue, e.eat(44) && this.regexp_eatDecimalDigits(e) && (s = e.lastIntValue), e.eat(125))) {
        -1 !== s && s < i && !r && e.raise("numbers out of order in {} quantifier");
        return !0;
      }
      e.switchU && !r && e.raise("Incomplete quantifier");
      e.pos = n;
    }
    return !1;
  };
  e4.regexp_eatAtom = function (e) {
    return this.regexp_eatPatternCharacters(e) || e.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e);
  };
  e4.regexp_eatReverseSolidusAtomEscape = function (e) {
    var r = e.pos;
    if (e.eat(92)) {
      if (this.regexp_eatAtomEscape(e)) return !0;
      e.pos = r;
    }
    return !1;
  };
  e4.regexp_eatUncapturingGroup = function (e) {
    var r = e.pos;
    if (e.eat(40)) {
      if (e.eat(63)) {
        if (this.options.ecmaVersion >= 16) {
          var n = this.regexp_eatModifiers(e);
          var i = e.eat(45);
          if (n || i) {
            for (var s = 0; s < n.length; s++) {
              var o = n.charAt(s);
              n.indexOf(o, s + 1) > -1 && e.raise("Duplicate regular expression modifiers");
            }
            if (i) {
              var a = this.regexp_eatModifiers(e);
              n || a || 58 !== e.current() || e.raise("Invalid regular expression modifiers");
              for (var h = 0; h < a.length; h++) {
                var d = a.charAt(h);
                (a.indexOf(d, h + 1) > -1 || n.indexOf(d) > -1) && e.raise("Duplicate regular expression modifiers");
              }
            }
          }
        }
        if (e.eat(58)) {
          if (this.regexp_disjunction(e), e.eat(41)) return !0;
          e.raise("Unterminated group");
        }
      }
      e.pos = r;
    }
    return !1;
  };
  e4.regexp_eatCapturingGroup = function (e) {
    if (e.eat(40)) {
      if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(e) : 63 === e.current() && e.raise("Invalid group"), this.regexp_disjunction(e), e.eat(41)) {
        e.numCapturingParens += 1;
        return !0;
      }
      e.raise("Unterminated group");
    }
    return !1;
  };
  e4.regexp_eatModifiers = function (e) {
    for (r = "", n = 0, void 0; -1 !== (n = e.current()) && te(n);) {
      var r;
      var n;
      r += z(n);
      e.advance();
    }
    return r;
  };
  e4.regexp_eatExtendedAtom = function (e) {
    return e.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e) || this.regexp_eatInvalidBracedQuantifier(e) || this.regexp_eatExtendedPatternCharacter(e);
  };
  e4.regexp_eatInvalidBracedQuantifier = function (e) {
    this.regexp_eatBracedQuantifier(e, !0) && e.raise("Nothing to repeat");
    return !1;
  };
  e4.regexp_eatSyntaxCharacter = function (e) {
    var r = e.current();
    return !!tt(r) && (e.lastIntValue = r, e.advance(), !0);
  };
  e4.regexp_eatPatternCharacters = function (e) {
    for (r = e.pos, n = 0, void 0; -1 !== (n = e.current()) && !tt(n);) {
      var r;
      var n;
      e.advance();
    }
    return e.pos !== r;
  };
  e4.regexp_eatExtendedPatternCharacter = function (e) {
    var r = e.current();
    return -1 !== r && 36 !== r && (!(r >= 40) || !(r <= 43)) && 46 !== r && 63 !== r && 91 !== r && 94 !== r && 124 !== r && (e.advance(), !0);
  };
  e4.regexp_groupSpecifier = function (e) {
    if (e.eat(63)) {
      this.regexp_eatGroupName(e) || e.raise("Invalid group");
      var r = this.options.ecmaVersion >= 16;
      var n = e.groupNames[e.lastStringValue];
      if (n) {
        if (r) for (i = 0, s = n, void 0; i < s.length; i += 1) {
          var i;
          var s;
          s[i].separatedFrom(e.branchID) || e.raise("Duplicate capture group name");
        } else e.raise("Duplicate capture group name");
      }
      r ? (n || (e.groupNames[e.lastStringValue] = [])).push(e.branchID) : e.groupNames[e.lastStringValue] = !0;
    }
  };
  e4.regexp_eatGroupName = function (e) {
    if (e.lastStringValue = "", e.eat(60)) {
      if (this.regexp_eatRegExpIdentifierName(e) && e.eat(62)) return !0;
      e.raise("Invalid capture group name");
    }
    return !1;
  };
  e4.regexp_eatRegExpIdentifierName = function (e) {
    if (e.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(e)) {
      for (e.lastStringValue += z(e.lastIntValue); this.regexp_eatRegExpIdentifierPart(e);) e.lastStringValue += z(e.lastIntValue);
      return !0;
    }
    return !1;
  };
  e4.regexp_eatRegExpIdentifierStart = function (e) {
    var r = e.pos;
    var n = this.options.ecmaVersion >= 11;
    var i = e.current(n);
    return (e.advance(n), 92 === i && this.regexp_eatRegExpUnicodeEscapeSequence(e, n) && (i = e.lastIntValue), tr(i)) ? (e.lastIntValue = i, !0) : (e.pos = r, !1);
  };
  e4.regexp_eatRegExpIdentifierPart = function (e) {
    var r = e.pos;
    var n = this.options.ecmaVersion >= 11;
    var i = e.current(n);
    return (e.advance(n), 92 === i && this.regexp_eatRegExpUnicodeEscapeSequence(e, n) && (i = e.lastIntValue), tn(i)) ? (e.lastIntValue = i, !0) : (e.pos = r, !1);
  };
  e4.regexp_eatAtomEscape = function (e) {
    return !!(this.regexp_eatBackReference(e) || this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e) || e.switchN && this.regexp_eatKGroupName(e)) || (e.switchU && (99 === e.current() && e.raise("Invalid unicode escape"), e.raise("Invalid escape")), !1);
  };
  e4.regexp_eatBackReference = function (e) {
    var r = e.pos;
    if (this.regexp_eatDecimalEscape(e)) {
      var n = e.lastIntValue;
      if (e.switchU) {
        n > e.maxBackReference && (e.maxBackReference = n);
        return !0;
      }
      if (n <= e.numCapturingParens) return !0;
      e.pos = r;
    }
    return !1;
  };
  e4.regexp_eatKGroupName = function (e) {
    if (e.eat(107)) {
      if (this.regexp_eatGroupName(e)) {
        e.backReferenceNames.push(e.lastStringValue);
        return !0;
      }
      e.raise("Invalid named reference");
    }
    return !1;
  };
  e4.regexp_eatCharacterEscape = function (e) {
    return this.regexp_eatControlEscape(e) || this.regexp_eatCControlLetter(e) || this.regexp_eatZero(e) || this.regexp_eatHexEscapeSequence(e) || this.regexp_eatRegExpUnicodeEscapeSequence(e, !1) || !e.switchU && this.regexp_eatLegacyOctalEscapeSequence(e) || this.regexp_eatIdentityEscape(e);
  };
  e4.regexp_eatCControlLetter = function (e) {
    var r = e.pos;
    if (e.eat(99)) {
      if (this.regexp_eatControlLetter(e)) return !0;
      e.pos = r;
    }
    return !1;
  };
  e4.regexp_eatZero = function (e) {
    return !(48 !== e.current() || tg(e.lookahead())) && (e.lastIntValue = 0, e.advance(), !0);
  };
  e4.regexp_eatControlEscape = function (e) {
    var r = e.current();
    return 116 === r ? (e.lastIntValue = 9, e.advance(), !0) : 110 === r ? (e.lastIntValue = 10, e.advance(), !0) : 118 === r ? (e.lastIntValue = 11, e.advance(), !0) : 102 === r ? (e.lastIntValue = 12, e.advance(), !0) : 114 === r && (e.lastIntValue = 13, e.advance(), !0);
  };
  e4.regexp_eatControlLetter = function (e) {
    var r = e.current();
    return !!ti(r) && (e.lastIntValue = r % 32, e.advance(), !0);
  };
  e4.regexp_eatRegExpUnicodeEscapeSequence = function (e, r) {
    void 0 === r && (r = !1);
    var n = e.pos;
    var i = r || e.switchU;
    if (e.eat(117)) {
      if (this.regexp_eatFixedHexDigits(e, 4)) {
        var s = e.lastIntValue;
        if (i && s >= 55296 && s <= 56319) {
          var o = e.pos;
          if (e.eat(92) && e.eat(117) && this.regexp_eatFixedHexDigits(e, 4)) {
            var a = e.lastIntValue;
            if (a >= 56320 && a <= 57343) {
              e.lastIntValue = (s - 55296) * 1024 + (a - 56320) + 65536;
              return !0;
            }
          }
          e.pos = o;
          e.lastIntValue = s;
        }
        return !0;
      }
      if (i && e.eat(123) && this.regexp_eatHexDigits(e) && e.eat(125) && ts(e.lastIntValue)) return !0;
      i && e.raise("Invalid unicode escape");
      e.pos = n;
    }
    return !1;
  };
  e4.regexp_eatIdentityEscape = function (e) {
    if (e.switchU) return !!this.regexp_eatSyntaxCharacter(e) || !!e.eat(47) && (e.lastIntValue = 47, !0);
    var r = e.current();
    return 99 !== r && (!e.switchN || 107 !== r) && (e.lastIntValue = r, e.advance(), !0);
  };
  e4.regexp_eatDecimalEscape = function (e) {
    e.lastIntValue = 0;
    var r = e.current();
    if (r >= 49 && r <= 57) {
      do {
        e.lastIntValue = 10 * e.lastIntValue + (r - 48);
        e.advance();
      } while ((r = e.current()) >= 48 && r <= 57);
      return !0;
    }
    return !1;
  };
  var to = 0;
  var ta = 1;
  var tl = 2;
  function tu(e) {
    return 100 === e || 68 === e || 115 === e || 83 === e || 119 === e || 87 === e;
  }
  function tc(e) {
    return ti(e) || 95 === e;
  }
  function th(e) {
    return tc(e) || tg(e);
  }
  function td(e) {
    return 33 === e || e >= 35 && e <= 38 || e >= 42 && e <= 44 || 46 === e || e >= 58 && e <= 64 || 94 === e || 96 === e || 126 === e;
  }
  function tf(e) {
    return 40 === e || 41 === e || 45 === e || 47 === e || e >= 91 && e <= 93 || e >= 123 && e <= 125;
  }
  function tp(e) {
    return 33 === e || 35 === e || 37 === e || 38 === e || 44 === e || 45 === e || e >= 58 && e <= 62 || 64 === e || 96 === e || 126 === e;
  }
  function tg(e) {
    return e >= 48 && e <= 57;
  }
  function tm(e) {
    return e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102;
  }
  function tv(e) {
    return e >= 65 && e <= 70 ? 10 + (e - 65) : e >= 97 && e <= 102 ? 10 + (e - 97) : e - 48;
  }
  function ty(e) {
    return e >= 48 && e <= 55;
  }
  e4.regexp_eatCharacterClassEscape = function (e) {
    var r;
    var n = e.current();
    if (tu(n)) {
      e.lastIntValue = -1;
      e.advance();
      return ta;
    }
    var i = !1;
    if (e.switchU && this.options.ecmaVersion >= 9 && ((i = 80 === n) || 112 === n)) {
      if (e.lastIntValue = -1, e.advance(), e.eat(123) && (r = this.regexp_eatUnicodePropertyValueExpression(e)) && e.eat(125)) {
        i && r === tl && e.raise("Invalid property name");
        return r;
      }
      e.raise("Invalid property name");
    }
    return to;
  };
  e4.regexp_eatUnicodePropertyValueExpression = function (e) {
    var r = e.pos;
    if (this.regexp_eatUnicodePropertyName(e) && e.eat(61)) {
      var n = e.lastStringValue;
      if (this.regexp_eatUnicodePropertyValue(e)) {
        var i = e.lastStringValue;
        this.regexp_validateUnicodePropertyNameAndValue(e, n, i);
        return ta;
      }
    }
    if (e.pos = r, this.regexp_eatLoneUnicodePropertyNameOrValue(e)) {
      var s = e.lastStringValue;
      return this.regexp_validateUnicodePropertyNameOrValue(e, s);
    }
    return to;
  };
  e4.regexp_validateUnicodePropertyNameAndValue = function (e, r, n) {
    N(e.unicodeProperties.nonBinary, r) || e.raise("Invalid property name");
    e.unicodeProperties.nonBinary[r].test(n) || e.raise("Invalid property value");
  };
  e4.regexp_validateUnicodePropertyNameOrValue = function (e, r) {
    return e.unicodeProperties.binary.test(r) ? ta : e.switchV && e.unicodeProperties.binaryOfStrings.test(r) ? tl : void e.raise("Invalid property name");
  };
  e4.regexp_eatUnicodePropertyName = function (e) {
    var r = 0;
    for (e.lastStringValue = ""; tc(r = e.current());) {
      e.lastStringValue += z(r);
      e.advance();
    }
    return "" !== e.lastStringValue;
  };
  e4.regexp_eatUnicodePropertyValue = function (e) {
    var r = 0;
    for (e.lastStringValue = ""; th(r = e.current());) {
      e.lastStringValue += z(r);
      e.advance();
    }
    return "" !== e.lastStringValue;
  };
  e4.regexp_eatLoneUnicodePropertyNameOrValue = function (e) {
    return this.regexp_eatUnicodePropertyValue(e);
  };
  e4.regexp_eatCharacterClass = function (e) {
    if (e.eat(91)) {
      var r = e.eat(94);
      var n = this.regexp_classContents(e);
      e.eat(93) || e.raise("Unterminated character class");
      r && n === tl && e.raise("Negated character class may contain strings");
      return !0;
    }
    return !1;
  };
  e4.regexp_classContents = function (e) {
    return 93 === e.current() ? ta : e.switchV ? this.regexp_classSetExpression(e) : (this.regexp_nonEmptyClassRanges(e), ta);
  };
  e4.regexp_nonEmptyClassRanges = function (e) {
    for (; this.regexp_eatClassAtom(e);) {
      var r = e.lastIntValue;
      if (e.eat(45) && this.regexp_eatClassAtom(e)) {
        var n = e.lastIntValue;
        e.switchU && (-1 === r || -1 === n) && e.raise("Invalid character class");
        -1 !== r && -1 !== n && r > n && e.raise("Range out of order in character class");
      }
    }
  };
  e4.regexp_eatClassAtom = function (e) {
    var r = e.pos;
    if (e.eat(92)) {
      if (this.regexp_eatClassEscape(e)) return !0;
      if (e.switchU) {
        var n = e.current();
        (99 === n || ty(n)) && e.raise("Invalid class escape");
        e.raise("Invalid escape");
      }
      e.pos = r;
    }
    var i = e.current();
    return 93 !== i && (e.lastIntValue = i, e.advance(), !0);
  };
  e4.regexp_eatClassEscape = function (e) {
    var r = e.pos;
    if (e.eat(98)) {
      e.lastIntValue = 8;
      return !0;
    }
    if (e.switchU && e.eat(45)) {
      e.lastIntValue = 45;
      return !0;
    }
    if (!e.switchU && e.eat(99)) {
      if (this.regexp_eatClassControlLetter(e)) return !0;
      e.pos = r;
    }
    return this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e);
  };
  e4.regexp_classSetExpression = function (e) {
    var r;
    var n = ta;
    if (this.regexp_eatClassSetRange(e)) ;else if (r = this.regexp_eatClassSetOperand(e)) {
      r === tl && (n = tl);
      for (var i = e.pos; e.eatChars([38, 38]);) {
        if (38 !== e.current() && (r = this.regexp_eatClassSetOperand(e))) {
          r !== tl && (n = ta);
          continue;
        }
        e.raise("Invalid character in character class");
      }
      if (i !== e.pos) return n;
      for (; e.eatChars([45, 45]);) this.regexp_eatClassSetOperand(e) || e.raise("Invalid character in character class");
      if (i !== e.pos) return n;
    } else e.raise("Invalid character in character class");
    for (;;) if (!this.regexp_eatClassSetRange(e)) {
      if (!(r = this.regexp_eatClassSetOperand(e))) return n;
      r === tl && (n = tl);
    }
  };
  e4.regexp_eatClassSetRange = function (e) {
    var r = e.pos;
    if (this.regexp_eatClassSetCharacter(e)) {
      var n = e.lastIntValue;
      if (e.eat(45) && this.regexp_eatClassSetCharacter(e)) {
        var i = e.lastIntValue;
        -1 !== n && -1 !== i && n > i && e.raise("Range out of order in character class");
        return !0;
      }
      e.pos = r;
    }
    return !1;
  };
  e4.regexp_eatClassSetOperand = function (e) {
    return this.regexp_eatClassSetCharacter(e) ? ta : this.regexp_eatClassStringDisjunction(e) || this.regexp_eatNestedClass(e);
  };
  e4.regexp_eatNestedClass = function (e) {
    var r = e.pos;
    if (e.eat(91)) {
      var n = e.eat(94);
      var i = this.regexp_classContents(e);
      if (e.eat(93)) {
        n && i === tl && e.raise("Negated character class may contain strings");
        return i;
      }
      e.pos = r;
    }
    if (e.eat(92)) {
      var s = this.regexp_eatCharacterClassEscape(e);
      if (s) return s;
      e.pos = r;
    }
    return null;
  };
  e4.regexp_eatClassStringDisjunction = function (e) {
    var r = e.pos;
    if (e.eatChars([92, 113])) {
      if (e.eat(123)) {
        var n = this.regexp_classStringDisjunctionContents(e);
        if (e.eat(125)) return n;
      } else e.raise("Invalid escape");
      e.pos = r;
    }
    return null;
  };
  e4.regexp_classStringDisjunctionContents = function (e) {
    for (var r = this.regexp_classString(e); e.eat(124);) this.regexp_classString(e) === tl && (r = tl);
    return r;
  };
  e4.regexp_classString = function (e) {
    for (var r = 0; this.regexp_eatClassSetCharacter(e);) r++;
    return 1 === r ? ta : tl;
  };
  e4.regexp_eatClassSetCharacter = function (e) {
    var r = e.pos;
    if (e.eat(92)) return !!(this.regexp_eatCharacterEscape(e) || this.regexp_eatClassSetReservedPunctuator(e)) || (e.eat(98) ? (e.lastIntValue = 8, !0) : (e.pos = r, !1));
    var n = e.current();
    return !(n < 0 || n === e.lookahead() && td(n) || tf(n)) && (e.advance(), e.lastIntValue = n, !0);
  };
  e4.regexp_eatClassSetReservedPunctuator = function (e) {
    var r = e.current();
    return !!tp(r) && (e.lastIntValue = r, e.advance(), !0);
  };
  e4.regexp_eatClassControlLetter = function (e) {
    var r = e.current();
    return (!!tg(r) || 95 === r) && (e.lastIntValue = r % 32, e.advance(), !0);
  };
  e4.regexp_eatHexEscapeSequence = function (e) {
    var r = e.pos;
    if (e.eat(120)) {
      if (this.regexp_eatFixedHexDigits(e, 2)) return !0;
      e.switchU && e.raise("Invalid escape");
      e.pos = r;
    }
    return !1;
  };
  e4.regexp_eatDecimalDigits = function (e) {
    var r = e.pos;
    var n = 0;
    for (e.lastIntValue = 0; tg(n = e.current());) {
      e.lastIntValue = 10 * e.lastIntValue + (n - 48);
      e.advance();
    }
    return e.pos !== r;
  };
  e4.regexp_eatHexDigits = function (e) {
    var r = e.pos;
    var n = 0;
    for (e.lastIntValue = 0; tm(n = e.current());) {
      e.lastIntValue = 16 * e.lastIntValue + tv(n);
      e.advance();
    }
    return e.pos !== r;
  };
  e4.regexp_eatLegacyOctalEscapeSequence = function (e) {
    if (this.regexp_eatOctalDigit(e)) {
      var r = e.lastIntValue;
      if (this.regexp_eatOctalDigit(e)) {
        var n = e.lastIntValue;
        r <= 3 && this.regexp_eatOctalDigit(e) ? e.lastIntValue = 64 * r + 8 * n + e.lastIntValue : e.lastIntValue = 8 * r + n;
      } else e.lastIntValue = r;
      return !0;
    }
    return !1;
  };
  e4.regexp_eatOctalDigit = function (e) {
    var r = e.current();
    return ty(r) ? (e.lastIntValue = r - 48, e.advance(), !0) : (e.lastIntValue = 0, !1);
  };
  e4.regexp_eatFixedHexDigits = function (e, r) {
    var n = e.pos;
    e.lastIntValue = 0;
    for (var i = 0; i < r; ++i) {
      var s = e.current();
      if (!tm(s)) {
        e.pos = n;
        return !1;
      }
      e.lastIntValue = 16 * e.lastIntValue + tv(s);
      e.advance();
    }
    return !0;
  };
  var tb = function (e) {
    this.type = e.type;
    this.value = e.value;
    this.start = e.start;
    this.end = e.end;
    e.options.locations && (this.loc = new U(e, e.startLoc, e.endLoc));
    e.options.ranges && (this.range = [e.start, e.end]);
  };
  var tO = ed.prototype;
  function tx(e, r) {
    return r ? parseInt(e, 8) : parseFloat(e.replace(/_/g, ""));
  }
  function tw(e) {
    return "function" != typeof BigInt ? null : BigInt(e.replace(/_/g, ""));
  }
  tO.next = function (e) {
    !e && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
    this.options.onToken && this.options.onToken(new tb(this));
    this.lastTokEnd = this.end;
    this.lastTokStart = this.start;
    this.lastTokEndLoc = this.endLoc;
    this.lastTokStartLoc = this.startLoc;
    this.nextToken();
  };
  tO.getToken = function () {
    this.next();
    return new tb(this);
  };
  "undefined" != typeof Symbol && (tO[Symbol.iterator] = function () {
    var e = this;
    return {
      next: function () {
        var r = e.getToken();
        return {
          done: r.type === S.eof,
          value: r
        };
      }
    };
  });
  tO.nextToken = function () {
    var e = this.curContext();
    return (e && e.preserveSpace || this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length) ? this.finishToken(S.eof) : e.override ? e.override(this) : void this.readToken(this.fullCharCodeAtPos());
  };
  tO.readToken = function (e) {
    return v(e, this.options.ecmaVersion >= 6) || 92 === e ? this.readWord() : this.getTokenFromCode(e);
  };
  tO.fullCharCodeAtPos = function () {
    var e = this.input.charCodeAt(this.pos);
    if (e <= 55295 || e >= 56320) return e;
    var r = this.input.charCodeAt(this.pos + 1);
    return r <= 56319 || r >= 57344 ? e : (e << 10) + r - 0x35fdc00;
  };
  tO.skipBlockComment = function () {
    var e = this.options.onComment && this.curPosition();
    var r = this.pos;
    var n = this.input.indexOf("*/", this.pos += 2);
    if (-1 === n && this.raise(this.pos - 2, "Unterminated comment"), this.pos = n + 2, this.options.locations) for (i = void 0, s = r, void 0; (i = T(this.input, s, this.pos)) > -1;) {
      var i;
      var s;
      ++this.curLine;
      s = this.lineStart = i;
    }
    this.options.onComment && this.options.onComment(!0, this.input.slice(r + 2, n), r, this.pos, e, this.curPosition());
  };
  tO.skipLineComment = function (e) {
    for (r = this.pos, n = this.options.onComment && this.curPosition(), i = this.input.charCodeAt(this.pos += e), void 0; this.pos < this.input.length && !C(i);) {
      var r;
      var n;
      var i;
      i = this.input.charCodeAt(++this.pos);
    }
    this.options.onComment && this.options.onComment(!1, this.input.slice(r + e, this.pos), r, this.pos, n, this.curPosition());
  };
  tO.skipSpace = function () {
    e: for (; this.pos < this.input.length;) {
      var e = this.input.charCodeAt(this.pos);
      switch (e) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          10 === this.input.charCodeAt(this.pos + 1) && ++this.pos;
        case 10:
        case 8232:
        case 8233:
          ++this.pos;
          this.options.locations && (++this.curLine, this.lineStart = this.pos);
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break e;
          }
          break;
        default:
          if (e > 8 && e < 14 || e >= 5760 && I.test(String.fromCharCode(e))) ++this.pos;else break e;
      }
    }
  };
  tO.finishToken = function (e, r) {
    this.end = this.pos;
    this.options.locations && (this.endLoc = this.curPosition());
    var n = this.type;
    this.type = e;
    this.value = r;
    this.updateContext(n);
  };
  tO.readToken_dot = function () {
    var e = this.input.charCodeAt(this.pos + 1);
    if (e >= 48 && e <= 57) return this.readNumber(!0);
    var r = this.input.charCodeAt(this.pos + 2);
    return this.options.ecmaVersion >= 6 && 46 === e && 46 === r ? (this.pos += 3, this.finishToken(S.ellipsis)) : (++this.pos, this.finishToken(S.dot));
  };
  tO.readToken_slash = function () {
    var e = this.input.charCodeAt(this.pos + 1);
    return this.exprAllowed ? (++this.pos, this.readRegexp()) : 61 === e ? this.finishOp(S.assign, 2) : this.finishOp(S.slash, 1);
  };
  tO.readToken_mult_modulo_exp = function (e) {
    var r = this.input.charCodeAt(this.pos + 1);
    var n = 1;
    var i = 42 === e ? S.star : S.modulo;
    return (this.options.ecmaVersion >= 7 && 42 === e && 42 === r && (++n, i = S.starstar, r = this.input.charCodeAt(this.pos + 2)), 61 === r) ? this.finishOp(S.assign, n + 1) : this.finishOp(i, n);
  };
  tO.readToken_pipe_amp = function (e) {
    var r = this.input.charCodeAt(this.pos + 1);
    return r === e ? this.options.ecmaVersion >= 12 && 61 === this.input.charCodeAt(this.pos + 2) ? this.finishOp(S.assign, 3) : this.finishOp(124 === e ? S.logicalOR : S.logicalAND, 2) : 61 === r ? this.finishOp(S.assign, 2) : this.finishOp(124 === e ? S.bitwiseOR : S.bitwiseAND, 1);
  };
  tO.readToken_caret = function () {
    return 61 === this.input.charCodeAt(this.pos + 1) ? this.finishOp(S.assign, 2) : this.finishOp(S.bitwiseXOR, 1);
  };
  tO.readToken_plus_min = function (e) {
    var r = this.input.charCodeAt(this.pos + 1);
    return r === e ? 45 === r && !this.inModule && 62 === this.input.charCodeAt(this.pos + 2) && (0 === this.lastTokEnd || E.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(S.incDec, 2) : 61 === r ? this.finishOp(S.assign, 2) : this.finishOp(S.plusMin, 1);
  };
  tO.readToken_lt_gt = function (e) {
    var r = this.input.charCodeAt(this.pos + 1);
    var n = 1;
    return r === e ? (n = 62 === e && 62 === this.input.charCodeAt(this.pos + 2) ? 3 : 2, 61 === this.input.charCodeAt(this.pos + n)) ? this.finishOp(S.assign, n + 1) : this.finishOp(S.bitShift, n) : 33 !== r || 60 !== e || this.inModule || 45 !== this.input.charCodeAt(this.pos + 2) || 45 !== this.input.charCodeAt(this.pos + 3) ? (61 === r && (n = 2), this.finishOp(S.relational, n)) : (this.skipLineComment(4), this.skipSpace(), this.nextToken());
  };
  tO.readToken_eq_excl = function (e) {
    var r = this.input.charCodeAt(this.pos + 1);
    return 61 === r ? this.finishOp(S.equality, 61 === this.input.charCodeAt(this.pos + 2) ? 3 : 2) : 61 === e && 62 === r && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(S.arrow)) : this.finishOp(61 === e ? S.eq : S.prefix, 1);
  };
  tO.readToken_question = function () {
    var e = this.options.ecmaVersion;
    if (e >= 11) {
      var r = this.input.charCodeAt(this.pos + 1);
      if (46 === r) {
        var n = this.input.charCodeAt(this.pos + 2);
        if (n < 48 || n > 57) return this.finishOp(S.questionDot, 2);
      }
      if (63 === r) return e >= 12 && 61 === this.input.charCodeAt(this.pos + 2) ? this.finishOp(S.assign, 3) : this.finishOp(S.coalesce, 2);
    }
    return this.finishOp(S.question, 1);
  };
  tO.readToken_numberSign = function () {
    var e = this.options.ecmaVersion;
    var r = 35;
    if (e >= 13 && (++this.pos, v(r = this.fullCharCodeAtPos(), !0) || 92 === r)) return this.finishToken(S.privateId, this.readWord1());
    this.raise(this.pos, "Unexpected character '" + z(r) + "'");
  };
  tO.getTokenFromCode = function (e) {
    switch (e) {
      case 46:
        return this.readToken_dot();
      case 40:
        ++this.pos;
        return this.finishToken(S.parenL);
      case 41:
        ++this.pos;
        return this.finishToken(S.parenR);
      case 59:
        ++this.pos;
        return this.finishToken(S.semi);
      case 44:
        ++this.pos;
        return this.finishToken(S.comma);
      case 91:
        ++this.pos;
        return this.finishToken(S.bracketL);
      case 93:
        ++this.pos;
        return this.finishToken(S.bracketR);
      case 123:
        ++this.pos;
        return this.finishToken(S.braceL);
      case 125:
        ++this.pos;
        return this.finishToken(S.braceR);
      case 58:
        ++this.pos;
        return this.finishToken(S.colon);
      case 96:
        if (this.options.ecmaVersion < 6) break;
        ++this.pos;
        return this.finishToken(S.backQuote);
      case 48:
        var r = this.input.charCodeAt(this.pos + 1);
        if (120 === r || 88 === r) return this.readRadixNumber(16);
        if (this.options.ecmaVersion >= 6) {
          if (111 === r || 79 === r) return this.readRadixNumber(8);
          if (98 === r || 66 === r) return this.readRadixNumber(2);
        }
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return this.readNumber(!1);
      case 34:
      case 39:
        return this.readString(e);
      case 47:
        return this.readToken_slash();
      case 37:
      case 42:
        return this.readToken_mult_modulo_exp(e);
      case 124:
      case 38:
        return this.readToken_pipe_amp(e);
      case 94:
        return this.readToken_caret();
      case 43:
      case 45:
        return this.readToken_plus_min(e);
      case 60:
      case 62:
        return this.readToken_lt_gt(e);
      case 61:
      case 33:
        return this.readToken_eq_excl(e);
      case 63:
        return this.readToken_question();
      case 126:
        return this.finishOp(S.prefix, 1);
      case 35:
        return this.readToken_numberSign();
    }
    this.raise(this.pos, "Unexpected character '" + z(e) + "'");
  };
  tO.finishOp = function (e, r) {
    var n = this.input.slice(this.pos, this.pos + r);
    this.pos += r;
    return this.finishToken(e, n);
  };
  tO.readRegexp = function () {
    for (n = this.pos, void 0;;) {
      var e;
      var r;
      var n;
      this.pos >= this.input.length && this.raise(n, "Unterminated regular expression");
      var i = this.input.charAt(this.pos);
      if (E.test(i) && this.raise(n, "Unterminated regular expression"), e) e = !1;else {
        if ("[" === i) r = !0;else if ("]" === i && r) r = !1;else if ("/" === i && !r) break;
        e = "\\" === i;
      }
      ++this.pos;
    }
    var s = this.input.slice(n, this.pos);
    ++this.pos;
    var o = this.pos;
    var a = this.readWord1();
    this.containsEsc && this.unexpected(o);
    var h = this.regexpState || (this.regexpState = new e7(this));
    h.reset(n, s, a);
    this.validateRegExpFlags(h);
    this.validateRegExpPattern(h);
    var d = null;
    try {
      d = new RegExp(s, a);
    } catch (e) {}
    return this.finishToken(S.regexp, {
      pattern: s,
      flags: a,
      value: d
    });
  };
  tO.readInt = function (e, r, n) {
    for (i = this.options.ecmaVersion >= 12 && void 0 === r, s = n && 48 === this.input.charCodeAt(this.pos), o = this.pos, a = 0, h = 0, d = 0, p = r, void 0; d < p; ++d, ++this.pos) {
      var i;
      var s;
      var o;
      var a;
      var h;
      var d;
      var p;
      var g = this.input.charCodeAt(this.pos);
      var m = void 0;
      if (i && 95 === g) {
        s && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
        95 === h && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
        0 === d && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
        h = g;
        continue;
      }
      if ((m = g >= 97 ? g - 97 + 10 : g >= 65 ? g - 65 + 10 : g >= 48 && g <= 57 ? g - 48 : 1 / 0) >= e) break;
      h = g;
      a = a * e + m;
    }
    return (i && 95 === h && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === o || null != r && this.pos - o !== r) ? null : a;
  };
  tO.readRadixNumber = function (e) {
    var r = this.pos;
    this.pos += 2;
    var n = this.readInt(e);
    null == n && this.raise(this.start + 2, "Expected number in radix " + e);
    this.options.ecmaVersion >= 11 && 110 === this.input.charCodeAt(this.pos) ? (n = tw(this.input.slice(r, this.pos)), ++this.pos) : v(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
    return this.finishToken(S.num, n);
  };
  tO.readNumber = function (e) {
    var r = this.pos;
    e || null !== this.readInt(10, void 0, !0) || this.raise(r, "Invalid number");
    var n = this.pos - r >= 2 && 48 === this.input.charCodeAt(r);
    n && this.strict && this.raise(r, "Invalid number");
    var i = this.input.charCodeAt(this.pos);
    if (!n && !e && this.options.ecmaVersion >= 11 && 110 === i) {
      var s = tw(this.input.slice(r, this.pos));
      ++this.pos;
      v(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
      return this.finishToken(S.num, s);
    }
    n && /[89]/.test(this.input.slice(r, this.pos)) && (n = !1);
    46 !== i || n || (++this.pos, this.readInt(10), i = this.input.charCodeAt(this.pos));
    69 !== i && 101 !== i || n || ((43 === (i = this.input.charCodeAt(++this.pos)) || 45 === i) && ++this.pos, null === this.readInt(10) && this.raise(r, "Invalid number"));
    v(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
    var o = tx(this.input.slice(r, this.pos), n);
    return this.finishToken(S.num, o);
  };
  tO.readCodePoint = function () {
    var e;
    if (123 === this.input.charCodeAt(this.pos)) {
      this.options.ecmaVersion < 6 && this.unexpected();
      var r = ++this.pos;
      e = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
      ++this.pos;
      e > 1114111 && this.invalidStringToken(r, "Code point out of bounds");
    } else e = this.readHexChar(4);
    return e;
  };
  tO.readString = function (e) {
    for (r = "", n = ++this.pos, void 0;;) {
      var r;
      var n;
      this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
      var i = this.input.charCodeAt(this.pos);
      if (i === e) break;
      92 === i ? (r += this.input.slice(n, this.pos), r += this.readEscapedChar(!1), n = this.pos) : 8232 === i || 8233 === i ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (C(i) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
    }
    r += this.input.slice(n, this.pos++);
    return this.finishToken(S.string, r);
  };
  var tk = {};
  tO.tryReadTemplateToken = function () {
    this.inTemplateElement = !0;
    try {
      this.readTmplToken();
    } catch (e) {
      if (e === tk) this.readInvalidTemplateToken();else throw e;
    }
    this.inTemplateElement = !1;
  };
  tO.invalidStringToken = function (e, r) {
    if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw tk;
    this.raise(e, r);
  };
  tO.readTmplToken = function () {
    for (e = "", r = this.pos, void 0;;) {
      var e;
      var r;
      this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
      var n = this.input.charCodeAt(this.pos);
      if (96 === n || 36 === n && 123 === this.input.charCodeAt(this.pos + 1)) {
        if (this.pos === this.start && (this.type === S.template || this.type === S.invalidTemplate)) {
          if (36 === n) {
            this.pos += 2;
            return this.finishToken(S.dollarBraceL);
          }
          ++this.pos;
          return this.finishToken(S.backQuote);
        }
        e += this.input.slice(r, this.pos);
        return this.finishToken(S.template, e);
      }
      if (92 === n) {
        e += this.input.slice(r, this.pos);
        e += this.readEscapedChar(!0);
        r = this.pos;
      } else if (C(n)) {
        switch (e += this.input.slice(r, this.pos), ++this.pos, n) {
          case 13:
            10 === this.input.charCodeAt(this.pos) && ++this.pos;
          case 10:
            e += "\n";
            break;
          default:
            e += String.fromCharCode(n);
        }
        this.options.locations && (++this.curLine, this.lineStart = this.pos);
        r = this.pos;
      } else ++this.pos;
    }
  };
  tO.readInvalidTemplateToken = function () {
    for (; this.pos < this.input.length; this.pos++) switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if ("{" !== this.input[this.pos + 1]) break;
      case "`":
        return this.finishToken(S.invalidTemplate, this.input.slice(this.start, this.pos));
      case "\r":
        "\n" === this.input[this.pos + 1] && ++this.pos;
      case "\n":
      case "\u2028":
      case "\u2029":
        ++this.curLine;
        this.lineStart = this.pos + 1;
    }
    this.raise(this.start, "Unterminated template");
  };
  tO.readEscapedChar = function (e) {
    var r = this.input.charCodeAt(++this.pos);
    switch (++this.pos, r) {
      case 110:
        return "\n";
      case 114:
        return "\r";
      case 120:
        return String.fromCharCode(this.readHexChar(2));
      case 117:
        return z(this.readCodePoint());
      case 116:
        return "	";
      case 98:
        return "\b";
      case 118:
        return "\v";
      case 102:
        return "\f";
      case 13:
        10 === this.input.charCodeAt(this.pos) && ++this.pos;
      case 10:
        this.options.locations && (this.lineStart = this.pos, ++this.curLine);
        return "";
      case 56:
      case 57:
        if (this.strict && this.invalidStringToken(this.pos - 1, "Invalid escape sequence"), e) {
          var n = this.pos - 1;
          this.invalidStringToken(n, "Invalid escape sequence in template string");
        }
      default:
        if (r >= 48 && r <= 55) {
          var i = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
          var s = parseInt(i, 8);
          s > 255 && (s = parseInt(i = i.slice(0, -1), 8));
          this.pos += i.length - 1;
          r = this.input.charCodeAt(this.pos);
          ("0" !== i || 56 === r || 57 === r) && (this.strict || e) && this.invalidStringToken(this.pos - 1 - i.length, e ? "Octal literal in template string" : "Octal literal in strict mode");
          return String.fromCharCode(s);
        }
        if (C(r)) {
          this.options.locations && (this.lineStart = this.pos, ++this.curLine);
          return "";
        }
        return String.fromCharCode(r);
    }
  };
  tO.readHexChar = function (e) {
    var r = this.pos;
    var n = this.readInt(16, e);
    null === n && this.invalidStringToken(r, "Bad character escape sequence");
    return n;
  };
  tO.readWord1 = function () {
    this.containsEsc = !1;
    for (e = "", r = !0, n = this.pos, i = this.options.ecmaVersion >= 6, void 0; this.pos < this.input.length;) {
      var e;
      var r;
      var n;
      var i;
      var s = this.fullCharCodeAtPos();
      if (y(s, i)) this.pos += s <= 65535 ? 1 : 2;else if (92 === s) {
        this.containsEsc = !0;
        e += this.input.slice(n, this.pos);
        var o = this.pos;
        117 !== this.input.charCodeAt(++this.pos) && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
        ++this.pos;
        var a = this.readCodePoint();
        (r ? v : y)(a, i) || this.invalidStringToken(o, "Invalid Unicode escape");
        e += z(a);
        n = this.pos;
      } else break;
      r = !1;
    }
    return e + this.input.slice(n, this.pos);
  };
  tO.readWord = function () {
    var e = this.readWord1();
    var r = S.name;
    this.keywords.test(e) && (r = k[e]);
    return this.finishToken(r, e);
  };
  var t_ = "8.15.0";
  function tS(e, r) {
    return ed.parse(e, r);
  }
  function tE(e, r, n) {
    return ed.parseExpressionAt(e, r, n);
  }
  function tA(e, r) {
    return ed.tokenizer(e, r);
  }
  ed.acorn = {
    Parser: ed,
    version: t_,
    defaultOptions: V,
    Position: F,
    SourceLocation: U,
    getLineInfo: Q,
    Node: eL,
    TokenType: b,
    tokTypes: S,
    keywordTypes: k,
    TokContext: eA,
    tokContexts: eC,
    isIdentifierChar: y,
    isIdentifierStart: v,
    Token: tb,
    isNewLine: C,
    lineBreak: E,
    lineBreakG: A,
    nonASCIIwhitespace: I
  };
  e.Node = eL;
  e.Parser = ed;
  e.Position = F;
  e.SourceLocation = U;
  e.TokContext = eA;
  e.Token = tb;
  e.TokenType = b;
  e.defaultOptions = V;
  e.getLineInfo = Q;
  e.isIdentifierChar = y;
  e.isIdentifierStart = v;
  e.isNewLine = C;
  e.keywordTypes = k;
  e.lineBreak = E;
  e.lineBreakG = A;
  e.nonASCIIwhitespace = I;
  e.parse = tS;
  e.parseExpressionAt = tE;
  e.tokContexts = eC;
  e.tokTypes = S;
  e.tokenizer = tA;
  e.version = t_;
});