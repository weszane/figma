var t;
t = function () {
  return (() => {
    "use strict";

    var e;
    var t = [, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.WorkerTask = t.WorkerMessageHandler = void 0;
      var r;
      var i = a(2);
      var n = a(5);
      var s = a(6);
      var o = a(66);
      var l = a(72);
      var c = a(4);
      var h = a(100);
      var u = a(101);
      var d = a(8);
      class f {
        constructor(e) {
          this.name = e;
          this.terminated = !1;
          this._capability = i.createPromiseCapability();
        }
        get finished() {
          return this._capability.promise;
        }
        finish() {
          this._capability.resolve();
        }
        terminate() {
          this.terminated = !0;
        }
        ensureNotTerminated() {
          if (this.terminated) throw Error("Worker task was terminated");
        }
      }
      t.WorkerTask = f;
      class g {
        static setup(e, t) {
          let a = !1;
          e.on("test", function (t) {
            a || (a = !0, e.send("test", t instanceof Uint8Array && 255 === t[0]));
          });
          e.on("configure", function (e) {
            i.setVerbosityLevel(e.verbosity);
          });
          e.on("GetDocRequest", function (e) {
            return g.createDocumentHandler(e, t);
          });
        }
        static createDocumentHandler(e, t) {
          let a;
          let r = !1;
          let g = null;
          let p = [];
          let m = i.getVerbosityLevel();
          let b = e.apiVersion;
          let y = "2.13.216";
          if (b !== y) throw Error(`The API version "${b}" does not match the Worker version "${y}".`);
          let w = [];
          for (let e in []) w.push(e);
          if (w.length) throw Error("The `Array.prototype` contains unexpected enumerable properties: " + w.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
          if ("undefined" == typeof ReadableStream) {
            let e = "The browser/environment lacks native support for critical functionality used by the PDF.js library (e.g. `ReadableStream`); ";
            if (c.isNodeJS) throw Error(e + "please use a `legacy`-build instead.");
            throw Error(e + "please update to a supported browser.");
          }
          let x = e.docId;
          let S = e.docBaseUrl;
          let k = e.docId + "_worker";
          let A = new h.MessageHandler(k, x, t);
          function v() {
            if (r) throw Error("Worker was terminated");
          }
          function C(e) {
            p.push(e);
          }
          function O(e) {
            e.finish();
            let t = p.indexOf(e);
            p.splice(t, 1);
          }
          async function F(e) {
            await a.ensureDoc("checkHeader");
            await a.ensureDoc("parseStartXRef");
            await a.ensureDoc("parse", [e]);
            await a.ensureDoc("checkFirstPage", [e]);
            await a.ensureDoc("checkLastPage", [e]);
            let t = await a.ensureDoc("isPureXfa");
            if (t) {
              let e = new f("loadXfaFonts");
              C(e);
              await Promise.all([a.loadXfaFonts(A, e).catch(e => { }).then(() => O(e)), a.loadXfaImages()]);
            }
            let [r, i] = await Promise.all([a.ensureDoc("numPages"), a.ensureDoc("fingerprints")]);
            return {
              numPages: r,
              fingerprints: i,
              htmlForXfa: t ? await a.ensureDoc("htmlForXfa") : null
            };
          }
          A.on("GetPage", function (e) {
            return a.getPage(e.pageIndex).then(function (e) {
              return Promise.all([a.ensure(e, "rotate"), a.ensure(e, "ref"), a.ensure(e, "userUnit"), a.ensure(e, "view")]).then(function ([e, t, a, r]) {
                return {
                  rotate: e,
                  ref: t,
                  userUnit: a,
                  view: r
                };
              });
            });
          });
          A.on("GetPageIndex", function (e) {
            let t = n.Ref.get(e.num, e.gen);
            return a.ensureCatalog("getPageIndex", [t]);
          });
          A.on("GetDestinations", function (e) {
            return a.ensureCatalog("destinations");
          });
          A.on("GetDestination", function (e) {
            return a.ensureCatalog("getDestination", [e.id]);
          });
          A.on("GetPageLabels", function (e) {
            return a.ensureCatalog("pageLabels");
          });
          A.on("GetPageLayout", function (e) {
            return a.ensureCatalog("pageLayout");
          });
          A.on("GetPageMode", function (e) {
            return a.ensureCatalog("pageMode");
          });
          A.on("GetViewerPreferences", function (e) {
            return a.ensureCatalog("viewerPreferences");
          });
          A.on("GetOpenAction", function (e) {
            return a.ensureCatalog("openAction");
          });
          A.on("GetAttachments", function (e) {
            return a.ensureCatalog("attachments");
          });
          A.on("GetJavaScript", function (e) {
            return a.ensureCatalog("javaScript");
          });
          A.on("GetDocJSActions", function (e) {
            return a.ensureCatalog("jsActions");
          });
          A.on("GetPageJSActions", function ({
            pageIndex: e
          }) {
            return a.getPage(e).then(function (e) {
              return a.ensure(e, "jsActions");
            });
          });
          A.on("GetOutline", function (e) {
            return a.ensureCatalog("documentOutline");
          });
          A.on("GetOptionalContentConfig", function (e) {
            return a.ensureCatalog("optionalContentConfig");
          });
          A.on("GetPermissions", function (e) {
            return a.ensureCatalog("permissions");
          });
          A.on("GetMetadata", function (e) {
            return Promise.all([a.ensureDoc("documentInfo"), a.ensureCatalog("metadata")]);
          });
          A.on("GetMarkInfo", function (e) {
            return a.ensureCatalog("markInfo");
          });
          A.on("GetData", function (e) {
            a.requestLoadedStream();
            return a.onLoadedStream().then(function (e) {
              return e.bytes;
            });
          });
          A.on("GetAnnotations", function ({
            pageIndex: e,
            intent: t
          }) {
            return a.getPage(e).then(function (e) {
              return e.getAnnotationsData(t);
            });
          });
          A.on("GetFieldObjects", function (e) {
            return a.ensureDoc("fieldObjects");
          });
          A.on("HasJSActions", function (e) {
            return a.ensureDoc("hasJSActions");
          });
          A.on("GetCalculationOrderIds", function (e) {
            return a.ensureDoc("calculationOrderIds");
          });
          A.on("SaveDocument", function ({
            isPureXfa: e,
            numPages: t,
            annotationStorage: r,
            filename: s
          }) {
            a.requestLoadedStream();
            let o = [a.onLoadedStream(), a.ensureCatalog("acroForm"), a.ensureCatalog("acroFormRef"), a.ensureDoc("xref"), a.ensureDoc("startXRef")];
            if (e) o.push(a.serializeXfaData(r)); else for (let e = 0; e < t; e++) o.push(a.getPage(e).then(function (t) {
              let a = new f(`Save: page ${e}`);
              return t.save(A, a, r).finally(function () {
                O(a);
              });
            }));
            return Promise.all(o).then(function ([t, a, r, o, c, ...h]) {
              let u = [];
              let d = null;
              if (e) {
                if (!(d = h[0])) return t.bytes;
              } else {
                for (let e of h) u = e.filter(e => null !== e).reduce((e, t) => e.concat(t), u);
                if (0 === u.length) return t.bytes;
              }
              let f = a instanceof n.Dict && a.get("XFA") || null;
              let g = null;
              let p = !1;
              if (Array.isArray(f)) {
                for (function () {
                  let e = 0;
                  let t = f.length;
                }(); e < t; e += 2) "datasets" === f[e] && (g = f[e + 1], r = null, p = !0);
                null === g && (g = o.getNewRef());
              } else f && (r = null, i.warn("Unsupported XFA type."));
              let m = Object.create(null);
              if (o.trailer) {
                let e = Object.create(null);
                let t = o.trailer.get("Info") || null;
                t instanceof n.Dict && t.forEach((t, a) => {
                  "string" == typeof a && (e[t] = i.stringToPDFString(a));
                });
                m = {
                  rootRef: o.trailer.getRaw("Root") || null,
                  encryptRef: o.trailer.getRaw("Encrypt") || null,
                  newRef: o.getNewRef(),
                  infoRef: o.trailer.getRaw("Info") || null,
                  info: e,
                  fileIds: o.trailer.get("ID") || null,
                  startXRef: c,
                  filename: s
                };
              }
              o.resetNewRef();
              return l.incrementalUpdate({
                originalData: t.bytes,
                xrefInfo: m,
                newRefs: u,
                xref: o,
                hasXfa: !!f,
                xfaDatasetsRef: g,
                hasXfaDatasetsEntry: p,
                acroFormRef: r,
                acroForm: a,
                xfaData: d
              });
            });
          });
          A.on("GetOperatorList", function (e, t) {
            let r = e.pageIndex;
            a.getPage(r).then(function (a) {
              let n = new f(`GetOperatorList: page ${r}`);
              C(n);
              let s = m >= i.VerbosityLevel.INFOS ? Date.now() : 0;
              a.getOperatorList({
                handler: A,
                sink: t,
                task: n,
                intent: e.intent,
                cacheKey: e.cacheKey,
                annotationStorage: e.annotationStorage
              }).then(function (e) {
                O(n);
                s && i.info(`page=${r + 1} - getOperatorList: time=${Date.now() - s}ms, len=${e.length}`);
                t.close();
              }, function (e) {
                O(n);
                n.terminated || (A.send("UnsupportedFeature", {
                  featureId: i.UNSUPPORTED_FEATURES.errorOperatorList
                }), t.error(e));
              });
            });
          });
          A.on("GetTextContent", function (e, t) {
            let r = e.pageIndex;
            a.getPage(r).then(function (a) {
              let n = new f("GetTextContent: page " + r);
              C(n);
              let s = m >= i.VerbosityLevel.INFOS ? Date.now() : 0;
              a.extractTextContent({
                handler: A,
                task: n,
                sink: t,
                includeMarkedContent: e.includeMarkedContent,
                combineTextItems: e.combineTextItems
              }).then(function () {
                O(n);
                s && i.info(`page=${r + 1} - getTextContent: time=${Date.now() - s}ms`);
                t.close();
              }, function (e) {
                O(n);
                n.terminated || t.error(e);
              });
            });
          });
          A.on("GetStructTree", function (e) {
            return a.getPage(e.pageIndex).then(function (e) {
              return a.ensure(e, "getStructTree");
            });
          });
          A.on("FontFallback", function (e) {
            return a.fontFallback(e.id, A);
          });
          A.on("Cleanup", function (e) {
            return a.cleanup(!0);
          });
          A.on("Terminate", function (e) {
            r = !0;
            let t = [];
            if (a) {
              a.terminate(new i.AbortException("Worker was terminated."));
              let e = a.cleanup();
              t.push(e);
              a = null;
            } else o.clearGlobalCaches();
            for (let e of (g && g(new i.AbortException("Worker was terminated.")), p)) {
              t.push(e.finished);
              e.terminate();
            }
            return Promise.all(t).then(function () {
              A.destroy();
              A = null;
            });
          });
          A.on("Ready", function (t) {
            (function (e) {
              function t(e) {
                v();
                A.send("GetDoc", {
                  pdfInfo: e
                });
              }
              function n(e) {
                if (v(), e instanceof i.PasswordException) {
                  let t = new f(`PasswordException: response ${e.code}`);
                  C(t);
                  A.sendWithPromise("PasswordRequest", e).then(function ({
                    password: e
                  }) {
                    O(t);
                    a.updatePassword(e);
                    o();
                  }).catch(function () {
                    O(t);
                    A.send("DocException", e);
                  });
                } else e instanceof i.InvalidPDFException || e instanceof i.MissingPDFException || e instanceof i.UnexpectedResponseException || e instanceof i.UnknownErrorException ? A.send("DocException", e) : A.send("DocException", new i.UnknownErrorException(e.message, e.toString()));
              }
              function o() {
                v();
                F(!1).then(t, function (e) {
                  if (v(), !(e instanceof d.XRefParseException)) {
                    n(e);
                    return;
                  }
                  a.requestLoadedStream();
                  a.onLoadedStream().then(function () {
                    v();
                    F(!0).then(t, n);
                  });
                });
              }
              v();
              let l = {
                maxImageSize: e.maxImageSize,
                disableFontFace: e.disableFontFace,
                ignoreErrors: e.ignoreErrors,
                isEvalSupported: e.isEvalSupported,
                fontExtraProperties: e.fontExtraProperties,
                useSystemFonts: e.useSystemFonts,
                cMapUrl: e.cMapUrl,
                standardFontDataUrl: e.standardFontDataUrl
              };
              (function (e, t, a) {
                let r;
                let n = i.createPromiseCapability();
                let o = e.source;
                if (o.data) {
                  try {
                    r = new s.LocalPdfManager(x, o.data, o.password, A, t, a, S);
                    n.resolve(r);
                  } catch (e) {
                    n.reject(e);
                  }
                  return n.promise;
                }
                let l;
                let c = [];
                try {
                  l = new u.PDFWorkerStream(A);
                } catch (e) {
                  n.reject(e);
                  return n.promise;
                }
                let h = l.getFullReader();
                h.headersReady.then(function () {
                  if (!h.isRangeSupported) return;
                  let e = o.disableAutoFetch || h.isStreamingSupported;
                  r = new s.NetworkPdfManager(x, l, {
                    msgHandler: A,
                    password: o.password,
                    length: h.contentLength,
                    disableAutoFetch: e,
                    rangeChunkSize: o.rangeChunkSize
                  }, t, a, S);
                  for (let e = 0; e < c.length; e++) r.sendProgressiveData(c[e]);
                  c = [];
                  n.resolve(r);
                  g = null;
                }).catch(function (e) {
                  n.reject(e);
                  g = null;
                });
                let d = 0;
                let f = function () {
                  let e = i.arraysToBytes(c);
                  o.length && e.length !== o.length && i.warn("reported HTTP length is different from actual");
                  try {
                    r = new s.LocalPdfManager(x, e, o.password, A, t, a, S);
                    n.resolve(r);
                  } catch (e) {
                    n.reject(e);
                  }
                  c = [];
                };
                new Promise(function (e, t) {
                  let a = function ({
                    value: e,
                    done: n
                  }) {
                    try {
                      if (v(), n) {
                        r || f();
                        g = null;
                        return;
                      }
                      d += i.arrayByteLength(e);
                      h.isStreamingSupported || A.send("DocProgress", {
                        loaded: d,
                        total: Math.max(d, h.contentLength || 0)
                      });
                      r ? r.sendProgressiveData(e) : c.push(e);
                      h.read().then(a, t);
                    } catch (e) {
                      t(e);
                    }
                  };
                  h.read().then(a, t);
                }).catch(function (e) {
                  n.reject(e);
                  g = null;
                });
                g = function (e) {
                  l.cancelAllRequests(e);
                };
                return n.promise;
              })(e, l, e.enableXfa).then(function (e) {
                if (r) {
                  e.terminate(new i.AbortException("Worker was terminated."));
                  return Error("Worker was terminated");
                }
                (a = e).onLoadedStream().then(function (e) {
                  A.send("DataLoaded", {
                    length: e.bytes.byteLength
                  });
                });
              }).then(o, n);
            })(e);
            e = null;
          });
          return k;
        }
        static initializeFromPort(e) {
          let t = new h.MessageHandler("worker", "main", e);
          g.setup(t, e);
          t.send("ready", null);
        }
      }
      t.WorkerMessageHandler = g;
      "undefined" == typeof window && !c.isNodeJS && "undefined" != typeof self && "function" == typeof (r = self).postMessage && "onmessage" in r && g.initializeFromPort(self);
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.VerbosityLevel = t.Util = t.UnknownErrorException = t.UnexpectedResponseException = t.UNSUPPORTED_FEATURES = t.TextRenderingMode = t.StreamType = t.RenderingIntentFlag = t.PermissionFlag = t.PasswordResponses = t.PasswordException = t.PageActionEventType = t.OPS = t.MissingPDFException = t.IsLittleEndianCached = t.IsEvalSupportedCached = t.InvalidPDFException = t.ImageKind = t.IDENTITY_MATRIX = t.FormatError = t.FontType = t.FONT_IDENTITY_MATRIX = t.DocumentActionEventType = t.CMapCompressionType = t.BaseException = t.AnnotationType = t.AnnotationStateModelType = t.AnnotationReviewState = t.AnnotationReplyType = t.AnnotationMode = t.AnnotationMarkedState = t.AnnotationFlag = t.AnnotationFieldFlag = t.AnnotationBorderStyleType = t.AnnotationActionEventType = t.AbortException = void 0;
      t.arrayByteLength = h;
      t.arraysToBytes = function (e) {
        let t = e.length;
        if (1 === t && e[0] instanceof Uint8Array) return e[0];
        let a = 0;
        for (let r = 0; r < t; r++) a += h(e[r]);
        let r = 0;
        let i = new Uint8Array(a);
        for (let a = 0; a < t; a++) {
          let t = e[a];
          t instanceof Uint8Array || (t = "string" == typeof t ? c(t) : new Uint8Array(t));
          let n = t.byteLength;
          i.set(t, r);
          r += n;
        }
        return i;
      };
      t.assert = function (e, t) {
        e || s(t);
      };
      t.bytesToString = function (e) {
        ("object" != typeof e || null === e || void 0 === e.length) && s("Invalid argument for bytesToString");
        let t = e.length;
        if (t < 8192) return String.fromCharCode.apply(null, e);
        let a = [];
        for (let r = 0; r < t; r += 8192) {
          let i = Math.min(r + 8192, t);
          let n = e.subarray(r, i);
          a.push(String.fromCharCode.apply(null, n));
        }
        return a.join("");
      };
      t.createPromiseCapability = function () {
        let e = Object.create(null);
        let t = !1;
        Object.defineProperty(e, "settled", {
          get: () => t
        });
        e.promise = new Promise(function (a, r) {
          e.resolve = function (e) {
            t = !0;
            a(e);
          };
          e.reject = function (e) {
            t = !0;
            r(e);
          };
        });
        return e;
      };
      t.createValidAbsoluteUrl = function (e, t = null, a = null) {
        if (!e) return null;
        try {
          if (a && "string" == typeof e) {
            if (a.addDefaultProtocol && e.startsWith("www.")) {
              let t = e.match(/\./g);
              t && t.length >= 2 && (e = `http://${e}`);
            }
            if (a.tryConvertEncoding) try {
              e = g(e);
            } catch (e) { }
          }
          let r = t ? new URL(e, t) : new URL(e);
          if (function (e) {
            if (!e) return !1;
            switch (e.protocol) {
              case "http:":
              case "https:":
              case "ftp:":
              case "mailto:":
              case "tel:":
                return !0;
              default:
                return !1;
            }
          }(r)) return r;
        } catch (e) { }
        return null;
      };
      t.escapeString = function (e) {
        return e.replace(/([()\\\n\r])/g, e => "\n" === e ? "\\n" : "\r" === e ? "\\r" : `\\${e}`);
      };
      t.getModificationDate = function (e = new Date()) {
        return [e.getUTCFullYear().toString(), (e.getUTCMonth() + 1).toString().padStart(2, "0"), e.getUTCDate().toString().padStart(2, "0"), e.getUTCHours().toString().padStart(2, "0"), e.getUTCMinutes().toString().padStart(2, "0"), e.getUTCSeconds().toString().padStart(2, "0")].join("");
      };
      t.getVerbosityLevel = function () {
        return i;
      };
      t.info = function (e) {
        i >= r.INFOS && console.log(`Info: ${e}`);
      };
      t.isArrayBuffer = function (e) {
        return "object" == typeof e && null !== e && void 0 !== e.byteLength;
      };
      t.isArrayEqual = function (e, t) {
        if (e.length !== t.length) return !1;
        for (function () {
          let a = 0;
          let r = e.length;
        }(); a < r; a++) if (e[a] !== t[a]) return !1;
        return !0;
      };
      t.isAscii = function (e) {
        return /^[\x00-\x7F]*$/.test(e);
      };
      t.isSameOrigin = function (e, t) {
        let a;
        try {
          if (!(a = new URL(e)).origin || "null" === a.origin) return !1;
        } catch (e) {
          return !1;
        }
        let r = new URL(t, a);
        return a.origin === r.origin;
      };
      t.objectFromMap = function (e) {
        let t = Object.create(null);
        for (let [a, r] of e) t[a] = r;
        return t;
      };
      t.objectSize = function (e) {
        return Object.keys(e).length;
      };
      t.setVerbosityLevel = function (e) {
        Number.isInteger(e) && (i = e);
      };
      t.shadow = o;
      t.string32 = function (e) {
        return String.fromCharCode(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e);
      };
      t.stringToBytes = c;
      t.stringToPDFString = function (e) {
        if (e[0] >= "\xef") {
          let t;
          if ("\xfe" === e[0] && "\xff" === e[1] ? t = "utf-16be" : "\xff" === e[0] && "\xfe" === e[1] ? t = "utf-16le" : "\xef" === e[0] && "\xbb" === e[1] && "\xbf" === e[2] && (t = "utf-8"), t) try {
            let a = new TextDecoder(t, {
              fatal: !0
            });
            let r = c(e);
            return a.decode(r);
          } catch (e) {
            n(`stringToPDFString: "${e}".`);
          }
        }
        let t = [];
        for (function () {
          let a = 0;
          let r = e.length;
        }(); a < r; a++) {
          let r = f[e.charCodeAt(a)];
          t.push(r ? String.fromCharCode(r) : e.charAt(a));
        }
        return t.join("");
      };
      t.stringToUTF16BEString = function (e) {
        let t = ["\xfe\xff"];
        for (function () {
          let a = 0;
          let r = e.length;
        }(); a < r; a++) {
          let r = e.charCodeAt(a);
          t.push(String.fromCharCode(r >> 8 & 255), String.fromCharCode(255 & r));
        }
        return t.join("");
      };
      t.stringToUTF8String = g;
      t.unreachable = s;
      t.utf8StringToString = function (e) {
        return unescape(encodeURIComponent(e));
      };
      t.warn = n;
      a(3);
      t.IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
      t.FONT_IDENTITY_MATRIX = [.001, 0, 0, .001, 0, 0];
      t.RenderingIntentFlag = {
        ANY: 1,
        DISPLAY: 2,
        PRINT: 4,
        ANNOTATIONS_FORMS: 16,
        ANNOTATIONS_STORAGE: 32,
        ANNOTATIONS_DISABLE: 64,
        OPLIST: 256
      };
      t.AnnotationMode = {
        DISABLE: 0,
        ENABLE: 1,
        ENABLE_FORMS: 2,
        ENABLE_STORAGE: 3
      };
      t.PermissionFlag = {
        PRINT: 4,
        MODIFY_CONTENTS: 8,
        COPY: 16,
        MODIFY_ANNOTATIONS: 32,
        FILL_INTERACTIVE_FORMS: 256,
        COPY_FOR_ACCESSIBILITY: 512,
        ASSEMBLE: 1024,
        PRINT_HIGH_QUALITY: 2048
      };
      t.TextRenderingMode = {
        FILL: 0,
        STROKE: 1,
        FILL_STROKE: 2,
        INVISIBLE: 3,
        FILL_ADD_TO_PATH: 4,
        STROKE_ADD_TO_PATH: 5,
        FILL_STROKE_ADD_TO_PATH: 6,
        ADD_TO_PATH: 7,
        FILL_STROKE_MASK: 3,
        ADD_TO_PATH_FLAG: 4
      };
      t.ImageKind = {
        GRAYSCALE_1BPP: 1,
        RGB_24BPP: 2,
        RGBA_32BPP: 3
      };
      t.AnnotationType = {
        TEXT: 1,
        LINK: 2,
        FREETEXT: 3,
        LINE: 4,
        SQUARE: 5,
        CIRCLE: 6,
        POLYGON: 7,
        POLYLINE: 8,
        HIGHLIGHT: 9,
        UNDERLINE: 10,
        SQUIGGLY: 11,
        STRIKEOUT: 12,
        STAMP: 13,
        CARET: 14,
        INK: 15,
        POPUP: 16,
        FILEATTACHMENT: 17,
        SOUND: 18,
        MOVIE: 19,
        WIDGET: 20,
        SCREEN: 21,
        PRINTERMARK: 22,
        TRAPNET: 23,
        WATERMARK: 24,
        THREED: 25,
        REDACT: 26
      };
      t.AnnotationStateModelType = {
        MARKED: "Marked",
        REVIEW: "Review"
      };
      t.AnnotationMarkedState = {
        MARKED: "Marked",
        UNMARKED: "Unmarked"
      };
      t.AnnotationReviewState = {
        ACCEPTED: "Accepted",
        REJECTED: "Rejected",
        CANCELLED: "Cancelled",
        COMPLETED: "Completed",
        NONE: "None"
      };
      t.AnnotationReplyType = {
        GROUP: "Group",
        REPLY: "R"
      };
      t.AnnotationFlag = {
        INVISIBLE: 1,
        HIDDEN: 2,
        PRINT: 4,
        NOZOOM: 8,
        NOROTATE: 16,
        NOVIEW: 32,
        READONLY: 64,
        LOCKED: 128,
        TOGGLENOVIEW: 256,
        LOCKEDCONTENTS: 512
      };
      t.AnnotationFieldFlag = {
        READONLY: 1,
        REQUIRED: 2,
        NOEXPORT: 4,
        MULTILINE: 4096,
        PASSWORD: 8192,
        NOTOGGLETOOFF: 16384,
        RADIO: 32768,
        PUSHBUTTON: 65536,
        COMBO: 131072,
        EDIT: 262144,
        SORT: 524288,
        FILESELECT: 1048576,
        MULTISELECT: 2097152,
        DONOTSPELLCHECK: 4194304,
        DONOTSCROLL: 8388608,
        COMB: 0x1000000,
        RICHTEXT: 0x2000000,
        RADIOSINUNISON: 0x2000000,
        COMMITONSELCHANGE: 0x4000000
      };
      t.AnnotationBorderStyleType = {
        SOLID: 1,
        DASHED: 2,
        BEVELED: 3,
        INSET: 4,
        UNDERLINE: 5
      };
      t.AnnotationActionEventType = {
        E: "Mouse Enter",
        X: "Mouse Exit",
        D: "Mouse Down",
        U: "Mouse Up",
        Fo: "Focus",
        Bl: "Blur",
        PO: "PageOpen",
        PC: "PageClose",
        PV: "PageVisible",
        PI: "PageInvisible",
        K: "Keystroke",
        F: "Format",
        V: "Validate",
        C: "Calculate"
      };
      t.DocumentActionEventType = {
        WC: "WillClose",
        WS: "WillSave",
        DS: "DidSave",
        WP: "WillPrint",
        DP: "DidPrint"
      };
      t.PageActionEventType = {
        O: "PageOpen",
        C: "PageClose"
      };
      t.StreamType = {
        UNKNOWN: "UNKNOWN",
        FLATE: "FLATE",
        LZW: "LZW",
        DCT: "DCT",
        JPX: "JPX",
        JBIG: "JBIG",
        A85: "A85",
        AHX: "AHX",
        CCF: "CCF",
        RLX: "RLX"
      };
      t.FontType = {
        UNKNOWN: "UNKNOWN",
        TYPE1: "TYPE1",
        TYPE1STANDARD: "TYPE1STANDARD",
        TYPE1C: "TYPE1C",
        CIDFONTTYPE0: "CIDFONTTYPE0",
        CIDFONTTYPE0C: "CIDFONTTYPE0C",
        TRUETYPE: "TRUETYPE",
        CIDFONTTYPE2: "CIDFONTTYPE2",
        TYPE3: "TYPE3",
        OPENTYPE: "OPENTYPE",
        TYPE0: "TYPE0",
        MMTYPE1: "MMTYPE1"
      };
      let r = {
        ERRORS: 0,
        WARNINGS: 1,
        INFOS: 5
      };
      t.VerbosityLevel = r;
      t.CMapCompressionType = {
        NONE: 0,
        BINARY: 1,
        STREAM: 2
      };
      t.OPS = {
        dependency: 1,
        setLineWidth: 2,
        setLineCap: 3,
        setLineJoin: 4,
        setMiterLimit: 5,
        setDash: 6,
        setRenderingIntent: 7,
        setFlatness: 8,
        setGState: 9,
        save: 10,
        restore: 11,
        transform: 12,
        moveTo: 13,
        lineTo: 14,
        curveTo: 15,
        curveTo2: 16,
        curveTo3: 17,
        closePath: 18,
        rectangle: 19,
        stroke: 20,
        closeStroke: 21,
        fill: 22,
        eoFill: 23,
        fillStroke: 24,
        eoFillStroke: 25,
        closeFillStroke: 26,
        closeEOFillStroke: 27,
        endPath: 28,
        clip: 29,
        eoClip: 30,
        beginText: 31,
        endText: 32,
        setCharSpacing: 33,
        setWordSpacing: 34,
        setHScale: 35,
        setLeading: 36,
        setFont: 37,
        setTextRenderingMode: 38,
        setTextRise: 39,
        moveText: 40,
        setLeadingMoveText: 41,
        setTextMatrix: 42,
        nextLine: 43,
        showText: 44,
        showSpacedText: 45,
        nextLineShowText: 46,
        nextLineSetSpacingShowText: 47,
        setCharWidth: 48,
        setCharWidthAndBounds: 49,
        setStrokeColorSpace: 50,
        setFillColorSpace: 51,
        setStrokeColor: 52,
        setStrokeColorN: 53,
        setFillColor: 54,
        setFillColorN: 55,
        setStrokeGray: 56,
        setFillGray: 57,
        setStrokeRGBColor: 58,
        setFillRGBColor: 59,
        setStrokeCMYKColor: 60,
        setFillCMYKColor: 61,
        shadingFill: 62,
        beginInlineImage: 63,
        beginImageData: 64,
        endInlineImage: 65,
        paintXObject: 66,
        markPoint: 67,
        markPointProps: 68,
        beginMarkedContent: 69,
        beginMarkedContentProps: 70,
        endMarkedContent: 71,
        beginCompat: 72,
        endCompat: 73,
        paintFormXObjectBegin: 74,
        paintFormXObjectEnd: 75,
        beginGroup: 76,
        endGroup: 77,
        beginAnnotations: 78,
        endAnnotations: 79,
        beginAnnotation: 80,
        endAnnotation: 81,
        paintJpegXObject: 82,
        paintImageMaskXObject: 83,
        paintImageMaskXObjectGroup: 84,
        paintImageXObject: 85,
        paintInlineImageXObject: 86,
        paintInlineImageXObjectGroup: 87,
        paintImageXObjectRepeat: 88,
        paintImageMaskXObjectRepeat: 89,
        paintSolidColorImageMask: 90,
        constructPath: 91
      };
      t.UNSUPPORTED_FEATURES = {
        unknown: "unknown",
        forms: "forms",
        javaScript: "javaScript",
        signatures: "signatures",
        smask: "smask",
        shadingPattern: "shadingPattern",
        font: "font",
        errorTilingPattern: "errorTilingPattern",
        errorExtGState: "errorExtGState",
        errorXObject: "errorXObject",
        errorFontLoadType3: "errorFontLoadType3",
        errorFontState: "errorFontState",
        errorFontMissing: "errorFontMissing",
        errorFontTranslate: "errorFontTranslate",
        errorColorSpace: "errorColorSpace",
        errorOperatorList: "errorOperatorList",
        errorFontToUnicode: "errorFontToUnicode",
        errorFontLoadNative: "errorFontLoadNative",
        errorFontBuildPath: "errorFontBuildPath",
        errorFontGetPath: "errorFontGetPath",
        errorMarkedContent: "errorMarkedContent",
        errorContentSubStream: "errorContentSubStream"
      };
      t.PasswordResponses = {
        NEED_PASSWORD: 1,
        INCORRECT_PASSWORD: 2
      };
      let i = r.WARNINGS;
      function n(e) {
        i >= r.WARNINGS && console.log(`Warning: ${e}`);
      }
      function s(e) {
        throw Error(e);
      }
      function o(e, t, a) {
        Object.defineProperty(e, t, {
          value: a,
          enumerable: !0,
          configurable: !0,
          writable: !1
        });
        return a;
      }
      let l = function () {
        function e(t, a) {
          this.constructor === e && s("Cannot initialize BaseException.");
          this.message = t;
          this.name = a;
        }
        e.prototype = Error();
        e.constructor = e;
        return e;
      }();
      function c(e) {
        "string" != typeof e && s("Invalid argument for stringToBytes");
        let t = e.length;
        let a = new Uint8Array(t);
        for (let r = 0; r < t; ++r) a[r] = 255 & e.charCodeAt(r);
        return a;
      }
      function h(e) {
        return void 0 !== e.length ? e.length : void 0 !== e.byteLength ? e.byteLength : void s("Invalid argument for arrayByteLength");
      }
      t.BaseException = l;
      t.PasswordException = class extends l {
        constructor(e, t) {
          super(e, "PasswordException");
          this.code = t;
        }
      };
      t.UnknownErrorException = class extends l {
        constructor(e, t) {
          super(e, "UnknownErrorException");
          this.details = t;
        }
      };
      t.InvalidPDFException = class extends l {
        constructor(e) {
          super(e, "InvalidPDFException");
        }
      };
      t.MissingPDFException = class extends l {
        constructor(e) {
          super(e, "MissingPDFException");
        }
      };
      t.UnexpectedResponseException = class extends l {
        constructor(e, t) {
          super(e, "UnexpectedResponseException");
          this.status = t;
        }
      };
      t.FormatError = class extends l {
        constructor(e) {
          super(e, "FormatError");
        }
      };
      t.AbortException = class extends l {
        constructor(e) {
          super(e, "AbortException");
        }
      };
      t.IsLittleEndianCached = {
        get value() {
          return o(this, "value", function () {
            let e = new Uint8Array(4);
            e[0] = 1;
            return 1 === new Uint32Array(e.buffer, 0, 1)[0];
          }());
        }
      };
      t.IsEvalSupportedCached = {
        get value() {
          return o(this, "value", function () {
            try {
              Function("");
              return !0;
            } catch (e) {
              return !1;
            }
          }());
        }
      };
      let u = [...Array(256).keys()].map(e => e.toString(16).padStart(2, "0"));
      class d {
        static makeHexColor(e, t, a) {
          return `#${u[e]}${u[t]}${u[a]}`;
        }
        static transform(e, t) {
          return [e[0] * t[0] + e[2] * t[1], e[1] * t[0] + e[3] * t[1], e[0] * t[2] + e[2] * t[3], e[1] * t[2] + e[3] * t[3], e[0] * t[4] + e[2] * t[5] + e[4], e[1] * t[4] + e[3] * t[5] + e[5]];
        }
        static applyTransform(e, t) {
          return [e[0] * t[0] + e[1] * t[2] + t[4], e[0] * t[1] + e[1] * t[3] + t[5]];
        }
        static applyInverseTransform(e, t) {
          let a = t[0] * t[3] - t[1] * t[2];
          return [(e[0] * t[3] - e[1] * t[2] + t[2] * t[5] - t[4] * t[3]) / a, (-e[0] * t[1] + e[1] * t[0] + t[4] * t[1] - t[5] * t[0]) / a];
        }
        static getAxialAlignedBoundingBox(e, t) {
          let a = d.applyTransform(e, t);
          let r = d.applyTransform(e.slice(2, 4), t);
          let i = d.applyTransform([e[0], e[3]], t);
          let n = d.applyTransform([e[2], e[1]], t);
          return [Math.min(a[0], r[0], i[0], n[0]), Math.min(a[1], r[1], i[1], n[1]), Math.max(a[0], r[0], i[0], n[0]), Math.max(a[1], r[1], i[1], n[1])];
        }
        static inverseTransform(e) {
          let t = e[0] * e[3] - e[1] * e[2];
          return [e[3] / t, -e[1] / t, -e[2] / t, e[0] / t, (e[2] * e[5] - e[4] * e[3]) / t, (e[4] * e[1] - e[5] * e[0]) / t];
        }
        static apply3dTransform(e, t) {
          return [e[0] * t[0] + e[1] * t[1] + e[2] * t[2], e[3] * t[0] + e[4] * t[1] + e[5] * t[2], e[6] * t[0] + e[7] * t[1] + e[8] * t[2]];
        }
        static singularValueDecompose2dScale(e) {
          let t = [e[0], e[2], e[1], e[3]];
          let a = e[0] * t[0] + e[1] * t[2];
          let r = e[0] * t[1] + e[1] * t[3];
          let i = e[2] * t[0] + e[3] * t[2];
          let n = e[2] * t[1] + e[3] * t[3];
          let s = (a + n) / 2;
          let o = Math.sqrt((a + n) ** 2 - 4 * (a * n - i * r)) / 2;
          return [Math.sqrt(s + o || 1), Math.sqrt(s - o || 1)];
        }
        static normalizeRect(e) {
          let t = e.slice(0);
          e[0] > e[2] && (t[0] = e[2], t[2] = e[0]);
          e[1] > e[3] && (t[1] = e[3], t[3] = e[1]);
          return t;
        }
        static intersect(e, t) {
          function a(e, t) {
            return e - t;
          }
          let r = [e[0], e[2], t[0], t[2]].sort(a);
          let i = [e[1], e[3], t[1], t[3]].sort(a);
          let n = [];
          return (e = d.normalizeRect(e), t = d.normalizeRect(t), (r[0] !== e[0] || r[1] !== t[0]) && (r[0] !== t[0] || r[1] !== e[0])) ? null : (n[0] = r[1], n[2] = r[2], (i[0] !== e[1] || i[1] !== t[1]) && (i[0] !== t[1] || i[1] !== e[1])) ? null : (n[1] = i[1], n[3] = i[2], n);
        }
        static bezierBoundingBox(e, t, a, r, i, n, s, o) {
          let l;
          let c;
          let h;
          let u;
          let d;
          let f;
          let g;
          let p;
          let m = [];
          let b = [[], []];
          for (let b = 0; b < 2; ++b) {
            if (0 === b ? (c = 6 * e - 12 * a + 6 * i, l = -3 * e + 9 * a - 9 * i + 3 * s, h = 3 * a - 3 * e) : (c = 6 * t - 12 * r + 6 * n, l = -3 * t + 9 * r - 9 * n + 3 * o, h = 3 * r - 3 * t), 1e-12 > Math.abs(l)) {
              if (1e-12 > Math.abs(c)) continue;
              0 < (u = -h / c) && u < 1 && m.push(u);
              continue;
            }
            p = Math.sqrt(g = c * c - 4 * h * l);
            !(g < 0) && (0 < (d = (-c + p) / (2 * l)) && d < 1 && m.push(d), 0 < (f = (-c - p) / (2 * l)) && f < 1 && m.push(f));
          }
          let y = m.length;
          let w;
          let x = y;
          for (; y--;) {
            w = 1 - (u = m[y]);
            b[0][y] = w * w * w * e + 3 * w * w * u * a + 3 * w * u * u * i + u * u * u * s;
            b[1][y] = w * w * w * t + 3 * w * w * u * r + 3 * w * u * u * n + u * u * u * o;
          }
          b[0][x] = e;
          b[1][x] = t;
          b[0][x + 1] = s;
          b[1][x + 1] = o;
          b[0].length = b[1].length = x + 2;
          return [Math.min(...b[0]), Math.min(...b[1]), Math.max(...b[0]), Math.max(...b[1])];
        }
      }
      t.Util = d;
      let f = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
      function g(e) {
        return decodeURIComponent(escape(e));
      }
    }, (e, t, a) => {
      a(4);
    }, (e, t) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.isNodeJS = void 0;
      let a = "object" == typeof process && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && "browser" !== process.type);
      t.isNodeJS = a;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.RefSetCache = t.RefSet = t.Ref = t.Name = t.EOF = t.Dict = t.Cmd = t.CIRCULAR_REF = void 0;
      t.clearPrimitiveCaches = function () {
        o._clearCache();
        s._clearCache();
        h._clearCache();
      };
      t.isCmd = function (e, t) {
        return e instanceof o && (void 0 === t || e.cmd === t);
      };
      t.isDict = function (e, t) {
        return e instanceof c && (void 0 === t || u(e.get("Type"), t));
      };
      t.isName = u;
      t.isRefsEqual = function (e, t) {
        return e.num === t.num && e.gen === t.gen;
      };
      var r = a(2);
      let i = Symbol("CIRCULAR_REF");
      t.CIRCULAR_REF = i;
      let n = Symbol("EOF");
      t.EOF = n;
      let s = function () {
        let e = Object.create(null);
        class t {
          constructor(e) {
            this.name = e;
          }
          static get(a) {
            return e[a] || (e[a] = new t(a));
          }
          static _clearCache() {
            e = Object.create(null);
          }
        }
        return t;
      }();
      t.Name = s;
      let o = function () {
        let e = Object.create(null);
        class t {
          constructor(e) {
            this.cmd = e;
          }
          static get(a) {
            return e[a] || (e[a] = new t(a));
          }
          static _clearCache() {
            e = Object.create(null);
          }
        }
        return t;
      }();
      t.Cmd = o;
      let l = function () {
        return l;
      };
      class c {
        constructor(e = null) {
          this._map = Object.create(null);
          this.xref = e;
          this.objId = null;
          this.suppressEncryption = !1;
          this.__nonSerializable__ = l;
        }
        assignXref(e) {
          this.xref = e;
        }
        get size() {
          return Object.keys(this._map).length;
        }
        get(e, t, a) {
          let r = this._map[e];
          return (void 0 === r && void 0 !== t && void 0 === (r = this._map[t]) && void 0 !== a && (r = this._map[a]), r instanceof h && this.xref) ? this.xref.fetch(r, this.suppressEncryption) : r;
        }
        async getAsync(e, t, a) {
          let r = this._map[e];
          return (void 0 === r && void 0 !== t && void 0 === (r = this._map[t]) && void 0 !== a && (r = this._map[a]), r instanceof h && this.xref) ? this.xref.fetchAsync(r, this.suppressEncryption) : r;
        }
        getArray(e, t, a) {
          let r = this._map[e];
          if (void 0 === r && void 0 !== t && void 0 === (r = this._map[t]) && void 0 !== a && (r = this._map[a]), r instanceof h && this.xref && (r = this.xref.fetch(r, this.suppressEncryption)), Array.isArray(r)) {
            r = r.slice();
            for (function () {
              let e = 0;
              let t = r.length;
            }(); e < t; e++) r[e] instanceof h && this.xref && (r[e] = this.xref.fetch(r[e], this.suppressEncryption));
          }
          return r;
        }
        getRaw(e) {
          return this._map[e];
        }
        getKeys() {
          return Object.keys(this._map);
        }
        getRawValues() {
          return Object.values(this._map);
        }
        set(e, t) {
          this._map[e] = t;
        }
        has(e) {
          return void 0 !== this._map[e];
        }
        forEach(e) {
          for (let t in this._map) e(t, this.get(t));
        }
        static get empty() {
          let e = new c(null);
          e.set = (e, t) => {
            r.unreachable("Should not call `set` on the empty dictionary.");
          };
          return r.shadow(this, "empty", e);
        }
        static merge({
          xref: e,
          dictArray: t,
          mergeSubDicts: a = !1
        }) {
          let r = new c(e);
          let i = new Map();
          for (let e of t) if (e instanceof c) for (let [t, r] of Object.entries(e._map)) {
            let e = i.get(t);
            if (void 0 === e) {
              e = [];
              i.set(t, e);
            } else if (!a || !(r instanceof c)) continue;
            e.push(r);
          }
          for (let [t, a] of i) {
            if (1 === a.length || !(a[0] instanceof c)) {
              r._map[t] = a[0];
              continue;
            }
            let i = new c(e);
            for (let e of a) for (let [t, a] of Object.entries(e._map)) void 0 === i._map[t] && (i._map[t] = a);
            i.size > 0 && (r._map[t] = i);
          }
          i.clear();
          return r.size > 0 ? r : c.empty;
        }
      }
      t.Dict = c;
      let h = function () {
        let e = Object.create(null);
        class t {
          constructor(e, t) {
            this.num = e;
            this.gen = t;
          }
          toString() {
            return 0 === this.gen ? `${this.num}R` : `${this.num}R${this.gen}`;
          }
          static get(a, r) {
            let i = 0 === r ? `${a}R` : `${a}R${r}`;
            return e[i] || (e[i] = new t(a, r));
          }
          static _clearCache() {
            e = Object.create(null);
          }
        }
        return t;
      }();
      function u(e, t) {
        return e instanceof s && (void 0 === t || e.name === t);
      }
      t.Ref = h;
      t.RefSet = class {
        constructor(e = null) {
          this._set = new Set(e && e._set);
        }
        has(e) {
          return this._set.has(e.toString());
        }
        put(e) {
          this._set.add(e.toString());
        }
        remove(e) {
          this._set.$$delete(e.toString());
        }
        forEach(e) {
          for (let t of this._set.values()) e(t);
        }
        clear() {
          this._set.clear();
        }
      };
      t.RefSetCache = class {
        constructor() {
          this._map = new Map();
        }
        get size() {
          return this._map.size;
        }
        get(e) {
          return this._map.get(e.toString());
        }
        has(e) {
          return this._map.has(e.toString());
        }
        put(e, t) {
          this._map.set(e.toString(), t);
        }
        putAlias(e, t) {
          this._map.set(e.toString(), this.get(t));
        }
        forEach(e) {
          for (let t of this._map.values()) e(t);
        }
        clear() {
          this._map.clear();
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.NetworkPdfManager = t.LocalPdfManager = void 0;
      var r = a(2);
      var i = a(7);
      var n = a(8);
      var s = a(11);
      var o = a(10);
      function l(e) {
        if (e) {
          let t = r.createValidAbsoluteUrl(e);
          if (t) return t.href;
          r.warn(`Invalid absolute docBaseUrl: "${e}".`);
        }
        return null;
      }
      class c {
        constructor() {
          this.constructor === c && r.unreachable("Cannot initialize BasePdfManager.");
        }
        get docId() {
          return this._docId;
        }
        get password() {
          return this._password;
        }
        get docBaseUrl() {
          return this._docBaseUrl;
        }
        onLoadedStream() {
          r.unreachable("Abstract method `onLoadedStream` called");
        }
        ensureDoc(e, t) {
          return this.ensure(this.pdfDocument, e, t);
        }
        ensureXRef(e, t) {
          return this.ensure(this.pdfDocument.xref, e, t);
        }
        ensureCatalog(e, t) {
          return this.ensure(this.pdfDocument.catalog, e, t);
        }
        getPage(e) {
          return this.pdfDocument.getPage(e);
        }
        fontFallback(e, t) {
          return this.pdfDocument.fontFallback(e, t);
        }
        loadXfaFonts(e, t) {
          return this.pdfDocument.loadXfaFonts(e, t);
        }
        loadXfaImages() {
          return this.pdfDocument.loadXfaImages();
        }
        serializeXfaData(e) {
          return this.pdfDocument.serializeXfaData(e);
        }
        cleanup(e = !1) {
          return this.pdfDocument.cleanup(e);
        }
        async ensure(e, t, a) {
          r.unreachable("Abstract method `ensure` called");
        }
        requestRange(e, t) {
          r.unreachable("Abstract method `requestRange` called");
        }
        requestLoadedStream() {
          r.unreachable("Abstract method `requestLoadedStream` called");
        }
        sendProgressiveData(e) {
          r.unreachable("Abstract method `sendProgressiveData` called");
        }
        updatePassword(e) {
          this._password = e;
        }
        terminate(e) {
          r.unreachable("Abstract method `terminate` called");
        }
      }
      t.LocalPdfManager = class extends c {
        constructor(e, t, a, r, i, n, c) {
          super();
          this._docId = e;
          this._password = a;
          this._docBaseUrl = l(c);
          this.msgHandler = r;
          this.evaluatorOptions = i;
          this.enableXfa = n;
          let h = new o.Stream(t);
          this.pdfDocument = new s.PDFDocument(this, h);
          this._loadedStreamPromise = Promise.resolve(h);
        }
        async ensure(e, t, a) {
          let r = e[t];
          return "function" == typeof r ? r.apply(e, a) : r;
        }
        requestRange(e, t) {
          return Promise.resolve();
        }
        requestLoadedStream() { }
        onLoadedStream() {
          return this._loadedStreamPromise;
        }
        terminate(e) { }
      };
      t.NetworkPdfManager = class extends c {
        constructor(e, t, a, r, n, o) {
          super();
          this._docId = e;
          this._password = a.password;
          this._docBaseUrl = l(o);
          this.msgHandler = a.msgHandler;
          this.evaluatorOptions = r;
          this.enableXfa = n;
          this.streamManager = new i.ChunkedStreamManager(t, {
            msgHandler: a.msgHandler,
            length: a.length,
            disableAutoFetch: a.disableAutoFetch,
            rangeChunkSize: a.rangeChunkSize
          });
          this.pdfDocument = new s.PDFDocument(this, this.streamManager.getStream());
        }
        async ensure(e, t, a) {
          try {
            let r = e[t];
            if ("function" == typeof r) return r.apply(e, a);
            return r;
          } catch (r) {
            if (!(r instanceof n.MissingDataException)) throw r;
            await this.requestRange(r.begin, r.end);
            return this.ensure(e, t, a);
          }
        }
        requestRange(e, t) {
          return this.streamManager.requestRange(e, t);
        }
        requestLoadedStream() {
          this.streamManager.requestAllChunks();
        }
        sendProgressiveData(e) {
          this.streamManager.onReceiveData({
            chunk: e
          });
        }
        onLoadedStream() {
          return this.streamManager.onLoadedStream();
        }
        terminate(e) {
          this.streamManager.abort(e);
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.ChunkedStreamManager = t.ChunkedStream = void 0;
      var r = a(2);
      var i = a(8);
      var n = a(10);
      class s extends n.Stream {
        constructor(e, t, a) {
          super(new Uint8Array(e), 0, e, null);
          this.chunkSize = t;
          this._loadedChunks = new Set();
          this.numChunks = Math.ceil(e / t);
          this.manager = a;
          this.progressiveDataLength = 0;
          this.lastSuccessfulEnsureByteChunk = -1;
        }
        getMissingChunks() {
          var _this = this;
          let e = [];
          for (function () {
            let t = 0;
            let a = _this.numChunks;
          }(); t < a; ++t) this._loadedChunks.has(t) || e.push(t);
          return e;
        }
        get numChunksLoaded() {
          return this._loadedChunks.size;
        }
        get isDataLoaded() {
          return this.numChunksLoaded === this.numChunks;
        }
        onReceiveData(e, t) {
          let a = this.chunkSize;
          if (e % a != 0) throw Error(`Bad begin offset: ${e}`);
          let r = e + t.byteLength;
          if (r % a != 0 && r !== this.bytes.length) throw Error(`Bad end offset: ${r}`);
          this.bytes.set(new Uint8Array(t), e);
          let i = Math.floor(e / a);
          let n = Math.floor((r - 1) / a) + 1;
          for (let e = i; e < n; ++e) this._loadedChunks.add(e);
        }
        onReceiveProgressiveData(e) {
          let t = this.progressiveDataLength;
          let a = Math.floor(t / this.chunkSize);
          this.bytes.set(new Uint8Array(e), t);
          t += e.byteLength;
          this.progressiveDataLength = t;
          let r = t >= this.end ? this.numChunks : Math.floor(t / this.chunkSize);
          for (let e = a; e < r; ++e) this._loadedChunks.add(e);
        }
        ensureByte(e) {
          if (e < this.progressiveDataLength) return;
          let t = Math.floor(e / this.chunkSize);
          if (!(t > this.numChunks) && t !== this.lastSuccessfulEnsureByteChunk) {
            if (!this._loadedChunks.has(t)) throw new i.MissingDataException(e, e + 1);
            this.lastSuccessfulEnsureByteChunk = t;
          }
        }
        ensureRange(e, t) {
          if (e >= t || t <= this.progressiveDataLength) return;
          let a = Math.floor(e / this.chunkSize);
          if (a > this.numChunks) return;
          let r = Math.min(Math.floor((t - 1) / this.chunkSize) + 1, this.numChunks);
          for (let n = a; n < r; ++n) if (!this._loadedChunks.has(n)) throw new i.MissingDataException(e, t);
        }
        nextEmptyChunk(e) {
          let t = this.numChunks;
          for (let a = 0; a < t; ++a) {
            let r = (e + a) % t;
            if (!this._loadedChunks.has(r)) return r;
          }
          return null;
        }
        hasChunk(e) {
          return this._loadedChunks.has(e);
        }
        getByte() {
          let e = this.pos;
          return e >= this.end ? -1 : (e >= this.progressiveDataLength && this.ensureByte(e), this.bytes[this.pos++]);
        }
        getBytes(e, t = !1) {
          let a = this.bytes;
          let r = this.pos;
          let i = this.end;
          if (!e) {
            i > this.progressiveDataLength && this.ensureRange(r, i);
            let e = a.subarray(r, i);
            return t ? new Uint8ClampedArray(e) : e;
          }
          let n = r + e;
          n > i && (n = i);
          n > this.progressiveDataLength && this.ensureRange(r, n);
          this.pos = n;
          let s = a.subarray(r, n);
          return t ? new Uint8ClampedArray(s) : s;
        }
        getByteRange(e, t) {
          e < 0 && (e = 0);
          t > this.end && (t = this.end);
          t > this.progressiveDataLength && this.ensureRange(e, t);
          return this.bytes.subarray(e, t);
        }
        makeSubStream(e, t, a = null) {
          function r() { }
          t ? e + t > this.progressiveDataLength && this.ensureRange(e, e + t) : e >= this.progressiveDataLength && this.ensureByte(e);
          r.prototype = Object.create(this);
          r.prototype.getMissingChunks = function () {
            let e = this.chunkSize;
            let t = Math.floor(this.start / e);
            let a = Math.floor((this.end - 1) / e) + 1;
            let r = [];
            for (let e = t; e < a; ++e) this._loadedChunks.has(e) || r.push(e);
            return r;
          };
          Object.defineProperty(r.prototype, "isDataLoaded", {
            get() {
              return this.numChunksLoaded === this.numChunks || 0 === this.getMissingChunks().length;
            },
            configurable: !0
          });
          let i = new r();
          i.pos = i.start = e;
          i.end = e + t || this.end;
          i.dict = a;
          return i;
        }
        getBaseStreams() {
          return [this];
        }
      }
      t.ChunkedStream = s;
      t.ChunkedStreamManager = class {
        constructor(e, t) {
          this.length = t.length;
          this.chunkSize = t.rangeChunkSize;
          this.stream = new s(this.length, this.chunkSize, this);
          this.pdfNetworkStream = e;
          this.disableAutoFetch = t.disableAutoFetch;
          this.msgHandler = t.msgHandler;
          this.currRequestId = 0;
          this._chunksNeededByRequest = new Map();
          this._requestsByChunk = new Map();
          this._promisesByRequest = new Map();
          this.progressiveDataLength = 0;
          this.aborted = !1;
          this._loadedStreamCapability = r.createPromiseCapability();
        }
        onLoadedStream() {
          return this._loadedStreamCapability.promise;
        }
        sendRequest(e, t) {
          let a = this.pdfNetworkStream.getRangeReader(e, t);
          a.isStreamingSupported || (a.onProgress = this.onProgress.bind(this));
          let i = [];
          let n = 0;
          return new Promise((e, t) => {
            let s = o => {
              try {
                if (!o.done) {
                  let e = o.value;
                  i.push(e);
                  n += r.arrayByteLength(e);
                  a.isStreamingSupported && this.onProgress({
                    loaded: n
                  });
                  a.read().then(s, t);
                  return;
                }
                let l = r.arraysToBytes(i);
                i = null;
                e(l);
              } catch (e) {
                t(e);
              }
            };
            a.read().then(s, t);
          }).then(t => {
            this.aborted || this.onReceiveData({
              chunk: t,
              begin: e
            });
          });
        }
        requestAllChunks() {
          let e = this.stream.getMissingChunks();
          this._requestChunks(e);
          return this._loadedStreamCapability.promise;
        }
        _requestChunks(e) {
          let t = this.currRequestId++;
          let a = new Set();
          for (let r of (this._chunksNeededByRequest.set(t, a), e)) this.stream.hasChunk(r) || a.add(r);
          if (0 === a.size) return Promise.resolve();
          let i = r.createPromiseCapability();
          this._promisesByRequest.set(t, i);
          let n = [];
          for (let e of a) {
            let a = this._requestsByChunk.get(e);
            a || (a = [], this._requestsByChunk.set(e, a), n.push(e));
            a.push(t);
          }
          if (n.length > 0) for (let e of this.groupChunks(n)) {
            let t = e.beginChunk * this.chunkSize;
            let a = Math.min(e.endChunk * this.chunkSize, this.length);
            this.sendRequest(t, a).catch(i.reject);
          }
          return i.promise.catch(e => {
            if (!this.aborted) throw e;
          });
        }
        getStream() {
          return this.stream;
        }
        requestRange(e, t) {
          t = Math.min(t, this.length);
          let a = this.getBeginChunk(e);
          let r = this.getEndChunk(t);
          let i = [];
          for (let e = a; e < r; ++e) i.push(e);
          return this._requestChunks(i);
        }
        requestRanges(e = []) {
          let t = [];
          for (let a of e) {
            let e = this.getBeginChunk(a.begin);
            let r = this.getEndChunk(a.end);
            for (let a = e; a < r; ++a) t.includes(a) || t.push(a);
          }
          t.sort(function (e, t) {
            return e - t;
          });
          return this._requestChunks(t);
        }
        groupChunks(e) {
          let t = [];
          let a = -1;
          let r = -1;
          for (function () {
            let i = 0;
            let n = e.length;
          }(); i < n; ++i) {
            let n = e[i];
            a < 0 && (a = n);
            r >= 0 && r + 1 !== n && (t.push({
              beginChunk: a,
              endChunk: r + 1
            }), a = n);
            i + 1 === e.length && t.push({
              beginChunk: a,
              endChunk: n + 1
            });
            r = n;
          }
          return t;
        }
        onProgress(e) {
          this.msgHandler.send("DocProgress", {
            loaded: this.stream.numChunksLoaded * this.chunkSize + e.loaded,
            total: this.length
          });
        }
        onReceiveData(e) {
          let t = e.chunk;
          let a = void 0 === e.begin;
          let r = a ? this.progressiveDataLength : e.begin;
          let i = r + t.byteLength;
          let n = Math.floor(r / this.chunkSize);
          let s = i < this.length ? Math.floor(i / this.chunkSize) : Math.ceil(i / this.chunkSize);
          a ? (this.stream.onReceiveProgressiveData(t), this.progressiveDataLength = i) : this.stream.onReceiveData(r, t);
          this.stream.isDataLoaded && this._loadedStreamCapability.resolve(this.stream);
          let o = [];
          for (let e = n; e < s; ++e) {
            let t = this._requestsByChunk.get(e);
            if (t) for (let a of (this._requestsByChunk.$$delete(e), t)) {
              let t = this._chunksNeededByRequest.get(a);
              t.has(e) && t.$$delete(e);
              t.size > 0 || o.push(a);
            }
          }
          if (!this.disableAutoFetch && 0 === this._requestsByChunk.size) {
            let e;
            if (1 === this.stream.numChunksLoaded) {
              let t = this.stream.numChunks - 1;
              this.stream.hasChunk(t) || (e = t);
            } else e = this.stream.nextEmptyChunk(s);
            Number.isInteger(e) && this._requestChunks([e]);
          }
          for (let e of o) {
            let t = this._promisesByRequest.get(e);
            this._promisesByRequest.$$delete(e);
            t.resolve();
          }
          this.msgHandler.send("DocProgress", {
            loaded: this.stream.numChunksLoaded * this.chunkSize,
            total: this.length
          });
        }
        onError(e) {
          this._loadedStreamCapability.reject(e);
        }
        getBeginChunk(e) {
          return Math.floor(e / this.chunkSize);
        }
        getEndChunk(e) {
          return Math.floor((e - 1) / this.chunkSize) + 1;
        }
        abort(e) {
          for (let t of (this.aborted = !0, this.pdfNetworkStream && this.pdfNetworkStream.cancelAllRequests(e), this._promisesByRequest.values())) t.reject(e);
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.XRefParseException = t.XRefEntryException = t.ParserEOFException = t.MissingDataException = t.DocStats = void 0;
      t.collectActions = function (e, t, a) {
        let n = Object.create(null);
        let s = h({
          dict: t,
          key: "AA",
          stopWhenFound: !1
        });
        if (s) for (let t = s.length - 1; t >= 0; t--) {
          let r = s[t];
          if (r instanceof i.Dict) for (let t of r.getKeys()) {
            let s = a[t];
            if (!s) continue;
            let o = r.getRaw(t);
            let l = new i.RefSet();
            let c = [];
            d(o, e, c, l);
            c.length > 0 && (n[s] = c);
          }
        }
        if (t.has("A")) {
          let a = t.get("A");
          let r = new i.RefSet();
          let s = [];
          d(a, e, s, r);
          s.length > 0 && (n.Action = s);
        }
        return r.objectSize(n) > 0 ? n : null;
      };
      t.encodeToXmlString = function (e) {
        let t = [];
        let a = 0;
        for (function () {
          let r = 0;
          let i = e.length;
        }(); r < i; r++) {
          let i = e.codePointAt(r);
          if (32 <= i && i <= 126) {
            let n = f[i];
            n && (a < r && t.push(e.substring(a, r)), t.push(n), a = r + 1);
          } else {
            a < r && t.push(e.substring(a, r));
            t.push(`&#x${i.toString(16).toUpperCase()};`);
            i > 55295 && (i < 57344 || i > 65533) && r++;
            a = r + 1;
          }
        }
        return 0 === t.length ? e : (a < e.length && t.push(e.substring(a, e.length)), t.join(""));
      };
      t.escapePDFName = function (e) {
        let t = [];
        let a = 0;
        for (function () {
          let r = 0;
          let i = e.length;
        }(); r < i; r++) {
          let i = e.charCodeAt(r);
          (i < 33 || i > 126 || 35 === i || 40 === i || 41 === i || 60 === i || 62 === i || 91 === i || 93 === i || 123 === i || 125 === i || 47 === i || 37 === i) && (a < r && t.push(e.substring(a, r)), t.push(`#${i.toString(16)}`), a = r + 1);
        }
        return 0 === t.length ? e : (a < e.length && t.push(e.substring(a, e.length)), t.join(""));
      };
      t.getArrayLookupTableFactory = function (e) {
        let t;
        return function () {
          if (e) {
            let a = e();
            e = null;
            t = Object.create(null);
            for (function () {
              let e = 0;
              let r = a.length;
            }(); e < r; e += 2) t[a[e]] = a[e + 1];
            a = null;
          }
          return t;
        };
      };
      t.getInheritableProperty = h;
      t.getLookupTableFactory = function (e) {
        let t;
        return function () {
          e && (t = Object.create(null), e(t), e = null);
          return t;
        };
      };
      t.isWhiteSpace = function (e) {
        return 32 === e || 9 === e || 13 === e || 10 === e;
      };
      t.log2 = function (e) {
        return e <= 0 ? 0 : Math.ceil(Math.log2(e));
      };
      t.parseXFAPath = function (e) {
        let t = /(.+)\[(\d+)\]$/;
        return e.split(".").map(e => {
          let a = e.match(t);
          return a ? {
            name: a[1],
            pos: parseInt(a[2], 10)
          } : {
            name: e,
            pos: 0
          };
        });
      };
      t.readInt8 = function (e, t) {
        return e[t] << 24 >> 24;
      };
      t.readUint16 = function (e, t) {
        return e[t] << 8 | e[t + 1];
      };
      t.readUint32 = function (e, t) {
        return (e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) >>> 0;
      };
      t.recoverJsURL = function (e) {
        let t = RegExp("^\\s*(" + "app.launchURL|window.open|xfa.host.gotoURL".split(".").join("\\.") + ")\\((?:'|\")([^'\"]*)(?:'|\")(?:,\\s*(\\w+)\\)|\\))", "i").exec(e);
        if (t && t[2]) {
          let e = t[2];
          let a = !1;
          "true" === t[3] && "app.launchURL" === t[1] && (a = !0);
          return {
            url: e,
            newWindow: a
          };
        }
        return null;
      };
      t.toRomanNumerals = function (e, t = !1) {
        let a;
        r.assert(Number.isInteger(e) && e > 0, "The number should be a positive integer.");
        let i = [];
        for (; e >= 1e3;) {
          e -= 1e3;
          i.push("M");
        }
        a = e / 100 | 0;
        e %= 100;
        i.push(u[a]);
        a = e / 10 | 0;
        e %= 10;
        i.push(u[10 + a]);
        i.push(u[20 + e]);
        let n = i.join("");
        return t ? n.toLowerCase() : n;
      };
      t.validateCSSFont = function (e) {
        let t = new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normal", "bold", "bolder", "lighter"]);
        let {
          fontFamily,
          fontWeight,
          italicAngle
        } = e;
        if (/^".*"$/.test(fontFamily)) {
          if (/[^\\]"/.test(fontFamily.slice(1, fontFamily.length - 1))) {
            r.warn(`XFA - FontFamily contains some unescaped ": ${fontFamily}.`);
            return !1;
          }
        } else if (/^'.*'$/.test(fontFamily)) {
          if (/[^\\]'/.test(fontFamily.slice(1, fontFamily.length - 1))) {
            r.warn(`XFA - FontFamily contains some unescaped ': ${fontFamily}.`);
            return !1;
          }
        } else for (let e of fontFamily.split(/[ \t]+/)) if (/^(\d|(-(\d|-)))/.test(e) || !/^[\w-\\]+$/.test(e)) {
          r.warn(`XFA - FontFamily contains some invalid <custom-ident>: ${fontFamily}.`);
          return !1;
        }
        let s = fontWeight ? fontWeight.toString() : "";
        e.fontWeight = t.has(s) ? s : "400";
        let o = parseFloat(italicAngle);
        e.italicAngle = isNaN(o) || o < -90 || o > 90 ? "14" : italicAngle.toString();
        return !0;
      };
      var r = a(2);
      var i = a(5);
      var n = a(9);
      class s extends r.BaseException {
        constructor(e, t) {
          super(`Missing data [${e}, ${t})`, "MissingDataException");
          this.begin = e;
          this.end = t;
        }
      }
      t.MissingDataException = s;
      class o extends r.BaseException {
        constructor(e) {
          super(e, "ParserEOFException");
        }
      }
      t.ParserEOFException = o;
      class l extends r.BaseException {
        constructor(e) {
          super(e, "XRefEntryException");
        }
      }
      t.XRefEntryException = l;
      class c extends r.BaseException {
        constructor(e) {
          super(e, "XRefParseException");
        }
      }
      function h({
        dict: e,
        key: t,
        getArray: a = !1,
        stopWhenFound: r = !0
      }) {
        let n;
        let s = new i.RefSet();
        for (; e instanceof i.Dict && !(e.objId && s.has(e.objId));) {
          e.objId && s.put(e.objId);
          let i = a ? e.getArray(t) : e.get(t);
          if (void 0 !== i) {
            if (r) return i;
            n || (n = []);
            n.push(i);
          }
          e = e.get("Parent");
        }
        return n;
      }
      t.XRefParseException = c;
      t.DocStats = class {
        constructor(e) {
          this._handler = e;
          this._streamTypes = new Set();
          this._fontTypes = new Set();
        }
        _send() {
          let e = Object.create(null);
          let t = Object.create(null);
          for (let t of this._streamTypes) e[t] = !0;
          for (let e of this._fontTypes) t[e] = !0;
          this._handler.send("DocStats", {
            streamTypes: e,
            fontTypes: t
          });
        }
        addStreamType(e) {
          this._streamTypes.has(e) || (this._streamTypes.add(e), this._send());
        }
        addFontType(e) {
          this._fontTypes.has(e) || (this._fontTypes.add(e), this._send());
        }
      };
      let u = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
      function d(e, t, a, s) {
        if (!e) return;
        let o = null;
        if (e instanceof i.Ref) {
          if (s.has(e)) return;
          o = e;
          s.put(o);
          e = t.fetch(e);
        }
        if (Array.isArray(e)) for (let r of e) d(r, t, a, s); else if (e instanceof i.Dict) {
          if (i.isName(e.get("S"), "JavaScript")) {
            let t;
            let i = e.get("JS");
            i instanceof n.BaseStream ? t = i.getString() : "string" == typeof i && (t = i);
            (t = t && r.stringToPDFString(t)) && a.push(t);
          }
          d(e.getRaw("Next"), t, a, s);
        }
        o && s.remove(o);
      }
      let f = {
        60: "&lt;",
        62: "&gt;",
        38: "&amp;",
        34: "&quot;",
        39: "&apos;"
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.BaseStream = void 0;
      var r = a(2);
      class i {
        constructor() {
          this.constructor === i && r.unreachable("Cannot initialize BaseStream.");
        }
        get length() {
          r.unreachable("Abstract getter `length` accessed");
        }
        get isEmpty() {
          r.unreachable("Abstract getter `isEmpty` accessed");
        }
        get isDataLoaded() {
          return r.shadow(this, "isDataLoaded", !0);
        }
        getByte() {
          r.unreachable("Abstract method `getByte` called");
        }
        getBytes(e, t = !1) {
          r.unreachable("Abstract method `getBytes` called");
        }
        peekByte() {
          let e = this.getByte();
          -1 !== e && this.pos--;
          return e;
        }
        peekBytes(e, t = !1) {
          let a = this.getBytes(e, t);
          this.pos -= a.length;
          return a;
        }
        getUint16() {
          let e = this.getByte();
          let t = this.getByte();
          return -1 === e || -1 === t ? -1 : (e << 8) + t;
        }
        getInt32() {
          let e = this.getByte();
          return (e << 24) + (this.getByte() << 16) + (this.getByte() << 8) + this.getByte();
        }
        getByteRange(e, t) {
          r.unreachable("Abstract method `getByteRange` called");
        }
        getString(e) {
          return r.bytesToString(this.getBytes(e, !1));
        }
        skip(e) {
          this.pos += e || 1;
        }
        reset() {
          r.unreachable("Abstract method `reset` called");
        }
        moveStart() {
          r.unreachable("Abstract method `moveStart` called");
        }
        makeSubStream(e, t, a = null) {
          r.unreachable("Abstract method `makeSubStream` called");
        }
        getBaseStreams() {
          return null;
        }
      }
      t.BaseStream = i;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.StringStream = t.Stream = t.NullStream = void 0;
      var r = a(9);
      var i = a(2);
      class n extends r.BaseStream {
        constructor(e, t, a, r) {
          super();
          this.bytes = e instanceof Uint8Array ? e : new Uint8Array(e);
          this.start = t || 0;
          this.pos = this.start;
          this.end = t + a || this.bytes.length;
          this.dict = r;
        }
        get length() {
          return this.end - this.start;
        }
        get isEmpty() {
          return 0 === this.length;
        }
        getByte() {
          return this.pos >= this.end ? -1 : this.bytes[this.pos++];
        }
        getBytes(e, t = !1) {
          let a = this.bytes;
          let r = this.pos;
          let i = this.end;
          if (!e) {
            let e = a.subarray(r, i);
            return t ? new Uint8ClampedArray(e) : e;
          }
          let n = r + e;
          n > i && (n = i);
          this.pos = n;
          let s = a.subarray(r, n);
          return t ? new Uint8ClampedArray(s) : s;
        }
        getByteRange(e, t) {
          e < 0 && (e = 0);
          t > this.end && (t = this.end);
          return this.bytes.subarray(e, t);
        }
        reset() {
          this.pos = this.start;
        }
        moveStart() {
          this.start = this.pos;
        }
        makeSubStream(e, t, a = null) {
          return new n(this.bytes.buffer, e, t, a);
        }
      }
      t.Stream = n;
      t.StringStream = class extends n {
        constructor(e) {
          super(i.stringToBytes(e));
        }
      };
      t.NullStream = class extends n {
        constructor() {
          super(new Uint8Array(0));
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.Page = t.PDFDocument = void 0;
      var r = a(2);
      var i = a(8);
      var n = a(5);
      var s = a(12);
      var o = a(10);
      var l = a(22);
      var c = a(9);
      var h = a(73);
      var u = a(64);
      var d = a(66);
      var f = a(27);
      var g = a(71);
      var p = a(62);
      var m = a(25);
      var b = a(29);
      var y = a(70);
      var w = a(75);
      var x = a(99);
      let S = [0, 0, 612, 792];
      class k {
        constructor({
          pdfManager: e,
          xref: t,
          pageIndex: a,
          pageDict: r,
          ref: i,
          globalIdFactory: n,
          fontCache: s,
          builtInCMapCache: o,
          standardFontDataCache: l,
          globalImageCache: c,
          nonBlendModesSet: h,
          xfaFactory: u
        }) {
          this.pdfManager = e;
          this.pageIndex = a;
          this.pageDict = r;
          this.xref = t;
          this.ref = i;
          this.fontCache = s;
          this.builtInCMapCache = o;
          this.standardFontDataCache = l;
          this.globalImageCache = c;
          this.nonBlendModesSet = h;
          this.evaluatorOptions = e.evaluatorOptions;
          this.resourcesPromise = null;
          this.xfaFactory = u;
          let d = {
            obj: 0
          };
          this._localIdFactory = class extends n {
            static createObjId() {
              return `p${a}_${++d.obj}`;
            }
            static getPageObjId() {
              return `page${i.toString()}`;
            }
          };
        }
        _getInheritableProperty(e, t = !1) {
          let a = i.getInheritableProperty({
            dict: this.pageDict,
            key: e,
            getArray: t,
            stopWhenFound: !1
          });
          return Array.isArray(a) ? 1 !== a.length && a[0] instanceof n.Dict ? n.Dict.merge({
            xref: this.xref,
            dictArray: a
          }) : a[0] : a;
        }
        get content() {
          return this.pageDict.getArray("Contents");
        }
        get resources() {
          return r.shadow(this, "resources", this._getInheritableProperty("Resources") || n.Dict.empty);
        }
        _getBoundingBox(e) {
          if (this.xfaData) return this.xfaData.bbox;
          let t = this._getInheritableProperty(e, !0);
          if (Array.isArray(t) && 4 === t.length) {
            if (t[2] - t[0] != 0 && t[3] - t[1] != 0) return t;
            r.warn(`Empty /${e} entry.`);
          }
          return null;
        }
        get mediaBox() {
          return r.shadow(this, "mediaBox", this._getBoundingBox("MediaBox") || S);
        }
        get cropBox() {
          return r.shadow(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
        }
        get userUnit() {
          let e = this.pageDict.get("UserUnit");
          ("number" != typeof e || e <= 0) && (e = 1);
          return r.shadow(this, "userUnit", e);
        }
        get view() {
          let e;
          let {
            cropBox,
            mediaBox
          } = this;
          if (cropBox === mediaBox || r.isArrayEqual(cropBox, mediaBox)) e = mediaBox; else {
            let i = r.Util.intersect(cropBox, mediaBox);
            i && i[2] - i[0] != 0 && i[3] - i[1] != 0 ? e = i : r.warn("Empty /CropBox and /MediaBox intersection.");
          }
          return r.shadow(this, "view", e || mediaBox);
        }
        get rotate() {
          let e = this._getInheritableProperty("Rotate") || 0;
          e % 90 != 0 ? e = 0 : e >= 360 ? e %= 360 : e < 0 && (e = (e % 360 + 360) % 360);
          return r.shadow(this, "rotate", e);
        }
        _onSubStreamError(e, t, a) {
          if (this.evaluatorOptions.ignoreErrors) {
            e.send("UnsupportedFeature", {
              featureId: r.UNSUPPORTED_FEATURES.errorContentSubStream
            });
            r.warn(`getContentStream - ignoring sub-stream (${a}): "${t}".`);
            return;
          }
          throw t;
        }
        getContentStream(e) {
          return this.pdfManager.ensure(this, "content").then(t => t instanceof c.BaseStream ? t : Array.isArray(t) ? new b.StreamsSequenceStream(t, this._onSubStreamError.bind(this, e)) : new o.NullStream());
        }
        get xfaData() {
          return r.shadow(this, "xfaData", this.xfaFactory ? {
            bbox: this.xfaFactory.getBoundingBox(this.pageIndex)
          } : null);
        }
        save(e, t, a) {
          let i = new m.PartialEvaluator({
            xref: this.xref,
            handler: e,
            pageIndex: this.pageIndex,
            idFactory: this._localIdFactory,
            fontCache: this.fontCache,
            builtInCMapCache: this.builtInCMapCache,
            standardFontDataCache: this.standardFontDataCache,
            globalImageCache: this.globalImageCache,
            options: this.evaluatorOptions
          });
          return this._parsedAnnotations.then(function (e) {
            let n = [];
            for (let s of e) s.mustBePrinted(a) && n.push(s.save(i, t, a).catch(function (e) {
              r.warn(`save - ignoring annotation data during "${t.name}" task: "${e}".`);
              return null;
            }));
            return Promise.all(n);
          });
        }
        loadResources(e) {
          this.resourcesPromise || (this.resourcesPromise = this.pdfManager.ensure(this, "resources"));
          return this.resourcesPromise.then(() => new g.ObjectLoader(this.resources, e, this.xref).load());
        }
        getOperatorList({
          handler: e,
          sink: t,
          task: a,
          intent: i,
          cacheKey: n,
          annotationStorage: s = null
        }) {
          let o = this.getContentStream(e);
          let l = this.loadResources(["ColorSpace", "ExtGState", "Font", "Pattern", "Properties", "Shading", "XObject"]);
          let c = new m.PartialEvaluator({
            xref: this.xref,
            handler: e,
            pageIndex: this.pageIndex,
            idFactory: this._localIdFactory,
            fontCache: this.fontCache,
            builtInCMapCache: this.builtInCMapCache,
            standardFontDataCache: this.standardFontDataCache,
            globalImageCache: this.globalImageCache,
            options: this.evaluatorOptions
          });
          return Promise.all([Promise.all([o, l]).then(([r]) => {
            let s = new p.OperatorList(i, t);
            e.send("StartRenderPage", {
              transparency: c.hasBlendModes(this.resources, this.nonBlendModesSet),
              pageIndex: this.pageIndex,
              cacheKey: n
            });
            return c.getOperatorList({
              stream: r,
              task: a,
              resources: this.resources,
              operatorList: s
            }).then(function () {
              return s;
            });
          }), this._parsedAnnotations]).then(function ([e, t]) {
            if (0 === t.length || i & r.RenderingIntentFlag.ANNOTATIONS_DISABLE) {
              e.flush(!0);
              return {
                length: e.totalLength
              };
            }
            let n = !!(i & r.RenderingIntentFlag.ANNOTATIONS_FORMS);
            let o = !!(i & r.RenderingIntentFlag.ANY);
            let l = !!(i & r.RenderingIntentFlag.DISPLAY);
            let h = !!(i & r.RenderingIntentFlag.PRINT);
            let u = [];
            for (let e of t) (o || l && e.mustBeViewed(s) || h && e.mustBePrinted(s)) && u.push(e.getOperatorList(c, a, i, n, s).catch(function (e) {
              r.warn(`getOperatorList - ignoring annotation data during "${a.name}" task: "${e}".`);
              return null;
            }));
            return Promise.all(u).then(function (t) {
              for (let a of (e.addOp(r.OPS.beginAnnotations, []), t)) e.addOpList(a);
              e.addOp(r.OPS.endAnnotations, []);
              e.flush(!0);
              return {
                length: e.totalLength
              };
            });
          });
        }
        extractTextContent({
          handler: e,
          task: t,
          includeMarkedContent: a,
          sink: r,
          combineTextItems: i
        }) {
          return Promise.all([this.getContentStream(e), this.loadResources(["ExtGState", "Font", "Properties", "XObject"])]).then(([n]) => new m.PartialEvaluator({
            xref: this.xref,
            handler: e,
            pageIndex: this.pageIndex,
            idFactory: this._localIdFactory,
            fontCache: this.fontCache,
            builtInCMapCache: this.builtInCMapCache,
            standardFontDataCache: this.standardFontDataCache,
            globalImageCache: this.globalImageCache,
            options: this.evaluatorOptions
          }).getTextContent({
            stream: n,
            task: t,
            resources: this.resources,
            includeMarkedContent: a,
            combineTextItems: i,
            sink: r,
            viewBox: this.view
          }));
        }
        async getStructTree() {
          let e = await this.pdfManager.ensureCatalog("structTreeRoot");
          return e ? (await this.pdfManager.ensure(this, "_parseStructTree", [e])).serializable : null;
        }
        _parseStructTree(e) {
          let t = new y.StructTreePage(e, this.pageDict);
          t.parse();
          return t;
        }
        getAnnotationsData(e) {
          return this._parsedAnnotations.then(function (t) {
            let a = [];
            if (0 === t.length) return a;
            let i = !!(e & r.RenderingIntentFlag.ANY);
            let n = !!(e & r.RenderingIntentFlag.DISPLAY);
            let s = !!(e & r.RenderingIntentFlag.PRINT);
            for (let e of t) (i || n && e.viewable || s && e.printable) && a.push(e.data);
            return a;
          });
        }
        get annotations() {
          let e = this._getInheritableProperty("Annots");
          return r.shadow(this, "annotations", Array.isArray(e) ? e : []);
        }
        get _parsedAnnotations() {
          let e = this.pdfManager.ensure(this, "annotations").then(() => {
            let e = [];
            for (let t of this.annotations) e.push(l.AnnotationFactory.create(this.xref, t, this.pdfManager, this._localIdFactory, !1).catch(function (e) {
              r.warn(`_parsedAnnotations: "${e}".`);
              return null;
            }));
            return Promise.all(e).then(function (e) {
              return e.filter(e => !!e);
            });
          });
          return r.shadow(this, "_parsedAnnotations", e);
        }
        get jsActions() {
          let e = i.collectActions(this.xref, this.pageDict, r.PageActionEventType);
          return r.shadow(this, "jsActions", e);
        }
      }
      t.Page = k;
      let A = new Uint8Array([37, 80, 68, 70, 45]);
      let v = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
      let C = new Uint8Array([101, 110, 100, 111, 98, 106]);
      let O = /^[1-9]\.\d$/;
      function F(e, t, a = 1024, r = !1) {
        let i = t.length;
        let n = e.peekBytes(a);
        let s = n.length - i;
        if (s <= 0) return !1;
        if (r) {
          let a = i - 1;
          let r = n.length - 1;
          for (; r >= a;) {
            let s = 0;
            for (; s < i && n[r - s] === t[a - s];) s++;
            if (s >= i) {
              e.pos += r - a;
              return !0;
            }
            r--;
          }
        } else {
          let a = 0;
          for (; a <= s;) {
            let r = 0;
            for (; r < i && n[a + r] === t[r];) r++;
            if (r >= i) {
              e.pos += a;
              return !0;
            }
            a++;
          }
        }
        return !1;
      }
      t.PDFDocument = class {
        constructor(e, t) {
          let a;
          if (t instanceof c.BaseStream) a = t; else if (r.isArrayBuffer(t)) a = new o.Stream(t); else throw Error("PDFDocument: Unknown argument type");
          if (a.length <= 0) throw new r.InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");
          this.pdfManager = e;
          this.stream = a;
          this.xref = new x.XRef(a, e);
          this._pagePromises = new Map();
          this._version = null;
          let i = {
            font: 0
          };
          this._globalIdFactory = class {
            static getDocId() {
              return `g_${e.docId}`;
            }
            static createFontId() {
              return `f${++i.font}`;
            }
            static createObjId() {
              r.unreachable("Abstract method `createObjId` called.");
            }
            static getPageObjId() {
              r.unreachable("Abstract method `getPageObjId` called.");
            }
          };
        }
        parse(e) {
          this.xref.parse(e);
          this.catalog = new u.Catalog(this.pdfManager, this.xref);
          this.catalog.version && (this._version = this.catalog.version);
        }
        get linearization() {
          let e = null;
          try {
            e = f.Linearization.create(this.stream);
          } catch (e) {
            if (e instanceof i.MissingDataException) throw e;
            r.info(e);
          }
          return r.shadow(this, "linearization", e);
        }
        get startXRef() {
          let e = this.stream;
          let t = 0;
          if (this.linearization) {
            e.reset();
            F(e, C) && (t = e.pos + 6 - e.start);
          } else {
            let a = v.length;
            let r = !1;
            let n = e.end;
            for (; !r && n > 0;) {
              (n -= 1024 - a) < 0 && (n = 0);
              e.pos = n;
              r = F(e, v, 1024, !0);
            }
            if (r) {
              let a;
              e.skip(9);
              do a = e.getByte(); while (i.isWhiteSpace(a));
              let r = "";
              for (; a >= 32 && a <= 57;) {
                r += String.fromCharCode(a);
                a = e.getByte();
              }
              isNaN(t = parseInt(r, 10)) && (t = 0);
            }
          }
          return r.shadow(this, "startXRef", t);
        }
        checkHeader() {
          let e = this.stream;
          if (e.reset(), !F(e, A)) return;
          e.moveStart();
          let t = "";
          let a;
          for (; (a = e.getByte()) > 32 && !(t.length >= 12);) t += String.fromCharCode(a);
          this._version || (this._version = t.substring(5));
        }
        parseStartXRef() {
          this.xref.setStartXRef(this.startXRef);
        }
        get numPages() {
          let e = 0;
          e = this.catalog.hasActualNumPages ? this.catalog.numPages : this.xfaFactory ? this.xfaFactory.getNumPages() : this.linearization ? this.linearization.numPages : this.catalog.numPages;
          return r.shadow(this, "numPages", e);
        }
        _hasOnlyDocumentSignatures(e, t = 0) {
          return !!Array.isArray(e) && e.every(e => {
            if (!((e = this.xref.fetchIfRef(e)) instanceof n.Dict)) return !1;
            if (e.has("Kids")) return ++t > 10 ? (r.warn("_hasOnlyDocumentSignatures: maximum recursion depth reached"), !1) : this._hasOnlyDocumentSignatures(e.get("Kids"), t);
            let a = n.isName(e.get("FT"), "Sig");
            let i = e.get("Rect");
            let s = Array.isArray(i) && i.every(e => 0 === e);
            return a && s;
          });
        }
        get xfaData() {
          let e = this.catalog.acroForm;
          if (!e) return null;
          let t = e.get("XFA");
          let a = {
            "xdp:xdp": "",
            template: "",
            datasets: "",
            config: "",
            connectionSet: "",
            localeSet: "",
            stylesheet: "",
            "/xdp:xdp": ""
          };
          if (t instanceof c.BaseStream && !t.isEmpty) try {
            a["xdp:xdp"] = r.stringToUTF8String(t.getString());
            return a;
          } catch (e) {
            r.warn("XFA - Invalid utf-8 string.");
            return null;
          }
          if (!Array.isArray(t) || 0 === t.length) return null;
          for (function () {
            let e = 0;
            let i = t.length;
          }(); e < i; e += 2) {
            let n;
            if (n = 0 === e ? "xdp:xdp" : e === i - 2 ? "/xdp:xdp" : t[e], !a.hasOwnProperty(n)) continue;
            let s = this.xref.fetchIfRef(t[e + 1]);
            if (s instanceof c.BaseStream && !s.isEmpty) try {
              a[n] = r.stringToUTF8String(s.getString());
            } catch (e) {
              r.warn("XFA - Invalid utf-8 string.");
              return null;
            }
          }
          return a;
        }
        get xfaFactory() {
          let e;
          this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm && (e = this.xfaData);
          return r.shadow(this, "xfaFactory", e ? new w.XFAFactory(e) : null);
        }
        get isPureXfa() {
          return !!this.xfaFactory && this.xfaFactory.isValid();
        }
        get htmlForXfa() {
          return this.xfaFactory ? this.xfaFactory.getPages() : null;
        }
        async loadXfaImages() {
          let e = await this.pdfManager.ensureCatalog("xfaImages");
          if (!e) return;
          let t = e.getKeys();
          let a = new g.ObjectLoader(e, t, this.xref);
          await a.load();
          let r = new Map();
          for (let a of t) {
            let t = e.get(a);
            t instanceof c.BaseStream && r.set(a, t.getBytes());
          }
          this.xfaFactory.setImages(r);
        }
        async loadXfaFonts(e, t) {
          let a = await this.pdfManager.ensureCatalog("acroForm");
          if (!a) return;
          let o = await a.getAsync("DR");
          if (!(o instanceof n.Dict)) return;
          let l = new g.ObjectLoader(o, ["Font"], this.xref);
          await l.load();
          let c = o.get("Font");
          if (!(c instanceof n.Dict)) return;
          let h = Object.assign(Object.create(null), this.pdfManager.evaluatorOptions);
          h.useSystemFonts = !1;
          let u = new m.PartialEvaluator({
            xref: this.xref,
            handler: e,
            pageIndex: -1,
            idFactory: this._globalIdFactory,
            fontCache: this.catalog.fontCache,
            builtInCMapCache: this.catalog.builtInCMapCache,
            standardFontDataCache: this.catalog.standardFontDataCache,
            options: h
          });
          let d = new p.OperatorList();
          let f = [];
          let b = {
            get font() {
              return f[f.length - 1];
            },
            set font(font) {
              f.push(font);
            },
            clone() {
              return this;
            }
          };
          let y = new Map();
          c.forEach((e, t) => {
            y.set(e, t);
          });
          let w = [];
          for (let [e, a] of y) {
            let s = a.get("FontDescriptor");
            if (!(s instanceof n.Dict)) continue;
            let l = s.get("FontFamily");
            let c = {
              fontFamily: l = l.replace(/[ ]+(\d)/g, "$1"),
              fontWeight: s.get("FontWeight"),
              italicAngle: -s.get("ItalicAngle")
            };
            i.validateCSSFont(c) && w.push(u.handleSetFont(o, [n.Name.get(e), 1], null, d, t, b, null, c).catch(function (e) {
              r.warn(`loadXfaFonts: "${e}".`);
              return null;
            }));
          }
          await Promise.all(w);
          let x = this.xfaFactory.setFonts(f);
          if (!x) return;
          h.ignoreErrors = !0;
          w.length = 0;
          f.length = 0;
          let S = new Set();
          for (let e of x) s.getXfaFontName(`${e}-Regular`) || S.add(e);
          for (let e of (S.size && x.push("PdfJS-Fallback"), x)) if (!S.has(e)) for (let a of [{
            name: "Regular",
            fontWeight: 400,
            italicAngle: 0
          }, {
            name: "Bold",
            fontWeight: 700,
            italicAngle: 0
          }, {
            name: "Italic",
            fontWeight: 400,
            italicAngle: 12
          }, {
            name: "BoldItalic",
            fontWeight: 700,
            italicAngle: 12
          }]) {
            let i = `${e}-${a.name}`;
            let l = s.getXfaFontDict(i);
            w.push(u.handleSetFont(o, [n.Name.get(i), 1], null, d, t, b, l, {
              fontFamily: e,
              fontWeight: a.fontWeight,
              italicAngle: a.italicAngle
            }).catch(function (e) {
              r.warn(`loadXfaFonts: "${e}".`);
              return null;
            }));
          }
          await Promise.all(w);
          this.xfaFactory.appendFonts(f, S);
        }
        async serializeXfaData(e) {
          return this.xfaFactory ? this.xfaFactory.serializeData(e) : null;
        }
        get formInfo() {
          let e = {
            hasFields: !1,
            hasAcroForm: !1,
            hasXfa: !1,
            hasSignatures: !1
          };
          let t = this.catalog.acroForm;
          if (!t) return r.shadow(this, "formInfo", e);
          try {
            let a = t.get("Fields");
            let r = Array.isArray(a) && a.length > 0;
            e.hasFields = r;
            let i = t.get("XFA");
            e.hasXfa = Array.isArray(i) && i.length > 0 || i instanceof c.BaseStream && !i.isEmpty;
            let n = t.get("SigFlags");
            let s = !!(1 & n);
            let o = s && this._hasOnlyDocumentSignatures(a);
            e.hasAcroForm = r && !o;
            e.hasSignatures = s;
          } catch (e) {
            if (e instanceof i.MissingDataException) throw e;
            r.warn(`Cannot fetch form information: "${e}".`);
          }
          return r.shadow(this, "formInfo", e);
        }
        get documentInfo() {
          let e;
          let t = this._version;
          "string" == typeof t && O.test(t) || (r.warn(`Invalid PDF header version number: ${t}`), t = null);
          let a = {
            PDFFormatVersion: t,
            Language: this.catalog.lang,
            EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null,
            IsLinearized: !!this.linearization,
            IsAcroFormPresent: this.formInfo.hasAcroForm,
            IsXFAPresent: this.formInfo.hasXfa,
            IsCollectionPresent: !!this.catalog.collection,
            IsSignaturesPresent: this.formInfo.hasSignatures
          };
          try {
            e = this.xref.trailer.get("Info");
          } catch (e) {
            if (e instanceof i.MissingDataException) throw e;
            r.info("The document information dictionary is invalid.");
          }
          if (!(e instanceof n.Dict)) return r.shadow(this, "documentInfo", a);
          for (let t of e.getKeys()) {
            let i = e.get(t);
            switch (t) {
              case "Title":
              case "Author":
              case "Subject":
              case "Keywords":
              case "Creator":
              case "Producer":
              case "CreationDate":
              case "ModDate":
                if ("string" == typeof i) {
                  a[t] = r.stringToPDFString(i);
                  continue;
                }
                break;
              case "Trapped":
                if (i instanceof n.Name) {
                  a[t] = i;
                  continue;
                }
                break;
              default:
                let s;
                switch (typeof i) {
                  case "string":
                    s = r.stringToPDFString(i);
                    break;
                  case "number":
                  case "boolean":
                    s = i;
                    break;
                  default:
                    i instanceof n.Name && (s = i);
                }
                if (void 0 === s) {
                  r.warn(`Bad value, for custom key "${t}", in Info: ${i}.`);
                  continue;
                }
                a.Custom || (a.Custom = Object.create(null));
                a.Custom[t] = s;
                continue;
            }
            r.warn(`Bad value, for key "${t}", in Info: ${i}.`);
          }
          return r.shadow(this, "documentInfo", a);
        }
        get fingerprints() {
          let e;
          let t;
          function a(e) {
            return "string" == typeof e && e.length > 0 && "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0" !== e;
          }
          function i(e) {
            let t = [];
            for (function () {
              let a = 0;
              let r = e.length;
            }(); a < r; a++) {
              let r = e[a].toString(16);
              t.push(r.padStart(2, "0"));
            }
            return t.join("");
          }
          let n = this.xref.trailer.get("ID");
          Array.isArray(n) && a(n[0]) ? (e = r.stringToBytes(n[0]), n[1] !== n[0] && a(n[1]) && (t = r.stringToBytes(n[1]))) : e = h.calculateMD5(this.stream.getByteRange(0, 1024), 0, 1024);
          return r.shadow(this, "fingerprints", [i(e), t ? i(t) : null]);
        }
        async _getLinearizationPage(e) {
          let {
            catalog,
            linearization,
            xref
          } = this;
          let s = n.Ref.get(linearization.objectNumberFirst, 0);
          try {
            let e = await xref.fetchAsync(s);
            if (e instanceof n.Dict) {
              let a = e.getRaw("Type");
              if (a instanceof n.Ref && (a = await xref.fetchAsync(a)), n.isName(a, "Page") || !e.has("Type") && !e.has("Kids")) {
                catalog.pageKidsCountCache.has(s) || catalog.pageKidsCountCache.put(s, 1);
                catalog.pageIndexCache.has(s) || catalog.pageIndexCache.put(s, 0);
                return [e, s];
              }
            }
            throw new r.FormatError("The Linearization dictionary doesn't point to a valid Page dictionary.");
          } catch (a) {
            r.warn(`_getLinearizationPage: "${a.message}".`);
            return catalog.getPageDict(e);
          }
        }
        getPage(e) {
          let t;
          let a = this._pagePromises.get(e);
          if (a) return a;
          let {
            catalog,
            linearization,
            xfaFactory
          } = this;
          t = (t = xfaFactory ? Promise.resolve([n.Dict.empty, null]) : linearization && linearization.pageFirst === e ? this._getLinearizationPage(e) : catalog.getPageDict(e)).then(([t, a]) => new k({
            pdfManager: this.pdfManager,
            xref: this.xref,
            pageIndex: e,
            pageDict: t,
            ref: a,
            globalIdFactory: this._globalIdFactory,
            fontCache: catalog.fontCache,
            builtInCMapCache: catalog.builtInCMapCache,
            standardFontDataCache: catalog.standardFontDataCache,
            globalImageCache: catalog.globalImageCache,
            nonBlendModesSet: catalog.nonBlendModesSet,
            xfaFactory
          }));
          this._pagePromises.set(e, t);
          return t;
        }
        async checkFirstPage(e = !1) {
          if (!e) try {
            await this.getPage(0);
          } catch (e) {
            if (e instanceof i.XRefEntryException) {
              this._pagePromises.$$delete(0);
              await this.cleanup();
              return new i.XRefParseException();
            }
          }
        }
        async checkLastPage(e = !1) {
          let t;
          let {
            catalog,
            pdfManager
          } = this;
          catalog.setActualNumPages();
          try {
            if (await Promise.all([pdfManager.ensureDoc("xfaFactory"), pdfManager.ensureDoc("linearization"), pdfManager.ensureCatalog("numPages")]), this.xfaFactory) return;
            if (t = this.linearization ? this.linearization.numPages : catalog.numPages, Number.isInteger(t)) {
              if (t <= 1) return;
            } else throw new r.FormatError("Page count is not an integer.");
            await this.getPage(t - 1);
          } catch (o) {
            let s;
            if (this._pagePromises.$$delete(t - 1), await this.cleanup(), o instanceof i.XRefEntryException && !e) throw new i.XRefParseException();
            r.warn(`checkLastPage - invalid /Pages tree /Count: ${t}.`);
            try {
              s = await catalog.getAllPageDicts(e);
            } catch (t) {
              if (t instanceof i.XRefEntryException && !e) throw new i.XRefParseException();
              catalog.setActualNumPages(1);
              return;
            }
            for (let [e, [t, r]] of s) {
              let i;
              t instanceof Error ? (i = Promise.reject(t)).catch(() => { }) : i = Promise.resolve(new k({
                pdfManager,
                xref: this.xref,
                pageIndex: e,
                pageDict: t,
                ref: r,
                globalIdFactory: this._globalIdFactory,
                fontCache: catalog.fontCache,
                builtInCMapCache: catalog.builtInCMapCache,
                standardFontDataCache: catalog.standardFontDataCache,
                globalImageCache: catalog.globalImageCache,
                nonBlendModesSet: catalog.nonBlendModesSet,
                xfaFactory: null
              }));
              this._pagePromises.set(e, i);
            }
            catalog.setActualNumPages(s.size);
          }
        }
        fontFallback(e, t) {
          return this.catalog.fontFallback(e, t);
        }
        async cleanup(e = !1) {
          return this.catalog ? this.catalog.cleanup(e) : d.clearGlobalCaches();
        }
        _collectFieldObjects(e, t, a) {
          let i = this.xref.fetchIfRef(t);
          if (i.has("T")) {
            let t = r.stringToPDFString(i.get("T"));
            e = "" === e ? t : `${e}.${t}`;
          }
          if (a.has(e) || a.set(e, []), a.get(e).push(l.AnnotationFactory.create(this.xref, t, this.pdfManager, this._localIdFactory, !0).then(e => e && e.getFieldObject()).catch(function (e) {
            r.warn(`_collectFieldObjects: "${e}".`);
            return null;
          })), i.has("Kids")) for (let t of i.get("Kids")) this._collectFieldObjects(e, t, a);
        }
        get fieldObjects() {
          if (!this.formInfo.hasFields) return r.shadow(this, "fieldObjects", Promise.resolve(null));
          let e = Object.create(null);
          let t = new Map();
          for (let e of this.catalog.acroForm.get("Fields")) this._collectFieldObjects("", e, t);
          let a = [];
          for (let [r, i] of t) a.push(Promise.all(i).then(t => {
            (t = t.filter(e => !!e)).length > 0 && (e[r] = t);
          }));
          return r.shadow(this, "fieldObjects", Promise.all(a).then(() => e));
        }
        get hasJSActions() {
          let e = this.pdfManager.ensureDoc("_parseHasJSActions");
          return r.shadow(this, "hasJSActions", e);
        }
        async _parseHasJSActions() {
          let [e, t] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);
          return !!e || !!t && Object.values(t).some(e => e.some(e => null !== e.actions));
        }
        get calculationOrderIds() {
          let e = this.catalog.acroForm;
          if (!e || !e.has("CO")) return r.shadow(this, "calculationOrderIds", null);
          let t = e.get("CO");
          if (!Array.isArray(t) || 0 === t.length) return r.shadow(this, "calculationOrderIds", null);
          let a = [];
          for (let e of t) e instanceof n.Ref && a.push(e.toString());
          return 0 === a.length ? r.shadow(this, "calculationOrderIds", null) : r.shadow(this, "calculationOrderIds", a);
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.getXfaFontDict = function (e) {
        let t = function (e) {
          let t;
          let a;
          let r = d(e);
          if (!r) return null;
          let {
            baseWidths,
            baseMapping,
            factors
          } = r;
          t = factors ? baseWidths.map((e, t) => e * factors[t]) : baseWidths;
          let o = -2;
          let l = [];
          for (let [e, r] of baseMapping.map((e, t) => [e, t]).sort(([e], [t]) => e - t)) -1 !== e && (e === o + 1 ? (a.push(t[r]), o += 1) : (o = e, a = [t[r]], l.push(e, a)));
          return l;
        }(e);
        let a = new i.Dict(null);
        a.set("BaseFont", i.Name.get(e));
        a.set("Type", i.Name.get("Font"));
        a.set("Subtype", i.Name.get("CIDFontType2"));
        a.set("Encoding", i.Name.get("Identity-H"));
        a.set("CIDToGIDMap", i.Name.get("Identity"));
        a.set("W", t);
        a.set("FirstChar", t[0]);
        a.set("LastChar", t[t.length - 2] + t[t.length - 1].length - 1);
        let r = new i.Dict(null);
        a.set("FontDescriptor", r);
        let n = new i.Dict(null);
        n.set("Ordering", "Identity");
        n.set("Registry", "Adobe");
        n.set("Supplement", 0);
        a.set("CIDSystemInfo", n);
        return a;
      };
      t.getXfaFontName = d;
      var r = a(13);
      var i = a(5);
      var n = a(14);
      var s = a(15);
      var o = a(16);
      var l = a(17);
      var c = a(8);
      var h = a(18);
      let u = c.getLookupTableFactory(function (e) {
        e["MyriadPro-Regular"] = e["PdfJS-Fallback-Regular"] = {
          name: "LiberationSans-Regular",
          factors: o.MyriadProRegularFactors,
          baseWidths: s.LiberationSansRegularWidths,
          baseMapping: s.LiberationSansRegularMapping,
          metrics: o.MyriadProRegularMetrics
        };
        e["MyriadPro-Bold"] = e["PdfJS-Fallback-Bold"] = {
          name: "LiberationSans-Bold",
          factors: o.MyriadProBoldFactors,
          baseWidths: s.LiberationSansBoldWidths,
          baseMapping: s.LiberationSansBoldMapping,
          metrics: o.MyriadProBoldMetrics
        };
        e["MyriadPro-It"] = e["MyriadPro-Italic"] = e["PdfJS-Fallback-Italic"] = {
          name: "LiberationSans-Italic",
          factors: o.MyriadProItalicFactors,
          baseWidths: s.LiberationSansItalicWidths,
          baseMapping: s.LiberationSansItalicMapping,
          metrics: o.MyriadProItalicMetrics
        };
        e["MyriadPro-BoldIt"] = e["MyriadPro-BoldItalic"] = e["PdfJS-Fallback-BoldItalic"] = {
          name: "LiberationSans-BoldItalic",
          factors: o.MyriadProBoldItalicFactors,
          baseWidths: s.LiberationSansBoldItalicWidths,
          baseMapping: s.LiberationSansBoldItalicMapping,
          metrics: o.MyriadProBoldItalicMetrics
        };
        e.ArialMT = e.Arial = e["Arial-Regular"] = {
          name: "LiberationSans-Regular",
          baseWidths: s.LiberationSansRegularWidths,
          baseMapping: s.LiberationSansRegularMapping
        };
        e["Arial-BoldMT"] = e["Arial-Bold"] = {
          name: "LiberationSans-Bold",
          baseWidths: s.LiberationSansBoldWidths,
          baseMapping: s.LiberationSansBoldMapping
        };
        e["Arial-ItalicMT"] = e["Arial-Italic"] = {
          name: "LiberationSans-Italic",
          baseWidths: s.LiberationSansItalicWidths,
          baseMapping: s.LiberationSansItalicMapping
        };
        e["Arial-BoldItalicMT"] = e["Arial-BoldItalic"] = {
          name: "LiberationSans-BoldItalic",
          baseWidths: s.LiberationSansBoldItalicWidths,
          baseMapping: s.LiberationSansBoldItalicMapping
        };
        e["Calibri-Regular"] = {
          name: "LiberationSans-Regular",
          factors: r.CalibriRegularFactors,
          baseWidths: s.LiberationSansRegularWidths,
          baseMapping: s.LiberationSansRegularMapping,
          metrics: r.CalibriRegularMetrics
        };
        e["Calibri-Bold"] = {
          name: "LiberationSans-Bold",
          factors: r.CalibriBoldFactors,
          baseWidths: s.LiberationSansBoldWidths,
          baseMapping: s.LiberationSansBoldMapping,
          metrics: r.CalibriBoldMetrics
        };
        e["Calibri-Italic"] = {
          name: "LiberationSans-Italic",
          factors: r.CalibriItalicFactors,
          baseWidths: s.LiberationSansItalicWidths,
          baseMapping: s.LiberationSansItalicMapping,
          metrics: r.CalibriItalicMetrics
        };
        e["Calibri-BoldItalic"] = {
          name: "LiberationSans-BoldItalic",
          factors: r.CalibriBoldItalicFactors,
          baseWidths: s.LiberationSansBoldItalicWidths,
          baseMapping: s.LiberationSansBoldItalicMapping,
          metrics: r.CalibriBoldItalicMetrics
        };
        e["Segoeui-Regular"] = {
          name: "LiberationSans-Regular",
          factors: l.SegoeuiRegularFactors,
          baseWidths: s.LiberationSansRegularWidths,
          baseMapping: s.LiberationSansRegularMapping,
          metrics: l.SegoeuiRegularMetrics
        };
        e["Segoeui-Bold"] = {
          name: "LiberationSans-Bold",
          factors: l.SegoeuiBoldFactors,
          baseWidths: s.LiberationSansBoldWidths,
          baseMapping: s.LiberationSansBoldMapping,
          metrics: l.SegoeuiBoldMetrics
        };
        e["Segoeui-Italic"] = {
          name: "LiberationSans-Italic",
          factors: l.SegoeuiItalicFactors,
          baseWidths: s.LiberationSansItalicWidths,
          baseMapping: s.LiberationSansItalicMapping,
          metrics: l.SegoeuiItalicMetrics
        };
        e["Segoeui-BoldItalic"] = {
          name: "LiberationSans-BoldItalic",
          factors: l.SegoeuiBoldItalicFactors,
          baseWidths: s.LiberationSansBoldItalicWidths,
          baseMapping: s.LiberationSansBoldItalicMapping,
          metrics: l.SegoeuiBoldItalicMetrics
        };
        e["Helvetica-Regular"] = e.Helvetica = {
          name: "LiberationSans-Regular",
          factors: n.HelveticaRegularFactors,
          baseWidths: s.LiberationSansRegularWidths,
          baseMapping: s.LiberationSansRegularMapping,
          metrics: n.HelveticaRegularMetrics
        };
        e["Helvetica-Bold"] = {
          name: "LiberationSans-Bold",
          factors: n.HelveticaBoldFactors,
          baseWidths: s.LiberationSansBoldWidths,
          baseMapping: s.LiberationSansBoldMapping,
          metrics: n.HelveticaBoldMetrics
        };
        e["Helvetica-Italic"] = {
          name: "LiberationSans-Italic",
          factors: n.HelveticaItalicFactors,
          baseWidths: s.LiberationSansItalicWidths,
          baseMapping: s.LiberationSansItalicMapping,
          metrics: n.HelveticaItalicMetrics
        };
        e["Helvetica-BoldItalic"] = {
          name: "LiberationSans-BoldItalic",
          factors: n.HelveticaBoldItalicFactors,
          baseWidths: s.LiberationSansBoldItalicWidths,
          baseMapping: s.LiberationSansBoldItalicMapping,
          metrics: n.HelveticaBoldItalicMetrics
        };
      });
      function d(e) {
        let t = h.normalizeFontName(e);
        return u()[t];
      }
    }, (e, t) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.CalibriRegularMetrics = t.CalibriRegularFactors = t.CalibriItalicMetrics = t.CalibriItalicFactors = t.CalibriBoldMetrics = t.CalibriBoldItalicMetrics = t.CalibriBoldItalicFactors = t.CalibriBoldFactors = void 0;
      t.CalibriBoldFactors = [1.3877, 1, 1, 1, .97801, .92482, .89552, .91133, .81988, .97566, .98152, .93548, .93548, 1.2798, .85284, .92794, 1, .96134, 1.54657, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .82845, .82845, .85284, .85284, .85284, .75859, .92138, .83908, .7762, .73293, .87289, .73133, .7514, .81921, .87356, .95958, .59526, .75727, .69225, 1.04924, .9121, .86943, .79795, .88198, .77958, .70864, .81055, .90399, .88653, .96017, .82577, .77892, .78257, .97507, 1.54657, .97507, .85284, .89552, .90176, .88762, .8785, .75241, .8785, .90518, .95015, .77618, .8785, .88401, .91916, .86304, .88401, .91488, .8785, .8801, .8785, .8785, .91343, .7173, 1.04106, .8785, .85075, .95794, .82616, .85162, .79492, .88331, 1.69808, .88331, .85284, .97801, .89552, .91133, .89552, .91133, 1.7801, .89552, 1.24487, 1.13254, 1.12401, .96839, .85284, .68787, .70645, .85592, .90747, 1.01466, 1.0088, .90323, 1, 1.07463, 1, .91056, .75806, 1.19118, .96839, .78864, .82845, .84133, .75859, .83908, .83908, .83908, .83908, .83908, .83908, .77539, .73293, .73133, .73133, .73133, .73133, .95958, .95958, .95958, .95958, .88506, .9121, .86943, .86943, .86943, .86943, .86943, .85284, .87508, .90399, .90399, .90399, .90399, .77892, .79795, .90807, .88762, .88762, .88762, .88762, .88762, .88762, .8715, .75241, .90518, .90518, .90518, .90518, .88401, .88401, .88401, .88401, .8785, .8785, .8801, .8801, .8801, .8801, .8801, .90747, .89049, .8785, .8785, .8785, .8785, .85162, .8785, .85162, .83908, .88762, .83908, .88762, .83908, .88762, .73293, .75241, .73293, .75241, .73293, .75241, .73293, .75241, .87289, .83016, .88506, .93125, .73133, .90518, .73133, .90518, .73133, .90518, .73133, .90518, .73133, .90518, .81921, .77618, .81921, .77618, .81921, .77618, 1, 1, .87356, .8785, .91075, .89608, .95958, .88401, .95958, .88401, .95958, .88401, .95958, .88401, .95958, .88401, .76229, .90167, .59526, .91916, 1, 1, .86304, .69225, .88401, 1, 1, .70424, .79468, .91926, .88175, .70823, .94903, .9121, .8785, 1, 1, .9121, .8785, .87802, .88656, .8785, .86943, .8801, .86943, .8801, .86943, .8801, .87402, .89291, .77958, .91343, 1, 1, .77958, .91343, .70864, .7173, .70864, .7173, .70864, .7173, .70864, .7173, 1, 1, .81055, .75841, .81055, 1.06452, .90399, .8785, .90399, .8785, .90399, .8785, .90399, .8785, .90399, .8785, .90399, .8785, .96017, .95794, .77892, .85162, .77892, .78257, .79492, .78257, .79492, .78257, .79492, .9297, .56892, .83908, .88762, .77539, .8715, .87508, .89049, 1, 1, .81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, .70674, .98387, .94721, 1.33431, 1.45894, .95161, 1.06303, .83908, .80352, .57184, .6965, .56289, .82001, .56029, .81235, 1.02988, .83908, .7762, .68156, .80367, .73133, .78257, .87356, .86943, .95958, .75727, .89019, 1.04924, .9121, .7648, .86943, .87356, .79795, .78275, .81055, .77892, .9762, .82577, .99819, .84896, .95958, .77892, .96108, 1.01407, .89049, 1.02988, .94211, .96108, .8936, .84021, .87842, .96399, .79109, .89049, 1.00813, 1.02988, .86077, .87445, .92099, .84723, .86513, .8801, .75638, .85714, .78216, .79586, .87965, .94211, .97747, .78287, .97926, .84971, 1.02988, .94211, .8801, .94211, .84971, .73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .90548, 1, 1, 1, 1, 1, 1, .96017, .95794, .96017, .95794, .96017, .95794, .77892, .85162, 1, 1, .89552, .90527, 1, .90363, .92794, .92794, .92794, .92794, .87012, .87012, .87012, .89552, .89552, 1.42259, .71143, 1.06152, 1, 1, 1.03372, 1.03372, .97171, 1.4956, 2.2807, .93835, .83406, .91133, .84107, .91133, 1, 1, 1, .72021, 1, 1.23108, .83489, .88525, .88525, .81499, .90527, 1.81055, .90527, 1.81055, 1.31006, 1.53711, .94434, 1.08696, 1, .95018, .77192, .85284, .90747, 1.17534, .69825, .9716, 1.37077, .90747, .90747, .85356, .90747, .90747, 1.44947, .85284, .8941, .8941, .70572, .8, .70572, .70572, .70572, .70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .99862, .99862, 1, 1, 1, 1, 1, 1.08004, .91027, 1, 1, 1, .99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .90727, .90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
      t.CalibriBoldMetrics = {
        lineHeight: 1.2207,
        lineGap: .2207
      };
      t.CalibriBoldItalicFactors = [1.3877, 1, 1, 1, .97801, .92482, .89552, .91133, .81988, .97566, .98152, .93548, .93548, 1.2798, .85284, .92794, 1, .96134, 1.56239, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .82845, .82845, .85284, .85284, .85284, .75859, .92138, .83908, .7762, .71805, .87289, .73133, .7514, .81921, .87356, .95958, .59526, .75727, .69225, 1.04924, .90872, .85938, .79795, .87068, .77958, .69766, .81055, .90399, .88653, .96068, .82577, .77892, .78257, .97507, 1.529, .97507, .85284, .89552, .90176, .94908, .86411, .74012, .86411, .88323, .95015, .86411, .86331, .88401, .91916, .86304, .88401, .9039, .86331, .86331, .86411, .86411, .90464, .70852, 1.04106, .86331, .84372, .95794, .82616, .84548, .79492, .88331, 1.69808, .88331, .85284, .97801, .89552, .91133, .89552, .91133, 1.7801, .89552, 1.24487, 1.13254, 1.19129, .96839, .85284, .68787, .70645, .85592, .90747, 1.01466, 1.0088, .90323, 1, 1.07463, 1, .91056, .75806, 1.19118, .96839, .78864, .82845, .84133, .75859, .83908, .83908, .83908, .83908, .83908, .83908, .77539, .71805, .73133, .73133, .73133, .73133, .95958, .95958, .95958, .95958, .88506, .90872, .85938, .85938, .85938, .85938, .85938, .85284, .87068, .90399, .90399, .90399, .90399, .77892, .79795, .90807, .94908, .94908, .94908, .94908, .94908, .94908, .85887, .74012, .88323, .88323, .88323, .88323, .88401, .88401, .88401, .88401, .8785, .86331, .86331, .86331, .86331, .86331, .86331, .90747, .89049, .86331, .86331, .86331, .86331, .84548, .86411, .84548, .83908, .94908, .83908, .94908, .83908, .94908, .71805, .74012, .71805, .74012, .71805, .74012, .71805, .74012, .87289, .79538, .88506, .92726, .73133, .88323, .73133, .88323, .73133, .88323, .73133, .88323, .73133, .88323, .81921, .86411, .81921, .86411, .81921, .86411, 1, 1, .87356, .86331, .91075, .8777, .95958, .88401, .95958, .88401, .95958, .88401, .95958, .88401, .95958, .88401, .76467, .90167, .59526, .91916, 1, 1, .86304, .69225, .88401, 1, 1, .70424, .77312, .91926, .88175, .70823, .94903, .90872, .86331, 1, 1, .90872, .86331, .86906, .88116, .86331, .85938, .86331, .85938, .86331, .85938, .86331, .87402, .86549, .77958, .90464, 1, 1, .77958, .90464, .69766, .70852, .69766, .70852, .69766, .70852, .69766, .70852, 1, 1, .81055, .75841, .81055, 1.06452, .90399, .86331, .90399, .86331, .90399, .86331, .90399, .86331, .90399, .86331, .90399, .86331, .96068, .95794, .77892, .84548, .77892, .78257, .79492, .78257, .79492, .78257, .79492, .9297, .56892, .83908, .94908, .77539, .85887, .87068, .89049, 1, 1, .81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, .70088, .98387, .94721, 1.33431, 1.45894, .95161, 1.48387, .83908, .80352, .57118, .6965, .56347, .79179, .55853, .80346, 1.02988, .83908, .7762, .67174, .86036, .73133, .78257, .87356, .86441, .95958, .75727, .89019, 1.04924, .90872, .74889, .85938, .87891, .79795, .7957, .81055, .77892, .97447, .82577, .97466, .87179, .95958, .77892, .94252, .95612, .8753, 1.02988, .92733, .94252, .87411, .84021, .8728, .95612, .74081, .8753, 1.02189, 1.02988, .84814, .87445, .91822, .84723, .85668, .86331, .81344, .87581, .76422, .82046, .96057, .92733, .99375, .78022, .95452, .86015, 1.02988, .92733, .86331, .92733, .86015, .73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .85174, 1, 1, 1, 1, 1, 1, .96068, .95794, .96068, .95794, .96068, .95794, .77892, .84548, 1, 1, .89552, .90527, 1, .90363, .92794, .92794, .92794, .89807, .87012, .87012, .87012, .89552, .89552, 1.42259, .71094, 1.06152, 1, 1, 1.03372, 1.03372, .97171, 1.4956, 2.2807, .92972, .83406, .91133, .83326, .91133, 1, 1, 1, .72021, 1, 1.23108, .83489, .88525, .88525, .81499, .90616, 1.81055, .90527, 1.81055, 1.3107, 1.53711, .94434, 1.08696, 1, .95018, .77192, .85284, .90747, 1.17534, .69825, .9716, 1.37077, .90747, .90747, .85356, .90747, .90747, 1.44947, .85284, .8941, .8941, .70572, .8, .70572, .70572, .70572, .70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .99862, .99862, 1, 1, 1, 1, 1, 1.08004, .91027, 1, 1, 1, .99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .90727, .90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
      t.CalibriBoldItalicMetrics = {
        lineHeight: 1.2207,
        lineGap: .2207
      };
      t.CalibriItalicFactors = [1.3877, 1, 1, 1, 1.17223, 1.1293, .89552, .91133, .80395, 1.02269, 1.15601, .91056, .91056, 1.2798, .85284, .89807, 1, .90861, 1.39543, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .96309, .96309, .85284, .85284, .85284, .83319, .88071, .8675, .81552, .72346, .85193, .73206, .7522, .81105, .86275, .90685, .6377, .77892, .75593, 1.02638, .89249, .84118, .77452, .85374, .75186, .67789, .79776, .88844, .85066, .94309, .77818, .7306, .76659, 1.10369, 1.38313, 1.10369, 1.06139, .89552, .8739, .9245, .9245, .83203, .9245, .85865, 1.09842, .9245, .9245, 1.03297, 1.07692, .90918, 1.03297, .94959, .9245, .92274, .9245, .9245, 1.02933, .77832, 1.20562, .9245, .8916, .98986, .86621, .89453, .79004, .94152, 1.77256, .94152, .85284, .97801, .89552, .91133, .89552, .91133, 1.91729, .89552, 1.17889, 1.13254, 1.16359, .92098, .85284, .68787, .71353, .84737, .90747, 1.0088, 1.0044, .87683, 1, 1.09091, 1, .92229, .739, 1.15642, .92098, .76288, .80504, .80972, .75859, .8675, .8675, .8675, .8675, .8675, .8675, .76318, .72346, .73206, .73206, .73206, .73206, .90685, .90685, .90685, .90685, .86477, .89249, .84118, .84118, .84118, .84118, .84118, .85284, .84557, .88844, .88844, .88844, .88844, .7306, .77452, .86331, .9245, .9245, .9245, .9245, .9245, .9245, .84843, .83203, .85865, .85865, .85865, .85865, .82601, .82601, .82601, .82601, .94469, .9245, .92274, .92274, .92274, .92274, .92274, .90747, .86651, .9245, .9245, .9245, .9245, .89453, .9245, .89453, .8675, .9245, .8675, .9245, .8675, .9245, .72346, .83203, .72346, .83203, .72346, .83203, .72346, .83203, .85193, .8875, .86477, .99034, .73206, .85865, .73206, .85865, .73206, .85865, .73206, .85865, .73206, .85865, .81105, .9245, .81105, .9245, .81105, .9245, 1, 1, .86275, .9245, .90872, .93591, .90685, .82601, .90685, .82601, .90685, .82601, .90685, 1.03297, .90685, .82601, .77896, 1.05611, .6377, 1.07692, 1, 1, .90918, .75593, 1.03297, 1, 1, .76032, .9375, .98156, .93407, .77261, 1.11429, .89249, .9245, 1, 1, .89249, .9245, .92534, .86698, .9245, .84118, .92274, .84118, .92274, .84118, .92274, .8667, .86291, .75186, 1.02933, 1, 1, .75186, 1.02933, .67789, .77832, .67789, .77832, .67789, .77832, .67789, .77832, 1, 1, .79776, .97655, .79776, 1.23023, .88844, .9245, .88844, .9245, .88844, .9245, .88844, .9245, .88844, .9245, .88844, .9245, .94309, .98986, .7306, .89453, .7306, .76659, .79004, .76659, .79004, .76659, .79004, 1.09231, .54873, .8675, .9245, .76318, .84843, .84557, .86651, 1, 1, .79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, .67009, .96334, .93695, 1.35191, 1.40909, .95161, 1.48387, .8675, .90861, .6192, .7363, .64824, .82411, .56321, .85696, 1.23516, .8675, .81552, .7286, .84134, .73206, .76659, .86275, .84369, .90685, .77892, .85871, 1.02638, .89249, .75828, .84118, .85984, .77452, .76466, .79776, .7306, .90782, .77818, .903, .87291, .90685, .7306, .99058, 1.03667, .94635, 1.23516, .9849, .99058, .92393, .8916, .942, 1.03667, .75026, .94635, 1.0297, 1.23516, .90918, .94048, .98217, .89746, .84153, .92274, .82507, .88832, .84438, .88178, 1.03525, .9849, 1.00225, .78086, .97248, .89404, 1.23516, .9849, .92274, .9849, .89404, .73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .90933, 1, 1, 1, 1, 1, 1, .94309, .98986, .94309, .98986, .94309, .98986, .7306, .89453, 1, 1, .89552, .90527, 1, .90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, .89552, .89552, 1.42259, .68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, .97858, .82616, .91133, .83437, .91133, 1, 1, 1, .70508, 1, 1.23108, .79801, .84426, .84426, .774, .90572, 1.81055, .90749, 1.81055, 1.28809, 1.55469, .94434, 1.07806, 1, .97094, .7589, .85284, .90747, 1.19658, .69825, .97622, 1.33512, .90747, .90747, .85284, .90747, .90747, 1.44947, .85284, .8941, .8941, .70572, .8, .70572, .70572, .70572, .70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .99862, .99862, 1, 1, 1, 1, 1, 1.0336, .91027, 1, 1, 1, .99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
      t.CalibriItalicMetrics = {
        lineHeight: 1.2207,
        lineGap: .2207
      };
      t.CalibriRegularFactors = [1.3877, 1, 1, 1, 1.17223, 1.1293, .89552, .91133, .80395, 1.02269, 1.15601, .91056, .91056, 1.2798, .85284, .89807, 1, .90861, 1.39016, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .96309, .96309, .85284, .85284, .85284, .83319, .88071, .8675, .81552, .73834, .85193, .73206, .7522, .81105, .86275, .90685, .6377, .77892, .75593, 1.02638, .89385, .85122, .77452, .86503, .75186, .68887, .79776, .88844, .85066, .94258, .77818, .7306, .76659, 1.10369, 1.39016, 1.10369, 1.06139, .89552, .8739, .86128, .94469, .8457, .94469, .89464, 1.09842, .84636, .94469, 1.03297, 1.07692, .90918, 1.03297, .95897, .94469, .9482, .94469, .94469, 1.04692, .78223, 1.20562, .94469, .90332, .98986, .86621, .90527, .79004, .94152, 1.77256, .94152, .85284, .97801, .89552, .91133, .89552, .91133, 1.91729, .89552, 1.17889, 1.13254, 1.08707, .92098, .85284, .68787, .71353, .84737, .90747, 1.0088, 1.0044, .87683, 1, 1.09091, 1, .92229, .739, 1.15642, .92098, .76288, .80504, .80972, .75859, .8675, .8675, .8675, .8675, .8675, .8675, .76318, .73834, .73206, .73206, .73206, .73206, .90685, .90685, .90685, .90685, .86477, .89385, .85122, .85122, .85122, .85122, .85122, .85284, .85311, .88844, .88844, .88844, .88844, .7306, .77452, .86331, .86128, .86128, .86128, .86128, .86128, .86128, .8693, .8457, .89464, .89464, .89464, .89464, .82601, .82601, .82601, .82601, .94469, .94469, .9482, .9482, .9482, .9482, .9482, .90747, .86651, .94469, .94469, .94469, .94469, .90527, .94469, .90527, .8675, .86128, .8675, .86128, .8675, .86128, .73834, .8457, .73834, .8457, .73834, .8457, .73834, .8457, .85193, .92454, .86477, .9921, .73206, .89464, .73206, .89464, .73206, .89464, .73206, .89464, .73206, .89464, .81105, .84636, .81105, .84636, .81105, .84636, 1, 1, .86275, .94469, .90872, .95786, .90685, .82601, .90685, .82601, .90685, .82601, .90685, 1.03297, .90685, .82601, .77741, 1.05611, .6377, 1.07692, 1, 1, .90918, .75593, 1.03297, 1, 1, .76032, .90452, .98156, 1.11842, .77261, 1.11429, .89385, .94469, 1, 1, .89385, .94469, .95877, .86901, .94469, .85122, .9482, .85122, .9482, .85122, .9482, .8667, .90016, .75186, 1.04692, 1, 1, .75186, 1.04692, .68887, .78223, .68887, .78223, .68887, .78223, .68887, .78223, 1, 1, .79776, .92188, .79776, 1.23023, .88844, .94469, .88844, .94469, .88844, .94469, .88844, .94469, .88844, .94469, .88844, .94469, .94258, .98986, .7306, .90527, .7306, .76659, .79004, .76659, .79004, .76659, .79004, 1.09231, .54873, .8675, .86128, .76318, .8693, .85311, .86651, 1, 1, .79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, .67742, .96334, .93695, 1.35191, 1.40909, .95161, 1.48387, .86686, .90861, .62267, .74359, .65649, .85498, .56963, .88254, 1.23516, .8675, .81552, .75443, .84503, .73206, .76659, .86275, .85122, .90685, .77892, .85746, 1.02638, .89385, .75657, .85122, .86275, .77452, .74171, .79776, .7306, .95165, .77818, .89772, .88831, .90685, .7306, .98142, 1.02191, .96576, 1.23516, .99018, .98142, .9236, .89258, .94035, 1.02191, .78848, .96576, .9561, 1.23516, .90918, .92578, .95424, .89746, .83969, .9482, .80113, .89442, .85208, .86155, .98022, .99018, 1.00452, .81209, .99247, .89181, 1.23516, .99018, .9482, .99018, .89181, .73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .96766, 1, 1, 1, 1, 1, 1, .94258, .98986, .94258, .98986, .94258, .98986, .7306, .90527, 1, 1, .89552, .90527, 1, .90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, .89552, .89552, 1.42259, .69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, .99331, .82616, .91133, .84286, .91133, 1, 1, 1, .70508, 1, 1.23108, .79801, .84426, .84426, .774, .90527, 1.81055, .90527, 1.81055, 1.28809, 1.55469, .94434, 1.07806, 1, .97094, .7589, .85284, .90747, 1.19658, .69825, .97622, 1.33512, .90747, .90747, .85356, .90747, .90747, 1.44947, .85284, .8941, .8941, .70572, .8, .70572, .70572, .70572, .70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .99862, .99862, 1, 1, 1, 1, 1, 1.0336, .91027, 1, 1, 1, .99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, .99413, .96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
      t.CalibriRegularMetrics = {
        lineHeight: 1.2207,
        lineGap: .2207
      };
    }, (e, t) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.HelveticaRegularMetrics = t.HelveticaRegularFactors = t.HelveticaItalicMetrics = t.HelveticaItalicFactors = t.HelveticaBoldMetrics = t.HelveticaBoldItalicMetrics = t.HelveticaBoldItalicFactors = t.HelveticaBoldFactors = void 0;
      t.HelveticaBoldFactors = [.76116, 1, 1, 1.0006, .99998, .99974, .99973, .99973, .99982, .99977, 1.00087, .99998, .99998, .99959, 1.00003, 1.0006, .99998, 1.0006, 1.0006, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, .9999, .99977, .99977, .99977, .99977, 1.00001, 1.00026, 1.00022, .99977, 1.0006, .99973, .99977, 1.00026, .99999, .99977, 1.00022, 1.00001, 1.00022, .99977, 1.00001, 1.00026, .99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, .99998, 1.0006, .99998, 1.00003, .99973, .99998, .99973, 1.00026, .99973, 1.00026, .99973, .99998, 1.00026, 1.00026, 1.0006, 1.0006, .99973, 1.0006, .99982, 1.00026, 1.00026, 1.00026, 1.00026, .99959, .99973, .99998, 1.00026, .99973, 1.00022, .99973, .99973, 1, .99959, 1.00077, .99959, 1.00003, .99998, .99973, .99973, .99973, .99973, 1.00077, .99973, .99998, 1.00025, .99968, .99973, 1.00003, 1.00025, .60299, 1.00024, 1.06409, 1, 1, .99998, 1, .99973, 1.0006, .99998, 1, .99936, .99973, 1.00002, 1.00002, 1.00002, 1.00026, .99977, .99977, .99977, .99977, .99977, .99977, 1, .99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, .99977, .99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, .99977, .99977, .99977, .99977, 1.00001, 1.00001, 1.00026, .99973, .99973, .99973, .99973, .99973, .99973, .99982, .99973, .99973, .99973, .99973, .99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, .99973, 1.00026, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, 1.03374, .99977, 1.00026, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, .99977, 1.00026, .99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, .99973, .99973, 1.0006, .99977, .99973, .99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, .99999, 1.00026, 1.0006, .99977, 1.00026, .99977, 1.00026, .99977, 1.00026, .9993, .9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, .99977, .99959, .99977, .99959, .99977, .99959, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00026, .99998, 1.00026, .8121, 1.00026, .99998, .99977, 1.00026, .99977, 1.00026, .99977, 1.00026, .99977, 1.00026, .99977, 1.00026, .99977, 1.00026, 1.00016, 1.00022, 1.00001, .99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, .99973, .99977, .99973, 1, .99982, 1.00022, 1.00026, 1.00001, .99973, 1.00026, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, 1.00034, .99977, 1, .99997, 1.00026, 1.00078, 1.00036, .99973, 1.00013, 1.0006, .99977, .99977, .99988, .85148, 1.00001, 1.00026, .99977, 1.00022, 1.0006, .99977, 1.00001, .99999, .99977, 1.00069, 1.00022, .99977, 1.00001, .99984, 1.00026, 1.00001, 1.00024, 1.00001, .9999, 1, 1.0006, 1.00001, 1.00041, .99962, 1.00026, 1.0006, .99995, 1.00041, .99942, .99973, .99927, 1.00082, .99902, 1.00026, 1.00087, 1.0006, 1.00069, .99973, .99867, .99973, .9993, 1.00026, 1.00049, 1.00056, 1, .99988, .99935, .99995, .99954, 1.00055, .99945, 1.00032, 1.0006, .99995, 1.00026, .99995, 1.00032, 1.00001, 1.00008, .99971, 1.00019, .9994, 1.00001, 1.0006, 1.00044, .99973, 1.00023, 1.00047, 1, .99942, .99561, .99989, 1.00035, .99977, 1.00035, .99977, 1.00019, .99944, 1.00001, 1.00021, .99926, 1.00035, 1.00035, .99942, 1.00048, .99999, .99977, 1.00022, 1.00035, 1.00001, .99977, 1.00026, .99989, 1.00057, 1.00001, .99936, 1.00052, 1.00012, .99996, 1.00043, 1, 1.00035, .9994, .99976, 1.00035, .99973, 1.00052, 1.00041, 1.00119, 1.00037, .99973, 1.00002, .99986, 1.00041, 1.00041, .99902, .9996, 1.00034, .99999, 1.00026, .99999, 1.00026, .99973, 1.00052, .99973, 1, .99973, 1.00041, 1.00075, .9994, 1.0003, .99999, 1, 1.00041, .99955, 1, .99915, .99973, .99973, 1.00026, 1.00119, .99955, .99973, 1.0006, .99911, 1.0006, 1.00026, .99972, 1.00026, .99902, 1.00041, .99973, .99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, .99973, 1, 1, .99973, 1, 1, .99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, .99973, .99973, .99972, 1, 1, 1.00106, .99999, .99998, .99998, .99999, .99998, 1.66475, 1, .99973, .99973, 1.00023, .99973, .99971, 1.00047, 1.00023, 1, .99991, .99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, .99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, .99561, 1.00027, 1.00031, 1.00031, .99915, 1.00031, 1.00031, .99999, 1.00003, .99999, .99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, .99999, 1, .99861, .99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, .99972, .99999, .99999, .99999, .99999, 1.40483, 1, .99977, 1.00054, 1, 1, .99953, .99962, 1.00042, .9995, 1, 1, 1, 1, 1, 1, 1, 1, .99998, .99998, .99998, .99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
      t.HelveticaBoldMetrics = {
        lineHeight: 1.2,
        lineGap: .2
      };
      t.HelveticaBoldItalicFactors = [.76116, 1, 1, 1.0006, .99998, .99974, .99973, .99973, .99982, .99977, 1.00087, .99998, .99998, .99959, 1.00003, 1.0006, .99998, 1.0006, 1.0006, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, .9999, .99977, .99977, .99977, .99977, 1.00001, 1.00026, 1.00022, .99977, 1.0006, .99973, .99977, 1.00026, .99999, .99977, 1.00022, 1.00001, 1.00022, .99977, 1.00001, 1.00026, .99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, .99998, 1.0006, .99998, 1.00003, .99973, .99998, .99973, 1.00026, .99973, 1.00026, .99973, .99998, 1.00026, 1.00026, 1.0006, 1.0006, .99973, 1.0006, .99982, 1.00026, 1.00026, 1.00026, 1.00026, .99959, .99973, .99998, 1.00026, .99973, 1.00022, .99973, .99973, 1, .99959, 1.00077, .99959, 1.00003, .99998, .99973, .99973, .99973, .99973, 1.00077, .99973, .99998, 1.00025, .99968, .99973, 1.00003, 1.00025, .60299, 1.00024, 1.06409, 1, 1, .99998, 1, .99973, 1.0006, .99998, 1, .99936, .99973, 1.00002, 1.00002, 1.00002, 1.00026, .99977, .99977, .99977, .99977, .99977, .99977, 1, .99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, .99977, .99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, .99977, .99977, .99977, .99977, 1.00001, 1.00001, 1.00026, .99973, .99973, .99973, .99973, .99973, .99973, .99982, .99973, .99973, .99973, .99973, .99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, .99973, 1.00026, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, 1.0044, .99977, 1.00026, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, .99977, 1.00026, .99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, .99971, .99973, .99973, 1.0006, .99977, .99973, .99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, .99999, 1.00026, 1.0006, .99977, 1.00026, .99977, 1.00026, .99977, 1.00026, .9993, .9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, .99977, .99959, .99977, .99959, .99977, .99959, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00026, .99998, 1.00026, .8121, 1.00026, .99998, .99977, 1.00026, .99977, 1.00026, .99977, 1.00026, .99977, 1.00026, .99977, 1.00026, .99977, 1.00026, 1.00016, 1.00022, 1.00001, .99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, .99973, .99977, .99973, 1, .99982, 1.00022, 1.00026, 1.00001, .99973, 1.00026, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99977, 1, 1, 1.00026, .99969, .99972, .99981, .9998, 1.0006, .99977, .99977, 1.00022, .91155, 1.00001, 1.00026, .99977, 1.00022, 1.0006, .99977, 1.00001, .99999, .99977, .99966, 1.00022, 1.00032, 1.00001, .99944, 1.00026, 1.00001, .99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, .99981, 1.00101, 1.00026, 1.0006, .99948, .99981, 1.00064, .99973, .99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, .99973, 1.01322, .99973, 1.00065, 1.00026, 1.00012, .99923, 1, 1.00064, 1.00076, .99948, 1.00055, 1.00063, 1.00007, .99943, 1.0006, .99948, 1.00026, .99948, .99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, .99973, .99978, 1.00001, 1.00057, .99989, .99967, .99964, .99967, .99977, .99999, .99977, 1.00038, .99977, 1.00001, .99973, 1.00066, .99967, .99967, 1.00041, .99998, .99999, .99977, 1.00022, .99967, 1.00001, .99977, 1.00026, .99964, 1.00031, 1.00001, .99999, .99999, 1, 1.00023, 1, 1, .99999, 1.00035, 1.00001, .99999, .99973, .99977, .99999, 1.00058, .99973, .99973, .99955, .9995, 1.00026, 1.00026, 1.00032, .99989, 1.00034, .99999, 1.00026, 1.00026, 1.00026, .99973, .45998, .99973, 1.00026, .99973, 1.00001, .99999, .99982, .99994, .99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, .99973, .99973, 1.00026, .99949, 1.00002, .99973, 1.0006, 1.0006, 1.0006, .99975, 1.00026, 1.00026, 1.00032, .98685, .99973, 1.00026, 1, 1, .99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, .99973, 1, 1, .99973, 1, 1, .99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, .99973, .99973, .99972, 1, 1, 1.00106, .99999, .99998, .99998, .99999, .99998, 1.66475, 1, .99973, .99973, 1, .99973, .99971, .99978, 1, 1, .99991, .99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, .99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, .99561, 1.00027, 1.00031, 1.00031, .99915, 1.00031, 1.00031, .99999, 1.00003, .99999, .99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, .99999, 1, .99861, .99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, .99972, .99999, .99999, .99999, .99999, 1.40483, 1, .99977, 1.00054, 1, 1, .99953, .99962, 1.00042, .9995, 1, 1, 1, 1, 1, 1, 1, 1, .99998, .99998, .99998, .99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
      t.HelveticaBoldItalicMetrics = {
        lineHeight: 1.35,
        lineGap: .2
      };
      t.HelveticaItalicFactors = [.76116, 1, 1, 1.0006, 1.0006, 1.00006, .99973, .99973, .99982, 1.00001, 1.00043, .99998, .99998, .99959, 1.00003, 1.0006, .99998, 1.0006, 1.0006, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, .99973, .99987, 1.00001, 1.00001, .99977, .99977, 1.00001, 1.00026, 1.00022, .99977, 1.0006, 1, 1.00001, .99973, .99999, .99977, 1.00022, 1.00001, 1.00022, .99977, 1.00001, 1.00026, .99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, .99949, .99973, .99998, .99973, .99973, 1, .99973, .99973, 1.0006, .99973, .99973, .99924, .99924, 1, .99924, .99999, .99973, .99973, .99973, .99973, .99998, 1, 1.0006, .99973, 1, .99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, .99998, .99973, .99973, .99973, .99973, 1.0009, .99973, .99998, 1.00025, .99968, .99973, 1.00003, 1.00025, .60299, 1.00024, 1.06409, 1, 1, .99998, 1, .9998, 1.0006, .99998, 1, .99936, .99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, .99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, .99977, .99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, .99977, .99977, .99977, .99977, 1.00001, 1.00001, 1.00026, .99973, .99973, .99973, .99973, .99973, .99973, .99982, 1, .99973, .99973, .99973, .99973, 1.0006, 1.0006, 1.0006, 1.0006, .99973, .99973, .99973, .99973, .99973, .99973, .99973, 1.06409, 1.00026, .99973, .99973, .99973, .99973, 1, .99973, 1, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, .99977, 1, .99977, 1, .99977, 1, .99977, 1, .99977, 1.0288, .99977, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00022, .99973, 1.00022, .99973, 1.00022, .99973, 1.00022, .99973, .99977, .99973, .99977, .99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, .99924, 1.0006, 1.0006, .99946, 1.00034, 1, .99924, 1.00001, 1, 1, .99973, .99924, .99973, .99924, .99973, 1.06311, .99973, 1.00024, .99973, .99924, .99977, .99973, .99977, .99973, .99977, .99973, 1.00041, .9998, .99973, 1.00022, .99973, 1.00022, .99973, 1.00022, .99973, 1, 1.00016, .99977, .99998, .99977, .99998, .99977, .99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, .89547, 1.00026, 1.0006, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, 1.00016, .99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, .99924, .99973, 1.00001, .99973, 1, .99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, 1.00001, 1, 1.00054, .99977, 1.00084, 1.00007, .99973, 1.00013, .99924, 1.00001, 1.00001, .99945, .91221, 1.00001, 1.00026, .99977, 1.00022, 1.0006, 1.00001, 1.00001, .99999, .99977, .99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, .99945, .99897, .99968, .99924, 1.00036, .99945, .99949, 1, 1.0006, .99897, .99918, .99968, .99911, .99924, 1, .99962, 1.01487, 1, 1.0005, .99973, 1.00012, 1.00043, 1, .99995, .99994, 1.00036, .99947, 1.00019, 1.00063, 1.00025, .99924, 1.00036, .99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, .99957, .99972, .9994, .99954, .99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, .99986, 1.00001, 1.00001, 1.00038, .99954, .99954, .9994, 1.00066, .99999, .99977, 1.00022, 1.00054, 1.00001, .99977, 1.00026, .99975, 1.0001, 1.00001, .99993, .9995, .99955, 1.00016, .99978, .99974, 1.00019, 1.00022, .99955, 1.00053, .99973, 1.00089, 1.00005, .99967, 1.00048, .99973, 1.00002, 1.00034, .99973, .99973, .99964, 1.00006, 1.00066, .99947, .99973, .98894, .99973, 1, .44898, 1, .99946, 1, 1.00039, 1.00082, .99991, .99991, .99985, 1.00022, 1.00023, 1.00061, 1.00006, .99966, .99973, .99973, .99973, 1.00019, 1.0008, 1, .99924, .99924, .99924, .99983, 1.00044, .99973, .99964, .98332, 1, .99973, 1, 1, .99962, .99895, 1.00016, .99977, 1.00016, .99977, 1.00016, .99977, 1.00001, 1, 1, 1, .99973, 1, 1, .99955, .99924, .99924, .99924, .99924, .99998, .99998, .99998, .99973, .99973, .99972, 1, 1, 1.00267, .99999, .99998, .99998, 1, .99998, 1.66475, 1, .99973, .99973, 1.00023, .99973, 1.00423, .99925, .99999, 1, .99991, .99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, .96329, 1, 1.20985, 1.39713, 1.00003, .8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, .99999, 1.00003, .99999, .99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, .99999, 1, .99861, .99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, .95317, .99999, .99999, .99999, .99999, 1.40483, 1, .99977, 1.00054, 1, 1, .99953, .99962, 1.00042, .9995, 1, 1, 1, 1, 1, 1, 1, 1, .99998, .99998, .99998, .99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
      t.HelveticaItalicMetrics = {
        lineHeight: 1.35,
        lineGap: .2
      };
      t.HelveticaRegularFactors = [.76116, 1, 1, 1.0006, 1.0006, 1.00006, .99973, .99973, .99982, 1.00001, 1.00043, .99998, .99998, .99959, 1.00003, 1.0006, .99998, 1.0006, 1.0006, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, .99973, .99987, 1.00001, 1.00001, .99977, .99977, 1.00001, 1.00026, 1.00022, .99977, 1.0006, 1, 1.00001, .99973, .99999, .99977, 1.00022, 1.00001, 1.00022, .99977, 1.00001, 1.00026, .99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, .99949, .99973, .99998, .99973, .99973, 1, .99973, .99973, 1.0006, .99973, .99973, .99924, .99924, 1, .99924, .99999, .99973, .99973, .99973, .99973, .99998, 1, 1.0006, .99973, 1, .99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, .99998, .99973, .99973, .99973, .99973, 1.0009, .99973, .99998, 1.00025, .99968, .99973, 1.00003, 1.00025, .60299, 1.00024, 1.06409, 1, 1, .99998, 1, .9998, 1.0006, .99998, 1, .99936, .99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, .99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, .99977, .99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, .99977, .99977, .99977, .99977, 1.00001, 1.00001, 1.00026, .99973, .99973, .99973, .99973, .99973, .99973, .99982, 1, .99973, .99973, .99973, .99973, 1.0006, 1.0006, 1.0006, 1.0006, .99973, .99973, .99973, .99973, .99973, .99973, .99973, 1.06409, 1.00026, .99973, .99973, .99973, .99973, 1, .99973, 1, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, .99977, 1, .99977, 1, .99977, 1, .99977, 1, .99977, 1.04596, .99977, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00022, .99973, 1.00022, .99973, 1.00022, .99973, 1.00022, .99973, .99977, .99973, .99977, .99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, .99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, .99924, 1.00001, 1, 1, .99973, .99924, .99973, .99924, .99973, 1.02572, .99973, 1.00005, .99973, .99924, .99977, .99973, .99977, .99973, .99977, .99973, .99999, .9998, .99973, 1.00022, .99973, 1.00022, .99973, 1.00022, .99973, 1, 1.00016, .99977, .99998, .99977, .99998, .99977, .99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, .84533, 1.00026, 1.0006, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, 1.00016, .99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, .99924, .99973, 1.00001, .99973, 1, .99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99928, 1, .99977, 1.00013, 1.00055, .99947, .99945, .99941, .99924, 1.00001, 1.00001, 1.0004, .91621, 1.00001, 1.00026, .99977, 1.00022, 1.0006, 1.00001, 1.00005, .99999, .99977, 1.00015, 1.00022, .99977, 1.00001, .99973, 1.00026, 1.00001, 1.00019, 1.00001, .99946, 1, 1.0006, 1.00001, .99978, 1.00045, .99973, .99924, 1.00023, .99978, .99966, 1, 1.00065, 1.00045, 1.00019, .99973, .99973, .99924, 1, 1, .96499, 1, 1.00055, .99973, 1.00008, 1.00027, 1, .9997, .99995, 1.00023, .99933, 1.00019, 1.00015, 1.00031, .99924, 1.00023, .99973, 1.00023, 1.00031, 1.00001, .99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, .99988, .99975, 1, 1.00082, .99561, .9996, 1.00035, 1.00001, .99962, 1.00001, 1.00092, .99964, 1.00001, .99963, .99999, 1.00035, 1.00035, 1.00082, .99962, .99999, .99977, 1.00022, 1.00035, 1.00001, .99977, 1.00026, .9996, .99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, .99971, .99962, 1.00035, .99975, .99977, .99973, 1.00043, .99953, 1.0007, .99915, .99973, 1.00008, .99892, 1.00073, 1.00073, 1.00114, .99915, 1.00073, .99955, .99973, 1.00092, .99973, 1, .99998, 1, 1.0003, 1, 1.00043, 1.00001, .99969, 1.0003, 1, 1.00035, 1.00001, .9995, 1, 1.00092, .99973, .99973, .99973, 1.0007, .9995, 1, .99924, 1.0006, .99924, .99972, 1.00062, .99973, 1.00114, 1.00073, 1, .99955, 1, 1, 1.00047, .99968, 1.00016, .99977, 1.00016, .99977, 1.00016, .99977, 1.00001, 1, 1, 1, .99973, 1, 1, .99955, .99924, .99924, .99924, .99924, .99998, .99998, .99998, .99973, .99973, .99972, 1, 1, 1.00267, .99999, .99998, .99998, 1, .99998, 1.66475, 1, .99973, .99973, 1.00023, .99973, .99971, .99925, 1.00023, 1, .99991, .99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, .96329, 1, 1.20985, 1.39713, 1.00003, .8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, .99915, 1.00031, 1.00031, .99999, 1.00003, .99999, .99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, .99999, 1, .99861, .99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, .95317, .99999, .99999, .99999, .99999, 1.40483, 1, .99977, 1.00054, 1, 1, .99953, .99962, 1.00042, .9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
      t.HelveticaRegularMetrics = {
        lineHeight: 1.2,
        lineGap: .2
      };
    }, (e, t) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.LiberationSansRegularWidths = t.LiberationSansRegularMapping = t.LiberationSansItalicWidths = t.LiberationSansItalicMapping = t.LiberationSansBoldWidths = t.LiberationSansBoldMapping = t.LiberationSansBoldItalicWidths = t.LiberationSansBoldItalicMapping = void 0;
      t.LiberationSansBoldWidths = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
      t.LiberationSansBoldMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
      t.LiberationSansBoldItalicWidths = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1e3, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1e3, 768, 600, 834, 834, 834, 834, 999, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
      t.LiberationSansBoldItalicMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
      t.LiberationSansItalicWidths = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 998, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
      t.LiberationSansItalicMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
      t.LiberationSansRegularWidths = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
      t.LiberationSansRegularMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    }, (e, t) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.MyriadProRegularMetrics = t.MyriadProRegularFactors = t.MyriadProItalicMetrics = t.MyriadProItalicFactors = t.MyriadProBoldMetrics = t.MyriadProBoldItalicMetrics = t.MyriadProBoldItalicFactors = t.MyriadProBoldFactors = void 0;
      t.MyriadProBoldFactors = [1.36898, 1, 1, .72706, .80479, .83734, .98894, .99793, .9897, .93884, .86209, .94292, .94292, 1.16661, 1.02058, .93582, .96694, .93582, 1.19137, .99793, .99793, .99793, .99793, .99793, .99793, .99793, .99793, .99793, .99793, .78076, .78076, 1.02058, 1.02058, 1.02058, .72851, .78966, .90838, .83637, .82391, .96376, .80061, .86275, .8768, .95407, 1.0258, .73901, .85022, .83655, 1.0156, .95546, .92179, .87107, .92179, .82114, .8096, .89713, .94438, .95353, .94083, .91905, .90406, .9446, .94292, 1.18777, .94292, 1.02058, .89903, .90088, .94938, .97898, .81093, .97571, .94938, 1.024, .9577, .95933, .98621, 1.0474, .97455, .98981, .9672, .95933, .9446, .97898, .97407, .97646, .78036, 1.10208, .95442, .95298, .97579, .9332, .94039, .938, .80687, 1.01149, .80687, 1.02058, .80479, .99793, .99793, .99793, .99793, 1.01149, 1.00872, .90088, .91882, 1.0213, .8361, 1.02058, .62295, .54324, .89022, 1.08595, 1, 1, .90088, 1, .97455, .93582, .90088, 1, 1.05686, .8361, .99642, .99642, .99642, .72851, .90838, .90838, .90838, .90838, .90838, .90838, .868, .82391, .80061, .80061, .80061, .80061, 1.0258, 1.0258, 1.0258, 1.0258, .97484, .95546, .92179, .92179, .92179, .92179, .92179, 1.02058, .92179, .94438, .94438, .94438, .94438, .90406, .86958, .98225, .94938, .94938, .94938, .94938, .94938, .94938, .9031, .81093, .94938, .94938, .94938, .94938, .98621, .98621, .98621, .98621, .93969, .95933, .9446, .9446, .9446, .9446, .9446, 1.08595, .9446, .95442, .95442, .95442, .95442, .94039, .97898, .94039, .90838, .94938, .90838, .94938, .90838, .94938, .82391, .81093, .82391, .81093, .82391, .81093, .82391, .81093, .96376, .84313, .97484, .97571, .80061, .94938, .80061, .94938, .80061, .94938, .80061, .94938, .80061, .94938, .8768, .9577, .8768, .9577, .8768, .9577, 1, 1, .95407, .95933, .97069, .95933, 1.0258, .98621, 1.0258, .98621, 1.0258, .98621, 1.0258, .98621, 1.0258, .98621, .887, 1.01591, .73901, 1.0474, 1, 1, .97455, .83655, .98981, 1, 1, .83655, .73977, .83655, .73903, .84638, 1.033, .95546, .95933, 1, 1, .95546, .95933, .8271, .95417, .95933, .92179, .9446, .92179, .9446, .92179, .9446, .936, .91964, .82114, .97646, 1, 1, .82114, .97646, .8096, .78036, .8096, .78036, 1, 1, .8096, .78036, 1, 1, .89713, .77452, .89713, 1.10208, .94438, .95442, .94438, .95442, .94438, .95442, .94438, .95442, .94438, .95442, .94438, .95442, .94083, .97579, .90406, .94039, .90406, .9446, .938, .9446, .938, .9446, .938, 1, .99793, .90838, .94938, .868, .9031, .92179, .9446, 1, 1, .89713, 1.10208, .90088, .90088, .90088, .90088, .90088, .90088, .90088, .90088, .90088, .90989, .9358, .91945, .83181, .75261, .87992, .82976, .96034, .83689, .97268, 1.0078, .90838, .83637, .8019, .90157, .80061, .9446, .95407, .92436, 1.0258, .85022, .97153, 1.0156, .95546, .89192, .92179, .92361, .87107, .96318, .89713, .93704, .95638, .91905, .91709, .92796, 1.0258, .93704, .94836, 1.0373, .95933, 1.0078, .95871, .94836, .96174, .92601, .9498, .98607, .95776, .95933, 1.05453, 1.0078, .98275, .9314, .95617, .91701, 1.05993, .9446, .78367, .9553, 1, .86832, 1.0128, .95871, .99394, .87548, .96361, .86774, 1.0078, .95871, .9446, .95871, .86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .94083, .97579, .94083, .97579, .94083, .97579, .90406, .94039, .96694, 1, .89903, 1, 1, 1, .93582, .93582, .93582, 1, .908, .908, .918, .94219, .94219, .96544, 1, 1.285, 1, 1, .81079, .81079, 1, 1, .74854, 1, 1, 1, 1, .99793, 1, 1, 1, .65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, .80535, .76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
      t.MyriadProBoldMetrics = {
        lineHeight: 1.2,
        lineGap: .2
      };
      t.MyriadProBoldItalicFactors = [1.36898, 1, 1, .66227, .80779, .81625, .97276, .97276, .97733, .92222, .83266, .94292, .94292, 1.16148, 1.02058, .93582, .96694, .93582, 1.17337, .97276, .97276, .97276, .97276, .97276, .97276, .97276, .97276, .97276, .97276, .78076, .78076, 1.02058, 1.02058, 1.02058, .71541, .76813, .85576, .80591, .80729, .94299, .77512, .83655, .86523, .92222, .98621, .71743, .81698, .79726, .98558, .92222, .90637, .83809, .90637, .80729, .76463, .86275, .90699, .91605, .9154, .85308, .85458, .90531, .94292, 1.21296, .94292, 1.02058, .89903, 1.18616, .99613, .91677, .78216, .91677, .90083, .98796, .9135, .92168, .95381, .98981, .95298, .95381, .93459, .92168, .91513, .92004, .91677, .95077, .748, 1.04502, .91677, .92061, .94236, .89544, .89364, .9, .80687, .8578, .80687, 1.02058, .80779, .97276, .97276, .97276, .97276, .8578, .99973, 1.18616, .91339, 1.08074, .82891, 1.02058, .55509, .71526, .89022, 1.08595, 1, 1, 1.18616, 1, .96736, .93582, 1.18616, 1, 1.04864, .82711, .99043, .99043, .99043, .71541, .85576, .85576, .85576, .85576, .85576, .85576, .845, .80729, .77512, .77512, .77512, .77512, .98621, .98621, .98621, .98621, .95961, .92222, .90637, .90637, .90637, .90637, .90637, 1.02058, .90251, .90699, .90699, .90699, .90699, .85458, .83659, .94951, .99613, .99613, .99613, .99613, .99613, .99613, .85811, .78216, .90083, .90083, .90083, .90083, .95381, .95381, .95381, .95381, .9135, .92168, .91513, .91513, .91513, .91513, .91513, 1.08595, .91677, .91677, .91677, .91677, .91677, .89364, .92332, .89364, .85576, .99613, .85576, .99613, .85576, .99613, .80729, .78216, .80729, .78216, .80729, .78216, .80729, .78216, .94299, .76783, .95961, .91677, .77512, .90083, .77512, .90083, .77512, .90083, .77512, .90083, .77512, .90083, .86523, .9135, .86523, .9135, .86523, .9135, 1, 1, .92222, .92168, .92222, .92168, .98621, .95381, .98621, .95381, .98621, .95381, .98621, .95381, .98621, .95381, .86036, .97096, .71743, .98981, 1, 1, .95298, .79726, .95381, 1, 1, .79726, .6894, .79726, .74321, .81691, 1.0006, .92222, .92168, 1, 1, .92222, .92168, .79464, .92098, .92168, .90637, .91513, .90637, .91513, .90637, .91513, .909, .87514, .80729, .95077, 1, 1, .80729, .95077, .76463, .748, .76463, .748, 1, 1, .76463, .748, 1, 1, .86275, .72651, .86275, 1.04502, .90699, .91677, .90699, .91677, .90699, .91677, .90699, .91677, .90699, .91677, .90699, .91677, .9154, .94236, .85458, .89364, .85458, .90531, .9, .90531, .9, .90531, .9, 1, .97276, .85576, .99613, .845, .85811, .90251, .91677, 1, 1, .86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, .85576, .80178, .66862, .7927, .69323, .88127, .72459, .89711, .95381, .85576, .80591, .7805, .94729, .77512, .90531, .92222, .90637, .98621, .81698, .92655, .98558, .92222, .85359, .90637, .90976, .83809, .94523, .86275, .83509, .93157, .85308, .83392, .92346, .98621, .83509, .92886, .91324, .92168, .95381, .90646, .92886, .90557, .86847, .90276, .91324, .86842, .92168, .99531, .95381, .9224, .85408, .92699, .86847, 1.0051, .91513, .80487, .93481, 1, .88159, 1.05214, .90646, .97355, .81539, .89398, .85923, .95381, .90646, .91513, .90646, .85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .9154, .94236, .9154, .94236, .9154, .94236, .85458, .89364, .96694, 1, .89903, 1, 1, 1, .91782, .91782, .91782, 1, .896, .896, .896, .9332, .9332, .95973, 1, 1.26, 1, 1, .80479, .80178, 1, 1, .85633, 1, 1, 1, 1, .97276, 1, 1, 1, .698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, .79199, .78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
      t.MyriadProBoldItalicMetrics = {
        lineHeight: 1.2,
        lineGap: .2
      };
      t.MyriadProItalicFactors = [1.36898, 1, 1, .65507, .84943, .85639, .88465, .88465, .86936, .88307, .86948, .85283, .85283, 1.06383, 1.02058, .75945, .9219, .75945, 1.17337, .88465, .88465, .88465, .88465, .88465, .88465, .88465, .88465, .88465, .88465, .75945, .75945, 1.02058, 1.02058, 1.02058, .69046, .70926, .85158, .77812, .76852, .89591, .70466, .76125, .80094, .86822, .83864, .728, .77212, .79475, .93637, .87514, .8588, .76013, .8588, .72421, .69866, .77598, .85991, .80811, .87832, .78112, .77512, .8562, 1.0222, 1.18417, 1.0222, 1.27014, .89903, 1.15012, .93859, .94399, .846, .94399, .81453, 1.0186, .94219, .96017, 1.03075, 1.02175, .912, 1.03075, .96998, .96017, .93859, .94399, .94399, .95493, .746, 1.12658, .94578, .91, .979, .882, .882, .83, .85034, .83537, .85034, 1.02058, .70869, .88465, .88465, .88465, .88465, .83537, .90083, 1.15012, .9161, .94565, .73541, 1.02058, .53609, .69353, .79519, 1.08595, 1, 1, 1.15012, 1, .91974, .75945, 1.15012, 1, .9446, .73361, .9005, .9005, .9005, .62864, .85158, .85158, .85158, .85158, .85158, .85158, .773, .76852, .70466, .70466, .70466, .70466, .83864, .83864, .83864, .83864, .90561, .87514, .8588, .8588, .8588, .8588, .8588, 1.02058, .85751, .85991, .85991, .85991, .85991, .77512, .76013, .88075, .93859, .93859, .93859, .93859, .93859, .93859, .8075, .846, .81453, .81453, .81453, .81453, .82424, .82424, .82424, .82424, .9278, .96017, .93859, .93859, .93859, .93859, .93859, 1.08595, .8562, .94578, .94578, .94578, .94578, .882, .94578, .882, .85158, .93859, .85158, .93859, .85158, .93859, .76852, .846, .76852, .846, .76852, .846, .76852, .846, .89591, .8544, .90561, .94399, .70466, .81453, .70466, .81453, .70466, .81453, .70466, .81453, .70466, .81453, .80094, .94219, .80094, .94219, .80094, .94219, 1, 1, .86822, .96017, .86822, .96017, .83864, .82424, .83864, .82424, .83864, .82424, .83864, 1.03075, .83864, .82424, .81402, 1.02738, .728, 1.02175, 1, 1, .912, .79475, 1.03075, 1, 1, .79475, .83911, .79475, .66266, .80553, 1.06676, .87514, .96017, 1, 1, .87514, .96017, .86865, .87396, .96017, .8588, .93859, .8588, .93859, .8588, .93859, .867, .84759, .72421, .95493, 1, 1, .72421, .95493, .69866, .746, .69866, .746, 1, 1, .69866, .746, 1, 1, .77598, .88417, .77598, 1.12658, .85991, .94578, .85991, .94578, .85991, .94578, .85991, .94578, .85991, .94578, .85991, .94578, .87832, .979, .77512, .882, .77512, .8562, .83, .8562, .83, .8562, .83, 1, .88465, .85158, .93859, .773, .8075, .85751, .8562, 1, 1, .77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, .85158, .77025, .62264, .7646, .65351, .86026, .69461, .89947, 1.03075, .85158, .77812, .76449, .88836, .70466, .8562, .86822, .8588, .83864, .77212, .85308, .93637, .87514, .82352, .8588, .85701, .76013, .89058, .77598, .8156, .82565, .78112, .77899, .89386, .83864, .8156, .9486, .92388, .96186, 1.03075, .91123, .9486, .93298, .878, .93942, .92388, .84596, .96186, .95119, 1.03075, .922, .88787, .95829, .88, .93559, .93859, .78815, .93758, 1, .89217, 1.03737, .91123, .93969, .77487, .85769, .86799, 1.03075, .91123, .93859, .91123, .86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .87832, .979, .87832, .979, .87832, .979, .77512, .882, .9219, 1, .89903, 1, 1, 1, .87321, .87321, .87321, 1, 1.027, 1.027, 1.027, .86847, .86847, .79121, 1, 1.124, 1, 1, .73572, .73572, 1, 1, .85034, 1, 1, 1, 1, .88465, 1, 1, 1, .669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, .74948, .75187, 1.02058, .98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
      t.MyriadProItalicMetrics = {
        lineHeight: 1.2,
        lineGap: .2
      };
      t.MyriadProRegularFactors = [1.36898, 1, 1, .76305, .82784, .94935, .89364, .92241, .89073, .90706, .98472, .85283, .85283, 1.0664, 1.02058, .74505, .9219, .74505, 1.23456, .92241, .92241, .92241, .92241, .92241, .92241, .92241, .92241, .92241, .92241, .74505, .74505, 1.02058, 1.02058, 1.02058, .73002, .72601, .91755, .8126, .80314, .92222, .73764, .79726, .83051, .90284, .86023, .74, .8126, .84869, .96518, .91115, .8858, .79761, .8858, .74498, .73914, .81363, .89591, .83659, .89633, .85608, .8111, .90531, 1.0222, 1.22736, 1.0222, 1.27014, .89903, .90088, .86667, 1.0231, .896, 1.01411, .90083, 1.05099, 1.00512, .99793, 1.05326, 1.09377, .938, 1.06226, 1.00119, .99793, .98714, 1.0231, 1.01231, .98196, .792, 1.19137, .99074, .962, 1.01915, .926, .942, .856, .85034, .92006, .85034, 1.02058, .69067, .92241, .92241, .92241, .92241, .92006, .9332, .90088, .91882, .93484, .75339, 1.02058, .56866, .54324, .79519, 1.08595, 1, 1, .90088, 1, .95325, .74505, .90088, 1, .97198, .75339, .91009, .91009, .91009, .66466, .91755, .91755, .91755, .91755, .91755, .91755, .788, .80314, .73764, .73764, .73764, .73764, .86023, .86023, .86023, .86023, .92915, .91115, .8858, .8858, .8858, .8858, .8858, 1.02058, .8858, .89591, .89591, .89591, .89591, .8111, .79611, .89713, .86667, .86667, .86667, .86667, .86667, .86667, .86936, .896, .90083, .90083, .90083, .90083, .84224, .84224, .84224, .84224, .97276, .99793, .98714, .98714, .98714, .98714, .98714, 1.08595, .89876, .99074, .99074, .99074, .99074, .942, 1.0231, .942, .91755, .86667, .91755, .86667, .91755, .86667, .80314, .896, .80314, .896, .80314, .896, .80314, .896, .92222, .93372, .92915, 1.01411, .73764, .90083, .73764, .90083, .73764, .90083, .73764, .90083, .73764, .90083, .83051, 1.00512, .83051, 1.00512, .83051, 1.00512, 1, 1, .90284, .99793, .90976, .99793, .86023, .84224, .86023, .84224, .86023, .84224, .86023, 1.05326, .86023, .84224, .82873, 1.07469, .74, 1.09377, 1, 1, .938, .84869, 1.06226, 1, 1, .84869, .83704, .84869, .81441, .85588, 1.08927, .91115, .99793, 1, 1, .91115, .99793, .91887, .90991, .99793, .8858, .98714, .8858, .98714, .8858, .98714, .894, .91434, .74498, .98196, 1, 1, .74498, .98196, .73914, .792, .73914, .792, 1, 1, .73914, .792, 1, 1, .81363, .904, .81363, 1.19137, .89591, .99074, .89591, .99074, .89591, .99074, .89591, .99074, .89591, .99074, .89591, .99074, .89633, 1.01915, .8111, .942, .8111, .90531, .856, .90531, .856, .90531, .856, 1, .92241, .91755, .86667, .788, .86936, .8858, .89876, 1, 1, .81363, 1.19137, .90088, .90088, .90088, .90088, .90088, .90088, .90088, .90088, .90088, .90388, 1.03901, .92138, .78105, .7154, .86169, .80513, .94007, .82528, .98612, 1.06226, .91755, .8126, .81884, .92819, .73764, .90531, .90284, .8858, .86023, .8126, .91172, .96518, .91115, .83089, .8858, .87791, .79761, .89297, .81363, .88157, .89992, .85608, .81992, .94307, .86023, .88157, .95308, .98699, .99793, 1.06226, .95817, .95308, .97358, .928, .98088, .98699, .92761, .99793, .96017, 1.06226, .986, .944, .95978, .938, .96705, .98714, .80442, .98972, 1, .89762, 1.04552, .95817, .99007, .87064, .91879, .88888, 1.06226, .95817, .98714, .95817, .88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .89633, 1.01915, .89633, 1.01915, .89633, 1.01915, .8111, .942, .9219, 1, .89903, 1, 1, 1, .93173, .93173, .93173, 1, 1.06304, 1.06304, 1.06904, .89903, .89903, .80549, 1, 1.156, 1, 1, .76575, .76575, 1, 1, .72458, 1, 1, 1, 1, .92241, 1, 1, 1, .619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, .74705, .71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
      t.MyriadProRegularMetrics = {
        lineHeight: 1.2,
        lineGap: .2
      };
    }, (e, t) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.SegoeuiRegularMetrics = t.SegoeuiRegularFactors = t.SegoeuiItalicMetrics = t.SegoeuiItalicFactors = t.SegoeuiBoldMetrics = t.SegoeuiBoldItalicMetrics = t.SegoeuiBoldItalicFactors = t.SegoeuiBoldFactors = void 0;
      t.SegoeuiBoldFactors = [1.76738, 1, 1, .99297, .9824, 1.04016, 1.06497, 1.03424, .97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, .9754, 1.21408, .9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, .81378, .81378, 1.2107, 1.2107, 1.2107, .71703, .97847, .97363, .88776, .8641, 1.02096, .79795, .85132, .914, 1.06085, 1.1406, .8007, .89858, .83693, 1.14889, 1.09398, .97489, .92094, .97489, .90399, .84041, .95923, 1.00135, 1, 1.06467, .98243, .90996, .99361, 1.1085, 1.56942, 1.1085, 1.2107, .74627, .94282, .96752, 1.01519, .86304, 1.01359, .97278, 1.15103, 1.01359, .98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, .99041, 1.0008, 1.01519, 1.01359, 1.02258, .79104, 1.16862, .99041, .97454, 1.02511, .99298, .96752, .95801, .94856, 1.16579, .94856, 1.2107, .9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, .8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, .75155, .94994, 1.28826, 1.21408, 1.21408, .91056, 1, .91572, .9754, .64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, .71703, .97363, .97363, .97363, .97363, .97363, .97363, .93506, .8641, .79795, .79795, .79795, .79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, .97426, .97426, .97426, .97426, .97426, 1.2107, .97489, 1.00135, 1.00135, 1.00135, 1.00135, .90996, .92094, 1.02798, .96752, .96752, .96752, .96752, .96752, .96752, .93136, .86304, .97278, .97278, .97278, .97278, 1.02285, 1.02285, 1.02285, 1.02285, .97122, .99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, .99041, .99041, .99041, .99041, .96752, 1.01519, .96752, .97363, .96752, .97363, .96752, .97363, .96752, .8641, .86304, .8641, .86304, .8641, .86304, .8641, .86304, 1.02096, 1.03057, 1.02096, 1.03517, .79795, .97278, .79795, .97278, .79795, .97278, .79795, .97278, .79795, .97278, .914, 1.01359, .914, 1.01359, .914, 1.01359, 1, 1, 1.06085, .98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, .97138, 1.08692, .8007, 1.02285, 1, 1, 1.00527, .83693, 1.02285, 1, 1, .83693, .9455, .83693, .90418, .83693, 1.13005, 1.09398, .99041, 1, 1, 1.09398, .99041, .96692, 1.09251, .99041, .97489, 1.0008, .97489, 1.0008, .97489, 1.0008, .93994, .97931, .90399, 1.02258, 1, 1, .90399, 1.02258, .84041, .79104, .84041, .79104, .84041, .79104, .84041, .79104, 1, 1, .95923, 1.07034, .95923, 1.16862, 1.00135, .99041, 1.00135, .99041, 1.00135, .99041, 1.00135, .99041, 1.00135, .99041, 1.00135, .99041, 1.06467, 1.02511, .90996, .96752, .90996, .99361, .95801, .99361, .95801, .99361, .95801, 1.07733, 1.03424, .97363, .96752, .93506, .93136, .97489, 1.0008, 1, 1, .95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, .75953, .81378, .79912, 1.15103, 1.21994, .95161, .87815, 1.01149, .81525, .7676, .98167, 1.01134, 1.02546, .84097, 1.03089, 1.18102, .97363, .88776, .85134, .97826, .79795, .99361, 1.06085, .97489, 1.1406, .89858, 1.0388, 1.14889, 1.09398, .86039, .97489, 1.0595, .92094, .94793, .95923, .90996, .99346, .98243, 1.02112, .95493, 1.1406, .90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, .97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, .98683, 1.0016, .99561, 1.07237, 1.0008, .90434, .99921, .93803, .8965, 1.23085, 1.06628, 1.04983, .96268, 1.0499, .98439, 1.18102, 1.06628, 1.0008, 1.06628, .98439, .79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, .90996, .96752, 1, 1.21408, .89903, 1, 1, .75155, 1.04394, 1.04394, 1.04394, 1.04394, .98633, .98633, .98633, .73047, .73047, 1.20642, .91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, .96039, 1.24633, 1, 1.12454, .93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, .771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, .86279, .94434, .86279, .94434, .86182, 1, 1, 1.16897, 1, .96085, .90137, 1.2107, 1.18416, 1.13973, .69825, .9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, .99862, .99862, 1, .87025, .87025, .87025, .87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, .99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
      t.SegoeuiBoldMetrics = {
        lineHeight: 1.33008,
        lineGap: 0
      };
      t.SegoeuiBoldItalicFactors = [1.76738, 1, 1, .98946, 1.03959, 1.04016, 1.02809, 1.036, .97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, .9754, 1.21261, .9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, .81378, .81378, 1.21237, 1.21237, 1.21237, .73541, .97847, .97363, .89723, .87897, 1.0426, .79429, .85292, .91149, 1.05815, 1.1406, .79631, .90128, .83853, 1.04396, 1.10615, .97552, .94436, .97552, .88641, .80527, .96083, 1.00135, 1, 1.06777, .9817, .91142, .99361, 1.11144, 1.57293, 1.11144, 1.21237, .74627, 1.31818, 1.06585, .97042, .83055, .97042, .93503, 1.1261, .97042, .97922, 1.14236, .94552, 1.01054, 1.14236, 1.02471, .97922, .94165, .97042, .97042, 1.0276, .78929, 1.1261, .97922, .95874, 1.02197, .98507, .96752, .97168, .95107, 1.16579, .95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, .87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, .79487, .94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, .91484, .9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, .73541, .97363, .97363, .97363, .97363, .97363, .97363, .94385, .87897, .79429, .79429, .79429, .79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, .97552, .97552, .97552, .97552, .97552, 1.21237, .97552, 1.00135, 1.00135, 1.00135, 1.00135, .91142, .94436, .98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, .96705, .83055, .93503, .93503, .93503, .93503, 1.14236, 1.14236, 1.14236, 1.14236, .93125, .97922, .94165, .94165, .94165, .94165, .94165, 1.29004, .94165, .97922, .97922, .97922, .97922, .96752, .97042, .96752, .97363, 1.06585, .97363, 1.06585, .97363, 1.06585, .87897, .83055, .87897, .83055, .87897, .83055, .87897, .83055, 1.0426, 1.0033, 1.0426, .97042, .79429, .93503, .79429, .93503, .79429, .93503, .79429, .93503, .79429, .93503, .91149, .97042, .91149, .97042, .91149, .97042, 1, 1, 1.05815, .97922, 1.05815, .97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, .97441, 1.04302, .79631, 1.01582, 1, 1, 1.01054, .83853, 1.14236, 1, 1, .83853, 1.09125, .83853, .90418, .83853, 1.19508, 1.10615, .97922, 1, 1, 1.10615, .97922, 1.01034, 1.10466, .97922, .97552, .94165, .97552, .94165, .97552, .94165, .91602, .91981, .88641, 1.0276, 1, 1, .88641, 1.0276, .80527, .78929, .80527, .78929, .80527, .78929, .80527, .78929, 1, 1, .96083, 1.05403, .95923, 1.16862, 1.00135, .97922, 1.00135, .97922, 1.00135, .97922, 1.00135, .97922, 1.00135, .97922, 1.00135, .97922, 1.06777, 1.02197, .91142, .96752, .91142, .99361, .97168, .99361, .97168, .99361, .97168, 1.23199, 1.036, .97363, 1.06585, .94385, .96705, .97552, .94165, 1, 1, .96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, .95161, 1.27126, 1.00811, .83284, .77702, .99137, .95253, 1.0347, .86142, 1.07205, 1.14236, .97363, .89723, .86869, 1.09818, .79429, .99361, 1.05815, .97552, 1.1406, .90128, 1.06662, 1.04396, 1.10615, .84918, .97552, 1.04694, .94436, .98015, .96083, .91142, 1.00356, .9817, 1.01945, .98999, 1.1406, .91142, 1.04961, .9898, 1.00639, 1.14236, 1.07514, 1.04961, .99607, 1.02897, 1.008, .9898, .95134, 1.00639, 1.11121, 1.14236, 1.00518, .97981, 1.02186, 1, 1.08578, .94165, .99314, .98387, .93028, .93377, 1.35125, 1.07514, 1.10687, .93491, 1.04232, 1.00351, 1.14236, 1.07514, .94165, 1.07514, 1.00351, .79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, .91142, .96752, 1, 1.21261, .89903, 1, 1, .75155, 1.04745, 1.04745, 1.04745, 1.04394, .98633, .98633, .98633, .72959, .72959, 1.20502, .91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, .96039, 1.24633, 1, 1.09125, .93327, 1.03336, 1.16541, 1.036, 1, 1, 1, .771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, .86364, .94434, .86279, .94434, .86224, 1, 1, 1.16798, 1, .96085, .90068, 1.21237, 1.18416, 1.13904, .69825, .9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, .99862, .99862, 1, .87025, .87025, .87025, .87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, .99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
      t.SegoeuiBoldItalicMetrics = {
        lineHeight: 1.33008,
        lineGap: 0
      };
      t.SegoeuiItalicFactors = [1.76738, 1, 1, .98946, 1.14763, 1.05365, 1.06234, .96927, .92586, 1.15373, 1.18414, .91349, .91349, 1.07403, 1.17308, .78383, 1.20088, .78383, 1.42531, .96927, .96927, .96927, .96927, .96927, .96927, .96927, .96927, .96927, .96927, .78383, .78383, 1.17308, 1.17308, 1.17308, .77349, .94565, .94729, .85944, .88506, .9858, .74817, .80016, .88449, .98039, .95782, .69238, .89898, .83231, .98183, 1.03989, .96924, .86237, .96924, .80595, .74524, .86091, .95402, .94143, .98448, .8858, .83089, .93285, 1.0949, 1.39016, 1.0949, 1.45994, .74627, 1.04839, .97454, .97454, .87207, .97454, .87533, 1.06151, .97454, 1.00176, 1.16484, 1.08132, .98047, 1.16484, 1.02989, 1.01054, .96225, .97454, .97454, 1.06598, .79004, 1.16344, 1.00351, .94629, .9973, .91016, .96777, .9043, .91082, .92481, .91082, 1.17308, .95748, .96927, .96927, 1, .96927, .92481, .80597, 1.04839, 1.23393, 1.1781, .9245, 1.17308, 1.20808, .63218, .94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, .85273, .78032, 1.04839, 1.09971, 1.22326, .9245, 1.09836, 1.13525, 1.15222, .70424, .94729, .94729, .94729, .94729, .94729, .94729, .85498, .88506, .74817, .74817, .74817, .74817, .95782, .95782, .95782, .95782, .9858, 1.03989, .96924, .96924, .96924, .96924, .96924, 1.17308, .96924, .95402, .95402, .95402, .95402, .83089, .86237, .88409, .97454, .97454, .97454, .97454, .97454, .97454, .92916, .87207, .87533, .87533, .87533, .87533, .93146, .93146, .93146, .93146, .93854, 1.01054, .96225, .96225, .96225, .96225, .96225, 1.24822, .8761, 1.00351, 1.00351, 1.00351, 1.00351, .96777, .97454, .96777, .94729, .97454, .94729, .97454, .94729, .97454, .88506, .87207, .88506, .87207, .88506, .87207, .88506, .87207, .9858, .95391, .9858, .97454, .74817, .87533, .74817, .87533, .74817, .87533, .74817, .87533, .74817, .87533, .88449, .97454, .88449, .97454, .88449, .97454, 1, 1, .98039, 1.00176, .98039, 1.00176, .95782, .93146, .95782, .93146, .95782, .93146, .95782, 1.16484, .95782, .93146, .84421, 1.12761, .69238, 1.08132, 1, 1, .98047, .83231, 1.16484, 1, 1, .84723, 1.04861, .84723, .78755, .83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, .9857, 1.03849, 1.01054, .96924, .96225, .96924, .96225, .96924, .96225, .92383, .90171, .80595, 1.06598, 1, 1, .80595, 1.06598, .74524, .79004, .74524, .79004, .74524, .79004, .74524, .79004, 1, 1, .86091, 1.02759, .85771, 1.16344, .95402, 1.00351, .95402, 1.00351, .95402, 1.00351, .95402, 1.00351, .95402, 1.00351, .95402, 1.00351, .98448, .9973, .83089, .96777, .83089, .93285, .9043, .93285, .9043, .93285, .9043, 1.31868, .96927, .94729, .97454, .85498, .92916, .96924, .8761, 1, 1, .86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, .81965, .81965, .94729, .78032, .71022, .90883, .84171, .99877, .77596, 1.05734, 1.2, .94729, .85944, .82791, .9607, .74817, .93285, .98039, .96924, .95782, .89898, .98316, .98183, 1.03989, .78614, .96924, .97642, .86237, .86075, .86091, .83089, .90082, .8858, .97296, 1.01284, .95782, .83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, .98205, 1.03809, 1.05097, 1.04, .95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, .96225, .8965, .97783, .93574, .94818, 1.30679, 1.0675, 1.11826, .99821, 1.0557, 1.0326, 1.2, 1.0675, .96225, 1.0675, 1.0326, .74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .98705, 1, 1, 1, 1, 1, 1, .98448, .9973, .98448, .9973, .98448, .9973, .83089, .96777, 1, 1.20088, .89903, 1, 1, .75155, .94945, .94945, .94945, .94945, 1.12317, 1.12317, 1.12317, .67603, .67603, 1.15621, .73584, 1.21191, 1.22135, 1.06483, .94868, .94868, .95996, 1.24633, 1, 1.07497, .87709, .96927, 1.01473, .96927, 1, 1, 1, .77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, .86321, .94434, .8649, .94434, .86182, 1, 1, 1.083, 1, .91578, .86438, 1.17308, 1.18416, 1.14589, .69825, .97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, .99862, .99862, 1, .87025, .87025, .87025, .87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, .99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
      t.SegoeuiItalicMetrics = {
        lineHeight: 1.33008,
        lineGap: 0
      };
      t.SegoeuiRegularFactors = [1.76738, 1, 1, .98594, 1.02285, 1.10454, 1.06234, .96927, .92037, 1.19985, 1.2046, .90616, .90616, 1.07152, 1.1714, .78032, 1.20088, .78032, 1.40246, .96927, .96927, .96927, .96927, .96927, .96927, .96927, .96927, .96927, .96927, .78032, .78032, 1.1714, 1.1714, 1.1714, .80597, .94084, .96706, .85944, .85734, .97093, .75842, .79936, .88198, .9831, .95782, .71387, .86969, .84636, 1.07796, 1.03584, .96924, .83968, .96924, .82826, .79649, .85771, .95132, .93119, .98965, .88433, .8287, .93365, 1.08612, 1.3638, 1.08612, 1.45786, .74627, .80499, .91484, 1.05707, .92383, 1.05882, .9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, .99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, .84863, 1.21968, 1.01756, .95801, 1.00068, .91797, .96777, .9043, .90351, .92105, .90351, 1.1714, .85337, .96927, .96927, .99912, .96927, .92105, .80597, 1.2434, 1.20808, 1.05937, .90957, 1.1714, 1.20808, .75155, .94261, 1.24644, 1.09971, 1.09971, .84751, 1, .85273, .78032, .61584, 1.05425, 1.17914, .90957, 1.08665, 1.11593, 1.14169, .73381, .96706, .96706, .96706, .96706, .96706, .96706, .86035, .85734, .75842, .75842, .75842, .75842, .95782, .95782, .95782, .95782, .97093, 1.03584, .96924, .96924, .96924, .96924, .96924, 1.1714, .96924, .95132, .95132, .95132, .95132, .8287, .83968, .89049, .91484, .91484, .91484, .91484, .91484, .91484, .93575, .92383, .9403, .9403, .9403, .9403, .8717, .8717, .8717, .8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, .95923, 1.01756, 1.01756, 1.01756, 1.01756, .96777, 1.05707, .96777, .96706, .91484, .96706, .91484, .96706, .91484, .85734, .92383, .85734, .92383, .85734, .92383, .85734, .92383, .97093, 1.0969, .97093, 1.05882, .75842, .9403, .75842, .9403, .75842, .9403, .75842, .9403, .75842, .9403, .88198, 1.05882, .88198, 1.05882, .88198, 1.05882, 1, 1, .9831, 1.01756, .9831, 1.01756, .95782, .8717, .95782, .8717, .95782, .8717, .95782, 1.09011, .95782, .8717, .84784, 1.11551, .71387, 1.09011, 1, 1, .99414, .84636, 1.09011, 1, 1, .84636, 1.0536, .84636, .94298, .84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, .96924, 1.05356, .96924, 1.05356, .96924, 1.05356, .93066, .98293, .82826, 1.04399, 1, 1, .82826, 1.04399, .79649, .84863, .79649, .84863, .79649, .84863, .79649, .84863, 1, 1, .85771, 1.17318, .85771, 1.21968, .95132, 1.01756, .95132, 1.01756, .95132, 1.01756, .95132, 1.01756, .95132, 1.01756, .95132, 1.01756, .98965, 1.00068, .8287, .96777, .8287, .93365, .9043, .93365, .9043, .93365, .9043, 1.08571, .96927, .96706, .91484, .86035, .93575, .96924, .95923, 1, 1, .85771, 1.21968, 1.11437, 1.11437, .93109, .91202, .60411, .84164, .55572, 1.01173, .97361, .81818, .81818, .96635, .78032, .72727, .92366, .98601, 1.03405, .77968, 1.09799, 1.2, .96706, .85944, .85638, .96491, .75842, .93365, .9831, .96924, .95782, .86969, .94152, 1.07796, 1.03584, .78437, .96924, .98715, .83968, .83491, .85771, .8287, .94492, .88433, .9287, 1.0098, .95782, .8287, 1.0625, .98248, 1.03424, 1.2, 1.01071, 1.0625, .95246, 1.03809, 1.04912, .98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, .99609, 1.00169, 1.05176, .99346, 1.05356, .9087, 1.03004, .95542, .93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, .75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, .98965, 1.00068, .98965, 1.00068, .98965, 1.00068, .8287, .96777, 1, 1.20088, .89903, 1, 1, .75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, .67428, .67428, 1.16039, .73291, 1.20996, 1.22135, 1.06483, .94868, .94868, .95996, 1.24633, 1, 1.07497, .87796, .96927, 1.01518, .96927, 1, 1, 1, .77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, .86279, .94434, .86279, .94434, .86182, 1, 1, 1.083, 1, .91578, .86507, 1.1714, 1.18416, 1.14589, .69825, .97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, .99862, .99862, 1, .87025, .87025, .87025, .87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, .99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
      t.SegoeuiRegularMetrics = {
        lineHeight: 1.33008,
        lineGap: 0
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.SEAC_ANALYSIS_ENABLED = t.MacStandardGlyphOrdering = t.FontFlags = void 0;
      t.getFontType = function (e, t, a = !1) {
        switch (e) {
          case "Type1":
            if (a) return r.FontType.TYPE1STANDARD;
            return "Type1C" === t ? r.FontType.TYPE1C : r.FontType.TYPE1;
          case "CIDFontType0":
            return "CIDFontType0C" === t ? r.FontType.CIDFONTTYPE0C : r.FontType.CIDFONTTYPE0;
          case "OpenType":
            return r.FontType.OPENTYPE;
          case "TrueType":
            return r.FontType.TRUETYPE;
          case "CIDFontType2":
            return r.FontType.CIDFONTTYPE2;
          case "MMType1":
            return r.FontType.MMTYPE1;
          case "Type0":
            return r.FontType.TYPE0;
          default:
            return r.FontType.UNKNOWN;
        }
      };
      t.normalizeFontName = function (e) {
        return e.replace(/[,_]/g, "-").replace(/\s/g, "");
      };
      t.recoverGlyphName = l;
      t.type1FontGlyphMapping = function (e, t, a) {
        let r;
        let s;
        let c;
        let h;
        let u = Object.create(null);
        let d = !!(e.flags & o.Symbolic);
        if (e.isInternalFont) for (s = 0, c = t; s < c.length; s++) (r = a.indexOf(c[s])) >= 0 ? u[s] = r : u[s] = 0; else if (e.baseEncodingName) for (s = 0, c = i.getEncoding(e.baseEncodingName); s < c.length; s++) (r = a.indexOf(c[s])) >= 0 ? u[s] = r : u[s] = 0; else if (d) for (s in t) u[s] = t[s]; else for (s = 0, c = i.StandardEncoding; s < c.length; s++) (r = a.indexOf(c[s])) >= 0 ? u[s] = r : u[s] = 0;
        let f = e.differences;
        if (f) for (s in f) {
          let e = f[s];
          if (-1 === (r = a.indexOf(e))) {
            h || (h = n.getGlyphsUnicode());
            let t = l(e, h);
            t !== e && (r = a.indexOf(t));
          }
          r >= 0 ? u[s] = r : u[s] = 0;
        }
        return u;
      };
      var r = a(2);
      var i = a(19);
      var n = a(20);
      var s = a(21);
      t.SEAC_ANALYSIS_ENABLED = !0;
      let o = {
        FixedPitch: 1,
        Serif: 2,
        Symbolic: 4,
        Script: 8,
        Nonsymbolic: 32,
        Italic: 64,
        AllCap: 65536,
        SmallCap: 131072,
        ForceBold: 262144
      };
      function l(e, t) {
        if (void 0 !== t[e]) return e;
        let a = s.getUnicodeForGlyph(e, t);
        if (-1 !== a) {
          for (let e in t) if (t[e] === a) return e;
        }
        r.info("Unable to recover a standard glyph name for: " + e);
        return e;
      }
      t.FontFlags = o;
      t.MacStandardGlyphOrdering = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
    }, (e, t) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.ZapfDingbatsEncoding = t.WinAnsiEncoding = t.SymbolSetEncoding = t.StandardEncoding = t.MacRomanEncoding = t.ExpertEncoding = void 0;
      t.getEncoding = function (e) {
        switch (e) {
          case "WinAnsiEncoding":
            return s;
          case "StandardEncoding":
            return n;
          case "MacRomanEncoding":
            return i;
          case "SymbolSetEncoding":
            return o;
          case "ZapfDingbatsEncoding":
            return l;
          case "ExpertEncoding":
            return a;
          case "MacExpertEncoding":
            return r;
          default:
            return null;
        }
      };
      let a = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
      t.ExpertEncoding = a;
      let r = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""];
      let i = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
      t.MacRomanEncoding = i;
      let n = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""];
      t.StandardEncoding = n;
      let s = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
      t.WinAnsiEncoding = s;
      let o = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];
      t.SymbolSetEncoding = o;
      let l = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
      t.ZapfDingbatsEncoding = l;
    }, (e, t, a) => {
      a.r(t);
      a.d(t, {
        getDingbatsGlyphsUnicode: () => n,
        getGlyphsUnicode: () => i
      });
      var r = a(8);
      let i = r.getArrayLookupTableFactory(function () {
        return ["A", 65, "AE", 198, "AEacute", 508, "AEmacron", 482, "AEsmall", 63462, "Aacute", 193, "Aacutesmall", 63457, "Abreve", 258, "Abreveacute", 7854, "Abrevecyrillic", 1232, "Abrevedotbelow", 7862, "Abrevegrave", 7856, "Abrevehookabove", 7858, "Abrevetilde", 7860, "Acaron", 461, "Acircle", 9398, "Acircumflex", 194, "Acircumflexacute", 7844, "Acircumflexdotbelow", 7852, "Acircumflexgrave", 7846, "Acircumflexhookabove", 7848, "Acircumflexsmall", 63458, "Acircumflextilde", 7850, "Acute", 63177, "Acutesmall", 63412, "Acyrillic", 1040, "Adblgrave", 512, "Adieresis", 196, "Adieresiscyrillic", 1234, "Adieresismacron", 478, "Adieresissmall", 63460, "Adotbelow", 7840, "Adotmacron", 480, "Agrave", 192, "Agravesmall", 63456, "Ahookabove", 7842, "Aiecyrillic", 1236, "Ainvertedbreve", 514, "Alpha", 913, "Alphatonos", 902, "Amacron", 256, "Amonospace", 65313, "Aogonek", 260, "Aring", 197, "Aringacute", 506, "Aringbelow", 7680, "Aringsmall", 63461, "Asmall", 63329, "Atilde", 195, "Atildesmall", 63459, "Aybarmenian", 1329, "B", 66, "Bcircle", 9399, "Bdotaccent", 7682, "Bdotbelow", 7684, "Becyrillic", 1041, "Benarmenian", 1330, "Beta", 914, "Bhook", 385, "Blinebelow", 7686, "Bmonospace", 65314, "Brevesmall", 63220, "Bsmall", 63330, "Btopbar", 386, "C", 67, "Caarmenian", 1342, "Cacute", 262, "Caron", 63178, "Caronsmall", 63221, "Ccaron", 268, "Ccedilla", 199, "Ccedillaacute", 7688, "Ccedillasmall", 63463, "Ccircle", 9400, "Ccircumflex", 264, "Cdot", 266, "Cdotaccent", 266, "Cedillasmall", 63416, "Chaarmenian", 1353, "Cheabkhasiancyrillic", 1212, "Checyrillic", 1063, "Chedescenderabkhasiancyrillic", 1214, "Chedescendercyrillic", 1206, "Chedieresiscyrillic", 1268, "Cheharmenian", 1347, "Chekhakassiancyrillic", 1227, "Cheverticalstrokecyrillic", 1208, "Chi", 935, "Chook", 391, "Circumflexsmall", 63222, "Cmonospace", 65315, "Coarmenian", 1361, "Csmall", 63331, "D", 68, "DZ", 497, "DZcaron", 452, "Daarmenian", 1332, "Dafrican", 393, "Dcaron", 270, "Dcedilla", 7696, "Dcircle", 9401, "Dcircumflexbelow", 7698, "Dcroat", 272, "Ddotaccent", 7690, "Ddotbelow", 7692, "Decyrillic", 1044, "Deicoptic", 1006, "Delta", 8710, "Deltagreek", 916, "Dhook", 394, "Dieresis", 63179, "DieresisAcute", 63180, "DieresisGrave", 63181, "Dieresissmall", 63400, "Digammagreek", 988, "Djecyrillic", 1026, "Dlinebelow", 7694, "Dmonospace", 65316, "Dotaccentsmall", 63223, "Dslash", 272, "Dsmall", 63332, "Dtopbar", 395, "Dz", 498, "Dzcaron", 453, "Dzeabkhasiancyrillic", 1248, "Dzecyrillic", 1029, "Dzhecyrillic", 1039, "E", 69, "Eacute", 201, "Eacutesmall", 63465, "Ebreve", 276, "Ecaron", 282, "Ecedillabreve", 7708, "Echarmenian", 1333, "Ecircle", 9402, "Ecircumflex", 202, "Ecircumflexacute", 7870, "Ecircumflexbelow", 7704, "Ecircumflexdotbelow", 7878, "Ecircumflexgrave", 7872, "Ecircumflexhookabove", 7874, "Ecircumflexsmall", 63466, "Ecircumflextilde", 7876, "Ecyrillic", 1028, "Edblgrave", 516, "Edieresis", 203, "Edieresissmall", 63467, "Edot", 278, "Edotaccent", 278, "Edotbelow", 7864, "Efcyrillic", 1060, "Egrave", 200, "Egravesmall", 63464, "Eharmenian", 1335, "Ehookabove", 7866, "Eightroman", 8551, "Einvertedbreve", 518, "Eiotifiedcyrillic", 1124, "Elcyrillic", 1051, "Elevenroman", 8554, "Emacron", 274, "Emacronacute", 7702, "Emacrongrave", 7700, "Emcyrillic", 1052, "Emonospace", 65317, "Encyrillic", 1053, "Endescendercyrillic", 1186, "Eng", 330, "Enghecyrillic", 1188, "Enhookcyrillic", 1223, "Eogonek", 280, "Eopen", 400, "Epsilon", 917, "Epsilontonos", 904, "Ercyrillic", 1056, "Ereversed", 398, "Ereversedcyrillic", 1069, "Escyrillic", 1057, "Esdescendercyrillic", 1194, "Esh", 425, "Esmall", 63333, "Eta", 919, "Etarmenian", 1336, "Etatonos", 905, "Eth", 208, "Ethsmall", 63472, "Etilde", 7868, "Etildebelow", 7706, "Euro", 8364, "Ezh", 439, "Ezhcaron", 494, "Ezhreversed", 440, "F", 70, "Fcircle", 9403, "Fdotaccent", 7710, "Feharmenian", 1366, "Feicoptic", 996, "Fhook", 401, "Fitacyrillic", 1138, "Fiveroman", 8548, "Fmonospace", 65318, "Fourroman", 8547, "Fsmall", 63334, "G", 71, "GBsquare", 13191, "Gacute", 500, "Gamma", 915, "Gammaafrican", 404, "Gangiacoptic", 1002, "Gbreve", 286, "Gcaron", 486, "Gcedilla", 290, "Gcircle", 9404, "Gcircumflex", 284, "Gcommaaccent", 290, "Gdot", 288, "Gdotaccent", 288, "Gecyrillic", 1043, "Ghadarmenian", 1346, "Ghemiddlehookcyrillic", 1172, "Ghestrokecyrillic", 1170, "Gheupturncyrillic", 1168, "Ghook", 403, "Gimarmenian", 1331, "Gjecyrillic", 1027, "Gmacron", 7712, "Gmonospace", 65319, "Grave", 63182, "Gravesmall", 63328, "Gsmall", 63335, "Gsmallhook", 667, "Gstroke", 484, "H", 72, "H18533", 9679, "H18543", 9642, "H18551", 9643, "H22073", 9633, "HPsquare", 13259, "Haabkhasiancyrillic", 1192, "Hadescendercyrillic", 1202, "Hardsigncyrillic", 1066, "Hbar", 294, "Hbrevebelow", 7722, "Hcedilla", 7720, "Hcircle", 9405, "Hcircumflex", 292, "Hdieresis", 7718, "Hdotaccent", 7714, "Hdotbelow", 7716, "Hmonospace", 65320, "Hoarmenian", 1344, "Horicoptic", 1e3, "Hsmall", 63336, "Hungarumlaut", 63183, "Hungarumlautsmall", 63224, "Hzsquare", 13200, "I", 73, "IAcyrillic", 1071, "IJ", 306, "IUcyrillic", 1070, "Iacute", 205, "Iacutesmall", 63469, "Ibreve", 300, "Icaron", 463, "Icircle", 9406, "Icircumflex", 206, "Icircumflexsmall", 63470, "Icyrillic", 1030, "Idblgrave", 520, "Idieresis", 207, "Idieresisacute", 7726, "Idieresiscyrillic", 1252, "Idieresissmall", 63471, "Idot", 304, "Idotaccent", 304, "Idotbelow", 7882, "Iebrevecyrillic", 1238, "Iecyrillic", 1045, "Ifraktur", 8465, "Igrave", 204, "Igravesmall", 63468, "Ihookabove", 7880, "Iicyrillic", 1048, "Iinvertedbreve", 522, "Iishortcyrillic", 1049, "Imacron", 298, "Imacroncyrillic", 1250, "Imonospace", 65321, "Iniarmenian", 1339, "Iocyrillic", 1025, "Iogonek", 302, "Iota", 921, "Iotaafrican", 406, "Iotadieresis", 938, "Iotatonos", 906, "Ismall", 63337, "Istroke", 407, "Itilde", 296, "Itildebelow", 7724, "Izhitsacyrillic", 1140, "Izhitsadblgravecyrillic", 1142, "J", 74, "Jaarmenian", 1345, "Jcircle", 9407, "Jcircumflex", 308, "Jecyrillic", 1032, "Jheharmenian", 1355, "Jmonospace", 65322, "Jsmall", 63338, "K", 75, "KBsquare", 13189, "KKsquare", 13261, "Kabashkircyrillic", 1184, "Kacute", 7728, "Kacyrillic", 1050, "Kadescendercyrillic", 1178, "Kahookcyrillic", 1219, "Kappa", 922, "Kastrokecyrillic", 1182, "Kaverticalstrokecyrillic", 1180, "Kcaron", 488, "Kcedilla", 310, "Kcircle", 9408, "Kcommaaccent", 310, "Kdotbelow", 7730, "Keharmenian", 1364, "Kenarmenian", 1343, "Khacyrillic", 1061, "Kheicoptic", 998, "Khook", 408, "Kjecyrillic", 1036, "Klinebelow", 7732, "Kmonospace", 65323, "Koppacyrillic", 1152, "Koppagreek", 990, "Ksicyrillic", 1134, "Ksmall", 63339, "L", 76, "LJ", 455, "LL", 63167, "Lacute", 313, "Lambda", 923, "Lcaron", 317, "Lcedilla", 315, "Lcircle", 9409, "Lcircumflexbelow", 7740, "Lcommaaccent", 315, "Ldot", 319, "Ldotaccent", 319, "Ldotbelow", 7734, "Ldotbelowmacron", 7736, "Liwnarmenian", 1340, "Lj", 456, "Ljecyrillic", 1033, "Llinebelow", 7738, "Lmonospace", 65324, "Lslash", 321, "Lslashsmall", 63225, "Lsmall", 63340, "M", 77, "MBsquare", 13190, "Macron", 63184, "Macronsmall", 63407, "Macute", 7742, "Mcircle", 9410, "Mdotaccent", 7744, "Mdotbelow", 7746, "Menarmenian", 1348, "Mmonospace", 65325, "Msmall", 63341, "Mturned", 412, "Mu", 924, "N", 78, "NJ", 458, "Nacute", 323, "Ncaron", 327, "Ncedilla", 325, "Ncircle", 9411, "Ncircumflexbelow", 7754, "Ncommaaccent", 325, "Ndotaccent", 7748, "Ndotbelow", 7750, "Nhookleft", 413, "Nineroman", 8552, "Nj", 459, "Njecyrillic", 1034, "Nlinebelow", 7752, "Nmonospace", 65326, "Nowarmenian", 1350, "Nsmall", 63342, "Ntilde", 209, "Ntildesmall", 63473, "Nu", 925, "O", 79, "OE", 338, "OEsmall", 63226, "Oacute", 211, "Oacutesmall", 63475, "Obarredcyrillic", 1256, "Obarreddieresiscyrillic", 1258, "Obreve", 334, "Ocaron", 465, "Ocenteredtilde", 415, "Ocircle", 9412, "Ocircumflex", 212, "Ocircumflexacute", 7888, "Ocircumflexdotbelow", 7896, "Ocircumflexgrave", 7890, "Ocircumflexhookabove", 7892, "Ocircumflexsmall", 63476, "Ocircumflextilde", 7894, "Ocyrillic", 1054, "Odblacute", 336, "Odblgrave", 524, "Odieresis", 214, "Odieresiscyrillic", 1254, "Odieresissmall", 63478, "Odotbelow", 7884, "Ogoneksmall", 63227, "Ograve", 210, "Ogravesmall", 63474, "Oharmenian", 1365, "Ohm", 8486, "Ohookabove", 7886, "Ohorn", 416, "Ohornacute", 7898, "Ohorndotbelow", 7906, "Ohorngrave", 7900, "Ohornhookabove", 7902, "Ohorntilde", 7904, "Ohungarumlaut", 336, "Oi", 418, "Oinvertedbreve", 526, "Omacron", 332, "Omacronacute", 7762, "Omacrongrave", 7760, "Omega", 8486, "Omegacyrillic", 1120, "Omegagreek", 937, "Omegaroundcyrillic", 1146, "Omegatitlocyrillic", 1148, "Omegatonos", 911, "Omicron", 927, "Omicrontonos", 908, "Omonospace", 65327, "Oneroman", 8544, "Oogonek", 490, "Oogonekmacron", 492, "Oopen", 390, "Oslash", 216, "Oslashacute", 510, "Oslashsmall", 63480, "Osmall", 63343, "Ostrokeacute", 510, "Otcyrillic", 1150, "Otilde", 213, "Otildeacute", 7756, "Otildedieresis", 7758, "Otildesmall", 63477, "P", 80, "Pacute", 7764, "Pcircle", 9413, "Pdotaccent", 7766, "Pecyrillic", 1055, "Peharmenian", 1354, "Pemiddlehookcyrillic", 1190, "Phi", 934, "Phook", 420, "Pi", 928, "Piwrarmenian", 1363, "Pmonospace", 65328, "Psi", 936, "Psicyrillic", 1136, "Psmall", 63344, "Q", 81, "Qcircle", 9414, "Qmonospace", 65329, "Qsmall", 63345, "R", 82, "Raarmenian", 1356, "Racute", 340, "Rcaron", 344, "Rcedilla", 342, "Rcircle", 9415, "Rcommaaccent", 342, "Rdblgrave", 528, "Rdotaccent", 7768, "Rdotbelow", 7770, "Rdotbelowmacron", 7772, "Reharmenian", 1360, "Rfraktur", 8476, "Rho", 929, "Ringsmall", 63228, "Rinvertedbreve", 530, "Rlinebelow", 7774, "Rmonospace", 65330, "Rsmall", 63346, "Rsmallinverted", 641, "Rsmallinvertedsuperior", 694, "S", 83, "SF010000", 9484, "SF020000", 9492, "SF030000", 9488, "SF040000", 9496, "SF050000", 9532, "SF060000", 9516, "SF070000", 9524, "SF080000", 9500, "SF090000", 9508, "SF100000", 9472, "SF110000", 9474, "SF190000", 9569, "SF200000", 9570, "SF210000", 9558, "SF220000", 9557, "SF230000", 9571, "SF240000", 9553, "SF250000", 9559, "SF260000", 9565, "SF270000", 9564, "SF280000", 9563, "SF360000", 9566, "SF370000", 9567, "SF380000", 9562, "SF390000", 9556, "SF400000", 9577, "SF410000", 9574, "SF420000", 9568, "SF430000", 9552, "SF440000", 9580, "SF450000", 9575, "SF460000", 9576, "SF470000", 9572, "SF480000", 9573, "SF490000", 9561, "SF500000", 9560, "SF510000", 9554, "SF520000", 9555, "SF530000", 9579, "SF540000", 9578, "Sacute", 346, "Sacutedotaccent", 7780, "Sampigreek", 992, "Scaron", 352, "Scarondotaccent", 7782, "Scaronsmall", 63229, "Scedilla", 350, "Schwa", 399, "Schwacyrillic", 1240, "Schwadieresiscyrillic", 1242, "Scircle", 9416, "Scircumflex", 348, "Scommaaccent", 536, "Sdotaccent", 7776, "Sdotbelow", 7778, "Sdotbelowdotaccent", 7784, "Seharmenian", 1357, "Sevenroman", 8550, "Shaarmenian", 1351, "Shacyrillic", 1064, "Shchacyrillic", 1065, "Sheicoptic", 994, "Shhacyrillic", 1210, "Shimacoptic", 1004, "Sigma", 931, "Sixroman", 8549, "Smonospace", 65331, "Softsigncyrillic", 1068, "Ssmall", 63347, "Stigmagreek", 986, "T", 84, "Tau", 932, "Tbar", 358, "Tcaron", 356, "Tcedilla", 354, "Tcircle", 9417, "Tcircumflexbelow", 7792, "Tcommaaccent", 354, "Tdotaccent", 7786, "Tdotbelow", 7788, "Tecyrillic", 1058, "Tedescendercyrillic", 1196, "Tenroman", 8553, "Tetsecyrillic", 1204, "Theta", 920, "Thook", 428, "Thorn", 222, "Thornsmall", 63486, "Threeroman", 8546, "Tildesmall", 63230, "Tiwnarmenian", 1359, "Tlinebelow", 7790, "Tmonospace", 65332, "Toarmenian", 1337, "Tonefive", 444, "Tonesix", 388, "Tonetwo", 423, "Tretroflexhook", 430, "Tsecyrillic", 1062, "Tshecyrillic", 1035, "Tsmall", 63348, "Twelveroman", 8555, "Tworoman", 8545, "U", 85, "Uacute", 218, "Uacutesmall", 63482, "Ubreve", 364, "Ucaron", 467, "Ucircle", 9418, "Ucircumflex", 219, "Ucircumflexbelow", 7798, "Ucircumflexsmall", 63483, "Ucyrillic", 1059, "Udblacute", 368, "Udblgrave", 532, "Udieresis", 220, "Udieresisacute", 471, "Udieresisbelow", 7794, "Udieresiscaron", 473, "Udieresiscyrillic", 1264, "Udieresisgrave", 475, "Udieresismacron", 469, "Udieresissmall", 63484, "Udotbelow", 7908, "Ugrave", 217, "Ugravesmall", 63481, "Uhookabove", 7910, "Uhorn", 431, "Uhornacute", 7912, "Uhorndotbelow", 7920, "Uhorngrave", 7914, "Uhornhookabove", 7916, "Uhorntilde", 7918, "Uhungarumlaut", 368, "Uhungarumlautcyrillic", 1266, "Uinvertedbreve", 534, "Ukcyrillic", 1144, "Umacron", 362, "Umacroncyrillic", 1262, "Umacrondieresis", 7802, "Umonospace", 65333, "Uogonek", 370, "Upsilon", 933, "Upsilon1", 978, "Upsilonacutehooksymbolgreek", 979, "Upsilonafrican", 433, "Upsilondieresis", 939, "Upsilondieresishooksymbolgreek", 980, "Upsilonhooksymbol", 978, "Upsilontonos", 910, "Uring", 366, "Ushortcyrillic", 1038, "Usmall", 63349, "Ustraightcyrillic", 1198, "Ustraightstrokecyrillic", 1200, "Utilde", 360, "Utildeacute", 7800, "Utildebelow", 7796, "V", 86, "Vcircle", 9419, "Vdotbelow", 7806, "Vecyrillic", 1042, "Vewarmenian", 1358, "Vhook", 434, "Vmonospace", 65334, "Voarmenian", 1352, "Vsmall", 63350, "Vtilde", 7804, "W", 87, "Wacute", 7810, "Wcircle", 9420, "Wcircumflex", 372, "Wdieresis", 7812, "Wdotaccent", 7814, "Wdotbelow", 7816, "Wgrave", 7808, "Wmonospace", 65335, "Wsmall", 63351, "X", 88, "Xcircle", 9421, "Xdieresis", 7820, "Xdotaccent", 7818, "Xeharmenian", 1341, "Xi", 926, "Xmonospace", 65336, "Xsmall", 63352, "Y", 89, "Yacute", 221, "Yacutesmall", 63485, "Yatcyrillic", 1122, "Ycircle", 9422, "Ycircumflex", 374, "Ydieresis", 376, "Ydieresissmall", 63487, "Ydotaccent", 7822, "Ydotbelow", 7924, "Yericyrillic", 1067, "Yerudieresiscyrillic", 1272, "Ygrave", 7922, "Yhook", 435, "Yhookabove", 7926, "Yiarmenian", 1349, "Yicyrillic", 1031, "Yiwnarmenian", 1362, "Ymonospace", 65337, "Ysmall", 63353, "Ytilde", 7928, "Yusbigcyrillic", 1130, "Yusbigiotifiedcyrillic", 1132, "Yuslittlecyrillic", 1126, "Yuslittleiotifiedcyrillic", 1128, "Z", 90, "Zaarmenian", 1334, "Zacute", 377, "Zcaron", 381, "Zcaronsmall", 63231, "Zcircle", 9423, "Zcircumflex", 7824, "Zdot", 379, "Zdotaccent", 379, "Zdotbelow", 7826, "Zecyrillic", 1047, "Zedescendercyrillic", 1176, "Zedieresiscyrillic", 1246, "Zeta", 918, "Zhearmenian", 1338, "Zhebrevecyrillic", 1217, "Zhecyrillic", 1046, "Zhedescendercyrillic", 1174, "Zhedieresiscyrillic", 1244, "Zlinebelow", 7828, "Zmonospace", 65338, "Zsmall", 63354, "Zstroke", 437, "a", 97, "aabengali", 2438, "aacute", 225, "aadeva", 2310, "aagujarati", 2694, "aagurmukhi", 2566, "aamatragurmukhi", 2622, "aarusquare", 13059, "aavowelsignbengali", 2494, "aavowelsigndeva", 2366, "aavowelsigngujarati", 2750, "abbreviationmarkarmenian", 1375, "abbreviationsigndeva", 2416, "abengali", 2437, "abopomofo", 12570, "abreve", 259, "abreveacute", 7855, "abrevecyrillic", 1233, "abrevedotbelow", 7863, "abrevegrave", 7857, "abrevehookabove", 7859, "abrevetilde", 7861, "acaron", 462, "acircle", 9424, "acircumflex", 226, "acircumflexacute", 7845, "acircumflexdotbelow", 7853, "acircumflexgrave", 7847, "acircumflexhookabove", 7849, "acircumflextilde", 7851, "acute", 180, "acutebelowcmb", 791, "acutecmb", 769, "acutecomb", 769, "acutedeva", 2388, "acutelowmod", 719, "acutetonecmb", 833, "acyrillic", 1072, "adblgrave", 513, "addakgurmukhi", 2673, "adeva", 2309, "adieresis", 228, "adieresiscyrillic", 1235, "adieresismacron", 479, "adotbelow", 7841, "adotmacron", 481, "ae", 230, "aeacute", 509, "aekorean", 12624, "aemacron", 483, "afii00208", 8213, "afii08941", 8356, "afii10017", 1040, "afii10018", 1041, "afii10019", 1042, "afii10020", 1043, "afii10021", 1044, "afii10022", 1045, "afii10023", 1025, "afii10024", 1046, "afii10025", 1047, "afii10026", 1048, "afii10027", 1049, "afii10028", 1050, "afii10029", 1051, "afii10030", 1052, "afii10031", 1053, "afii10032", 1054, "afii10033", 1055, "afii10034", 1056, "afii10035", 1057, "afii10036", 1058, "afii10037", 1059, "afii10038", 1060, "afii10039", 1061, "afii10040", 1062, "afii10041", 1063, "afii10042", 1064, "afii10043", 1065, "afii10044", 1066, "afii10045", 1067, "afii10046", 1068, "afii10047", 1069, "afii10048", 1070, "afii10049", 1071, "afii10050", 1168, "afii10051", 1026, "afii10052", 1027, "afii10053", 1028, "afii10054", 1029, "afii10055", 1030, "afii10056", 1031, "afii10057", 1032, "afii10058", 1033, "afii10059", 1034, "afii10060", 1035, "afii10061", 1036, "afii10062", 1038, "afii10063", 63172, "afii10064", 63173, "afii10065", 1072, "afii10066", 1073, "afii10067", 1074, "afii10068", 1075, "afii10069", 1076, "afii10070", 1077, "afii10071", 1105, "afii10072", 1078, "afii10073", 1079, "afii10074", 1080, "afii10075", 1081, "afii10076", 1082, "afii10077", 1083, "afii10078", 1084, "afii10079", 1085, "afii10080", 1086, "afii10081", 1087, "afii10082", 1088, "afii10083", 1089, "afii10084", 1090, "afii10085", 1091, "afii10086", 1092, "afii10087", 1093, "afii10088", 1094, "afii10089", 1095, "afii10090", 1096, "afii10091", 1097, "afii10092", 1098, "afii10093", 1099, "afii10094", 1100, "afii10095", 1101, "afii10096", 1102, "afii10097", 1103, "afii10098", 1169, "afii10099", 1106, "afii10100", 1107, "afii10101", 1108, "afii10102", 1109, "afii10103", 1110, "afii10104", 1111, "afii10105", 1112, "afii10106", 1113, "afii10107", 1114, "afii10108", 1115, "afii10109", 1116, "afii10110", 1118, "afii10145", 1039, "afii10146", 1122, "afii10147", 1138, "afii10148", 1140, "afii10192", 63174, "afii10193", 1119, "afii10194", 1123, "afii10195", 1139, "afii10196", 1141, "afii10831", 63175, "afii10832", 63176, "afii10846", 1241, "afii299", 8206, "afii300", 8207, "afii301", 8205, "afii57381", 1642, "afii57388", 1548, "afii57392", 1632, "afii57393", 1633, "afii57394", 1634, "afii57395", 1635, "afii57396", 1636, "afii57397", 1637, "afii57398", 1638, "afii57399", 1639, "afii57400", 1640, "afii57401", 1641, "afii57403", 1563, "afii57407", 1567, "afii57409", 1569, "afii57410", 1570, "afii57411", 1571, "afii57412", 1572, "afii57413", 1573, "afii57414", 1574, "afii57415", 1575, "afii57416", 1576, "afii57417", 1577, "afii57418", 1578, "afii57419", 1579, "afii57420", 1580, "afii57421", 1581, "afii57422", 1582, "afii57423", 1583, "afii57424", 1584, "afii57425", 1585, "afii57426", 1586, "afii57427", 1587, "afii57428", 1588, "afii57429", 1589, "afii57430", 1590, "afii57431", 1591, "afii57432", 1592, "afii57433", 1593, "afii57434", 1594, "afii57440", 1600, "afii57441", 1601, "afii57442", 1602, "afii57443", 1603, "afii57444", 1604, "afii57445", 1605, "afii57446", 1606, "afii57448", 1608, "afii57449", 1609, "afii57450", 1610, "afii57451", 1611, "afii57452", 1612, "afii57453", 1613, "afii57454", 1614, "afii57455", 1615, "afii57456", 1616, "afii57457", 1617, "afii57458", 1618, "afii57470", 1607, "afii57505", 1700, "afii57506", 1662, "afii57507", 1670, "afii57508", 1688, "afii57509", 1711, "afii57511", 1657, "afii57512", 1672, "afii57513", 1681, "afii57514", 1722, "afii57519", 1746, "afii57534", 1749, "afii57636", 8362, "afii57645", 1470, "afii57658", 1475, "afii57664", 1488, "afii57665", 1489, "afii57666", 1490, "afii57667", 1491, "afii57668", 1492, "afii57669", 1493, "afii57670", 1494, "afii57671", 1495, "afii57672", 1496, "afii57673", 1497, "afii57674", 1498, "afii57675", 1499, "afii57676", 1500, "afii57677", 1501, "afii57678", 1502, "afii57679", 1503, "afii57680", 1504, "afii57681", 1505, "afii57682", 1506, "afii57683", 1507, "afii57684", 1508, "afii57685", 1509, "afii57686", 1510, "afii57687", 1511, "afii57688", 1512, "afii57689", 1513, "afii57690", 1514, "afii57694", 64298, "afii57695", 64299, "afii57700", 64331, "afii57705", 64287, "afii57716", 1520, "afii57717", 1521, "afii57718", 1522, "afii57723", 64309, "afii57793", 1460, "afii57794", 1461, "afii57795", 1462, "afii57796", 1467, "afii57797", 1464, "afii57798", 1463, "afii57799", 1456, "afii57800", 1458, "afii57801", 1457, "afii57802", 1459, "afii57803", 1474, "afii57804", 1473, "afii57806", 1465, "afii57807", 1468, "afii57839", 1469, "afii57841", 1471, "afii57842", 1472, "afii57929", 700, "afii61248", 8453, "afii61289", 8467, "afii61352", 8470, "afii61573", 8236, "afii61574", 8237, "afii61575", 8238, "afii61664", 8204, "afii63167", 1645, "afii64937", 701, "agrave", 224, "agujarati", 2693, "agurmukhi", 2565, "ahiragana", 12354, "ahookabove", 7843, "aibengali", 2448, "aibopomofo", 12574, "aideva", 2320, "aiecyrillic", 1237, "aigujarati", 2704, "aigurmukhi", 2576, "aimatragurmukhi", 2632, "ainarabic", 1593, "ainfinalarabic", 65226, "aininitialarabic", 65227, "ainmedialarabic", 65228, "ainvertedbreve", 515, "aivowelsignbengali", 2504, "aivowelsigndeva", 2376, "aivowelsigngujarati", 2760, "akatakana", 12450, "akatakanahalfwidth", 65393, "akorean", 12623, "alef", 1488, "alefarabic", 1575, "alefdageshhebrew", 64304, "aleffinalarabic", 65166, "alefhamzaabovearabic", 1571, "alefhamzaabovefinalarabic", 65156, "alefhamzabelowarabic", 1573, "alefhamzabelowfinalarabic", 65160, "alefhebrew", 1488, "aleflamedhebrew", 64335, "alefmaddaabovearabic", 1570, "alefmaddaabovefinalarabic", 65154, "alefmaksuraarabic", 1609, "alefmaksurafinalarabic", 65264, "alefmaksurainitialarabic", 65267, "alefmaksuramedialarabic", 65268, "alefpatahhebrew", 64302, "alefqamatshebrew", 64303, "aleph", 8501, "allequal", 8780, "alpha", 945, "alphatonos", 940, "amacron", 257, "amonospace", 65345, "ampersand", 38, "ampersandmonospace", 65286, "ampersandsmall", 63270, "amsquare", 13250, "anbopomofo", 12578, "angbopomofo", 12580, "angbracketleft", 12296, "angbracketright", 12297, "angkhankhuthai", 3674, "angle", 8736, "anglebracketleft", 12296, "anglebracketleftvertical", 65087, "anglebracketright", 12297, "anglebracketrightvertical", 65088, "angleleft", 9001, "angleright", 9002, "angstrom", 8491, "anoteleia", 903, "anudattadeva", 2386, "anusvarabengali", 2434, "anusvaradeva", 2306, "anusvaragujarati", 2690, "aogonek", 261, "apaatosquare", 13056, "aparen", 9372, "apostrophearmenian", 1370, "apostrophemod", 700, "apple", 63743, "approaches", 8784, "approxequal", 8776, "approxequalorimage", 8786, "approximatelyequal", 8773, "araeaekorean", 12686, "araeakorean", 12685, "arc", 8978, "arighthalfring", 7834, "aring", 229, "aringacute", 507, "aringbelow", 7681, "arrowboth", 8596, "arrowdashdown", 8675, "arrowdashleft", 8672, "arrowdashright", 8674, "arrowdashup", 8673, "arrowdblboth", 8660, "arrowdbldown", 8659, "arrowdblleft", 8656, "arrowdblright", 8658, "arrowdblup", 8657, "arrowdown", 8595, "arrowdownleft", 8601, "arrowdownright", 8600, "arrowdownwhite", 8681, "arrowheaddownmod", 709, "arrowheadleftmod", 706, "arrowheadrightmod", 707, "arrowheadupmod", 708, "arrowhorizex", 63719, "arrowleft", 8592, "arrowleftdbl", 8656, "arrowleftdblstroke", 8653, "arrowleftoverright", 8646, "arrowleftwhite", 8678, "arrowright", 8594, "arrowrightdblstroke", 8655, "arrowrightheavy", 10142, "arrowrightoverleft", 8644, "arrowrightwhite", 8680, "arrowtableft", 8676, "arrowtabright", 8677, "arrowup", 8593, "arrowupdn", 8597, "arrowupdnbse", 8616, "arrowupdownbase", 8616, "arrowupleft", 8598, "arrowupleftofdown", 8645, "arrowupright", 8599, "arrowupwhite", 8679, "arrowvertex", 63718, "asciicircum", 94, "asciicircummonospace", 65342, "asciitilde", 126, "asciitildemonospace", 65374, "ascript", 593, "ascriptturned", 594, "asmallhiragana", 12353, "asmallkatakana", 12449, "asmallkatakanahalfwidth", 65383, "asterisk", 42, "asteriskaltonearabic", 1645, "asteriskarabic", 1645, "asteriskmath", 8727, "asteriskmonospace", 65290, "asterisksmall", 65121, "asterism", 8258, "asuperior", 63209, "asymptoticallyequal", 8771, "at", 64, "atilde", 227, "atmonospace", 65312, "atsmall", 65131, "aturned", 592, "aubengali", 2452, "aubopomofo", 12576, "audeva", 2324, "augujarati", 2708, "augurmukhi", 2580, "aulengthmarkbengali", 2519, "aumatragurmukhi", 2636, "auvowelsignbengali", 2508, "auvowelsigndeva", 2380, "auvowelsigngujarati", 2764, "avagrahadeva", 2365, "aybarmenian", 1377, "ayin", 1506, "ayinaltonehebrew", 64288, "ayinhebrew", 1506, "b", 98, "babengali", 2476, "backslash", 92, "backslashmonospace", 65340, "badeva", 2348, "bagujarati", 2732, "bagurmukhi", 2604, "bahiragana", 12400, "bahtthai", 3647, "bakatakana", 12496, "bar", 124, "barmonospace", 65372, "bbopomofo", 12549, "bcircle", 9425, "bdotaccent", 7683, "bdotbelow", 7685, "beamedsixteenthnotes", 9836, "because", 8757, "becyrillic", 1073, "beharabic", 1576, "behfinalarabic", 65168, "behinitialarabic", 65169, "behiragana", 12409, "behmedialarabic", 65170, "behmeeminitialarabic", 64671, "behmeemisolatedarabic", 64520, "behnoonfinalarabic", 64621, "bekatakana", 12505, "benarmenian", 1378, "bet", 1489, "beta", 946, "betasymbolgreek", 976, "betdagesh", 64305, "betdageshhebrew", 64305, "bethebrew", 1489, "betrafehebrew", 64332, "bhabengali", 2477, "bhadeva", 2349, "bhagujarati", 2733, "bhagurmukhi", 2605, "bhook", 595, "bihiragana", 12403, "bikatakana", 12499, "bilabialclick", 664, "bindigurmukhi", 2562, "birusquare", 13105, "blackcircle", 9679, "blackdiamond", 9670, "blackdownpointingtriangle", 9660, "blackleftpointingpointer", 9668, "blackleftpointingtriangle", 9664, "blacklenticularbracketleft", 12304, "blacklenticularbracketleftvertical", 65083, "blacklenticularbracketright", 12305, "blacklenticularbracketrightvertical", 65084, "blacklowerlefttriangle", 9699, "blacklowerrighttriangle", 9698, "blackrectangle", 9644, "blackrightpointingpointer", 9658, "blackrightpointingtriangle", 9654, "blacksmallsquare", 9642, "blacksmilingface", 9787, "blacksquare", 9632, "blackstar", 9733, "blackupperlefttriangle", 9700, "blackupperrighttriangle", 9701, "blackuppointingsmalltriangle", 9652, "blackuppointingtriangle", 9650, "blank", 9251, "blinebelow", 7687, "block", 9608, "bmonospace", 65346, "bobaimaithai", 3610, "bohiragana", 12412, "bokatakana", 12508, "bparen", 9373, "bqsquare", 13251, "braceex", 63732, "braceleft", 123, "braceleftbt", 63731, "braceleftmid", 63730, "braceleftmonospace", 65371, "braceleftsmall", 65115, "bracelefttp", 63729, "braceleftvertical", 65079, "braceright", 125, "bracerightbt", 63742, "bracerightmid", 63741, "bracerightmonospace", 65373, "bracerightsmall", 65116, "bracerighttp", 63740, "bracerightvertical", 65080, "bracketleft", 91, "bracketleftbt", 63728, "bracketleftex", 63727, "bracketleftmonospace", 65339, "bracketlefttp", 63726, "bracketright", 93, "bracketrightbt", 63739, "bracketrightex", 63738, "bracketrightmonospace", 65341, "bracketrighttp", 63737, "breve", 728, "brevebelowcmb", 814, "brevecmb", 774, "breveinvertedbelowcmb", 815, "breveinvertedcmb", 785, "breveinverteddoublecmb", 865, "bridgebelowcmb", 810, "bridgeinvertedbelowcmb", 826, "brokenbar", 166, "bstroke", 384, "bsuperior", 63210, "btopbar", 387, "buhiragana", 12406, "bukatakana", 12502, "bullet", 8226, "bulletinverse", 9688, "bulletoperator", 8729, "bullseye", 9678, "c", 99, "caarmenian", 1390, "cabengali", 2458, "cacute", 263, "cadeva", 2330, "cagujarati", 2714, "cagurmukhi", 2586, "calsquare", 13192, "candrabindubengali", 2433, "candrabinducmb", 784, "candrabindudeva", 2305, "candrabindugujarati", 2689, "capslock", 8682, "careof", 8453, "caron", 711, "caronbelowcmb", 812, "caroncmb", 780, "carriagereturn", 8629, "cbopomofo", 12568, "ccaron", 269, "ccedilla", 231, "ccedillaacute", 7689, "ccircle", 9426, "ccircumflex", 265, "ccurl", 597, "cdot", 267, "cdotaccent", 267, "cdsquare", 13253, "cedilla", 184, "cedillacmb", 807, "cent", 162, "centigrade", 8451, "centinferior", 63199, "centmonospace", 65504, "centoldstyle", 63394, "centsuperior", 63200, "chaarmenian", 1401, "chabengali", 2459, "chadeva", 2331, "chagujarati", 2715, "chagurmukhi", 2587, "chbopomofo", 12564, "cheabkhasiancyrillic", 1213, "checkmark", 10003, "checyrillic", 1095, "chedescenderabkhasiancyrillic", 1215, "chedescendercyrillic", 1207, "chedieresiscyrillic", 1269, "cheharmenian", 1395, "chekhakassiancyrillic", 1228, "cheverticalstrokecyrillic", 1209, "chi", 967, "chieuchacirclekorean", 12919, "chieuchaparenkorean", 12823, "chieuchcirclekorean", 12905, "chieuchkorean", 12618, "chieuchparenkorean", 12809, "chochangthai", 3594, "chochanthai", 3592, "chochingthai", 3593, "chochoethai", 3596, "chook", 392, "cieucacirclekorean", 12918, "cieucaparenkorean", 12822, "cieuccirclekorean", 12904, "cieuckorean", 12616, "cieucparenkorean", 12808, "cieucuparenkorean", 12828, "circle", 9675, "circlecopyrt", 169, "circlemultiply", 8855, "circleot", 8857, "circleplus", 8853, "circlepostalmark", 12342, "circlewithlefthalfblack", 9680, "circlewithrighthalfblack", 9681, "circumflex", 710, "circumflexbelowcmb", 813, "circumflexcmb", 770, "clear", 8999, "clickalveolar", 450, "clickdental", 448, "clicklateral", 449, "clickretroflex", 451, "club", 9827, "clubsuitblack", 9827, "clubsuitwhite", 9831, "cmcubedsquare", 13220, "cmonospace", 65347, "cmsquaredsquare", 13216, "coarmenian", 1409, "colon", 58, "colonmonetary", 8353, "colonmonospace", 65306, "colonsign", 8353, "colonsmall", 65109, "colontriangularhalfmod", 721, "colontriangularmod", 720, "comma", 44, "commaabovecmb", 787, "commaaboverightcmb", 789, "commaaccent", 63171, "commaarabic", 1548, "commaarmenian", 1373, "commainferior", 63201, "commamonospace", 65292, "commareversedabovecmb", 788, "commareversedmod", 701, "commasmall", 65104, "commasuperior", 63202, "commaturnedabovecmb", 786, "commaturnedmod", 699, "compass", 9788, "congruent", 8773, "contourintegral", 8750, "control", 8963, "controlACK", 6, "controlBEL", 7, "controlBS", 8, "controlCAN", 24, "controlCR", 13, "controlDC1", 17, "controlDC2", 18, "controlDC3", 19, "controlDC4", 20, "controlDEL", 127, "controlDLE", 16, "controlEM", 25, "controlENQ", 5, "controlEOT", 4, "controlESC", 27, "controlETB", 23, "controlETX", 3, "controlFF", 12, "controlFS", 28, "controlGS", 29, "controlHT", 9, "controlLF", 10, "controlNAK", 21, "controlNULL", 0, "controlRS", 30, "controlSI", 15, "controlSO", 14, "controlSOT", 2, "controlSTX", 1, "controlSUB", 26, "controlSYN", 22, "controlUS", 31, "controlVT", 11, "copyright", 169, "copyrightsans", 63721, "copyrightserif", 63193, "cornerbracketleft", 12300, "cornerbracketlefthalfwidth", 65378, "cornerbracketleftvertical", 65089, "cornerbracketright", 12301, "cornerbracketrighthalfwidth", 65379, "cornerbracketrightvertical", 65090, "corporationsquare", 13183, "cosquare", 13255, "coverkgsquare", 13254, "cparen", 9374, "cruzeiro", 8354, "cstretched", 663, "curlyand", 8911, "curlyor", 8910, "currency", 164, "cyrBreve", 63185, "cyrFlex", 63186, "cyrbreve", 63188, "cyrflex", 63189, "d", 100, "daarmenian", 1380, "dabengali", 2470, "dadarabic", 1590, "dadeva", 2342, "dadfinalarabic", 65214, "dadinitialarabic", 65215, "dadmedialarabic", 65216, "dagesh", 1468, "dageshhebrew", 1468, "dagger", 8224, "daggerdbl", 8225, "dagujarati", 2726, "dagurmukhi", 2598, "dahiragana", 12384, "dakatakana", 12480, "dalarabic", 1583, "dalet", 1491, "daletdagesh", 64307, "daletdageshhebrew", 64307, "dalethebrew", 1491, "dalfinalarabic", 65194, "dammaarabic", 1615, "dammalowarabic", 1615, "dammatanaltonearabic", 1612, "dammatanarabic", 1612, "danda", 2404, "dargahebrew", 1447, "dargalefthebrew", 1447, "dasiapneumatacyrilliccmb", 1157, "dblGrave", 63187, "dblanglebracketleft", 12298, "dblanglebracketleftvertical", 65085, "dblanglebracketright", 12299, "dblanglebracketrightvertical", 65086, "dblarchinvertedbelowcmb", 811, "dblarrowleft", 8660, "dblarrowright", 8658, "dbldanda", 2405, "dblgrave", 63190, "dblgravecmb", 783, "dblintegral", 8748, "dbllowline", 8215, "dbllowlinecmb", 819, "dbloverlinecmb", 831, "dblprimemod", 698, "dblverticalbar", 8214, "dblverticallineabovecmb", 782, "dbopomofo", 12553, "dbsquare", 13256, "dcaron", 271, "dcedilla", 7697, "dcircle", 9427, "dcircumflexbelow", 7699, "dcroat", 273, "ddabengali", 2465, "ddadeva", 2337, "ddagujarati", 2721, "ddagurmukhi", 2593, "ddalarabic", 1672, "ddalfinalarabic", 64393, "dddhadeva", 2396, "ddhabengali", 2466, "ddhadeva", 2338, "ddhagujarati", 2722, "ddhagurmukhi", 2594, "ddotaccent", 7691, "ddotbelow", 7693, "decimalseparatorarabic", 1643, "decimalseparatorpersian", 1643, "decyrillic", 1076, "degree", 176, "dehihebrew", 1453, "dehiragana", 12391, "deicoptic", 1007, "dekatakana", 12487, "deleteleft", 9003, "deleteright", 8998, "delta", 948, "deltaturned", 397, "denominatorminusonenumeratorbengali", 2552, "dezh", 676, "dhabengali", 2471, "dhadeva", 2343, "dhagujarati", 2727, "dhagurmukhi", 2599, "dhook", 599, "dialytikatonos", 901, "dialytikatonoscmb", 836, "diamond", 9830, "diamondsuitwhite", 9826, "dieresis", 168, "dieresisacute", 63191, "dieresisbelowcmb", 804, "dieresiscmb", 776, "dieresisgrave", 63192, "dieresistonos", 901, "dihiragana", 12386, "dikatakana", 12482, "dittomark", 12291, "divide", 247, "divides", 8739, "divisionslash", 8725, "djecyrillic", 1106, "dkshade", 9619, "dlinebelow", 7695, "dlsquare", 13207, "dmacron", 273, "dmonospace", 65348, "dnblock", 9604, "dochadathai", 3598, "dodekthai", 3604, "dohiragana", 12393, "dokatakana", 12489, "dollar", 36, "dollarinferior", 63203, "dollarmonospace", 65284, "dollaroldstyle", 63268, "dollarsmall", 65129, "dollarsuperior", 63204, "dong", 8363, "dorusquare", 13094, "dotaccent", 729, "dotaccentcmb", 775, "dotbelowcmb", 803, "dotbelowcomb", 803, "dotkatakana", 12539, "dotlessi", 305, "dotlessj", 63166, "dotlessjstrokehook", 644, "dotmath", 8901, "dottedcircle", 9676, "doubleyodpatah", 64287, "doubleyodpatahhebrew", 64287, "downtackbelowcmb", 798, "downtackmod", 725, "dparen", 9375, "dsuperior", 63211, "dtail", 598, "dtopbar", 396, "duhiragana", 12389, "dukatakana", 12485, "dz", 499, "dzaltone", 675, "dzcaron", 454, "dzcurl", 677, "dzeabkhasiancyrillic", 1249, "dzecyrillic", 1109, "dzhecyrillic", 1119, "e", 101, "eacute", 233, "earth", 9793, "ebengali", 2447, "ebopomofo", 12572, "ebreve", 277, "ecandradeva", 2317, "ecandragujarati", 2701, "ecandravowelsigndeva", 2373, "ecandravowelsigngujarati", 2757, "ecaron", 283, "ecedillabreve", 7709, "echarmenian", 1381, "echyiwnarmenian", 1415, "ecircle", 9428, "ecircumflex", 234, "ecircumflexacute", 7871, "ecircumflexbelow", 7705, "ecircumflexdotbelow", 7879, "ecircumflexgrave", 7873, "ecircumflexhookabove", 7875, "ecircumflextilde", 7877, "ecyrillic", 1108, "edblgrave", 517, "edeva", 2319, "edieresis", 235, "edot", 279, "edotaccent", 279, "edotbelow", 7865, "eegurmukhi", 2575, "eematragurmukhi", 2631, "efcyrillic", 1092, "egrave", 232, "egujarati", 2703, "eharmenian", 1383, "ehbopomofo", 12573, "ehiragana", 12360, "ehookabove", 7867, "eibopomofo", 12575, "eight", 56, "eightarabic", 1640, "eightbengali", 2542, "eightcircle", 9319, "eightcircleinversesansserif", 10129, "eightdeva", 2414, "eighteencircle", 9329, "eighteenparen", 9349, "eighteenperiod", 9369, "eightgujarati", 2798, "eightgurmukhi", 2670, "eighthackarabic", 1640, "eighthangzhou", 12328, "eighthnotebeamed", 9835, "eightideographicparen", 12839, "eightinferior", 8328, "eightmonospace", 65304, "eightoldstyle", 63288, "eightparen", 9339, "eightperiod", 9359, "eightpersian", 1784, "eightroman", 8567, "eightsuperior", 8312, "eightthai", 3672, "einvertedbreve", 519, "eiotifiedcyrillic", 1125, "ekatakana", 12456, "ekatakanahalfwidth", 65396, "ekonkargurmukhi", 2676, "ekorean", 12628, "elcyrillic", 1083, "element", 8712, "elevencircle", 9322, "elevenparen", 9342, "elevenperiod", 9362, "elevenroman", 8570, "ellipsis", 8230, "ellipsisvertical", 8942, "emacron", 275, "emacronacute", 7703, "emacrongrave", 7701, "emcyrillic", 1084, "emdash", 8212, "emdashvertical", 65073, "emonospace", 65349, "emphasismarkarmenian", 1371, "emptyset", 8709, "enbopomofo", 12579, "encyrillic", 1085, "endash", 8211, "endashvertical", 65074, "endescendercyrillic", 1187, "eng", 331, "engbopomofo", 12581, "enghecyrillic", 1189, "enhookcyrillic", 1224, "enspace", 8194, "eogonek", 281, "eokorean", 12627, "eopen", 603, "eopenclosed", 666, "eopenreversed", 604, "eopenreversedclosed", 606, "eopenreversedhook", 605, "eparen", 9376, "epsilon", 949, "epsilontonos", 941, "equal", 61, "equalmonospace", 65309, "equalsmall", 65126, "equalsuperior", 8316, "equivalence", 8801, "erbopomofo", 12582, "ercyrillic", 1088, "ereversed", 600, "ereversedcyrillic", 1101, "escyrillic", 1089, "esdescendercyrillic", 1195, "esh", 643, "eshcurl", 646, "eshortdeva", 2318, "eshortvowelsigndeva", 2374, "eshreversedloop", 426, "eshsquatreversed", 645, "esmallhiragana", 12359, "esmallkatakana", 12455, "esmallkatakanahalfwidth", 65386, "estimated", 8494, "esuperior", 63212, "eta", 951, "etarmenian", 1384, "etatonos", 942, "eth", 240, "etilde", 7869, "etildebelow", 7707, "etnahtafoukhhebrew", 1425, "etnahtafoukhlefthebrew", 1425, "etnahtahebrew", 1425, "etnahtalefthebrew", 1425, "eturned", 477, "eukorean", 12641, "euro", 8364, "evowelsignbengali", 2503, "evowelsigndeva", 2375, "evowelsigngujarati", 2759, "exclam", 33, "exclamarmenian", 1372, "exclamdbl", 8252, "exclamdown", 161, "exclamdownsmall", 63393, "exclammonospace", 65281, "exclamsmall", 63265, "existential", 8707, "ezh", 658, "ezhcaron", 495, "ezhcurl", 659, "ezhreversed", 441, "ezhtail", 442, "f", 102, "fadeva", 2398, "fagurmukhi", 2654, "fahrenheit", 8457, "fathaarabic", 1614, "fathalowarabic", 1614, "fathatanarabic", 1611, "fbopomofo", 12552, "fcircle", 9429, "fdotaccent", 7711, "feharabic", 1601, "feharmenian", 1414, "fehfinalarabic", 65234, "fehinitialarabic", 65235, "fehmedialarabic", 65236, "feicoptic", 997, "female", 9792, "ff", 64256, "f_f", 64256, "ffi", 64259, "ffl", 64260, "fi", 64257, "fifteencircle", 9326, "fifteenparen", 9346, "fifteenperiod", 9366, "figuredash", 8210, "filledbox", 9632, "filledrect", 9644, "finalkaf", 1498, "finalkafdagesh", 64314, "finalkafdageshhebrew", 64314, "finalkafhebrew", 1498, "finalmem", 1501, "finalmemhebrew", 1501, "finalnun", 1503, "finalnunhebrew", 1503, "finalpe", 1507, "finalpehebrew", 1507, "finaltsadi", 1509, "finaltsadihebrew", 1509, "firsttonechinese", 713, "fisheye", 9673, "fitacyrillic", 1139, "five", 53, "fivearabic", 1637, "fivebengali", 2539, "fivecircle", 9316, "fivecircleinversesansserif", 10126, "fivedeva", 2411, "fiveeighths", 8541, "fivegujarati", 2795, "fivegurmukhi", 2667, "fivehackarabic", 1637, "fivehangzhou", 12325, "fiveideographicparen", 12836, "fiveinferior", 8325, "fivemonospace", 65301, "fiveoldstyle", 63285, "fiveparen", 9336, "fiveperiod", 9356, "fivepersian", 1781, "fiveroman", 8564, "fivesuperior", 8309, "fivethai", 3669, "fl", 64258, "florin", 402, "fmonospace", 65350, "fmsquare", 13209, "fofanthai", 3615, "fofathai", 3613, "fongmanthai", 3663, "forall", 8704, "four", 52, "fourarabic", 1636, "fourbengali", 2538, "fourcircle", 9315, "fourcircleinversesansserif", 10125, "fourdeva", 2410, "fourgujarati", 2794, "fourgurmukhi", 2666, "fourhackarabic", 1636, "fourhangzhou", 12324, "fourideographicparen", 12835, "fourinferior", 8324, "fourmonospace", 65300, "fournumeratorbengali", 2551, "fouroldstyle", 63284, "fourparen", 9335, "fourperiod", 9355, "fourpersian", 1780, "fourroman", 8563, "foursuperior", 8308, "fourteencircle", 9325, "fourteenparen", 9345, "fourteenperiod", 9365, "fourthai", 3668, "fourthtonechinese", 715, "fparen", 9377, "fraction", 8260, "franc", 8355, "g", 103, "gabengali", 2455, "gacute", 501, "gadeva", 2327, "gafarabic", 1711, "gaffinalarabic", 64403, "gafinitialarabic", 64404, "gafmedialarabic", 64405, "gagujarati", 2711, "gagurmukhi", 2583, "gahiragana", 12364, "gakatakana", 12460, "gamma", 947, "gammalatinsmall", 611, "gammasuperior", 736, "gangiacoptic", 1003, "gbopomofo", 12557, "gbreve", 287, "gcaron", 487, "gcedilla", 291, "gcircle", 9430, "gcircumflex", 285, "gcommaaccent", 291, "gdot", 289, "gdotaccent", 289, "gecyrillic", 1075, "gehiragana", 12370, "gekatakana", 12466, "geometricallyequal", 8785, "gereshaccenthebrew", 1436, "gereshhebrew", 1523, "gereshmuqdamhebrew", 1437, "germandbls", 223, "gershayimaccenthebrew", 1438, "gershayimhebrew", 1524, "getamark", 12307, "ghabengali", 2456, "ghadarmenian", 1394, "ghadeva", 2328, "ghagujarati", 2712, "ghagurmukhi", 2584, "ghainarabic", 1594, "ghainfinalarabic", 65230, "ghaininitialarabic", 65231, "ghainmedialarabic", 65232, "ghemiddlehookcyrillic", 1173, "ghestrokecyrillic", 1171, "gheupturncyrillic", 1169, "ghhadeva", 2394, "ghhagurmukhi", 2650, "ghook", 608, "ghzsquare", 13203, "gihiragana", 12366, "gikatakana", 12462, "gimarmenian", 1379, "gimel", 1490, "gimeldagesh", 64306, "gimeldageshhebrew", 64306, "gimelhebrew", 1490, "gjecyrillic", 1107, "glottalinvertedstroke", 446, "glottalstop", 660, "glottalstopinverted", 662, "glottalstopmod", 704, "glottalstopreversed", 661, "glottalstopreversedmod", 705, "glottalstopreversedsuperior", 740, "glottalstopstroke", 673, "glottalstopstrokereversed", 674, "gmacron", 7713, "gmonospace", 65351, "gohiragana", 12372, "gokatakana", 12468, "gparen", 9378, "gpasquare", 13228, "gradient", 8711, "grave", 96, "gravebelowcmb", 790, "gravecmb", 768, "gravecomb", 768, "gravedeva", 2387, "gravelowmod", 718, "gravemonospace", 65344, "gravetonecmb", 832, "greater", 62, "greaterequal", 8805, "greaterequalorless", 8923, "greatermonospace", 65310, "greaterorequivalent", 8819, "greaterorless", 8823, "greateroverequal", 8807, "greatersmall", 65125, "gscript", 609, "gstroke", 485, "guhiragana", 12368, "guillemotleft", 171, "guillemotright", 187, "guilsinglleft", 8249, "guilsinglright", 8250, "gukatakana", 12464, "guramusquare", 13080, "gysquare", 13257, "h", 104, "haabkhasiancyrillic", 1193, "haaltonearabic", 1729, "habengali", 2489, "hadescendercyrillic", 1203, "hadeva", 2361, "hagujarati", 2745, "hagurmukhi", 2617, "haharabic", 1581, "hahfinalarabic", 65186, "hahinitialarabic", 65187, "hahiragana", 12399, "hahmedialarabic", 65188, "haitusquare", 13098, "hakatakana", 12495, "hakatakanahalfwidth", 65418, "halantgurmukhi", 2637, "hamzaarabic", 1569, "hamzalowarabic", 1569, "hangulfiller", 12644, "hardsigncyrillic", 1098, "harpoonleftbarbup", 8636, "harpoonrightbarbup", 8640, "hasquare", 13258, "hatafpatah", 1458, "hatafpatah16", 1458, "hatafpatah23", 1458, "hatafpatah2f", 1458, "hatafpatahhebrew", 1458, "hatafpatahnarrowhebrew", 1458, "hatafpatahquarterhebrew", 1458, "hatafpatahwidehebrew", 1458, "hatafqamats", 1459, "hatafqamats1b", 1459, "hatafqamats28", 1459, "hatafqamats34", 1459, "hatafqamatshebrew", 1459, "hatafqamatsnarrowhebrew", 1459, "hatafqamatsquarterhebrew", 1459, "hatafqamatswidehebrew", 1459, "hatafsegol", 1457, "hatafsegol17", 1457, "hatafsegol24", 1457, "hatafsegol30", 1457, "hatafsegolhebrew", 1457, "hatafsegolnarrowhebrew", 1457, "hatafsegolquarterhebrew", 1457, "hatafsegolwidehebrew", 1457, "hbar", 295, "hbopomofo", 12559, "hbrevebelow", 7723, "hcedilla", 7721, "hcircle", 9431, "hcircumflex", 293, "hdieresis", 7719, "hdotaccent", 7715, "hdotbelow", 7717, "he", 1492, "heart", 9829, "heartsuitblack", 9829, "heartsuitwhite", 9825, "hedagesh", 64308, "hedageshhebrew", 64308, "hehaltonearabic", 1729, "heharabic", 1607, "hehebrew", 1492, "hehfinalaltonearabic", 64423, "hehfinalalttwoarabic", 65258, "hehfinalarabic", 65258, "hehhamzaabovefinalarabic", 64421, "hehhamzaaboveisolatedarabic", 64420, "hehinitialaltonearabic", 64424, "hehinitialarabic", 65259, "hehiragana", 12408, "hehmedialaltonearabic", 64425, "hehmedialarabic", 65260, "heiseierasquare", 13179, "hekatakana", 12504, "hekatakanahalfwidth", 65421, "hekutaarusquare", 13110, "henghook", 615, "herutusquare", 13113, "het", 1495, "hethebrew", 1495, "hhook", 614, "hhooksuperior", 689, "hieuhacirclekorean", 12923, "hieuhaparenkorean", 12827, "hieuhcirclekorean", 12909, "hieuhkorean", 12622, "hieuhparenkorean", 12813, "hihiragana", 12402, "hikatakana", 12498, "hikatakanahalfwidth", 65419, "hiriq", 1460, "hiriq14", 1460, "hiriq21", 1460, "hiriq2d", 1460, "hiriqhebrew", 1460, "hiriqnarrowhebrew", 1460, "hiriqquarterhebrew", 1460, "hiriqwidehebrew", 1460, "hlinebelow", 7830, "hmonospace", 65352, "hoarmenian", 1392, "hohipthai", 3627, "hohiragana", 12411, "hokatakana", 12507, "hokatakanahalfwidth", 65422, "holam", 1465, "holam19", 1465, "holam26", 1465, "holam32", 1465, "holamhebrew", 1465, "holamnarrowhebrew", 1465, "holamquarterhebrew", 1465, "holamwidehebrew", 1465, "honokhukthai", 3630, "hookabovecomb", 777, "hookcmb", 777, "hookpalatalizedbelowcmb", 801, "hookretroflexbelowcmb", 802, "hoonsquare", 13122, "horicoptic", 1001, "horizontalbar", 8213, "horncmb", 795, "hotsprings", 9832, "house", 8962, "hparen", 9379, "hsuperior", 688, "hturned", 613, "huhiragana", 12405, "huiitosquare", 13107, "hukatakana", 12501, "hukatakanahalfwidth", 65420, "hungarumlaut", 733, "hungarumlautcmb", 779, "hv", 405, "hyphen", 45, "hypheninferior", 63205, "hyphenmonospace", 65293, "hyphensmall", 65123, "hyphensuperior", 63206, "hyphentwo", 8208, "i", 105, "iacute", 237, "iacyrillic", 1103, "ibengali", 2439, "ibopomofo", 12583, "ibreve", 301, "icaron", 464, "icircle", 9432, "icircumflex", 238, "icyrillic", 1110, "idblgrave", 521, "ideographearthcircle", 12943, "ideographfirecircle", 12939, "ideographicallianceparen", 12863, "ideographiccallparen", 12858, "ideographiccentrecircle", 12965, "ideographicclose", 12294, "ideographiccomma", 12289, "ideographiccommaleft", 65380, "ideographiccongratulationparen", 12855, "ideographiccorrectcircle", 12963, "ideographicearthparen", 12847, "ideographicenterpriseparen", 12861, "ideographicexcellentcircle", 12957, "ideographicfestivalparen", 12864, "ideographicfinancialcircle", 12950, "ideographicfinancialparen", 12854, "ideographicfireparen", 12843, "ideographichaveparen", 12850, "ideographichighcircle", 12964, "ideographiciterationmark", 12293, "ideographiclaborcircle", 12952, "ideographiclaborparen", 12856, "ideographicleftcircle", 12967, "ideographiclowcircle", 12966, "ideographicmedicinecircle", 12969, "ideographicmetalparen", 12846, "ideographicmoonparen", 12842, "ideographicnameparen", 12852, "ideographicperiod", 12290, "ideographicprintcircle", 12958, "ideographicreachparen", 12867, "ideographicrepresentparen", 12857, "ideographicresourceparen", 12862, "ideographicrightcircle", 12968, "ideographicsecretcircle", 12953, "ideographicselfparen", 12866, "ideographicsocietyparen", 12851, "ideographicspace", 12288, "ideographicspecialparen", 12853, "ideographicstockparen", 12849, "ideographicstudyparen", 12859, "ideographicsunparen", 12848, "ideographicsuperviseparen", 12860, "ideographicwaterparen", 12844, "ideographicwoodparen", 12845, "ideographiczero", 12295, "ideographmetalcircle", 12942, "ideographmooncircle", 12938, "ideographnamecircle", 12948, "ideographsuncircle", 12944, "ideographwatercircle", 12940, "ideographwoodcircle", 12941, "ideva", 2311, "idieresis", 239, "idieresisacute", 7727, "idieresiscyrillic", 1253, "idotbelow", 7883, "iebrevecyrillic", 1239, "iecyrillic", 1077, "ieungacirclekorean", 12917, "ieungaparenkorean", 12821, "ieungcirclekorean", 12903, "ieungkorean", 12615, "ieungparenkorean", 12807, "igrave", 236, "igujarati", 2695, "igurmukhi", 2567, "ihiragana", 12356, "ihookabove", 7881, "iibengali", 2440, "iicyrillic", 1080, "iideva", 2312, "iigujarati", 2696, "iigurmukhi", 2568, "iimatragurmukhi", 2624, "iinvertedbreve", 523, "iishortcyrillic", 1081, "iivowelsignbengali", 2496, "iivowelsigndeva", 2368, "iivowelsigngujarati", 2752, "ij", 307, "ikatakana", 12452, "ikatakanahalfwidth", 65394, "ikorean", 12643, "ilde", 732, "iluyhebrew", 1452, "imacron", 299, "imacroncyrillic", 1251, "imageorapproximatelyequal", 8787, "imatragurmukhi", 2623, "imonospace", 65353, "increment", 8710, "infinity", 8734, "iniarmenian", 1387, "integral", 8747, "integralbottom", 8993, "integralbt", 8993, "integralex", 63733, "integraltop", 8992, "integraltp", 8992, "intersection", 8745, "intisquare", 13061, "invbullet", 9688, "invcircle", 9689, "invsmileface", 9787, "iocyrillic", 1105, "iogonek", 303, "iota", 953, "iotadieresis", 970, "iotadieresistonos", 912, "iotalatin", 617, "iotatonos", 943, "iparen", 9380, "irigurmukhi", 2674, "ismallhiragana", 12355, "ismallkatakana", 12451, "ismallkatakanahalfwidth", 65384, "issharbengali", 2554, "istroke", 616, "isuperior", 63213, "iterationhiragana", 12445, "iterationkatakana", 12541, "itilde", 297, "itildebelow", 7725, "iubopomofo", 12585, "iucyrillic", 1102, "ivowelsignbengali", 2495, "ivowelsigndeva", 2367, "ivowelsigngujarati", 2751, "izhitsacyrillic", 1141, "izhitsadblgravecyrillic", 1143, "j", 106, "jaarmenian", 1393, "jabengali", 2460, "jadeva", 2332, "jagujarati", 2716, "jagurmukhi", 2588, "jbopomofo", 12560, "jcaron", 496, "jcircle", 9433, "jcircumflex", 309, "jcrossedtail", 669, "jdotlessstroke", 607, "jecyrillic", 1112, "jeemarabic", 1580, "jeemfinalarabic", 65182, "jeeminitialarabic", 65183, "jeemmedialarabic", 65184, "jeharabic", 1688, "jehfinalarabic", 64395, "jhabengali", 2461, "jhadeva", 2333, "jhagujarati", 2717, "jhagurmukhi", 2589, "jheharmenian", 1403, "jis", 12292, "jmonospace", 65354, "jparen", 9381, "jsuperior", 690, "k", 107, "kabashkircyrillic", 1185, "kabengali", 2453, "kacute", 7729, "kacyrillic", 1082, "kadescendercyrillic", 1179, "kadeva", 2325, "kaf", 1499, "kafarabic", 1603, "kafdagesh", 64315, "kafdageshhebrew", 64315, "kaffinalarabic", 65242, "kafhebrew", 1499, "kafinitialarabic", 65243, "kafmedialarabic", 65244, "kafrafehebrew", 64333, "kagujarati", 2709, "kagurmukhi", 2581, "kahiragana", 12363, "kahookcyrillic", 1220, "kakatakana", 12459, "kakatakanahalfwidth", 65398, "kappa", 954, "kappasymbolgreek", 1008, "kapyeounmieumkorean", 12657, "kapyeounphieuphkorean", 12676, "kapyeounpieupkorean", 12664, "kapyeounssangpieupkorean", 12665, "karoriisquare", 13069, "kashidaautoarabic", 1600, "kashidaautonosidebearingarabic", 1600, "kasmallkatakana", 12533, "kasquare", 13188, "kasraarabic", 1616, "kasratanarabic", 1613, "kastrokecyrillic", 1183, "katahiraprolongmarkhalfwidth", 65392, "kaverticalstrokecyrillic", 1181, "kbopomofo", 12558, "kcalsquare", 13193, "kcaron", 489, "kcedilla", 311, "kcircle", 9434, "kcommaaccent", 311, "kdotbelow", 7731, "keharmenian", 1412, "kehiragana", 12369, "kekatakana", 12465, "kekatakanahalfwidth", 65401, "kenarmenian", 1391, "kesmallkatakana", 12534, "kgreenlandic", 312, "khabengali", 2454, "khacyrillic", 1093, "khadeva", 2326, "khagujarati", 2710, "khagurmukhi", 2582, "khaharabic", 1582, "khahfinalarabic", 65190, "khahinitialarabic", 65191, "khahmedialarabic", 65192, "kheicoptic", 999, "khhadeva", 2393, "khhagurmukhi", 2649, "khieukhacirclekorean", 12920, "khieukhaparenkorean", 12824, "khieukhcirclekorean", 12906, "khieukhkorean", 12619, "khieukhparenkorean", 12810, "khokhaithai", 3586, "khokhonthai", 3589, "khokhuatthai", 3587, "khokhwaithai", 3588, "khomutthai", 3675, "khook", 409, "khorakhangthai", 3590, "khzsquare", 13201, "kihiragana", 12365, "kikatakana", 12461, "kikatakanahalfwidth", 65399, "kiroguramusquare", 13077, "kiromeetorusquare", 13078, "kirosquare", 13076, "kiyeokacirclekorean", 12910, "kiyeokaparenkorean", 12814, "kiyeokcirclekorean", 12896, "kiyeokkorean", 12593, "kiyeokparenkorean", 12800, "kiyeoksioskorean", 12595, "kjecyrillic", 1116, "klinebelow", 7733, "klsquare", 13208, "kmcubedsquare", 13222, "kmonospace", 65355, "kmsquaredsquare", 13218, "kohiragana", 12371, "kohmsquare", 13248, "kokaithai", 3585, "kokatakana", 12467, "kokatakanahalfwidth", 65402, "kooposquare", 13086, "koppacyrillic", 1153, "koreanstandardsymbol", 12927, "koroniscmb", 835, "kparen", 9382, "kpasquare", 13226, "ksicyrillic", 1135, "ktsquare", 13263, "kturned", 670, "kuhiragana", 12367, "kukatakana", 12463, "kukatakanahalfwidth", 65400, "kvsquare", 13240, "kwsquare", 13246, "l", 108, "labengali", 2482, "lacute", 314, "ladeva", 2354, "lagujarati", 2738, "lagurmukhi", 2610, "lakkhangyaothai", 3653, "lamaleffinalarabic", 65276, "lamalefhamzaabovefinalarabic", 65272, "lamalefhamzaaboveisolatedarabic", 65271, "lamalefhamzabelowfinalarabic", 65274, "lamalefhamzabelowisolatedarabic", 65273, "lamalefisolatedarabic", 65275, "lamalefmaddaabovefinalarabic", 65270, "lamalefmaddaaboveisolatedarabic", 65269, "lamarabic", 1604, "lambda", 955, "lambdastroke", 411, "lamed", 1500, "lameddagesh", 64316, "lameddageshhebrew", 64316, "lamedhebrew", 1500, "lamfinalarabic", 65246, "lamhahinitialarabic", 64714, "laminitialarabic", 65247, "lamjeeminitialarabic", 64713, "lamkhahinitialarabic", 64715, "lamlamhehisolatedarabic", 65010, "lammedialarabic", 65248, "lammeemhahinitialarabic", 64904, "lammeeminitialarabic", 64716, "largecircle", 9711, "lbar", 410, "lbelt", 620, "lbopomofo", 12556, "lcaron", 318, "lcedilla", 316, "lcircle", 9435, "lcircumflexbelow", 7741, "lcommaaccent", 316, "ldot", 320, "ldotaccent", 320, "ldotbelow", 7735, "ldotbelowmacron", 7737, "leftangleabovecmb", 794, "lefttackbelowcmb", 792, "less", 60, "lessequal", 8804, "lessequalorgreater", 8922, "lessmonospace", 65308, "lessorequivalent", 8818, "lessorgreater", 8822, "lessoverequal", 8806, "lesssmall", 65124, "lezh", 622, "lfblock", 9612, "lhookretroflex", 621, "lira", 8356, "liwnarmenian", 1388, "lj", 457, "ljecyrillic", 1113, "ll", 63168, "lladeva", 2355, "llagujarati", 2739, "llinebelow", 7739, "llladeva", 2356, "llvocalicbengali", 2529, "llvocalicdeva", 2401, "llvocalicvowelsignbengali", 2531, "llvocalicvowelsigndeva", 2403, "lmiddletilde", 619, "lmonospace", 65356, "lmsquare", 13264, "lochulathai", 3628, "logicaland", 8743, "logicalnot", 172, "logicalnotreversed", 8976, "logicalor", 8744, "lolingthai", 3621, "longs", 383, "lowlinecenterline", 65102, "lowlinecmb", 818, "lowlinedashed", 65101, "lozenge", 9674, "lparen", 9383, "lslash", 322, "lsquare", 8467, "lsuperior", 63214, "ltshade", 9617, "luthai", 3622, "lvocalicbengali", 2444, "lvocalicdeva", 2316, "lvocalicvowelsignbengali", 2530, "lvocalicvowelsigndeva", 2402, "lxsquare", 13267, "m", 109, "mabengali", 2478, "macron", 175, "macronbelowcmb", 817, "macroncmb", 772, "macronlowmod", 717, "macronmonospace", 65507, "macute", 7743, "madeva", 2350, "magujarati", 2734, "magurmukhi", 2606, "mahapakhhebrew", 1444, "mahapakhlefthebrew", 1444, "mahiragana", 12414, "maichattawalowleftthai", 63637, "maichattawalowrightthai", 63636, "maichattawathai", 3659, "maichattawaupperleftthai", 63635, "maieklowleftthai", 63628, "maieklowrightthai", 63627, "maiekthai", 3656, "maiekupperleftthai", 63626, "maihanakatleftthai", 63620, "maihanakatthai", 3633, "maitaikhuleftthai", 63625, "maitaikhuthai", 3655, "maitholowleftthai", 63631, "maitholowrightthai", 63630, "maithothai", 3657, "maithoupperleftthai", 63629, "maitrilowleftthai", 63634, "maitrilowrightthai", 63633, "maitrithai", 3658, "maitriupperleftthai", 63632, "maiyamokthai", 3654, "makatakana", 12510, "makatakanahalfwidth", 65423, "male", 9794, "mansyonsquare", 13127, "maqafhebrew", 1470, "mars", 9794, "masoracirclehebrew", 1455, "masquare", 13187, "mbopomofo", 12551, "mbsquare", 13268, "mcircle", 9436, "mcubedsquare", 13221, "mdotaccent", 7745, "mdotbelow", 7747, "meemarabic", 1605, "meemfinalarabic", 65250, "meeminitialarabic", 65251, "meemmedialarabic", 65252, "meemmeeminitialarabic", 64721, "meemmeemisolatedarabic", 64584, "meetorusquare", 13133, "mehiragana", 12417, "meizierasquare", 13182, "mekatakana", 12513, "mekatakanahalfwidth", 65426, "mem", 1502, "memdagesh", 64318, "memdageshhebrew", 64318, "memhebrew", 1502, "menarmenian", 1396, "merkhahebrew", 1445, "merkhakefulahebrew", 1446, "merkhakefulalefthebrew", 1446, "merkhalefthebrew", 1445, "mhook", 625, "mhzsquare", 13202, "middledotkatakanahalfwidth", 65381, "middot", 183, "mieumacirclekorean", 12914, "mieumaparenkorean", 12818, "mieumcirclekorean", 12900, "mieumkorean", 12609, "mieumpansioskorean", 12656, "mieumparenkorean", 12804, "mieumpieupkorean", 12654, "mieumsioskorean", 12655, "mihiragana", 12415, "mikatakana", 12511, "mikatakanahalfwidth", 65424, "minus", 8722, "minusbelowcmb", 800, "minuscircle", 8854, "minusmod", 727, "minusplus", 8723, "minute", 8242, "miribaarusquare", 13130, "mirisquare", 13129, "mlonglegturned", 624, "mlsquare", 13206, "mmcubedsquare", 13219, "mmonospace", 65357, "mmsquaredsquare", 13215, "mohiragana", 12418, "mohmsquare", 13249, "mokatakana", 12514, "mokatakanahalfwidth", 65427, "molsquare", 13270, "momathai", 3617, "moverssquare", 13223, "moverssquaredsquare", 13224, "mparen", 9384, "mpasquare", 13227, "mssquare", 13235, "msuperior", 63215, "mturned", 623, "mu", 181, "mu1", 181, "muasquare", 13186, "muchgreater", 8811, "muchless", 8810, "mufsquare", 13196, "mugreek", 956, "mugsquare", 13197, "muhiragana", 12416, "mukatakana", 12512, "mukatakanahalfwidth", 65425, "mulsquare", 13205, "multiply", 215, "mumsquare", 13211, "munahhebrew", 1443, "munahlefthebrew", 1443, "musicalnote", 9834, "musicalnotedbl", 9835, "musicflatsign", 9837, "musicsharpsign", 9839, "mussquare", 13234, "muvsquare", 13238, "muwsquare", 13244, "mvmegasquare", 13241, "mvsquare", 13239, "mwmegasquare", 13247, "mwsquare", 13245, "n", 110, "nabengali", 2472, "nabla", 8711, "nacute", 324, "nadeva", 2344, "nagujarati", 2728, "nagurmukhi", 2600, "nahiragana", 12394, "nakatakana", 12490, "nakatakanahalfwidth", 65413, "napostrophe", 329, "nasquare", 13185, "nbopomofo", 12555, "nbspace", 160, "ncaron", 328, "ncedilla", 326, "ncircle", 9437, "ncircumflexbelow", 7755, "ncommaaccent", 326, "ndotaccent", 7749, "ndotbelow", 7751, "nehiragana", 12397, "nekatakana", 12493, "nekatakanahalfwidth", 65416, "newsheqelsign", 8362, "nfsquare", 13195, "ngabengali", 2457, "ngadeva", 2329, "ngagujarati", 2713, "ngagurmukhi", 2585, "ngonguthai", 3591, "nhiragana", 12435, "nhookleft", 626, "nhookretroflex", 627, "nieunacirclekorean", 12911, "nieunaparenkorean", 12815, "nieuncieuckorean", 12597, "nieuncirclekorean", 12897, "nieunhieuhkorean", 12598, "nieunkorean", 12596, "nieunpansioskorean", 12648, "nieunparenkorean", 12801, "nieunsioskorean", 12647, "nieuntikeutkorean", 12646, "nihiragana", 12395, "nikatakana", 12491, "nikatakanahalfwidth", 65414, "nikhahitleftthai", 63641, "nikhahitthai", 3661, "nine", 57, "ninearabic", 1641, "ninebengali", 2543, "ninecircle", 9320, "ninecircleinversesansserif", 10130, "ninedeva", 2415, "ninegujarati", 2799, "ninegurmukhi", 2671, "ninehackarabic", 1641, "ninehangzhou", 12329, "nineideographicparen", 12840, "nineinferior", 8329, "ninemonospace", 65305, "nineoldstyle", 63289, "nineparen", 9340, "nineperiod", 9360, "ninepersian", 1785, "nineroman", 8568, "ninesuperior", 8313, "nineteencircle", 9330, "nineteenparen", 9350, "nineteenperiod", 9370, "ninethai", 3673, "nj", 460, "njecyrillic", 1114, "nkatakana", 12531, "nkatakanahalfwidth", 65437, "nlegrightlong", 414, "nlinebelow", 7753, "nmonospace", 65358, "nmsquare", 13210, "nnabengali", 2467, "nnadeva", 2339, "nnagujarati", 2723, "nnagurmukhi", 2595, "nnnadeva", 2345, "nohiragana", 12398, "nokatakana", 12494, "nokatakanahalfwidth", 65417, "nonbreakingspace", 160, "nonenthai", 3603, "nonuthai", 3609, "noonarabic", 1606, "noonfinalarabic", 65254, "noonghunnaarabic", 1722, "noonghunnafinalarabic", 64415, "nooninitialarabic", 65255, "noonjeeminitialarabic", 64722, "noonjeemisolatedarabic", 64587, "noonmedialarabic", 65256, "noonmeeminitialarabic", 64725, "noonmeemisolatedarabic", 64590, "noonnoonfinalarabic", 64653, "notcontains", 8716, "notelement", 8713, "notelementof", 8713, "notequal", 8800, "notgreater", 8815, "notgreaternorequal", 8817, "notgreaternorless", 8825, "notidentical", 8802, "notless", 8814, "notlessnorequal", 8816, "notparallel", 8742, "notprecedes", 8832, "notsubset", 8836, "notsucceeds", 8833, "notsuperset", 8837, "nowarmenian", 1398, "nparen", 9385, "nssquare", 13233, "nsuperior", 8319, "ntilde", 241, "nu", 957, "nuhiragana", 12396, "nukatakana", 12492, "nukatakanahalfwidth", 65415, "nuktabengali", 2492, "nuktadeva", 2364, "nuktagujarati", 2748, "nuktagurmukhi", 2620, "numbersign", 35, "numbersignmonospace", 65283, "numbersignsmall", 65119, "numeralsigngreek", 884, "numeralsignlowergreek", 885, "numero", 8470, "nun", 1504, "nundagesh", 64320, "nundageshhebrew", 64320, "nunhebrew", 1504, "nvsquare", 13237, "nwsquare", 13243, "nyabengali", 2462, "nyadeva", 2334, "nyagujarati", 2718, "nyagurmukhi", 2590, "o", 111, "oacute", 243, "oangthai", 3629, "obarred", 629, "obarredcyrillic", 1257, "obarreddieresiscyrillic", 1259, "obengali", 2451, "obopomofo", 12571, "obreve", 335, "ocandradeva", 2321, "ocandragujarati", 2705, "ocandravowelsigndeva", 2377, "ocandravowelsigngujarati", 2761, "ocaron", 466, "ocircle", 9438, "ocircumflex", 244, "ocircumflexacute", 7889, "ocircumflexdotbelow", 7897, "ocircumflexgrave", 7891, "ocircumflexhookabove", 7893, "ocircumflextilde", 7895, "ocyrillic", 1086, "odblacute", 337, "odblgrave", 525, "odeva", 2323, "odieresis", 246, "odieresiscyrillic", 1255, "odotbelow", 7885, "oe", 339, "oekorean", 12634, "ogonek", 731, "ogonekcmb", 808, "ograve", 242, "ogujarati", 2707, "oharmenian", 1413, "ohiragana", 12362, "ohookabove", 7887, "ohorn", 417, "ohornacute", 7899, "ohorndotbelow", 7907, "ohorngrave", 7901, "ohornhookabove", 7903, "ohorntilde", 7905, "ohungarumlaut", 337, "oi", 419, "oinvertedbreve", 527, "okatakana", 12458, "okatakanahalfwidth", 65397, "okorean", 12631, "olehebrew", 1451, "omacron", 333, "omacronacute", 7763, "omacrongrave", 7761, "omdeva", 2384, "omega", 969, "omega1", 982, "omegacyrillic", 1121, "omegalatinclosed", 631, "omegaroundcyrillic", 1147, "omegatitlocyrillic", 1149, "omegatonos", 974, "omgujarati", 2768, "omicron", 959, "omicrontonos", 972, "omonospace", 65359, "one", 49, "onearabic", 1633, "onebengali", 2535, "onecircle", 9312, "onecircleinversesansserif", 10122, "onedeva", 2407, "onedotenleader", 8228, "oneeighth", 8539, "onefitted", 63196, "onegujarati", 2791, "onegurmukhi", 2663, "onehackarabic", 1633, "onehalf", 189, "onehangzhou", 12321, "oneideographicparen", 12832, "oneinferior", 8321, "onemonospace", 65297, "onenumeratorbengali", 2548, "oneoldstyle", 63281, "oneparen", 9332, "oneperiod", 9352, "onepersian", 1777, "onequarter", 188, "oneroman", 8560, "onesuperior", 185, "onethai", 3665, "onethird", 8531, "oogonek", 491, "oogonekmacron", 493, "oogurmukhi", 2579, "oomatragurmukhi", 2635, "oopen", 596, "oparen", 9386, "openbullet", 9702, "option", 8997, "ordfeminine", 170, "ordmasculine", 186, "orthogonal", 8735, "oshortdeva", 2322, "oshortvowelsigndeva", 2378, "oslash", 248, "oslashacute", 511, "osmallhiragana", 12361, "osmallkatakana", 12457, "osmallkatakanahalfwidth", 65387, "ostrokeacute", 511, "osuperior", 63216, "otcyrillic", 1151, "otilde", 245, "otildeacute", 7757, "otildedieresis", 7759, "oubopomofo", 12577, "overline", 8254, "overlinecenterline", 65098, "overlinecmb", 773, "overlinedashed", 65097, "overlinedblwavy", 65100, "overlinewavy", 65099, "overscore", 175, "ovowelsignbengali", 2507, "ovowelsigndeva", 2379, "ovowelsigngujarati", 2763, "p", 112, "paampssquare", 13184, "paasentosquare", 13099, "pabengali", 2474, "pacute", 7765, "padeva", 2346, "pagedown", 8671, "pageup", 8670, "pagujarati", 2730, "pagurmukhi", 2602, "pahiragana", 12401, "paiyannoithai", 3631, "pakatakana", 12497, "palatalizationcyrilliccmb", 1156, "palochkacyrillic", 1216, "pansioskorean", 12671, "paragraph", 182, "parallel", 8741, "parenleft", 40, "parenleftaltonearabic", 64830, "parenleftbt", 63725, "parenleftex", 63724, "parenleftinferior", 8333, "parenleftmonospace", 65288, "parenleftsmall", 65113, "parenleftsuperior", 8317, "parenlefttp", 63723, "parenleftvertical", 65077, "parenright", 41, "parenrightaltonearabic", 64831, "parenrightbt", 63736, "parenrightex", 63735, "parenrightinferior", 8334, "parenrightmonospace", 65289, "parenrightsmall", 65114, "parenrightsuperior", 8318, "parenrighttp", 63734, "parenrightvertical", 65078, "partialdiff", 8706, "paseqhebrew", 1472, "pashtahebrew", 1433, "pasquare", 13225, "patah", 1463, "patah11", 1463, "patah1d", 1463, "patah2a", 1463, "patahhebrew", 1463, "patahnarrowhebrew", 1463, "patahquarterhebrew", 1463, "patahwidehebrew", 1463, "pazerhebrew", 1441, "pbopomofo", 12550, "pcircle", 9439, "pdotaccent", 7767, "pe", 1508, "pecyrillic", 1087, "pedagesh", 64324, "pedageshhebrew", 64324, "peezisquare", 13115, "pefinaldageshhebrew", 64323, "peharabic", 1662, "peharmenian", 1402, "pehebrew", 1508, "pehfinalarabic", 64343, "pehinitialarabic", 64344, "pehiragana", 12410, "pehmedialarabic", 64345, "pekatakana", 12506, "pemiddlehookcyrillic", 1191, "perafehebrew", 64334, "percent", 37, "percentarabic", 1642, "percentmonospace", 65285, "percentsmall", 65130, "period", 46, "periodarmenian", 1417, "periodcentered", 183, "periodhalfwidth", 65377, "periodinferior", 63207, "periodmonospace", 65294, "periodsmall", 65106, "periodsuperior", 63208, "perispomenigreekcmb", 834, "perpendicular", 8869, "perthousand", 8240, "peseta", 8359, "pfsquare", 13194, "phabengali", 2475, "phadeva", 2347, "phagujarati", 2731, "phagurmukhi", 2603, "phi", 966, "phi1", 981, "phieuphacirclekorean", 12922, "phieuphaparenkorean", 12826, "phieuphcirclekorean", 12908, "phieuphkorean", 12621, "phieuphparenkorean", 12812, "philatin", 632, "phinthuthai", 3642, "phisymbolgreek", 981, "phook", 421, "phophanthai", 3614, "phophungthai", 3612, "phosamphaothai", 3616, "pi", 960, "pieupacirclekorean", 12915, "pieupaparenkorean", 12819, "pieupcieuckorean", 12662, "pieupcirclekorean", 12901, "pieupkiyeokkorean", 12658, "pieupkorean", 12610, "pieupparenkorean", 12805, "pieupsioskiyeokkorean", 12660, "pieupsioskorean", 12612, "pieupsiostikeutkorean", 12661, "pieupthieuthkorean", 12663, "pieuptikeutkorean", 12659, "pihiragana", 12404, "pikatakana", 12500, "pisymbolgreek", 982, "piwrarmenian", 1411, "plus", 43, "plusbelowcmb", 799, "pluscircle", 8853, "plusminus", 177, "plusmod", 726, "plusmonospace", 65291, "plussmall", 65122, "plussuperior", 8314, "pmonospace", 65360, "pmsquare", 13272, "pohiragana", 12413, "pointingindexdownwhite", 9759, "pointingindexleftwhite", 9756, "pointingindexrightwhite", 9758, "pointingindexupwhite", 9757, "pokatakana", 12509, "poplathai", 3611, "postalmark", 12306, "postalmarkface", 12320, "pparen", 9387, "precedes", 8826, "prescription", 8478, "primemod", 697, "primereversed", 8245, "product", 8719, "projective", 8965, "prolongedkana", 12540, "propellor", 8984, "propersubset", 8834, "propersuperset", 8835, "proportion", 8759, "proportional", 8733, "psi", 968, "psicyrillic", 1137, "psilipneumatacyrilliccmb", 1158, "pssquare", 13232, "puhiragana", 12407, "pukatakana", 12503, "pvsquare", 13236, "pwsquare", 13242, "q", 113, "qadeva", 2392, "qadmahebrew", 1448, "qafarabic", 1602, "qaffinalarabic", 65238, "qafinitialarabic", 65239, "qafmedialarabic", 65240, "qamats", 1464, "qamats10", 1464, "qamats1a", 1464, "qamats1c", 1464, "qamats27", 1464, "qamats29", 1464, "qamats33", 1464, "qamatsde", 1464, "qamatshebrew", 1464, "qamatsnarrowhebrew", 1464, "qamatsqatanhebrew", 1464, "qamatsqatannarrowhebrew", 1464, "qamatsqatanquarterhebrew", 1464, "qamatsqatanwidehebrew", 1464, "qamatsquarterhebrew", 1464, "qamatswidehebrew", 1464, "qarneyparahebrew", 1439, "qbopomofo", 12561, "qcircle", 9440, "qhook", 672, "qmonospace", 65361, "qof", 1511, "qofdagesh", 64327, "qofdageshhebrew", 64327, "qofhebrew", 1511, "qparen", 9388, "quarternote", 9833, "qubuts", 1467, "qubuts18", 1467, "qubuts25", 1467, "qubuts31", 1467, "qubutshebrew", 1467, "qubutsnarrowhebrew", 1467, "qubutsquarterhebrew", 1467, "qubutswidehebrew", 1467, "question", 63, "questionarabic", 1567, "questionarmenian", 1374, "questiondown", 191, "questiondownsmall", 63423, "questiongreek", 894, "questionmonospace", 65311, "questionsmall", 63295, "quotedbl", 34, "quotedblbase", 8222, "quotedblleft", 8220, "quotedblmonospace", 65282, "quotedblprime", 12318, "quotedblprimereversed", 12317, "quotedblright", 8221, "quoteleft", 8216, "quoteleftreversed", 8219, "quotereversed", 8219, "quoteright", 8217, "quoterightn", 329, "quotesinglbase", 8218, "quotesingle", 39, "quotesinglemonospace", 65287, "r", 114, "raarmenian", 1404, "rabengali", 2480, "racute", 341, "radeva", 2352, "radical", 8730, "radicalex", 63717, "radoverssquare", 13230, "radoverssquaredsquare", 13231, "radsquare", 13229, "rafe", 1471, "rafehebrew", 1471, "ragujarati", 2736, "ragurmukhi", 2608, "rahiragana", 12425, "rakatakana", 12521, "rakatakanahalfwidth", 65431, "ralowerdiagonalbengali", 2545, "ramiddlediagonalbengali", 2544, "ramshorn", 612, "ratio", 8758, "rbopomofo", 12566, "rcaron", 345, "rcedilla", 343, "rcircle", 9441, "rcommaaccent", 343, "rdblgrave", 529, "rdotaccent", 7769, "rdotbelow", 7771, "rdotbelowmacron", 7773, "referencemark", 8251, "reflexsubset", 8838, "reflexsuperset", 8839, "registered", 174, "registersans", 63720, "registerserif", 63194, "reharabic", 1585, "reharmenian", 1408, "rehfinalarabic", 65198, "rehiragana", 12428, "rekatakana", 12524, "rekatakanahalfwidth", 65434, "resh", 1512, "reshdageshhebrew", 64328, "reshhebrew", 1512, "reversedtilde", 8765, "reviahebrew", 1431, "reviamugrashhebrew", 1431, "revlogicalnot", 8976, "rfishhook", 638, "rfishhookreversed", 639, "rhabengali", 2525, "rhadeva", 2397, "rho", 961, "rhook", 637, "rhookturned", 635, "rhookturnedsuperior", 693, "rhosymbolgreek", 1009, "rhotichookmod", 734, "rieulacirclekorean", 12913, "rieulaparenkorean", 12817, "rieulcirclekorean", 12899, "rieulhieuhkorean", 12608, "rieulkiyeokkorean", 12602, "rieulkiyeoksioskorean", 12649, "rieulkorean", 12601, "rieulmieumkorean", 12603, "rieulpansioskorean", 12652, "rieulparenkorean", 12803, "rieulphieuphkorean", 12607, "rieulpieupkorean", 12604, "rieulpieupsioskorean", 12651, "rieulsioskorean", 12605, "rieulthieuthkorean", 12606, "rieultikeutkorean", 12650, "rieulyeorinhieuhkorean", 12653, "rightangle", 8735, "righttackbelowcmb", 793, "righttriangle", 8895, "rihiragana", 12426, "rikatakana", 12522, "rikatakanahalfwidth", 65432, "ring", 730, "ringbelowcmb", 805, "ringcmb", 778, "ringhalfleft", 703, "ringhalfleftarmenian", 1369, "ringhalfleftbelowcmb", 796, "ringhalfleftcentered", 723, "ringhalfright", 702, "ringhalfrightbelowcmb", 825, "ringhalfrightcentered", 722, "rinvertedbreve", 531, "rittorusquare", 13137, "rlinebelow", 7775, "rlongleg", 636, "rlonglegturned", 634, "rmonospace", 65362, "rohiragana", 12429, "rokatakana", 12525, "rokatakanahalfwidth", 65435, "roruathai", 3619, "rparen", 9389, "rrabengali", 2524, "rradeva", 2353, "rragurmukhi", 2652, "rreharabic", 1681, "rrehfinalarabic", 64397, "rrvocalicbengali", 2528, "rrvocalicdeva", 2400, "rrvocalicgujarati", 2784, "rrvocalicvowelsignbengali", 2500, "rrvocalicvowelsigndeva", 2372, "rrvocalicvowelsigngujarati", 2756, "rsuperior", 63217, "rtblock", 9616, "rturned", 633, "rturnedsuperior", 692, "ruhiragana", 12427, "rukatakana", 12523, "rukatakanahalfwidth", 65433, "rupeemarkbengali", 2546, "rupeesignbengali", 2547, "rupiah", 63197, "ruthai", 3620, "rvocalicbengali", 2443, "rvocalicdeva", 2315, "rvocalicgujarati", 2699, "rvocalicvowelsignbengali", 2499, "rvocalicvowelsigndeva", 2371, "rvocalicvowelsigngujarati", 2755, "s", 115, "sabengali", 2488, "sacute", 347, "sacutedotaccent", 7781, "sadarabic", 1589, "sadeva", 2360, "sadfinalarabic", 65210, "sadinitialarabic", 65211, "sadmedialarabic", 65212, "sagujarati", 2744, "sagurmukhi", 2616, "sahiragana", 12373, "sakatakana", 12469, "sakatakanahalfwidth", 65403, "sallallahoualayhewasallamarabic", 65018, "samekh", 1505, "samekhdagesh", 64321, "samekhdageshhebrew", 64321, "samekhhebrew", 1505, "saraaathai", 3634, "saraaethai", 3649, "saraaimaimalaithai", 3652, "saraaimaimuanthai", 3651, "saraamthai", 3635, "saraathai", 3632, "saraethai", 3648, "saraiileftthai", 63622, "saraiithai", 3637, "saraileftthai", 63621, "saraithai", 3636, "saraothai", 3650, "saraueeleftthai", 63624, "saraueethai", 3639, "saraueleftthai", 63623, "sarauethai", 3638, "sarauthai", 3640, "sarauuthai", 3641, "sbopomofo", 12569, "scaron", 353, "scarondotaccent", 7783, "scedilla", 351, "schwa", 601, "schwacyrillic", 1241, "schwadieresiscyrillic", 1243, "schwahook", 602, "scircle", 9442, "scircumflex", 349, "scommaaccent", 537, "sdotaccent", 7777, "sdotbelow", 7779, "sdotbelowdotaccent", 7785, "seagullbelowcmb", 828, "second", 8243, "secondtonechinese", 714, "section", 167, "seenarabic", 1587, "seenfinalarabic", 65202, "seeninitialarabic", 65203, "seenmedialarabic", 65204, "segol", 1462, "segol13", 1462, "segol1f", 1462, "segol2c", 1462, "segolhebrew", 1462, "segolnarrowhebrew", 1462, "segolquarterhebrew", 1462, "segoltahebrew", 1426, "segolwidehebrew", 1462, "seharmenian", 1405, "sehiragana", 12379, "sekatakana", 12475, "sekatakanahalfwidth", 65406, "semicolon", 59, "semicolonarabic", 1563, "semicolonmonospace", 65307, "semicolonsmall", 65108, "semivoicedmarkkana", 12444, "semivoicedmarkkanahalfwidth", 65439, "sentisquare", 13090, "sentosquare", 13091, "seven", 55, "sevenarabic", 1639, "sevenbengali", 2541, "sevencircle", 9318, "sevencircleinversesansserif", 10128, "sevendeva", 2413, "seveneighths", 8542, "sevengujarati", 2797, "sevengurmukhi", 2669, "sevenhackarabic", 1639, "sevenhangzhou", 12327, "sevenideographicparen", 12838, "seveninferior", 8327, "sevenmonospace", 65303, "sevenoldstyle", 63287, "sevenparen", 9338, "sevenperiod", 9358, "sevenpersian", 1783, "sevenroman", 8566, "sevensuperior", 8311, "seventeencircle", 9328, "seventeenparen", 9348, "seventeenperiod", 9368, "seventhai", 3671, "sfthyphen", 173, "shaarmenian", 1399, "shabengali", 2486, "shacyrillic", 1096, "shaddaarabic", 1617, "shaddadammaarabic", 64609, "shaddadammatanarabic", 64606, "shaddafathaarabic", 64608, "shaddakasraarabic", 64610, "shaddakasratanarabic", 64607, "shade", 9618, "shadedark", 9619, "shadelight", 9617, "shademedium", 9618, "shadeva", 2358, "shagujarati", 2742, "shagurmukhi", 2614, "shalshelethebrew", 1427, "shbopomofo", 12565, "shchacyrillic", 1097, "sheenarabic", 1588, "sheenfinalarabic", 65206, "sheeninitialarabic", 65207, "sheenmedialarabic", 65208, "sheicoptic", 995, "sheqel", 8362, "sheqelhebrew", 8362, "sheva", 1456, "sheva115", 1456, "sheva15", 1456, "sheva22", 1456, "sheva2e", 1456, "shevahebrew", 1456, "shevanarrowhebrew", 1456, "shevaquarterhebrew", 1456, "shevawidehebrew", 1456, "shhacyrillic", 1211, "shimacoptic", 1005, "shin", 1513, "shindagesh", 64329, "shindageshhebrew", 64329, "shindageshshindot", 64300, "shindageshshindothebrew", 64300, "shindageshsindot", 64301, "shindageshsindothebrew", 64301, "shindothebrew", 1473, "shinhebrew", 1513, "shinshindot", 64298, "shinshindothebrew", 64298, "shinsindot", 64299, "shinsindothebrew", 64299, "shook", 642, "sigma", 963, "sigma1", 962, "sigmafinal", 962, "sigmalunatesymbolgreek", 1010, "sihiragana", 12375, "sikatakana", 12471, "sikatakanahalfwidth", 65404, "siluqhebrew", 1469, "siluqlefthebrew", 1469, "similar", 8764, "sindothebrew", 1474, "siosacirclekorean", 12916, "siosaparenkorean", 12820, "sioscieuckorean", 12670, "sioscirclekorean", 12902, "sioskiyeokkorean", 12666, "sioskorean", 12613, "siosnieunkorean", 12667, "siosparenkorean", 12806, "siospieupkorean", 12669, "siostikeutkorean", 12668, "six", 54, "sixarabic", 1638, "sixbengali", 2540, "sixcircle", 9317, "sixcircleinversesansserif", 10127, "sixdeva", 2412, "sixgujarati", 2796, "sixgurmukhi", 2668, "sixhackarabic", 1638, "sixhangzhou", 12326, "sixideographicparen", 12837, "sixinferior", 8326, "sixmonospace", 65302, "sixoldstyle", 63286, "sixparen", 9337, "sixperiod", 9357, "sixpersian", 1782, "sixroman", 8565, "sixsuperior", 8310, "sixteencircle", 9327, "sixteencurrencydenominatorbengali", 2553, "sixteenparen", 9347, "sixteenperiod", 9367, "sixthai", 3670, "slash", 47, "slashmonospace", 65295, "slong", 383, "slongdotaccent", 7835, "smileface", 9786, "smonospace", 65363, "sofpasuqhebrew", 1475, "softhyphen", 173, "softsigncyrillic", 1100, "sohiragana", 12381, "sokatakana", 12477, "sokatakanahalfwidth", 65407, "soliduslongoverlaycmb", 824, "solidusshortoverlaycmb", 823, "sorusithai", 3625, "sosalathai", 3624, "sosothai", 3595, "sosuathai", 3626, "space", 32, "spacehackarabic", 32, "spade", 9824, "spadesuitblack", 9824, "spadesuitwhite", 9828, "sparen", 9390, "squarebelowcmb", 827, "squarecc", 13252, "squarecm", 13213, "squarediagonalcrosshatchfill", 9641, "squarehorizontalfill", 9636, "squarekg", 13199, "squarekm", 13214, "squarekmcapital", 13262, "squareln", 13265, "squarelog", 13266, "squaremg", 13198, "squaremil", 13269, "squaremm", 13212, "squaremsquared", 13217, "squareorthogonalcrosshatchfill", 9638, "squareupperlefttolowerrightfill", 9639, "squareupperrighttolowerleftfill", 9640, "squareverticalfill", 9637, "squarewhitewithsmallblack", 9635, "srsquare", 13275, "ssabengali", 2487, "ssadeva", 2359, "ssagujarati", 2743, "ssangcieuckorean", 12617, "ssanghieuhkorean", 12677, "ssangieungkorean", 12672, "ssangkiyeokkorean", 12594, "ssangnieunkorean", 12645, "ssangpieupkorean", 12611, "ssangsioskorean", 12614, "ssangtikeutkorean", 12600, "ssuperior", 63218, "sterling", 163, "sterlingmonospace", 65505, "strokelongoverlaycmb", 822, "strokeshortoverlaycmb", 821, "subset", 8834, "subsetnotequal", 8842, "subsetorequal", 8838, "succeeds", 8827, "suchthat", 8715, "suhiragana", 12377, "sukatakana", 12473, "sukatakanahalfwidth", 65405, "sukunarabic", 1618, "summation", 8721, "sun", 9788, "superset", 8835, "supersetnotequal", 8843, "supersetorequal", 8839, "svsquare", 13276, "syouwaerasquare", 13180, "t", 116, "tabengali", 2468, "tackdown", 8868, "tackleft", 8867, "tadeva", 2340, "tagujarati", 2724, "tagurmukhi", 2596, "taharabic", 1591, "tahfinalarabic", 65218, "tahinitialarabic", 65219, "tahiragana", 12383, "tahmedialarabic", 65220, "taisyouerasquare", 13181, "takatakana", 12479, "takatakanahalfwidth", 65408, "tatweelarabic", 1600, "tau", 964, "tav", 1514, "tavdages", 64330, "tavdagesh", 64330, "tavdageshhebrew", 64330, "tavhebrew", 1514, "tbar", 359, "tbopomofo", 12554, "tcaron", 357, "tccurl", 680, "tcedilla", 355, "tcheharabic", 1670, "tchehfinalarabic", 64379, "tchehinitialarabic", 64380, "tchehmedialarabic", 64381, "tcircle", 9443, "tcircumflexbelow", 7793, "tcommaaccent", 355, "tdieresis", 7831, "tdotaccent", 7787, "tdotbelow", 7789, "tecyrillic", 1090, "tedescendercyrillic", 1197, "teharabic", 1578, "tehfinalarabic", 65174, "tehhahinitialarabic", 64674, "tehhahisolatedarabic", 64524, "tehinitialarabic", 65175, "tehiragana", 12390, "tehjeeminitialarabic", 64673, "tehjeemisolatedarabic", 64523, "tehmarbutaarabic", 1577, "tehmarbutafinalarabic", 65172, "tehmedialarabic", 65176, "tehmeeminitialarabic", 64676, "tehmeemisolatedarabic", 64526, "tehnoonfinalarabic", 64627, "tekatakana", 12486, "tekatakanahalfwidth", 65411, "telephone", 8481, "telephoneblack", 9742, "telishagedolahebrew", 1440, "telishaqetanahebrew", 1449, "tencircle", 9321, "tenideographicparen", 12841, "tenparen", 9341, "tenperiod", 9361, "tenroman", 8569, "tesh", 679, "tet", 1496, "tetdagesh", 64312, "tetdageshhebrew", 64312, "tethebrew", 1496, "tetsecyrillic", 1205, "tevirhebrew", 1435, "tevirlefthebrew", 1435, "thabengali", 2469, "thadeva", 2341, "thagujarati", 2725, "thagurmukhi", 2597, "thalarabic", 1584, "thalfinalarabic", 65196, "thanthakhatlowleftthai", 63640, "thanthakhatlowrightthai", 63639, "thanthakhatthai", 3660, "thanthakhatupperleftthai", 63638, "theharabic", 1579, "thehfinalarabic", 65178, "thehinitialarabic", 65179, "thehmedialarabic", 65180, "thereexists", 8707, "therefore", 8756, "theta", 952, "theta1", 977, "thetasymbolgreek", 977, "thieuthacirclekorean", 12921, "thieuthaparenkorean", 12825, "thieuthcirclekorean", 12907, "thieuthkorean", 12620, "thieuthparenkorean", 12811, "thirteencircle", 9324, "thirteenparen", 9344, "thirteenperiod", 9364, "thonangmonthothai", 3601, "thook", 429, "thophuthaothai", 3602, "thorn", 254, "thothahanthai", 3607, "thothanthai", 3600, "thothongthai", 3608, "thothungthai", 3606, "thousandcyrillic", 1154, "thousandsseparatorarabic", 1644, "thousandsseparatorpersian", 1644, "three", 51, "threearabic", 1635, "threebengali", 2537, "threecircle", 9314, "threecircleinversesansserif", 10124, "threedeva", 2409, "threeeighths", 8540, "threegujarati", 2793, "threegurmukhi", 2665, "threehackarabic", 1635, "threehangzhou", 12323, "threeideographicparen", 12834, "threeinferior", 8323, "threemonospace", 65299, "threenumeratorbengali", 2550, "threeoldstyle", 63283, "threeparen", 9334, "threeperiod", 9354, "threepersian", 1779, "threequarters", 190, "threequartersemdash", 63198, "threeroman", 8562, "threesuperior", 179, "threethai", 3667, "thzsquare", 13204, "tihiragana", 12385, "tikatakana", 12481, "tikatakanahalfwidth", 65409, "tikeutacirclekorean", 12912, "tikeutaparenkorean", 12816, "tikeutcirclekorean", 12898, "tikeutkorean", 12599, "tikeutparenkorean", 12802, "tilde", 732, "tildebelowcmb", 816, "tildecmb", 771, "tildecomb", 771, "tildedoublecmb", 864, "tildeoperator", 8764, "tildeoverlaycmb", 820, "tildeverticalcmb", 830, "timescircle", 8855, "tipehahebrew", 1430, "tipehalefthebrew", 1430, "tippigurmukhi", 2672, "titlocyrilliccmb", 1155, "tiwnarmenian", 1407, "tlinebelow", 7791, "tmonospace", 65364, "toarmenian", 1385, "tohiragana", 12392, "tokatakana", 12488, "tokatakanahalfwidth", 65412, "tonebarextrahighmod", 741, "tonebarextralowmod", 745, "tonebarhighmod", 742, "tonebarlowmod", 744, "tonebarmidmod", 743, "tonefive", 445, "tonesix", 389, "tonetwo", 424, "tonos", 900, "tonsquare", 13095, "topatakthai", 3599, "tortoiseshellbracketleft", 12308, "tortoiseshellbracketleftsmall", 65117, "tortoiseshellbracketleftvertical", 65081, "tortoiseshellbracketright", 12309, "tortoiseshellbracketrightsmall", 65118, "tortoiseshellbracketrightvertical", 65082, "totaothai", 3605, "tpalatalhook", 427, "tparen", 9391, "trademark", 8482, "trademarksans", 63722, "trademarkserif", 63195, "tretroflexhook", 648, "triagdn", 9660, "triaglf", 9668, "triagrt", 9658, "triagup", 9650, "ts", 678, "tsadi", 1510, "tsadidagesh", 64326, "tsadidageshhebrew", 64326, "tsadihebrew", 1510, "tsecyrillic", 1094, "tsere", 1461, "tsere12", 1461, "tsere1e", 1461, "tsere2b", 1461, "tserehebrew", 1461, "tserenarrowhebrew", 1461, "tserequarterhebrew", 1461, "tserewidehebrew", 1461, "tshecyrillic", 1115, "tsuperior", 63219, "ttabengali", 2463, "ttadeva", 2335, "ttagujarati", 2719, "ttagurmukhi", 2591, "tteharabic", 1657, "ttehfinalarabic", 64359, "ttehinitialarabic", 64360, "ttehmedialarabic", 64361, "tthabengali", 2464, "tthadeva", 2336, "tthagujarati", 2720, "tthagurmukhi", 2592, "tturned", 647, "tuhiragana", 12388, "tukatakana", 12484, "tukatakanahalfwidth", 65410, "tusmallhiragana", 12387, "tusmallkatakana", 12483, "tusmallkatakanahalfwidth", 65391, "twelvecircle", 9323, "twelveparen", 9343, "twelveperiod", 9363, "twelveroman", 8571, "twentycircle", 9331, "twentyhangzhou", 21316, "twentyparen", 9351, "twentyperiod", 9371, "two", 50, "twoarabic", 1634, "twobengali", 2536, "twocircle", 9313, "twocircleinversesansserif", 10123, "twodeva", 2408, "twodotenleader", 8229, "twodotleader", 8229, "twodotleadervertical", 65072, "twogujarati", 2792, "twogurmukhi", 2664, "twohackarabic", 1634, "twohangzhou", 12322, "twoideographicparen", 12833, "twoinferior", 8322, "twomonospace", 65298, "twonumeratorbengali", 2549, "twooldstyle", 63282, "twoparen", 9333, "twoperiod", 9353, "twopersian", 1778, "tworoman", 8561, "twostroke", 443, "twosuperior", 178, "twothai", 3666, "twothirds", 8532, "u", 117, "uacute", 250, "ubar", 649, "ubengali", 2441, "ubopomofo", 12584, "ubreve", 365, "ucaron", 468, "ucircle", 9444, "ucircumflex", 251, "ucircumflexbelow", 7799, "ucyrillic", 1091, "udattadeva", 2385, "udblacute", 369, "udblgrave", 533, "udeva", 2313, "udieresis", 252, "udieresisacute", 472, "udieresisbelow", 7795, "udieresiscaron", 474, "udieresiscyrillic", 1265, "udieresisgrave", 476, "udieresismacron", 470, "udotbelow", 7909, "ugrave", 249, "ugujarati", 2697, "ugurmukhi", 2569, "uhiragana", 12358, "uhookabove", 7911, "uhorn", 432, "uhornacute", 7913, "uhorndotbelow", 7921, "uhorngrave", 7915, "uhornhookabove", 7917, "uhorntilde", 7919, "uhungarumlaut", 369, "uhungarumlautcyrillic", 1267, "uinvertedbreve", 535, "ukatakana", 12454, "ukatakanahalfwidth", 65395, "ukcyrillic", 1145, "ukorean", 12636, "umacron", 363, "umacroncyrillic", 1263, "umacrondieresis", 7803, "umatragurmukhi", 2625, "umonospace", 65365, "underscore", 95, "underscoredbl", 8215, "underscoremonospace", 65343, "underscorevertical", 65075, "underscorewavy", 65103, "union", 8746, "universal", 8704, "uogonek", 371, "uparen", 9392, "upblock", 9600, "upperdothebrew", 1476, "upsilon", 965, "upsilondieresis", 971, "upsilondieresistonos", 944, "upsilonlatin", 650, "upsilontonos", 973, "uptackbelowcmb", 797, "uptackmod", 724, "uragurmukhi", 2675, "uring", 367, "ushortcyrillic", 1118, "usmallhiragana", 12357, "usmallkatakana", 12453, "usmallkatakanahalfwidth", 65385, "ustraightcyrillic", 1199, "ustraightstrokecyrillic", 1201, "utilde", 361, "utildeacute", 7801, "utildebelow", 7797, "uubengali", 2442, "uudeva", 2314, "uugujarati", 2698, "uugurmukhi", 2570, "uumatragurmukhi", 2626, "uuvowelsignbengali", 2498, "uuvowelsigndeva", 2370, "uuvowelsigngujarati", 2754, "uvowelsignbengali", 2497, "uvowelsigndeva", 2369, "uvowelsigngujarati", 2753, "v", 118, "vadeva", 2357, "vagujarati", 2741, "vagurmukhi", 2613, "vakatakana", 12535, "vav", 1493, "vavdagesh", 64309, "vavdagesh65", 64309, "vavdageshhebrew", 64309, "vavhebrew", 1493, "vavholam", 64331, "vavholamhebrew", 64331, "vavvavhebrew", 1520, "vavyodhebrew", 1521, "vcircle", 9445, "vdotbelow", 7807, "vecyrillic", 1074, "veharabic", 1700, "vehfinalarabic", 64363, "vehinitialarabic", 64364, "vehmedialarabic", 64365, "vekatakana", 12537, "venus", 9792, "verticalbar", 124, "verticallineabovecmb", 781, "verticallinebelowcmb", 809, "verticallinelowmod", 716, "verticallinemod", 712, "vewarmenian", 1406, "vhook", 651, "vikatakana", 12536, "viramabengali", 2509, "viramadeva", 2381, "viramagujarati", 2765, "visargabengali", 2435, "visargadeva", 2307, "visargagujarati", 2691, "vmonospace", 65366, "voarmenian", 1400, "voicediterationhiragana", 12446, "voicediterationkatakana", 12542, "voicedmarkkana", 12443, "voicedmarkkanahalfwidth", 65438, "vokatakana", 12538, "vparen", 9393, "vtilde", 7805, "vturned", 652, "vuhiragana", 12436, "vukatakana", 12532, "w", 119, "wacute", 7811, "waekorean", 12633, "wahiragana", 12431, "wakatakana", 12527, "wakatakanahalfwidth", 65436, "wakorean", 12632, "wasmallhiragana", 12430, "wasmallkatakana", 12526, "wattosquare", 13143, "wavedash", 12316, "wavyunderscorevertical", 65076, "wawarabic", 1608, "wawfinalarabic", 65262, "wawhamzaabovearabic", 1572, "wawhamzaabovefinalarabic", 65158, "wbsquare", 13277, "wcircle", 9446, "wcircumflex", 373, "wdieresis", 7813, "wdotaccent", 7815, "wdotbelow", 7817, "wehiragana", 12433, "weierstrass", 8472, "wekatakana", 12529, "wekorean", 12638, "weokorean", 12637, "wgrave", 7809, "whitebullet", 9702, "whitecircle", 9675, "whitecircleinverse", 9689, "whitecornerbracketleft", 12302, "whitecornerbracketleftvertical", 65091, "whitecornerbracketright", 12303, "whitecornerbracketrightvertical", 65092, "whitediamond", 9671, "whitediamondcontainingblacksmalldiamond", 9672, "whitedownpointingsmalltriangle", 9663, "whitedownpointingtriangle", 9661, "whiteleftpointingsmalltriangle", 9667, "whiteleftpointingtriangle", 9665, "whitelenticularbracketleft", 12310, "whitelenticularbracketright", 12311, "whiterightpointingsmalltriangle", 9657, "whiterightpointingtriangle", 9655, "whitesmallsquare", 9643, "whitesmilingface", 9786, "whitesquare", 9633, "whitestar", 9734, "whitetelephone", 9743, "whitetortoiseshellbracketleft", 12312, "whitetortoiseshellbracketright", 12313, "whiteuppointingsmalltriangle", 9653, "whiteuppointingtriangle", 9651, "wihiragana", 12432, "wikatakana", 12528, "wikorean", 12639, "wmonospace", 65367, "wohiragana", 12434, "wokatakana", 12530, "wokatakanahalfwidth", 65382, "won", 8361, "wonmonospace", 65510, "wowaenthai", 3623, "wparen", 9394, "wring", 7832, "wsuperior", 695, "wturned", 653, "wynn", 447, "x", 120, "xabovecmb", 829, "xbopomofo", 12562, "xcircle", 9447, "xdieresis", 7821, "xdotaccent", 7819, "xeharmenian", 1389, "xi", 958, "xmonospace", 65368, "xparen", 9395, "xsuperior", 739, "y", 121, "yaadosquare", 13134, "yabengali", 2479, "yacute", 253, "yadeva", 2351, "yaekorean", 12626, "yagujarati", 2735, "yagurmukhi", 2607, "yahiragana", 12420, "yakatakana", 12516, "yakatakanahalfwidth", 65428, "yakorean", 12625, "yamakkanthai", 3662, "yasmallhiragana", 12419, "yasmallkatakana", 12515, "yasmallkatakanahalfwidth", 65388, "yatcyrillic", 1123, "ycircle", 9448, "ycircumflex", 375, "ydieresis", 255, "ydotaccent", 7823, "ydotbelow", 7925, "yeharabic", 1610, "yehbarreearabic", 1746, "yehbarreefinalarabic", 64431, "yehfinalarabic", 65266, "yehhamzaabovearabic", 1574, "yehhamzaabovefinalarabic", 65162, "yehhamzaaboveinitialarabic", 65163, "yehhamzaabovemedialarabic", 65164, "yehinitialarabic", 65267, "yehmedialarabic", 65268, "yehmeeminitialarabic", 64733, "yehmeemisolatedarabic", 64600, "yehnoonfinalarabic", 64660, "yehthreedotsbelowarabic", 1745, "yekorean", 12630, "yen", 165, "yenmonospace", 65509, "yeokorean", 12629, "yeorinhieuhkorean", 12678, "yerahbenyomohebrew", 1450, "yerahbenyomolefthebrew", 1450, "yericyrillic", 1099, "yerudieresiscyrillic", 1273, "yesieungkorean", 12673, "yesieungpansioskorean", 12675, "yesieungsioskorean", 12674, "yetivhebrew", 1434, "ygrave", 7923, "yhook", 436, "yhookabove", 7927, "yiarmenian", 1397, "yicyrillic", 1111, "yikorean", 12642, "yinyang", 9775, "yiwnarmenian", 1410, "ymonospace", 65369, "yod", 1497, "yoddagesh", 64313, "yoddageshhebrew", 64313, "yodhebrew", 1497, "yodyodhebrew", 1522, "yodyodpatahhebrew", 64287, "yohiragana", 12424, "yoikorean", 12681, "yokatakana", 12520, "yokatakanahalfwidth", 65430, "yokorean", 12635, "yosmallhiragana", 12423, "yosmallkatakana", 12519, "yosmallkatakanahalfwidth", 65390, "yotgreek", 1011, "yoyaekorean", 12680, "yoyakorean", 12679, "yoyakthai", 3618, "yoyingthai", 3597, "yparen", 9396, "ypogegrammeni", 890, "ypogegrammenigreekcmb", 837, "yr", 422, "yring", 7833, "ysuperior", 696, "ytilde", 7929, "yturned", 654, "yuhiragana", 12422, "yuikorean", 12684, "yukatakana", 12518, "yukatakanahalfwidth", 65429, "yukorean", 12640, "yusbigcyrillic", 1131, "yusbigiotifiedcyrillic", 1133, "yuslittlecyrillic", 1127, "yuslittleiotifiedcyrillic", 1129, "yusmallhiragana", 12421, "yusmallkatakana", 12517, "yusmallkatakanahalfwidth", 65389, "yuyekorean", 12683, "yuyeokorean", 12682, "yyabengali", 2527, "yyadeva", 2399, "z", 122, "zaarmenian", 1382, "zacute", 378, "zadeva", 2395, "zagurmukhi", 2651, "zaharabic", 1592, "zahfinalarabic", 65222, "zahinitialarabic", 65223, "zahiragana", 12374, "zahmedialarabic", 65224, "zainarabic", 1586, "zainfinalarabic", 65200, "zakatakana", 12470, "zaqefgadolhebrew", 1429, "zaqefqatanhebrew", 1428, "zarqahebrew", 1432, "zayin", 1494, "zayindagesh", 64310, "zayindageshhebrew", 64310, "zayinhebrew", 1494, "zbopomofo", 12567, "zcaron", 382, "zcircle", 9449, "zcircumflex", 7825, "zcurl", 657, "zdot", 380, "zdotaccent", 380, "zdotbelow", 7827, "zecyrillic", 1079, "zedescendercyrillic", 1177, "zedieresiscyrillic", 1247, "zehiragana", 12380, "zekatakana", 12476, "zero", 48, "zeroarabic", 1632, "zerobengali", 2534, "zerodeva", 2406, "zerogujarati", 2790, "zerogurmukhi", 2662, "zerohackarabic", 1632, "zeroinferior", 8320, "zeromonospace", 65296, "zerooldstyle", 63280, "zeropersian", 1776, "zerosuperior", 8304, "zerothai", 3664, "zerowidthjoiner", 65279, "zerowidthnonjoiner", 8204, "zerowidthspace", 8203, "zeta", 950, "zhbopomofo", 12563, "zhearmenian", 1386, "zhebrevecyrillic", 1218, "zhecyrillic", 1078, "zhedescendercyrillic", 1175, "zhedieresiscyrillic", 1245, "zihiragana", 12376, "zikatakana", 12472, "zinorhebrew", 1454, "zlinebelow", 7829, "zmonospace", 65370, "zohiragana", 12382, "zokatakana", 12478, "zparen", 9397, "zretroflexhook", 656, "zstroke", 438, "zuhiragana", 12378, "zukatakana", 12474, ".notdef", 0, "angbracketleftbig", 9001, "angbracketleftBig", 9001, "angbracketleftbigg", 9001, "angbracketleftBigg", 9001, "angbracketrightBig", 9002, "angbracketrightbig", 9002, "angbracketrightBigg", 9002, "angbracketrightbigg", 9002, "arrowhookleft", 8618, "arrowhookright", 8617, "arrowlefttophalf", 8636, "arrowleftbothalf", 8637, "arrownortheast", 8599, "arrownorthwest", 8598, "arrowrighttophalf", 8640, "arrowrightbothalf", 8641, "arrowsoutheast", 8600, "arrowsouthwest", 8601, "backslashbig", 8726, "backslashBig", 8726, "backslashBigg", 8726, "backslashbigg", 8726, "bardbl", 8214, "bracehtipdownleft", 65079, "bracehtipdownright", 65079, "bracehtipupleft", 65080, "bracehtipupright", 65080, "braceleftBig", 123, "braceleftbig", 123, "braceleftbigg", 123, "braceleftBigg", 123, "bracerightBig", 125, "bracerightbig", 125, "bracerightbigg", 125, "bracerightBigg", 125, "bracketleftbig", 91, "bracketleftBig", 91, "bracketleftbigg", 91, "bracketleftBigg", 91, "bracketrightBig", 93, "bracketrightbig", 93, "bracketrightbigg", 93, "bracketrightBigg", 93, "ceilingleftbig", 8968, "ceilingleftBig", 8968, "ceilingleftBigg", 8968, "ceilingleftbigg", 8968, "ceilingrightbig", 8969, "ceilingrightBig", 8969, "ceilingrightbigg", 8969, "ceilingrightBigg", 8969, "circledotdisplay", 8857, "circledottext", 8857, "circlemultiplydisplay", 8855, "circlemultiplytext", 8855, "circleplusdisplay", 8853, "circleplustext", 8853, "contintegraldisplay", 8750, "contintegraltext", 8750, "coproductdisplay", 8720, "coproducttext", 8720, "floorleftBig", 8970, "floorleftbig", 8970, "floorleftbigg", 8970, "floorleftBigg", 8970, "floorrightbig", 8971, "floorrightBig", 8971, "floorrightBigg", 8971, "floorrightbigg", 8971, "hatwide", 770, "hatwider", 770, "hatwidest", 770, "intercal", 7488, "integraldisplay", 8747, "integraltext", 8747, "intersectiondisplay", 8898, "intersectiontext", 8898, "logicalanddisplay", 8743, "logicalandtext", 8743, "logicalordisplay", 8744, "logicalortext", 8744, "parenleftBig", 40, "parenleftbig", 40, "parenleftBigg", 40, "parenleftbigg", 40, "parenrightBig", 41, "parenrightbig", 41, "parenrightBigg", 41, "parenrightbigg", 41, "prime", 8242, "productdisplay", 8719, "producttext", 8719, "radicalbig", 8730, "radicalBig", 8730, "radicalBigg", 8730, "radicalbigg", 8730, "radicalbt", 8730, "radicaltp", 8730, "radicalvertex", 8730, "slashbig", 47, "slashBig", 47, "slashBigg", 47, "slashbigg", 47, "summationdisplay", 8721, "summationtext", 8721, "tildewide", 732, "tildewider", 732, "tildewidest", 732, "uniondisplay", 8899, "unionmultidisplay", 8846, "unionmultitext", 8846, "unionsqdisplay", 8852, "unionsqtext", 8852, "uniontext", 8899, "vextenddouble", 8741, "vextendsingle", 8739];
      });
      let n = r.getArrayLookupTableFactory(function () {
        return ["space", 32, "a1", 9985, "a2", 9986, "a202", 9987, "a3", 9988, "a4", 9742, "a5", 9990, "a119", 9991, "a118", 9992, "a117", 9993, "a11", 9755, "a12", 9758, "a13", 9996, "a14", 9997, "a15", 9998, "a16", 9999, "a105", 1e4, "a17", 10001, "a18", 10002, "a19", 10003, "a20", 10004, "a21", 10005, "a22", 10006, "a23", 10007, "a24", 10008, "a25", 10009, "a26", 10010, "a27", 10011, "a28", 10012, "a6", 10013, "a7", 10014, "a8", 10015, "a9", 10016, "a10", 10017, "a29", 10018, "a30", 10019, "a31", 10020, "a32", 10021, "a33", 10022, "a34", 10023, "a35", 9733, "a36", 10025, "a37", 10026, "a38", 10027, "a39", 10028, "a40", 10029, "a41", 10030, "a42", 10031, "a43", 10032, "a44", 10033, "a45", 10034, "a46", 10035, "a47", 10036, "a48", 10037, "a49", 10038, "a50", 10039, "a51", 10040, "a52", 10041, "a53", 10042, "a54", 10043, "a55", 10044, "a56", 10045, "a57", 10046, "a58", 10047, "a59", 10048, "a60", 10049, "a61", 10050, "a62", 10051, "a63", 10052, "a64", 10053, "a65", 10054, "a66", 10055, "a67", 10056, "a68", 10057, "a69", 10058, "a70", 10059, "a71", 9679, "a72", 10061, "a73", 9632, "a74", 10063, "a203", 10064, "a75", 10065, "a204", 10066, "a76", 9650, "a77", 9660, "a78", 9670, "a79", 10070, "a81", 9687, "a82", 10072, "a83", 10073, "a84", 10074, "a97", 10075, "a98", 10076, "a99", 10077, "a100", 10078, "a101", 10081, "a102", 10082, "a103", 10083, "a104", 10084, "a106", 10085, "a107", 10086, "a108", 10087, "a112", 9827, "a111", 9830, "a110", 9829, "a109", 9824, "a120", 9312, "a121", 9313, "a122", 9314, "a123", 9315, "a124", 9316, "a125", 9317, "a126", 9318, "a127", 9319, "a128", 9320, "a129", 9321, "a130", 10102, "a131", 10103, "a132", 10104, "a133", 10105, "a134", 10106, "a135", 10107, "a136", 10108, "a137", 10109, "a138", 10110, "a139", 10111, "a140", 10112, "a141", 10113, "a142", 10114, "a143", 10115, "a144", 10116, "a145", 10117, "a146", 10118, "a147", 10119, "a148", 10120, "a149", 10121, "a150", 10122, "a151", 10123, "a152", 10124, "a153", 10125, "a154", 10126, "a155", 10127, "a156", 10128, "a157", 10129, "a158", 10130, "a159", 10131, "a160", 10132, "a161", 8594, "a163", 8596, "a164", 8597, "a196", 10136, "a165", 10137, "a192", 10138, "a166", 10139, "a167", 10140, "a168", 10141, "a169", 10142, "a170", 10143, "a171", 10144, "a172", 10145, "a173", 10146, "a162", 10147, "a174", 10148, "a175", 10149, "a176", 10150, "a177", 10151, "a178", 10152, "a179", 10153, "a193", 10154, "a180", 10155, "a199", 10156, "a181", 10157, "a200", 10158, "a182", 10159, "a201", 10161, "a183", 10162, "a184", 10163, "a197", 10164, "a185", 10165, "a194", 10166, "a198", 10167, "a186", 10168, "a195", 10169, "a187", 10170, "a188", 10171, "a189", 10172, "a190", 10173, "a191", 10174, "a89", 10088, "a90", 10089, "a93", 10090, "a94", 10091, "a91", 10092, "a92", 10093, "a205", 10094, "a85", 10095, "a206", 10096, "a86", 10097, "a87", 10098, "a88", 10099, "a95", 10100, "a96", 10101, ".notdef", 0];
      });
    }, (e, t, a) => {
      a.r(t);
      a.d(t, {
        clearUnicodeCaches: () => g,
        getCharUnicodeCategory: () => f,
        getNormalizedUnicodes: () => c,
        getUnicodeForGlyph: () => s,
        getUnicodeRangeFor: () => l,
        mapSpecialUnicodeValues: () => n,
        reverseIfRtl: () => h
      });
      var r = a(8);
      let i = r.getLookupTableFactory(function (e) {
        e[63721] = 169;
        e[63193] = 169;
        e[63720] = 174;
        e[63194] = 174;
        e[63722] = 8482;
        e[63195] = 8482;
        e[63729] = 9127;
        e[63730] = 9128;
        e[63731] = 9129;
        e[63740] = 9131;
        e[63741] = 9132;
        e[63742] = 9133;
        e[63726] = 9121;
        e[63727] = 9122;
        e[63728] = 9123;
        e[63737] = 9124;
        e[63738] = 9125;
        e[63739] = 9126;
        e[63723] = 9115;
        e[63724] = 9116;
        e[63725] = 9117;
        e[63734] = 9118;
        e[63735] = 9119;
        e[63736] = 9120;
      });
      function n(e) {
        return e >= 65520 && e <= 65535 ? 0 : e >= 62976 && e <= 63743 ? i()[e] || e : 173 === e ? 45 : e;
      }
      function s(e, t) {
        let a = t[e];
        if (void 0 !== a) return a;
        if (!e) return -1;
        if ("u" === e[0]) {
          let t;
          let r = e.length;
          if (7 === r && "n" === e[1] && "i" === e[2]) t = e.substring(3); else {
            if (!(r >= 5) || !(r <= 7)) return -1;
            t = e.substring(1);
          }
          if (t === t.toUpperCase() && (a = parseInt(t, 16)) >= 0) return a;
        }
        return -1;
      }
      let o = [{
        begin: 0,
        end: 127
      }, {
        begin: 128,
        end: 255
      }, {
        begin: 256,
        end: 383
      }, {
        begin: 384,
        end: 591
      }, {
        begin: 592,
        end: 687
      }, {
        begin: 688,
        end: 767
      }, {
        begin: 768,
        end: 879
      }, {
        begin: 880,
        end: 1023
      }, {
        begin: 11392,
        end: 11519
      }, {
        begin: 1024,
        end: 1279
      }, {
        begin: 1328,
        end: 1423
      }, {
        begin: 1424,
        end: 1535
      }, {
        begin: 42240,
        end: 42559
      }, {
        begin: 1536,
        end: 1791
      }, {
        begin: 1984,
        end: 2047
      }, {
        begin: 2304,
        end: 2431
      }, {
        begin: 2432,
        end: 2559
      }, {
        begin: 2560,
        end: 2687
      }, {
        begin: 2688,
        end: 2815
      }, {
        begin: 2816,
        end: 2943
      }, {
        begin: 2944,
        end: 3071
      }, {
        begin: 3072,
        end: 3199
      }, {
        begin: 3200,
        end: 3327
      }, {
        begin: 3328,
        end: 3455
      }, {
        begin: 3584,
        end: 3711
      }, {
        begin: 3712,
        end: 3839
      }, {
        begin: 4256,
        end: 4351
      }, {
        begin: 6912,
        end: 7039
      }, {
        begin: 4352,
        end: 4607
      }, {
        begin: 7680,
        end: 7935
      }, {
        begin: 7936,
        end: 8191
      }, {
        begin: 8192,
        end: 8303
      }, {
        begin: 8304,
        end: 8351
      }, {
        begin: 8352,
        end: 8399
      }, {
        begin: 8400,
        end: 8447
      }, {
        begin: 8448,
        end: 8527
      }, {
        begin: 8528,
        end: 8591
      }, {
        begin: 8592,
        end: 8703
      }, {
        begin: 8704,
        end: 8959
      }, {
        begin: 8960,
        end: 9215
      }, {
        begin: 9216,
        end: 9279
      }, {
        begin: 9280,
        end: 9311
      }, {
        begin: 9312,
        end: 9471
      }, {
        begin: 9472,
        end: 9599
      }, {
        begin: 9600,
        end: 9631
      }, {
        begin: 9632,
        end: 9727
      }, {
        begin: 9728,
        end: 9983
      }, {
        begin: 9984,
        end: 10175
      }, {
        begin: 12288,
        end: 12351
      }, {
        begin: 12352,
        end: 12447
      }, {
        begin: 12448,
        end: 12543
      }, {
        begin: 12544,
        end: 12591
      }, {
        begin: 12592,
        end: 12687
      }, {
        begin: 43072,
        end: 43135
      }, {
        begin: 12800,
        end: 13055
      }, {
        begin: 13056,
        end: 13311
      }, {
        begin: 44032,
        end: 55215
      }, {
        begin: 55296,
        end: 57343
      }, {
        begin: 67840,
        end: 67871
      }, {
        begin: 19968,
        end: 40959
      }, {
        begin: 57344,
        end: 63743
      }, {
        begin: 12736,
        end: 12783
      }, {
        begin: 64256,
        end: 64335
      }, {
        begin: 64336,
        end: 65023
      }, {
        begin: 65056,
        end: 65071
      }, {
        begin: 65040,
        end: 65055
      }, {
        begin: 65104,
        end: 65135
      }, {
        begin: 65136,
        end: 65279
      }, {
        begin: 65280,
        end: 65519
      }, {
        begin: 65520,
        end: 65535
      }, {
        begin: 3840,
        end: 4095
      }, {
        begin: 1792,
        end: 1871
      }, {
        begin: 1920,
        end: 1983
      }, {
        begin: 3456,
        end: 3583
      }, {
        begin: 4096,
        end: 4255
      }, {
        begin: 4608,
        end: 4991
      }, {
        begin: 5024,
        end: 5119
      }, {
        begin: 5120,
        end: 5759
      }, {
        begin: 5760,
        end: 5791
      }, {
        begin: 5792,
        end: 5887
      }, {
        begin: 6016,
        end: 6143
      }, {
        begin: 6144,
        end: 6319
      }, {
        begin: 10240,
        end: 10495
      }, {
        begin: 40960,
        end: 42127
      }, {
        begin: 5888,
        end: 5919
      }, {
        begin: 66304,
        end: 66351
      }, {
        begin: 66352,
        end: 66383
      }, {
        begin: 66560,
        end: 66639
      }, {
        begin: 118784,
        end: 119039
      }, {
        begin: 119808,
        end: 120831
      }, {
        begin: 1044480,
        end: 1048573
      }, {
        begin: 65024,
        end: 65039
      }, {
        begin: 917504,
        end: 917631
      }, {
        begin: 6400,
        end: 6479
      }, {
        begin: 6480,
        end: 6527
      }, {
        begin: 6528,
        end: 6623
      }, {
        begin: 6656,
        end: 6687
      }, {
        begin: 11264,
        end: 11359
      }, {
        begin: 11568,
        end: 11647
      }, {
        begin: 19904,
        end: 19967
      }, {
        begin: 43008,
        end: 43055
      }, {
        begin: 65536,
        end: 65663
      }, {
        begin: 65856,
        end: 65935
      }, {
        begin: 66432,
        end: 66463
      }, {
        begin: 66464,
        end: 66527
      }, {
        begin: 66640,
        end: 66687
      }, {
        begin: 66688,
        end: 66735
      }, {
        begin: 67584,
        end: 67647
      }, {
        begin: 68096,
        end: 68191
      }, {
        begin: 119552,
        end: 119647
      }, {
        begin: 73728,
        end: 74751
      }, {
        begin: 119648,
        end: 119679
      }, {
        begin: 7040,
        end: 7103
      }, {
        begin: 7168,
        end: 7247
      }, {
        begin: 7248,
        end: 7295
      }, {
        begin: 43136,
        end: 43231
      }, {
        begin: 43264,
        end: 43311
      }, {
        begin: 43312,
        end: 43359
      }, {
        begin: 43520,
        end: 43615
      }, {
        begin: 65936,
        end: 65999
      }, {
        begin: 66e3,
        end: 66047
      }, {
        begin: 66208,
        end: 66271
      }, {
        begin: 127024,
        end: 127135
      }];
      function l(e) {
        for (function () {
          let t = 0;
          let a = o.length;
        }(); t < a; t++) {
          let a = o[t];
          if (e >= a.begin && e < a.end) return t;
        }
        return -1;
      }
      let c = r.getArrayLookupTableFactory(function () {
        return ["\xa8", " \u0308", "\xaf", " \u0304", "\xb4", " \u0301", "\xb5", "\u03BC", "\xb8", " \u0327", "\u0132", "IJ", "\u0133", "ij", "\u013F", "L\xb7", "\u0140", "l\xb7", "\u0149", "\u02BCn", "\u017F", "s", "\u01C4", "D\u017D", "\u01C5", "D\u017E", "\u01C6", "d\u017E", "\u01C7", "LJ", "\u01C8", "Lj", "\u01C9", "lj", "\u01CA", "NJ", "\u01CB", "Nj", "\u01CC", "nj", "\u01F1", "DZ", "\u01F2", "Dz", "\u01F3", "dz", "\u02D8", " \u0306", "\u02D9", " \u0307", "\u02DA", " \u030A", "\u02DB", " \u0328", "\u02DC", " \u0303", "\u02DD", " \u030B", "\u037A", " \u0345", "\u0384", " \u0301", "\u03D0", "\u03B2", "\u03D1", "\u03B8", "\u03D2", "\u03A5", "\u03D5", "\u03C6", "\u03D6", "\u03C0", "\u03F0", "\u03BA", "\u03F1", "\u03C1", "\u03F2", "\u03C2", "\u03F4", "\u0398", "\u03F5", "\u03B5", "\u03F9", "\u03A3", "\u0587", "\u0565\u0582", "\u0675", "\u0627\u0674", "\u0676", "\u0648\u0674", "\u0677", "\u06C7\u0674", "\u0678", "\u064A\u0674", "\u0E33", "\u0E4D\u0E32", "\u0EB3", "\u0ECD\u0EB2", "\u0EDC", "\u0EAB\u0E99", "\u0EDD", "\u0EAB\u0EA1", "\u0F77", "\u0FB2\u0F81", "\u0F79", "\u0FB3\u0F81", "\u1E9A", "a\u02BE", "\u1FBD", " \u0313", "\u1FBF", " \u0313", "\u1FC0", " \u0342", "\u1FFE", " \u0314", "\u2002", " ", "\u2003", " ", "\u2004", " ", "\u2005", " ", "\u2006", " ", "\u2008", " ", "\u2009", " ", "\u200A", " ", "\u2017", " \u0333", "\u2024", ".", "\u2025", "..", "\u2026", "...", "\u2033", "\u2032\u2032", "\u2034", "\u2032\u2032\u2032", "\u2036", "\u2035\u2035", "\u2037", "\u2035\u2035\u2035", "\u203C", "!!", "\u203E", " \u0305", "\u2047", "??", "\u2048", "?!", "\u2049", "!?", "\u2057", "\u2032\u2032\u2032\u2032", "\u205F", " ", "\u20A8", "Rs", "\u2100", "a/c", "\u2101", "a/s", "\u2103", "\xb0C", "\u2105", "c/o", "\u2106", "c/u", "\u2107", "\u0190", "\u2109", "\xb0F", "\u2116", "No", "\u2121", "TEL", "\u2135", "\u05D0", "\u2136", "\u05D1", "\u2137", "\u05D2", "\u2138", "\u05D3", "\u213B", "FAX", "\u2160", "I", "\u2161", "II", "\u2162", "III", "\u2163", "IV", "\u2164", "V", "\u2165", "VI", "\u2166", "VII", "\u2167", "VIII", "\u2168", "IX", "\u2169", "X", "\u216A", "XI", "\u216B", "XII", "\u216C", "L", "\u216D", "C", "\u216E", "D", "\u216F", "M", "\u2170", "i", "\u2171", "ii", "\u2172", "iii", "\u2173", "iv", "\u2174", "v", "\u2175", "vi", "\u2176", "vii", "\u2177", "viii", "\u2178", "ix", "\u2179", "x", "\u217A", "xi", "\u217B", "xii", "\u217C", "l", "\u217D", "c", "\u217E", "d", "\u217F", "m", "\u222C", "\u222B\u222B", "\u222D", "\u222B\u222B\u222B", "\u222F", "\u222E\u222E", "\u2230", "\u222E\u222E\u222E", "\u2474", "(1)", "\u2475", "(2)", "\u2476", "(3)", "\u2477", "(4)", "\u2478", "(5)", "\u2479", "(6)", "\u247A", "(7)", "\u247B", "(8)", "\u247C", "(9)", "\u247D", "(10)", "\u247E", "(11)", "\u247F", "(12)", "\u2480", "(13)", "\u2481", "(14)", "\u2482", "(15)", "\u2483", "(16)", "\u2484", "(17)", "\u2485", "(18)", "\u2486", "(19)", "\u2487", "(20)", "\u2488", "1.", "\u2489", "2.", "\u248A", "3.", "\u248B", "4.", "\u248C", "5.", "\u248D", "6.", "\u248E", "7.", "\u248F", "8.", "\u2490", "9.", "\u2491", "10.", "\u2492", "11.", "\u2493", "12.", "\u2494", "13.", "\u2495", "14.", "\u2496", "15.", "\u2497", "16.", "\u2498", "17.", "\u2499", "18.", "\u249A", "19.", "\u249B", "20.", "\u249C", "(a)", "\u249D", "(b)", "\u249E", "(c)", "\u249F", "(d)", "\u24A0", "(e)", "\u24A1", "(f)", "\u24A2", "(g)", "\u24A3", "(h)", "\u24A4", "(i)", "\u24A5", "(j)", "\u24A6", "(k)", "\u24A7", "(l)", "\u24A8", "(m)", "\u24A9", "(n)", "\u24AA", "(o)", "\u24AB", "(p)", "\u24AC", "(q)", "\u24AD", "(r)", "\u24AE", "(s)", "\u24AF", "(t)", "\u24B0", "(u)", "\u24B1", "(v)", "\u24B2", "(w)", "\u24B3", "(x)", "\u24B4", "(y)", "\u24B5", "(z)", "\u2A0C", "\u222B\u222B\u222B\u222B", "\u2A74", "::=", "\u2A75", "==", "\u2A76", "===", "\u2E9F", "\u6BCD", "\u2EF3", "\u9F9F", "\u2F00", "\u4E00", "\u2F01", "\u4E28", "\u2F02", "\u4E36", "\u2F03", "\u4E3F", "\u2F04", "\u4E59", "\u2F05", "\u4E85", "\u2F06", "\u4E8C", "\u2F07", "\u4EA0", "\u2F08", "\u4EBA", "\u2F09", "\u513F", "\u2F0A", "\u5165", "\u2F0B", "\u516B", "\u2F0C", "\u5182", "\u2F0D", "\u5196", "\u2F0E", "\u51AB", "\u2F0F", "\u51E0", "\u2F10", "\u51F5", "\u2F11", "\u5200", "\u2F12", "\u529B", "\u2F13", "\u52F9", "\u2F14", "\u5315", "\u2F15", "\u531A", "\u2F16", "\u5338", "\u2F17", "\u5341", "\u2F18", "\u535C", "\u2F19", "\u5369", "\u2F1A", "\u5382", "\u2F1B", "\u53B6", "\u2F1C", "\u53C8", "\u2F1D", "\u53E3", "\u2F1E", "\u56D7", "\u2F1F", "\u571F", "\u2F20", "\u58EB", "\u2F21", "\u5902", "\u2F22", "\u590A", "\u2F23", "\u5915", "\u2F24", "\u5927", "\u2F25", "\u5973", "\u2F26", "\u5B50", "\u2F27", "\u5B80", "\u2F28", "\u5BF8", "\u2F29", "\u5C0F", "\u2F2A", "\u5C22", "\u2F2B", "\u5C38", "\u2F2C", "\u5C6E", "\u2F2D", "\u5C71", "\u2F2E", "\u5DDB", "\u2F2F", "\u5DE5", "\u2F30", "\u5DF1", "\u2F31", "\u5DFE", "\u2F32", "\u5E72", "\u2F33", "\u5E7A", "\u2F34", "\u5E7F", "\u2F35", "\u5EF4", "\u2F36", "\u5EFE", "\u2F37", "\u5F0B", "\u2F38", "\u5F13", "\u2F39", "\u5F50", "\u2F3A", "\u5F61", "\u2F3B", "\u5F73", "\u2F3C", "\u5FC3", "\u2F3D", "\u6208", "\u2F3E", "\u6236", "\u2F3F", "\u624B", "\u2F40", "\u652F", "\u2F41", "\u6534", "\u2F42", "\u6587", "\u2F43", "\u6597", "\u2F44", "\u65A4", "\u2F45", "\u65B9", "\u2F46", "\u65E0", "\u2F47", "\u65E5", "\u2F48", "\u66F0", "\u2F49", "\u6708", "\u2F4A", "\u6728", "\u2F4B", "\u6B20", "\u2F4C", "\u6B62", "\u2F4D", "\u6B79", "\u2F4E", "\u6BB3", "\u2F4F", "\u6BCB", "\u2F50", "\u6BD4", "\u2F51", "\u6BDB", "\u2F52", "\u6C0F", "\u2F53", "\u6C14", "\u2F54", "\u6C34", "\u2F55", "\u706B", "\u2F56", "\u722A", "\u2F57", "\u7236", "\u2F58", "\u723B", "\u2F59", "\u723F", "\u2F5A", "\u7247", "\u2F5B", "\u7259", "\u2F5C", "\u725B", "\u2F5D", "\u72AC", "\u2F5E", "\u7384", "\u2F5F", "\u7389", "\u2F60", "\u74DC", "\u2F61", "\u74E6", "\u2F62", "\u7518", "\u2F63", "\u751F", "\u2F64", "\u7528", "\u2F65", "\u7530", "\u2F66", "\u758B", "\u2F67", "\u7592", "\u2F68", "\u7676", "\u2F69", "\u767D", "\u2F6A", "\u76AE", "\u2F6B", "\u76BF", "\u2F6C", "\u76EE", "\u2F6D", "\u77DB", "\u2F6E", "\u77E2", "\u2F6F", "\u77F3", "\u2F70", "\u793A", "\u2F71", "\u79B8", "\u2F72", "\u79BE", "\u2F73", "\u7A74", "\u2F74", "\u7ACB", "\u2F75", "\u7AF9", "\u2F76", "\u7C73", "\u2F77", "\u7CF8", "\u2F78", "\u7F36", "\u2F79", "\u7F51", "\u2F7A", "\u7F8A", "\u2F7B", "\u7FBD", "\u2F7C", "\u8001", "\u2F7D", "\u800C", "\u2F7E", "\u8012", "\u2F7F", "\u8033", "\u2F80", "\u807F", "\u2F81", "\u8089", "\u2F82", "\u81E3", "\u2F83", "\u81EA", "\u2F84", "\u81F3", "\u2F85", "\u81FC", "\u2F86", "\u820C", "\u2F87", "\u821B", "\u2F88", "\u821F", "\u2F89", "\u826E", "\u2F8A", "\u8272", "\u2F8B", "\u8278", "\u2F8C", "\u864D", "\u2F8D", "\u866B", "\u2F8E", "\u8840", "\u2F8F", "\u884C", "\u2F90", "\u8863", "\u2F91", "\u897E", "\u2F92", "\u898B", "\u2F93", "\u89D2", "\u2F94", "\u8A00", "\u2F95", "\u8C37", "\u2F96", "\u8C46", "\u2F97", "\u8C55", "\u2F98", "\u8C78", "\u2F99", "\u8C9D", "\u2F9A", "\u8D64", "\u2F9B", "\u8D70", "\u2F9C", "\u8DB3", "\u2F9D", "\u8EAB", "\u2F9E", "\u8ECA", "\u2F9F", "\u8F9B", "\u2FA0", "\u8FB0", "\u2FA1", "\u8FB5", "\u2FA2", "\u9091", "\u2FA3", "\u9149", "\u2FA4", "\u91C6", "\u2FA5", "\u91CC", "\u2FA6", "\u91D1", "\u2FA7", "\u9577", "\u2FA8", "\u9580", "\u2FA9", "\u961C", "\u2FAA", "\u96B6", "\u2FAB", "\u96B9", "\u2FAC", "\u96E8", "\u2FAD", "\u9751", "\u2FAE", "\u975E", "\u2FAF", "\u9762", "\u2FB0", "\u9769", "\u2FB1", "\u97CB", "\u2FB2", "\u97ED", "\u2FB3", "\u97F3", "\u2FB4", "\u9801", "\u2FB5", "\u98A8", "\u2FB6", "\u98DB", "\u2FB7", "\u98DF", "\u2FB8", "\u9996", "\u2FB9", "\u9999", "\u2FBA", "\u99AC", "\u2FBB", "\u9AA8", "\u2FBC", "\u9AD8", "\u2FBD", "\u9ADF", "\u2FBE", "\u9B25", "\u2FBF", "\u9B2F", "\u2FC0", "\u9B32", "\u2FC1", "\u9B3C", "\u2FC2", "\u9B5A", "\u2FC3", "\u9CE5", "\u2FC4", "\u9E75", "\u2FC5", "\u9E7F", "\u2FC6", "\u9EA5", "\u2FC7", "\u9EBB", "\u2FC8", "\u9EC3", "\u2FC9", "\u9ECD", "\u2FCA", "\u9ED1", "\u2FCB", "\u9EF9", "\u2FCC", "\u9EFD", "\u2FCD", "\u9F0E", "\u2FCE", "\u9F13", "\u2FCF", "\u9F20", "\u2FD0", "\u9F3B", "\u2FD1", "\u9F4A", "\u2FD2", "\u9F52", "\u2FD3", "\u9F8D", "\u2FD4", "\u9F9C", "\u2FD5", "\u9FA0", "\u3036", "\u3012", "\u3038", "\u5341", "\u3039", "\u5344", "\u303A", "\u5345", "\u309B", " \u3099", "\u309C", " \u309A", "\u3131", "\u1100", "\u3132", "\u1101", "\u3133", "\u11AA", "\u3134", "\u1102", "\u3135", "\u11AC", "\u3136", "\u11AD", "\u3137", "\u1103", "\u3138", "\u1104", "\u3139", "\u1105", "\u313A", "\u11B0", "\u313B", "\u11B1", "\u313C", "\u11B2", "\u313D", "\u11B3", "\u313E", "\u11B4", "\u313F", "\u11B5", "\u3140", "\u111A", "\u3141", "\u1106", "\u3142", "\u1107", "\u3143", "\u1108", "\u3144", "\u1121", "\u3145", "\u1109", "\u3146", "\u110A", "\u3147", "\u110B", "\u3148", "\u110C", "\u3149", "\u110D", "\u314A", "\u110E", "\u314B", "\u110F", "\u314C", "\u1110", "\u314D", "\u1111", "\u314E", "\u1112", "\u314F", "\u1161", "\u3150", "\u1162", "\u3151", "\u1163", "\u3152", "\u1164", "\u3153", "\u1165", "\u3154", "\u1166", "\u3155", "\u1167", "\u3156", "\u1168", "\u3157", "\u1169", "\u3158", "\u116A", "\u3159", "\u116B", "\u315A", "\u116C", "\u315B", "\u116D", "\u315C", "\u116E", "\u315D", "\u116F", "\u315E", "\u1170", "\u315F", "\u1171", "\u3160", "\u1172", "\u3161", "\u1173", "\u3162", "\u1174", "\u3163", "\u1175", "\u3164", "\u1160", "\u3165", "\u1114", "\u3166", "\u1115", "\u3167", "\u11C7", "\u3168", "\u11C8", "\u3169", "\u11CC", "\u316A", "\u11CE", "\u316B", "\u11D3", "\u316C", "\u11D7", "\u316D", "\u11D9", "\u316E", "\u111C", "\u316F", "\u11DD", "\u3170", "\u11DF", "\u3171", "\u111D", "\u3172", "\u111E", "\u3173", "\u1120", "\u3174", "\u1122", "\u3175", "\u1123", "\u3176", "\u1127", "\u3177", "\u1129", "\u3178", "\u112B", "\u3179", "\u112C", "\u317A", "\u112D", "\u317B", "\u112E", "\u317C", "\u112F", "\u317D", "\u1132", "\u317E", "\u1136", "\u317F", "\u1140", "\u3180", "\u1147", "\u3181", "\u114C", "\u3182", "\u11F1", "\u3183", "\u11F2", "\u3184", "\u1157", "\u3185", "\u1158", "\u3186", "\u1159", "\u3187", "\u1184", "\u3188", "\u1185", "\u3189", "\u1188", "\u318A", "\u1191", "\u318B", "\u1192", "\u318C", "\u1194", "\u318D", "\u119E", "\u318E", "\u11A1", "\u3200", "(\u1100)", "\u3201", "(\u1102)", "\u3202", "(\u1103)", "\u3203", "(\u1105)", "\u3204", "(\u1106)", "\u3205", "(\u1107)", "\u3206", "(\u1109)", "\u3207", "(\u110B)", "\u3208", "(\u110C)", "\u3209", "(\u110E)", "\u320A", "(\u110F)", "\u320B", "(\u1110)", "\u320C", "(\u1111)", "\u320D", "(\u1112)", "\u320E", "(\u1100\u1161)", "\u320F", "(\u1102\u1161)", "\u3210", "(\u1103\u1161)", "\u3211", "(\u1105\u1161)", "\u3212", "(\u1106\u1161)", "\u3213", "(\u1107\u1161)", "\u3214", "(\u1109\u1161)", "\u3215", "(\u110B\u1161)", "\u3216", "(\u110C\u1161)", "\u3217", "(\u110E\u1161)", "\u3218", "(\u110F\u1161)", "\u3219", "(\u1110\u1161)", "\u321A", "(\u1111\u1161)", "\u321B", "(\u1112\u1161)", "\u321C", "(\u110C\u116E)", "\u321D", "(\u110B\u1169\u110C\u1165\u11AB)", "\u321E", "(\u110B\u1169\u1112\u116E)", "\u3220", "(\u4E00)", "\u3221", "(\u4E8C)", "\u3222", "(\u4E09)", "\u3223", "(\u56DB)", "\u3224", "(\u4E94)", "\u3225", "(\u516D)", "\u3226", "(\u4E03)", "\u3227", "(\u516B)", "\u3228", "(\u4E5D)", "\u3229", "(\u5341)", "\u322A", "(\u6708)", "\u322B", "(\u706B)", "\u322C", "(\u6C34)", "\u322D", "(\u6728)", "\u322E", "(\u91D1)", "\u322F", "(\u571F)", "\u3230", "(\u65E5)", "\u3231", "(\u682A)", "\u3232", "(\u6709)", "\u3233", "(\u793E)", "\u3234", "(\u540D)", "\u3235", "(\u7279)", "\u3236", "(\u8CA1)", "\u3237", "(\u795D)", "\u3238", "(\u52B4)", "\u3239", "(\u4EE3)", "\u323A", "(\u547C)", "\u323B", "(\u5B66)", "\u323C", "(\u76E3)", "\u323D", "(\u4F01)", "\u323E", "(\u8CC7)", "\u323F", "(\u5354)", "\u3240", "(\u796D)", "\u3241", "(\u4F11)", "\u3242", "(\u81EA)", "\u3243", "(\u81F3)", "\u32C0", "1\u6708", "\u32C1", "2\u6708", "\u32C2", "3\u6708", "\u32C3", "4\u6708", "\u32C4", "5\u6708", "\u32C5", "6\u6708", "\u32C6", "7\u6708", "\u32C7", "8\u6708", "\u32C8", "9\u6708", "\u32C9", "10\u6708", "\u32CA", "11\u6708", "\u32CB", "12\u6708", "\u3358", "0\u70B9", "\u3359", "1\u70B9", "\u335A", "2\u70B9", "\u335B", "3\u70B9", "\u335C", "4\u70B9", "\u335D", "5\u70B9", "\u335E", "6\u70B9", "\u335F", "7\u70B9", "\u3360", "8\u70B9", "\u3361", "9\u70B9", "\u3362", "10\u70B9", "\u3363", "11\u70B9", "\u3364", "12\u70B9", "\u3365", "13\u70B9", "\u3366", "14\u70B9", "\u3367", "15\u70B9", "\u3368", "16\u70B9", "\u3369", "17\u70B9", "\u336A", "18\u70B9", "\u336B", "19\u70B9", "\u336C", "20\u70B9", "\u336D", "21\u70B9", "\u336E", "22\u70B9", "\u336F", "23\u70B9", "\u3370", "24\u70B9", "\u33E0", "1\u65E5", "\u33E1", "2\u65E5", "\u33E2", "3\u65E5", "\u33E3", "4\u65E5", "\u33E4", "5\u65E5", "\u33E5", "6\u65E5", "\u33E6", "7\u65E5", "\u33E7", "8\u65E5", "\u33E8", "9\u65E5", "\u33E9", "10\u65E5", "\u33EA", "11\u65E5", "\u33EB", "12\u65E5", "\u33EC", "13\u65E5", "\u33ED", "14\u65E5", "\u33EE", "15\u65E5", "\u33EF", "16\u65E5", "\u33F0", "17\u65E5", "\u33F1", "18\u65E5", "\u33F2", "19\u65E5", "\u33F3", "20\u65E5", "\u33F4", "21\u65E5", "\u33F5", "22\u65E5", "\u33F6", "23\u65E5", "\u33F7", "24\u65E5", "\u33F8", "25\u65E5", "\u33F9", "26\u65E5", "\u33FA", "27\u65E5", "\u33FB", "28\u65E5", "\u33FC", "29\u65E5", "\u33FD", "30\u65E5", "\u33FE", "31\u65E5", "\uFB00", "ff", "\uFB01", "fi", "\uFB02", "fl", "\uFB03", "ffi", "\uFB04", "ffl", "\uFB05", "\u017Ft", "\uFB06", "st", "\uFB13", "\u0574\u0576", "\uFB14", "\u0574\u0565", "\uFB15", "\u0574\u056B", "\uFB16", "\u057E\u0576", "\uFB17", "\u0574\u056D", "\uFB4F", "\u05D0\u05DC", "\uFB50", "\u0671", "\uFB51", "\u0671", "\uFB52", "\u067B", "\uFB53", "\u067B", "\uFB54", "\u067B", "\uFB55", "\u067B", "\uFB56", "\u067E", "\uFB57", "\u067E", "\uFB58", "\u067E", "\uFB59", "\u067E", "\uFB5A", "\u0680", "\uFB5B", "\u0680", "\uFB5C", "\u0680", "\uFB5D", "\u0680", "\uFB5E", "\u067A", "\uFB5F", "\u067A", "\uFB60", "\u067A", "\uFB61", "\u067A", "\uFB62", "\u067F", "\uFB63", "\u067F", "\uFB64", "\u067F", "\uFB65", "\u067F", "\uFB66", "\u0679", "\uFB67", "\u0679", "\uFB68", "\u0679", "\uFB69", "\u0679", "\uFB6A", "\u06A4", "\uFB6B", "\u06A4", "\uFB6C", "\u06A4", "\uFB6D", "\u06A4", "\uFB6E", "\u06A6", "\uFB6F", "\u06A6", "\uFB70", "\u06A6", "\uFB71", "\u06A6", "\uFB72", "\u0684", "\uFB73", "\u0684", "\uFB74", "\u0684", "\uFB75", "\u0684", "\uFB76", "\u0683", "\uFB77", "\u0683", "\uFB78", "\u0683", "\uFB79", "\u0683", "\uFB7A", "\u0686", "\uFB7B", "\u0686", "\uFB7C", "\u0686", "\uFB7D", "\u0686", "\uFB7E", "\u0687", "\uFB7F", "\u0687", "\uFB80", "\u0687", "\uFB81", "\u0687", "\uFB82", "\u068D", "\uFB83", "\u068D", "\uFB84", "\u068C", "\uFB85", "\u068C", "\uFB86", "\u068E", "\uFB87", "\u068E", "\uFB88", "\u0688", "\uFB89", "\u0688", "\uFB8A", "\u0698", "\uFB8B", "\u0698", "\uFB8C", "\u0691", "\uFB8D", "\u0691", "\uFB8E", "\u06A9", "\uFB8F", "\u06A9", "\uFB90", "\u06A9", "\uFB91", "\u06A9", "\uFB92", "\u06AF", "\uFB93", "\u06AF", "\uFB94", "\u06AF", "\uFB95", "\u06AF", "\uFB96", "\u06B3", "\uFB97", "\u06B3", "\uFB98", "\u06B3", "\uFB99", "\u06B3", "\uFB9A", "\u06B1", "\uFB9B", "\u06B1", "\uFB9C", "\u06B1", "\uFB9D", "\u06B1", "\uFB9E", "\u06BA", "\uFB9F", "\u06BA", "\uFBA0", "\u06BB", "\uFBA1", "\u06BB", "\uFBA2", "\u06BB", "\uFBA3", "\u06BB", "\uFBA4", "\u06C0", "\uFBA5", "\u06C0", "\uFBA6", "\u06C1", "\uFBA7", "\u06C1", "\uFBA8", "\u06C1", "\uFBA9", "\u06C1", "\uFBAA", "\u06BE", "\uFBAB", "\u06BE", "\uFBAC", "\u06BE", "\uFBAD", "\u06BE", "\uFBAE", "\u06D2", "\uFBAF", "\u06D2", "\uFBB0", "\u06D3", "\uFBB1", "\u06D3", "\uFBD3", "\u06AD", "\uFBD4", "\u06AD", "\uFBD5", "\u06AD", "\uFBD6", "\u06AD", "\uFBD7", "\u06C7", "\uFBD8", "\u06C7", "\uFBD9", "\u06C6", "\uFBDA", "\u06C6", "\uFBDB", "\u06C8", "\uFBDC", "\u06C8", "\uFBDD", "\u0677", "\uFBDE", "\u06CB", "\uFBDF", "\u06CB", "\uFBE0", "\u06C5", "\uFBE1", "\u06C5", "\uFBE2", "\u06C9", "\uFBE3", "\u06C9", "\uFBE4", "\u06D0", "\uFBE5", "\u06D0", "\uFBE6", "\u06D0", "\uFBE7", "\u06D0", "\uFBE8", "\u0649", "\uFBE9", "\u0649", "\uFBEA", "\u0626\u0627", "\uFBEB", "\u0626\u0627", "\uFBEC", "\u0626\u06D5", "\uFBED", "\u0626\u06D5", "\uFBEE", "\u0626\u0648", "\uFBEF", "\u0626\u0648", "\uFBF0", "\u0626\u06C7", "\uFBF1", "\u0626\u06C7", "\uFBF2", "\u0626\u06C6", "\uFBF3", "\u0626\u06C6", "\uFBF4", "\u0626\u06C8", "\uFBF5", "\u0626\u06C8", "\uFBF6", "\u0626\u06D0", "\uFBF7", "\u0626\u06D0", "\uFBF8", "\u0626\u06D0", "\uFBF9", "\u0626\u0649", "\uFBFA", "\u0626\u0649", "\uFBFB", "\u0626\u0649", "\uFBFC", "\u06CC", "\uFBFD", "\u06CC", "\uFBFE", "\u06CC", "\uFBFF", "\u06CC", "\uFC00", "\u0626\u062C", "\uFC01", "\u0626\u062D", "\uFC02", "\u0626\u0645", "\uFC03", "\u0626\u0649", "\uFC04", "\u0626\u064A", "\uFC05", "\u0628\u062C", "\uFC06", "\u0628\u062D", "\uFC07", "\u0628\u062E", "\uFC08", "\u0628\u0645", "\uFC09", "\u0628\u0649", "\uFC0A", "\u0628\u064A", "\uFC0B", "\u062A\u062C", "\uFC0C", "\u062A\u062D", "\uFC0D", "\u062A\u062E", "\uFC0E", "\u062A\u0645", "\uFC0F", "\u062A\u0649", "\uFC10", "\u062A\u064A", "\uFC11", "\u062B\u062C", "\uFC12", "\u062B\u0645", "\uFC13", "\u062B\u0649", "\uFC14", "\u062B\u064A", "\uFC15", "\u062C\u062D", "\uFC16", "\u062C\u0645", "\uFC17", "\u062D\u062C", "\uFC18", "\u062D\u0645", "\uFC19", "\u062E\u062C", "\uFC1A", "\u062E\u062D", "\uFC1B", "\u062E\u0645", "\uFC1C", "\u0633\u062C", "\uFC1D", "\u0633\u062D", "\uFC1E", "\u0633\u062E", "\uFC1F", "\u0633\u0645", "\uFC20", "\u0635\u062D", "\uFC21", "\u0635\u0645", "\uFC22", "\u0636\u062C", "\uFC23", "\u0636\u062D", "\uFC24", "\u0636\u062E", "\uFC25", "\u0636\u0645", "\uFC26", "\u0637\u062D", "\uFC27", "\u0637\u0645", "\uFC28", "\u0638\u0645", "\uFC29", "\u0639\u062C", "\uFC2A", "\u0639\u0645", "\uFC2B", "\u063A\u062C", "\uFC2C", "\u063A\u0645", "\uFC2D", "\u0641\u062C", "\uFC2E", "\u0641\u062D", "\uFC2F", "\u0641\u062E", "\uFC30", "\u0641\u0645", "\uFC31", "\u0641\u0649", "\uFC32", "\u0641\u064A", "\uFC33", "\u0642\u062D", "\uFC34", "\u0642\u0645", "\uFC35", "\u0642\u0649", "\uFC36", "\u0642\u064A", "\uFC37", "\u0643\u0627", "\uFC38", "\u0643\u062C", "\uFC39", "\u0643\u062D", "\uFC3A", "\u0643\u062E", "\uFC3B", "\u0643\u0644", "\uFC3C", "\u0643\u0645", "\uFC3D", "\u0643\u0649", "\uFC3E", "\u0643\u064A", "\uFC3F", "\u0644\u062C", "\uFC40", "\u0644\u062D", "\uFC41", "\u0644\u062E", "\uFC42", "\u0644\u0645", "\uFC43", "\u0644\u0649", "\uFC44", "\u0644\u064A", "\uFC45", "\u0645\u062C", "\uFC46", "\u0645\u062D", "\uFC47", "\u0645\u062E", "\uFC48", "\u0645\u0645", "\uFC49", "\u0645\u0649", "\uFC4A", "\u0645\u064A", "\uFC4B", "\u0646\u062C", "\uFC4C", "\u0646\u062D", "\uFC4D", "\u0646\u062E", "\uFC4E", "\u0646\u0645", "\uFC4F", "\u0646\u0649", "\uFC50", "\u0646\u064A", "\uFC51", "\u0647\u062C", "\uFC52", "\u0647\u0645", "\uFC53", "\u0647\u0649", "\uFC54", "\u0647\u064A", "\uFC55", "\u064A\u062C", "\uFC56", "\u064A\u062D", "\uFC57", "\u064A\u062E", "\uFC58", "\u064A\u0645", "\uFC59", "\u064A\u0649", "\uFC5A", "\u064A\u064A", "\uFC5B", "\u0630\u0670", "\uFC5C", "\u0631\u0670", "\uFC5D", "\u0649\u0670", "\uFC5E", " \u064C\u0651", "\uFC5F", " \u064D\u0651", "\uFC60", " \u064E\u0651", "\uFC61", " \u064F\u0651", "\uFC62", " \u0650\u0651", "\uFC63", " \u0651\u0670", "\uFC64", "\u0626\u0631", "\uFC65", "\u0626\u0632", "\uFC66", "\u0626\u0645", "\uFC67", "\u0626\u0646", "\uFC68", "\u0626\u0649", "\uFC69", "\u0626\u064A", "\uFC6A", "\u0628\u0631", "\uFC6B", "\u0628\u0632", "\uFC6C", "\u0628\u0645", "\uFC6D", "\u0628\u0646", "\uFC6E", "\u0628\u0649", "\uFC6F", "\u0628\u064A", "\uFC70", "\u062A\u0631", "\uFC71", "\u062A\u0632", "\uFC72", "\u062A\u0645", "\uFC73", "\u062A\u0646", "\uFC74", "\u062A\u0649", "\uFC75", "\u062A\u064A", "\uFC76", "\u062B\u0631", "\uFC77", "\u062B\u0632", "\uFC78", "\u062B\u0645", "\uFC79", "\u062B\u0646", "\uFC7A", "\u062B\u0649", "\uFC7B", "\u062B\u064A", "\uFC7C", "\u0641\u0649", "\uFC7D", "\u0641\u064A", "\uFC7E", "\u0642\u0649", "\uFC7F", "\u0642\u064A", "\uFC80", "\u0643\u0627", "\uFC81", "\u0643\u0644", "\uFC82", "\u0643\u0645", "\uFC83", "\u0643\u0649", "\uFC84", "\u0643\u064A", "\uFC85", "\u0644\u0645", "\uFC86", "\u0644\u0649", "\uFC87", "\u0644\u064A", "\uFC88", "\u0645\u0627", "\uFC89", "\u0645\u0645", "\uFC8A", "\u0646\u0631", "\uFC8B", "\u0646\u0632", "\uFC8C", "\u0646\u0645", "\uFC8D", "\u0646\u0646", "\uFC8E", "\u0646\u0649", "\uFC8F", "\u0646\u064A", "\uFC90", "\u0649\u0670", "\uFC91", "\u064A\u0631", "\uFC92", "\u064A\u0632", "\uFC93", "\u064A\u0645", "\uFC94", "\u064A\u0646", "\uFC95", "\u064A\u0649", "\uFC96", "\u064A\u064A", "\uFC97", "\u0626\u062C", "\uFC98", "\u0626\u062D", "\uFC99", "\u0626\u062E", "\uFC9A", "\u0626\u0645", "\uFC9B", "\u0626\u0647", "\uFC9C", "\u0628\u062C", "\uFC9D", "\u0628\u062D", "\uFC9E", "\u0628\u062E", "\uFC9F", "\u0628\u0645", "\uFCA0", "\u0628\u0647", "\uFCA1", "\u062A\u062C", "\uFCA2", "\u062A\u062D", "\uFCA3", "\u062A\u062E", "\uFCA4", "\u062A\u0645", "\uFCA5", "\u062A\u0647", "\uFCA6", "\u062B\u0645", "\uFCA7", "\u062C\u062D", "\uFCA8", "\u062C\u0645", "\uFCA9", "\u062D\u062C", "\uFCAA", "\u062D\u0645", "\uFCAB", "\u062E\u062C", "\uFCAC", "\u062E\u0645", "\uFCAD", "\u0633\u062C", "\uFCAE", "\u0633\u062D", "\uFCAF", "\u0633\u062E", "\uFCB0", "\u0633\u0645", "\uFCB1", "\u0635\u062D", "\uFCB2", "\u0635\u062E", "\uFCB3", "\u0635\u0645", "\uFCB4", "\u0636\u062C", "\uFCB5", "\u0636\u062D", "\uFCB6", "\u0636\u062E", "\uFCB7", "\u0636\u0645", "\uFCB8", "\u0637\u062D", "\uFCB9", "\u0638\u0645", "\uFCBA", "\u0639\u062C", "\uFCBB", "\u0639\u0645", "\uFCBC", "\u063A\u062C", "\uFCBD", "\u063A\u0645", "\uFCBE", "\u0641\u062C", "\uFCBF", "\u0641\u062D", "\uFCC0", "\u0641\u062E", "\uFCC1", "\u0641\u0645", "\uFCC2", "\u0642\u062D", "\uFCC3", "\u0642\u0645", "\uFCC4", "\u0643\u062C", "\uFCC5", "\u0643\u062D", "\uFCC6", "\u0643\u062E", "\uFCC7", "\u0643\u0644", "\uFCC8", "\u0643\u0645", "\uFCC9", "\u0644\u062C", "\uFCCA", "\u0644\u062D", "\uFCCB", "\u0644\u062E", "\uFCCC", "\u0644\u0645", "\uFCCD", "\u0644\u0647", "\uFCCE", "\u0645\u062C", "\uFCCF", "\u0645\u062D", "\uFCD0", "\u0645\u062E", "\uFCD1", "\u0645\u0645", "\uFCD2", "\u0646\u062C", "\uFCD3", "\u0646\u062D", "\uFCD4", "\u0646\u062E", "\uFCD5", "\u0646\u0645", "\uFCD6", "\u0646\u0647", "\uFCD7", "\u0647\u062C", "\uFCD8", "\u0647\u0645", "\uFCD9", "\u0647\u0670", "\uFCDA", "\u064A\u062C", "\uFCDB", "\u064A\u062D", "\uFCDC", "\u064A\u062E", "\uFCDD", "\u064A\u0645", "\uFCDE", "\u064A\u0647", "\uFCDF", "\u0626\u0645", "\uFCE0", "\u0626\u0647", "\uFCE1", "\u0628\u0645", "\uFCE2", "\u0628\u0647", "\uFCE3", "\u062A\u0645", "\uFCE4", "\u062A\u0647", "\uFCE5", "\u062B\u0645", "\uFCE6", "\u062B\u0647", "\uFCE7", "\u0633\u0645", "\uFCE8", "\u0633\u0647", "\uFCE9", "\u0634\u0645", "\uFCEA", "\u0634\u0647", "\uFCEB", "\u0643\u0644", "\uFCEC", "\u0643\u0645", "\uFCED", "\u0644\u0645", "\uFCEE", "\u0646\u0645", "\uFCEF", "\u0646\u0647", "\uFCF0", "\u064A\u0645", "\uFCF1", "\u064A\u0647", "\uFCF2", "\u0640\u064E\u0651", "\uFCF3", "\u0640\u064F\u0651", "\uFCF4", "\u0640\u0650\u0651", "\uFCF5", "\u0637\u0649", "\uFCF6", "\u0637\u064A", "\uFCF7", "\u0639\u0649", "\uFCF8", "\u0639\u064A", "\uFCF9", "\u063A\u0649", "\uFCFA", "\u063A\u064A", "\uFCFB", "\u0633\u0649", "\uFCFC", "\u0633\u064A", "\uFCFD", "\u0634\u0649", "\uFCFE", "\u0634\u064A", "\uFCFF", "\u062D\u0649", "\uFD00", "\u062D\u064A", "\uFD01", "\u062C\u0649", "\uFD02", "\u062C\u064A", "\uFD03", "\u062E\u0649", "\uFD04", "\u062E\u064A", "\uFD05", "\u0635\u0649", "\uFD06", "\u0635\u064A", "\uFD07", "\u0636\u0649", "\uFD08", "\u0636\u064A", "\uFD09", "\u0634\u062C", "\uFD0A", "\u0634\u062D", "\uFD0B", "\u0634\u062E", "\uFD0C", "\u0634\u0645", "\uFD0D", "\u0634\u0631", "\uFD0E", "\u0633\u0631", "\uFD0F", "\u0635\u0631", "\uFD10", "\u0636\u0631", "\uFD11", "\u0637\u0649", "\uFD12", "\u0637\u064A", "\uFD13", "\u0639\u0649", "\uFD14", "\u0639\u064A", "\uFD15", "\u063A\u0649", "\uFD16", "\u063A\u064A", "\uFD17", "\u0633\u0649", "\uFD18", "\u0633\u064A", "\uFD19", "\u0634\u0649", "\uFD1A", "\u0634\u064A", "\uFD1B", "\u062D\u0649", "\uFD1C", "\u062D\u064A", "\uFD1D", "\u062C\u0649", "\uFD1E", "\u062C\u064A", "\uFD1F", "\u062E\u0649", "\uFD20", "\u062E\u064A", "\uFD21", "\u0635\u0649", "\uFD22", "\u0635\u064A", "\uFD23", "\u0636\u0649", "\uFD24", "\u0636\u064A", "\uFD25", "\u0634\u062C", "\uFD26", "\u0634\u062D", "\uFD27", "\u0634\u062E", "\uFD28", "\u0634\u0645", "\uFD29", "\u0634\u0631", "\uFD2A", "\u0633\u0631", "\uFD2B", "\u0635\u0631", "\uFD2C", "\u0636\u0631", "\uFD2D", "\u0634\u062C", "\uFD2E", "\u0634\u062D", "\uFD2F", "\u0634\u062E", "\uFD30", "\u0634\u0645", "\uFD31", "\u0633\u0647", "\uFD32", "\u0634\u0647", "\uFD33", "\u0637\u0645", "\uFD34", "\u0633\u062C", "\uFD35", "\u0633\u062D", "\uFD36", "\u0633\u062E", "\uFD37", "\u0634\u062C", "\uFD38", "\u0634\u062D", "\uFD39", "\u0634\u062E", "\uFD3A", "\u0637\u0645", "\uFD3B", "\u0638\u0645", "\uFD3C", "\u0627\u064B", "\uFD3D", "\u0627\u064B", "\uFD50", "\u062A\u062C\u0645", "\uFD51", "\u062A\u062D\u062C", "\uFD52", "\u062A\u062D\u062C", "\uFD53", "\u062A\u062D\u0645", "\uFD54", "\u062A\u062E\u0645", "\uFD55", "\u062A\u0645\u062C", "\uFD56", "\u062A\u0645\u062D", "\uFD57", "\u062A\u0645\u062E", "\uFD58", "\u062C\u0645\u062D", "\uFD59", "\u062C\u0645\u062D", "\uFD5A", "\u062D\u0645\u064A", "\uFD5B", "\u062D\u0645\u0649", "\uFD5C", "\u0633\u062D\u062C", "\uFD5D", "\u0633\u062C\u062D", "\uFD5E", "\u0633\u062C\u0649", "\uFD5F", "\u0633\u0645\u062D", "\uFD60", "\u0633\u0645\u062D", "\uFD61", "\u0633\u0645\u062C", "\uFD62", "\u0633\u0645\u0645", "\uFD63", "\u0633\u0645\u0645", "\uFD64", "\u0635\u062D\u062D", "\uFD65", "\u0635\u062D\u062D", "\uFD66", "\u0635\u0645\u0645", "\uFD67", "\u0634\u062D\u0645", "\uFD68", "\u0634\u062D\u0645", "\uFD69", "\u0634\u062C\u064A", "\uFD6A", "\u0634\u0645\u062E", "\uFD6B", "\u0634\u0645\u062E", "\uFD6C", "\u0634\u0645\u0645", "\uFD6D", "\u0634\u0645\u0645", "\uFD6E", "\u0636\u062D\u0649", "\uFD6F", "\u0636\u062E\u0645", "\uFD70", "\u0636\u062E\u0645", "\uFD71", "\u0637\u0645\u062D", "\uFD72", "\u0637\u0645\u062D", "\uFD73", "\u0637\u0645\u0645", "\uFD74", "\u0637\u0645\u064A", "\uFD75", "\u0639\u062C\u0645", "\uFD76", "\u0639\u0645\u0645", "\uFD77", "\u0639\u0645\u0645", "\uFD78", "\u0639\u0645\u0649", "\uFD79", "\u063A\u0645\u0645", "\uFD7A", "\u063A\u0645\u064A", "\uFD7B", "\u063A\u0645\u0649", "\uFD7C", "\u0641\u062E\u0645", "\uFD7D", "\u0641\u062E\u0645", "\uFD7E", "\u0642\u0645\u062D", "\uFD7F", "\u0642\u0645\u0645", "\uFD80", "\u0644\u062D\u0645", "\uFD81", "\u0644\u062D\u064A", "\uFD82", "\u0644\u062D\u0649", "\uFD83", "\u0644\u062C\u062C", "\uFD84", "\u0644\u062C\u062C", "\uFD85", "\u0644\u062E\u0645", "\uFD86", "\u0644\u062E\u0645", "\uFD87", "\u0644\u0645\u062D", "\uFD88", "\u0644\u0645\u062D", "\uFD89", "\u0645\u062D\u062C", "\uFD8A", "\u0645\u062D\u0645", "\uFD8B", "\u0645\u062D\u064A", "\uFD8C", "\u0645\u062C\u062D", "\uFD8D", "\u0645\u062C\u0645", "\uFD8E", "\u0645\u062E\u062C", "\uFD8F", "\u0645\u062E\u0645", "\uFD92", "\u0645\u062C\u062E", "\uFD93", "\u0647\u0645\u062C", "\uFD94", "\u0647\u0645\u0645", "\uFD95", "\u0646\u062D\u0645", "\uFD96", "\u0646\u062D\u0649", "\uFD97", "\u0646\u062C\u0645", "\uFD98", "\u0646\u062C\u0645", "\uFD99", "\u0646\u062C\u0649", "\uFD9A", "\u0646\u0645\u064A", "\uFD9B", "\u0646\u0645\u0649", "\uFD9C", "\u064A\u0645\u0645", "\uFD9D", "\u064A\u0645\u0645", "\uFD9E", "\u0628\u062E\u064A", "\uFD9F", "\u062A\u062C\u064A", "\uFDA0", "\u062A\u062C\u0649", "\uFDA1", "\u062A\u062E\u064A", "\uFDA2", "\u062A\u062E\u0649", "\uFDA3", "\u062A\u0645\u064A", "\uFDA4", "\u062A\u0645\u0649", "\uFDA5", "\u062C\u0645\u064A", "\uFDA6", "\u062C\u062D\u0649", "\uFDA7", "\u062C\u0645\u0649", "\uFDA8", "\u0633\u062E\u0649", "\uFDA9", "\u0635\u062D\u064A", "\uFDAA", "\u0634\u062D\u064A", "\uFDAB", "\u0636\u062D\u064A", "\uFDAC", "\u0644\u062C\u064A", "\uFDAD", "\u0644\u0645\u064A", "\uFDAE", "\u064A\u062D\u064A", "\uFDAF", "\u064A\u062C\u064A", "\uFDB0", "\u064A\u0645\u064A", "\uFDB1", "\u0645\u0645\u064A", "\uFDB2", "\u0642\u0645\u064A", "\uFDB3", "\u0646\u062D\u064A", "\uFDB4", "\u0642\u0645\u062D", "\uFDB5", "\u0644\u062D\u0645", "\uFDB6", "\u0639\u0645\u064A", "\uFDB7", "\u0643\u0645\u064A", "\uFDB8", "\u0646\u062C\u062D", "\uFDB9", "\u0645\u062E\u064A", "\uFDBA", "\u0644\u062C\u0645", "\uFDBB", "\u0643\u0645\u0645", "\uFDBC", "\u0644\u062C\u0645", "\uFDBD", "\u0646\u062C\u062D", "\uFDBE", "\u062C\u062D\u064A", "\uFDBF", "\u062D\u062C\u064A", "\uFDC0", "\u0645\u062C\u064A", "\uFDC1", "\u0641\u0645\u064A", "\uFDC2", "\u0628\u062D\u064A", "\uFDC3", "\u0643\u0645\u0645", "\uFDC4", "\u0639\u062C\u0645", "\uFDC5", "\u0635\u0645\u0645", "\uFDC6", "\u0633\u062E\u064A", "\uFDC7", "\u0646\u062C\u064A", "\uFE49", "\u203E", "\uFE4A", "\u203E", "\uFE4B", "\u203E", "\uFE4C", "\u203E", "\uFE4D", "_", "\uFE4E", "_", "\uFE4F", "_", "\uFE80", "\u0621", "\uFE81", "\u0622", "\uFE82", "\u0622", "\uFE83", "\u0623", "\uFE84", "\u0623", "\uFE85", "\u0624", "\uFE86", "\u0624", "\uFE87", "\u0625", "\uFE88", "\u0625", "\uFE89", "\u0626", "\uFE8A", "\u0626", "\uFE8B", "\u0626", "\uFE8C", "\u0626", "\uFE8D", "\u0627", "\uFE8E", "\u0627", "\uFE8F", "\u0628", "\uFE90", "\u0628", "\uFE91", "\u0628", "\uFE92", "\u0628", "\uFE93", "\u0629", "\uFE94", "\u0629", "\uFE95", "\u062A", "\uFE96", "\u062A", "\uFE97", "\u062A", "\uFE98", "\u062A", "\uFE99", "\u062B", "\uFE9A", "\u062B", "\uFE9B", "\u062B", "\uFE9C", "\u062B", "\uFE9D", "\u062C", "\uFE9E", "\u062C", "\uFE9F", "\u062C", "\uFEA0", "\u062C", "\uFEA1", "\u062D", "\uFEA2", "\u062D", "\uFEA3", "\u062D", "\uFEA4", "\u062D", "\uFEA5", "\u062E", "\uFEA6", "\u062E", "\uFEA7", "\u062E", "\uFEA8", "\u062E", "\uFEA9", "\u062F", "\uFEAA", "\u062F", "\uFEAB", "\u0630", "\uFEAC", "\u0630", "\uFEAD", "\u0631", "\uFEAE", "\u0631", "\uFEAF", "\u0632", "\uFEB0", "\u0632", "\uFEB1", "\u0633", "\uFEB2", "\u0633", "\uFEB3", "\u0633", "\uFEB4", "\u0633", "\uFEB5", "\u0634", "\uFEB6", "\u0634", "\uFEB7", "\u0634", "\uFEB8", "\u0634", "\uFEB9", "\u0635", "\uFEBA", "\u0635", "\uFEBB", "\u0635", "\uFEBC", "\u0635", "\uFEBD", "\u0636", "\uFEBE", "\u0636", "\uFEBF", "\u0636", "\uFEC0", "\u0636", "\uFEC1", "\u0637", "\uFEC2", "\u0637", "\uFEC3", "\u0637", "\uFEC4", "\u0637", "\uFEC5", "\u0638", "\uFEC6", "\u0638", "\uFEC7", "\u0638", "\uFEC8", "\u0638", "\uFEC9", "\u0639", "\uFECA", "\u0639", "\uFECB", "\u0639", "\uFECC", "\u0639", "\uFECD", "\u063A", "\uFECE", "\u063A", "\uFECF", "\u063A", "\uFED0", "\u063A", "\uFED1", "\u0641", "\uFED2", "\u0641", "\uFED3", "\u0641", "\uFED4", "\u0641", "\uFED5", "\u0642", "\uFED6", "\u0642", "\uFED7", "\u0642", "\uFED8", "\u0642", "\uFED9", "\u0643", "\uFEDA", "\u0643", "\uFEDB", "\u0643", "\uFEDC", "\u0643", "\uFEDD", "\u0644", "\uFEDE", "\u0644", "\uFEDF", "\u0644", "\uFEE0", "\u0644", "\uFEE1", "\u0645", "\uFEE2", "\u0645", "\uFEE3", "\u0645", "\uFEE4", "\u0645", "\uFEE5", "\u0646", "\uFEE6", "\u0646", "\uFEE7", "\u0646", "\uFEE8", "\u0646", "\uFEE9", "\u0647", "\uFEEA", "\u0647", "\uFEEB", "\u0647", "\uFEEC", "\u0647", "\uFEED", "\u0648", "\uFEEE", "\u0648", "\uFEEF", "\u0649", "\uFEF0", "\u0649", "\uFEF1", "\u064A", "\uFEF2", "\u064A", "\uFEF3", "\u064A", "\uFEF4", "\u064A", "\uFEF5", "\u0644\u0622", "\uFEF6", "\u0644\u0622", "\uFEF7", "\u0644\u0623", "\uFEF8", "\u0644\u0623", "\uFEF9", "\u0644\u0625", "\uFEFA", "\u0644\u0625", "\uFEFB", "\u0644\u0627", "\uFEFC", "\u0644\u0627"];
      });
      function h(e) {
        var t;
        let a;
        let r = e.length;
        if (r <= 1 || (!((t = e.charCodeAt(0)) >= (a = o[13]).begin) || !(t < a.end)) && (!(t >= (a = o[11]).begin) || !(t < a.end))) return e;
        let i = [];
        for (let t = r - 1; t >= 0; t--) i.push(e[t]);
        return i.join("");
      }
      let u = RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u");
      let d = new Map();
      function f(e) {
        let t = d.get(e);
        if (t) return t;
        let a = e.match(u);
        let r = {
          isWhitespace: !!(a && a[1]),
          isZeroWidthDiacritic: !!(a && a[2]),
          isInvisibleFormatMark: !!(a && a[3])
        };
        d.set(e, r);
        return r;
      }
      function g() {
        d.clear();
      }
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.MarkupAnnotation = t.AnnotationFactory = t.AnnotationBorderStyle = t.Annotation = void 0;
      t.getQuadPoints = y;
      var r = a(2);
      var i = a(8);
      var n = a(23);
      var s = a(5);
      var o = a(9);
      var l = a(60);
      var c = a(64);
      var h = a(24);
      var u = a(67);
      var d = a(71);
      var f = a(62);
      var g = a(10);
      var p = a(72);
      var m = a(75);
      function b(e, t = new Uint8ClampedArray(3)) {
        if (!Array.isArray(e)) return t;
        let a = t || new Uint8ClampedArray(3);
        switch (e.length) {
          case 0:
            return null;
          case 1:
            h.ColorSpace.singletons.gray.getRgbItem(e, 0, a, 0);
            return a;
          case 3:
            h.ColorSpace.singletons.rgb.getRgbItem(e, 0, a, 0);
            return a;
          case 4:
            h.ColorSpace.singletons.cmyk.getRgbItem(e, 0, a, 0);
            return a;
          default:
            return t;
        }
      }
      function y(e, t) {
        if (!e.has("QuadPoints")) return null;
        let a = e.getArray("QuadPoints");
        if (!Array.isArray(a) || 0 === a.length || a.length % 8 > 0) return null;
        let r = [];
        for (function () {
          let e = 0;
          let i = a.length / 8;
        }(); e < i; e++) {
          r.push([]);
          for (function () {
            let i = 8 * e;
            let n = 8 * e + 8;
          }(); i < n; i += 2) {
            let n = a[i];
            let s = a[i + 1];
            if (null !== t && (n < t[0] || n > t[2] || s < t[1] || s > t[3])) return null;
            r[e].push({
              x: n,
              y: s
            });
          }
        }
        return r.map(e => {
          let [t, a, r, i] = e.reduce(([e, t, a, r], i) => [Math.min(e, i.x), Math.max(t, i.x), Math.min(a, i.y), Math.max(r, i.y)], [Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE]);
          return [{
            x: t,
            y: i
          }, {
            x: a,
            y: i
          }, {
            x: t,
            y: r
          }, {
            x: a,
            y: r
          }];
        });
      }
      function w(e, t, a) {
        let [i, n, s, o] = r.Util.getAxialAlignedBoundingBox(t, a);
        if (i === s || n === o) return [1, 0, 0, 1, e[0], e[1]];
        let l = (e[2] - e[0]) / (s - i);
        let c = (e[3] - e[1]) / (o - n);
        return [l, 0, 0, c, e[0] - i * l, e[1] - n * c];
      }
      t.AnnotationFactory = class {
        static create(e, t, a, r, i) {
          return Promise.all([a.ensureCatalog("acroForm"), i ? this._getPageIndex(e, t, a) : -1]).then(([n, s]) => a.ensure(this, "_create", [e, t, a, r, n, i, s]));
        }
        static _create(e, t, a, n, o, l, c = -1) {
          let h = e.fetchIfRef(t);
          if (!(h instanceof s.Dict)) return;
          let u = t instanceof s.Ref ? t.toString() : `annot_${n.createObjId()}`;
          let d = h.get("Subtype");
          let f = {
            xref: e,
            ref: t,
            dict: h,
            subtype: d = d instanceof s.Name ? d.name : null,
            id: u,
            pdfManager: a,
            acroForm: o instanceof s.Dict ? o : s.Dict.empty,
            collectFields: l,
            pageIndex: c
          };
          switch (d) {
            case "Link":
              return new T(f);
            case "Text":
              return new I(f);
            case "Widget":
              let g = i.getInheritableProperty({
                dict: h,
                key: "FT"
              });
              switch (g = g instanceof s.Name ? g.name : null) {
                case "Tx":
                  return new v(f);
                case "Btn":
                  return new C(f);
                case "Ch":
                  return new O(f);
                case "Sig":
                  return new F(f);
              }
              r.warn(`Unimplemented widget field type "${g}", falling back to base field type.`);
              return new A(f);
            case "Popup":
              return new M(f);
            case "FreeText":
              return new P(f);
            case "Line":
              return new E(f);
            case "Square":
              return new N(f);
            case "Circle":
              return new B(f);
            case "PolyLine":
              return new D(f);
            case "Polygon":
              return new L(f);
            case "Caret":
              return new R(f);
            case "Ink":
              return new $(f);
            case "Highlight":
              return new j(f);
            case "Underline":
              return new _(f);
            case "Squiggly":
              return new U(f);
            case "StrikeOut":
              return new X(f);
            case "Stamp":
              return new H(f);
            case "FileAttachment":
              return new q(f);
            default:
              l || (d ? r.warn(`Unimplemented annotation type "${d}", falling back to base annotation.`) : r.warn("Annotation is missing the required /Subtype."));
              return new x(f);
          }
        }
        static async _getPageIndex(e, t, a) {
          try {
            let r = await e.fetchIfRefAsync(t);
            if (!(r instanceof s.Dict)) return -1;
            let i = r.getRaw("P");
            if (!(i instanceof s.Ref)) return -1;
            return await a.ensureCatalog("getPageIndex", [i]);
          } catch (e) {
            r.warn(`_getPageIndex: "${e}".`);
            return -1;
          }
        }
      };
      class x {
        constructor(e) {
          this._streams = [];
          this.data = {
            annotationFlags: this.flags,
            borderStyle: this.borderStyle,
            color: this.color,
            backgroundColor: this.backgroundColor,
            borderColor: this.borderColor,
            contentsObj: this._contents,
            hasAppearance: !!this.appearance,
            id: e.id,
            modificationDate: this.modificationDate,
            rect: this.rectangle,
            subtype: e.subtype,
            hasOwnCanvas: !1
          };
          let t = e.dict;
          if (this.setTitle(t.get("T")), this.setContents(t.get("Contents")), this.setModificationDate(t.get("M")), this.setFlags(t.get("F")), this.setRectangle(t.getArray("Rect")), this.setColor(t.getArray("C")), this.setBorderStyle(t), this.setAppearance(t), this.setBorderAndBackgroundColors(t.get("MK")), this.appearance && this._streams.push(this.appearance), e.collectFields) {
            let a = t.get("Kids");
            if (Array.isArray(a)) {
              let e = [];
              for (let t of a) t instanceof s.Ref && e.push(t.toString());
              0 !== e.length && (this.data.kidIds = e);
            }
            this.data.actions = i.collectActions(e.xref, t, r.AnnotationActionEventType);
            this.data.fieldName = this._constructFieldName(t);
            this.data.pageIndex = e.pageIndex;
          }
          this._fallbackFontDict = null;
        }
        _hasFlag(e, t) {
          return !!(e & t);
        }
        _isViewable(e) {
          return !this._hasFlag(e, r.AnnotationFlag.INVISIBLE) && !this._hasFlag(e, r.AnnotationFlag.NOVIEW);
        }
        _isPrintable(e) {
          return this._hasFlag(e, r.AnnotationFlag.PRINT) && !this._hasFlag(e, r.AnnotationFlag.INVISIBLE);
        }
        mustBeViewed(e) {
          let t = e && e.get(this.data.id);
          return t && void 0 !== t.hidden ? !t.hidden : this.viewable && !this._hasFlag(this.flags, r.AnnotationFlag.HIDDEN);
        }
        mustBePrinted(e) {
          let t = e && e.get(this.data.id);
          return t && void 0 !== t.print ? t.print : this.printable;
        }
        get viewable() {
          return null !== this.data.quadPoints && (0 === this.flags || this._isViewable(this.flags));
        }
        get printable() {
          return null !== this.data.quadPoints && 0 !== this.flags && this._isPrintable(this.flags);
        }
        _parseStringHelper(e) {
          let t = "string" == typeof e ? r.stringToPDFString(e) : "";
          let a = t && "rtl" === l.bidi(t).dir ? "rtl" : "ltr";
          return {
            str: t,
            dir: a
          };
        }
        setTitle(e) {
          this._title = this._parseStringHelper(e);
        }
        setContents(e) {
          this._contents = this._parseStringHelper(e);
        }
        setModificationDate(e) {
          this.modificationDate = "string" == typeof e ? e : null;
        }
        setFlags(e) {
          this.flags = Number.isInteger(e) && e > 0 ? e : 0;
        }
        hasFlag(e) {
          return this._hasFlag(this.flags, e);
        }
        setRectangle(e) {
          Array.isArray(e) && 4 === e.length ? this.rectangle = r.Util.normalizeRect(e) : this.rectangle = [0, 0, 0, 0];
        }
        setColor(e) {
          this.color = b(e);
        }
        setBorderAndBackgroundColors(e) {
          e instanceof s.Dict ? (this.borderColor = b(e.getArray("BC"), null), this.backgroundColor = b(e.getArray("BG"), null)) : this.borderColor = this.backgroundColor = null;
        }
        setBorderStyle(e) {
          if (this.borderStyle = new S(), e instanceof s.Dict) {
            if (e.has("BS")) {
              let t = e.get("BS");
              let a = t.get("Type");
              (!a || s.isName(a, "Border")) && (this.borderStyle.setWidth(t.get("W"), this.rectangle), this.borderStyle.setStyle(t.get("S")), this.borderStyle.setDashArray(t.getArray("D")));
            } else if (e.has("Border")) {
              let t = e.getArray("Border");
              Array.isArray(t) && t.length >= 3 && (this.borderStyle.setHorizontalCornerRadius(t[0]), this.borderStyle.setVerticalCornerRadius(t[1]), this.borderStyle.setWidth(t[2], this.rectangle), 4 === t.length && this.borderStyle.setDashArray(t[3], !0));
            } else this.borderStyle.setWidth(0);
          }
        }
        setAppearance(e) {
          this.appearance = null;
          let t = e.get("AP");
          if (!(t instanceof s.Dict)) return;
          let a = t.get("N");
          if (a instanceof o.BaseStream) {
            this.appearance = a;
            return;
          }
          if (!(a instanceof s.Dict)) return;
          let r = e.get("AS");
          r instanceof s.Name && a.has(r.name) && (this.appearance = a.get(r.name));
        }
        loadResources(e, t) {
          return t.dict.getAsync("Resources").then(t => {
            if (t) return new d.ObjectLoader(t, e, t.xref).load().then(function () {
              return t;
            });
          });
        }
        getOperatorList(e, t, a, i, n) {
          let o = this.data;
          let l = this.appearance;
          let c = o.hasOwnCanvas && a & r.RenderingIntentFlag.DISPLAY;
          if (!l) {
            if (!c) return Promise.resolve(new f.OperatorList());
            (l = new g.StringStream("")).dict = new s.Dict();
          }
          let h = l.dict;
          let u = this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"], l);
          let d = h.getArray("BBox") || [0, 0, 1, 1];
          let p = h.getArray("Matrix") || [1, 0, 0, 1, 0, 0];
          let m = w(o.rect, d, p);
          return u.then(a => {
            let i = new f.OperatorList();
            i.addOp(r.OPS.beginAnnotation, [o.id, o.rect, m, p, c]);
            return e.getOperatorList({
              stream: l,
              task: t,
              resources: a,
              operatorList: i,
              fallbackFontDict: this._fallbackFontDict
            }).then(() => (i.addOp(r.OPS.endAnnotation, []), this.reset(), i));
          });
        }
        async save(e, t, a) {
          return null;
        }
        getFieldObject() {
          return this.data.kidIds ? {
            id: this.data.id,
            actions: this.data.actions,
            name: this.data.fieldName,
            strokeColor: this.data.borderColor,
            fillColor: this.data.backgroundColor,
            type: "",
            kidIds: this.data.kidIds,
            page: this.data.pageIndex
          } : null;
        }
        reset() {
          for (let e of this._streams) e.reset();
        }
        _constructFieldName(e) {
          if (!e.has("T") && !e.has("Parent")) {
            r.warn("Unknown field name, falling back to empty field name.");
            return "";
          }
          if (!e.has("Parent")) return r.stringToPDFString(e.get("T"));
          let t = [];
          e.has("T") && t.unshift(r.stringToPDFString(e.get("T")));
          let a = e;
          let i = new s.RefSet();
          for (e.objId && i.put(e.objId); a.has("Parent") && !(!((a = a.get("Parent")) instanceof s.Dict) || a.objId && i.has(a.objId));) {
            a.objId && i.put(a.objId);
            a.has("T") && t.unshift(r.stringToPDFString(a.get("T")));
          }
          return t.join(".");
        }
      }
      t.Annotation = x;
      class S {
        constructor() {
          this.width = 1;
          this.style = r.AnnotationBorderStyleType.SOLID;
          this.dashArray = [3];
          this.horizontalCornerRadius = 0;
          this.verticalCornerRadius = 0;
        }
        setWidth(e, t = [0, 0, 0, 0]) {
          if (e instanceof s.Name) {
            this.width = 0;
            return;
          }
          if ("number" == typeof e) {
            if (e > 0) {
              let a = (t[2] - t[0]) / 2;
              let i = (t[3] - t[1]) / 2;
              a > 0 && i > 0 && (e > a || e > i) && (r.warn(`AnnotationBorderStyle.setWidth - ignoring width: ${e}`), e = 1);
            }
            this.width = e;
          }
        }
        setStyle(e) {
          if (e instanceof s.Name) switch (e.name) {
            case "S":
              this.style = r.AnnotationBorderStyleType.SOLID;
              break;
            case "D":
              this.style = r.AnnotationBorderStyleType.DASHED;
              break;
            case "B":
              this.style = r.AnnotationBorderStyleType.BEVELED;
              break;
            case "I":
              this.style = r.AnnotationBorderStyleType.INSET;
              break;
            case "U":
              this.style = r.AnnotationBorderStyleType.UNDERLINE;
          }
        }
        setDashArray(e, t = !1) {
          if (Array.isArray(e) && e.length > 0) {
            let a = !0;
            let r = !0;
            for (let t of e) if (+t >= 0) t > 0 && (r = !1); else {
              a = !1;
              break;
            }
            a && !r ? (this.dashArray = e, t && this.setStyle(s.Name.get("D"))) : this.width = 0;
          } else e && (this.width = 0);
        }
        setHorizontalCornerRadius(e) {
          Number.isInteger(e) && (this.horizontalCornerRadius = e);
        }
        setVerticalCornerRadius(e) {
          Number.isInteger(e) && (this.verticalCornerRadius = e);
        }
      }
      t.AnnotationBorderStyle = S;
      class k extends x {
        constructor(e) {
          super(e);
          let t = e.dict;
          if (t.has("IRT")) {
            let e = t.getRaw("IRT");
            this.data.inReplyTo = e instanceof s.Ref ? e.toString() : null;
            let a = t.get("RT");
            this.data.replyType = a instanceof s.Name ? a.name : r.AnnotationReplyType.REPLY;
          }
          if (this.data.replyType === r.AnnotationReplyType.GROUP) {
            let e = t.get("IRT");
            this.setTitle(e.get("T"));
            this.data.titleObj = this._title;
            this.setContents(e.get("Contents"));
            this.data.contentsObj = this._contents;
            e.has("CreationDate") ? (this.setCreationDate(e.get("CreationDate")), this.data.creationDate = this.creationDate) : this.data.creationDate = null;
            e.has("M") ? (this.setModificationDate(e.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null;
            this.data.hasPopup = e.has("Popup");
            e.has("C") ? (this.setColor(e.getArray("C")), this.data.color = this.color) : this.data.color = null;
          } else {
            this.data.titleObj = this._title;
            this.setCreationDate(t.get("CreationDate"));
            this.data.creationDate = this.creationDate;
            this.data.hasPopup = t.has("Popup");
            t.has("C") || (this.data.color = null);
          }
          t.has("RC") && (this.data.richText = m.XFAFactory.getRichTextAsHtml(t.get("RC")));
        }
        setCreationDate(e) {
          this.creationDate = "string" == typeof e ? e : null;
        }
        _setDefaultAppearance({
          xref: e,
          extra: t,
          strokeColor: a,
          fillColor: r,
          blendMode: i,
          strokeAlpha: n,
          fillAlpha: o,
          pointsCallback: l
        }) {
          let c = Number.MAX_VALUE;
          let h = Number.MAX_VALUE;
          let u = Number.MIN_VALUE;
          let d = Number.MIN_VALUE;
          let f = ["q"];
          t && f.push(t);
          a && f.push(`${a[0]} ${a[1]} ${a[2]} RG`);
          r && f.push(`${r[0]} ${r[1]} ${r[2]} rg`);
          let p = this.data.quadPoints;
          for (let e of (p || (p = [[{
            x: this.rectangle[0],
            y: this.rectangle[3]
          }, {
            x: this.rectangle[2],
            y: this.rectangle[3]
          }, {
            x: this.rectangle[0],
            y: this.rectangle[1]
          }, {
            x: this.rectangle[2],
            y: this.rectangle[1]
          }]]), p)) {
            let [t, a, r, i] = l(f, e);
            c = Math.min(c, t);
            u = Math.max(u, a);
            h = Math.min(h, r);
            d = Math.max(d, i);
          }
          f.push("Q");
          let m = new s.Dict(e);
          let b = new s.Dict(e);
          b.set("Subtype", s.Name.get("Form"));
          let y = new g.StringStream(f.join(" "));
          y.dict = b;
          m.set("Fm0", y);
          let w = new s.Dict(e);
          i && w.set("BM", s.Name.get(i));
          "number" == typeof n && w.set("CA", n);
          "number" == typeof o && w.set("ca", o);
          let x = new s.Dict(e);
          x.set("GS0", w);
          let S = new s.Dict(e);
          S.set("ExtGState", x);
          S.set("XObject", m);
          let k = new s.Dict(e);
          k.set("Resources", S);
          let A = this.data.rect = [c, h, u, d];
          k.set("BBox", A);
          this.appearance = new g.StringStream("/GS0 gs /Fm0 Do");
          this.appearance.dict = k;
          this._streams.push(this.appearance, y);
        }
      }
      t.MarkupAnnotation = k;
      class A extends x {
        constructor(e) {
          super(e);
          let t = e.dict;
          let a = this.data;
          this.ref = e.ref;
          a.annotationType = r.AnnotationType.WIDGET;
          void 0 === a.fieldName && (a.fieldName = this._constructFieldName(t));
          void 0 === a.actions && (a.actions = i.collectActions(e.xref, t, r.AnnotationActionEventType));
          let o = i.getInheritableProperty({
            dict: t,
            key: "V",
            getArray: !0
          });
          a.fieldValue = this._decodeFormValue(o);
          let l = i.getInheritableProperty({
            dict: t,
            key: "DV",
            getArray: !0
          });
          a.defaultFieldValue = this._decodeFormValue(l);
          void 0 === o && null !== a.defaultFieldValue && (a.fieldValue = a.defaultFieldValue);
          a.alternativeText = r.stringToPDFString(t.get("TU") || "");
          let c = i.getInheritableProperty({
            dict: t,
            key: "DA"
          }) || e.acroForm.get("DA");
          this._defaultAppearance = "string" == typeof c ? c : "";
          a.defaultAppearanceData = n.parseDefaultAppearance(this._defaultAppearance);
          let h = i.getInheritableProperty({
            dict: t,
            key: "FT"
          });
          a.fieldType = h instanceof s.Name ? h.name : null;
          let u = i.getInheritableProperty({
            dict: t,
            key: "DR"
          });
          let d = e.acroForm.get("DR");
          let f = this.appearance && this.appearance.dict.get("Resources");
          this._fieldResources = {
            localResources: u,
            acroFormResources: d,
            appearanceResources: f,
            mergedResources: s.Dict.merge({
              xref: e.xref,
              dictArray: [u, f, d],
              mergeSubDicts: !0
            })
          };
          a.fieldFlags = i.getInheritableProperty({
            dict: t,
            key: "Ff"
          });
          (!Number.isInteger(a.fieldFlags) || a.fieldFlags < 0) && (a.fieldFlags = 0);
          a.readOnly = this.hasFieldFlag(r.AnnotationFieldFlag.READONLY);
          a.hidden = this._hasFlag(a.annotationFlags, r.AnnotationFlag.HIDDEN);
        }
        _decodeFormValue(e) {
          return Array.isArray(e) ? e.filter(e => "string" == typeof e).map(e => r.stringToPDFString(e)) : e instanceof s.Name ? r.stringToPDFString(e.name) : "string" == typeof e ? r.stringToPDFString(e) : null;
        }
        hasFieldFlag(e) {
          return !!(this.data.fieldFlags & e);
        }
        getOperatorList(e, t, a, i, n) {
          return !i || this instanceof F ? this._hasText ? this._getAppearance(e, t, n).then(s => {
            if (this.appearance && null === s) return super.getOperatorList(e, t, a, i, n);
            let o = new f.OperatorList();
            if (!this._defaultAppearance || null === s) return o;
            let l = [1, 0, 0, 1, 0, 0];
            let c = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]];
            let h = w(this.data.rect, c, l);
            o.addOp(r.OPS.beginAnnotation, [this.data.id, this.data.rect, h, l]);
            let u = new g.StringStream(s);
            return e.getOperatorList({
              stream: u,
              task: t,
              resources: this._fieldResources.mergedResources,
              operatorList: o
            }).then(function () {
              o.addOp(r.OPS.endAnnotation, []);
              return o;
            });
          }) : super.getOperatorList(e, t, a, i, n) : Promise.resolve(new f.OperatorList());
        }
        async save(e, t, a) {
          if (!a) return null;
          let i = a.get(this.data.id);
          let n = i && i.value;
          if (n === this.data.fieldValue || void 0 === n) return null;
          let o = await this._getAppearance(e, t, a);
          if (null === o) return null;
          let {
            xref
          } = e;
          let c = xref.fetchIfRef(this.ref);
          if (!(c instanceof s.Dict)) return null;
          let h = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]];
          let u = {
            path: r.stringToPDFString(c.get("T") || ""),
            value: n
          };
          let d = xref.getNewRef();
          let f = new s.Dict(xref);
          f.set("N", d);
          let g = xref.encrypt;
          let m = null;
          let b = null;
          g && (m = g.createCipherTransform(this.ref.num, this.ref.gen), o = (b = g.createCipherTransform(d.num, d.gen)).encryptString(o));
          c.set("V", r.isAscii(n) ? n : r.stringToUTF16BEString(n));
          c.set("AP", f);
          c.set("M", `D:${r.getModificationDate()}`);
          let y = new s.Dict(xref);
          y.set("Length", o.length);
          y.set("Subtype", s.Name.get("Form"));
          y.set("Resources", this._getSaveFieldResources(xref));
          y.set("BBox", h);
          let w = [`${this.ref.num} ${this.ref.gen} obj
`];
          p.writeDict(c, w, m);
          w.push("\nendobj\n");
          let x = [`${d.num} ${d.gen} obj
`];
          p.writeDict(y, x, b);
          x.push(" stream\n", o, "\nendstream\nendobj\n");
          return [{
            ref: this.ref,
            data: w.join(""),
            xfa: u
          }, {
            ref: d,
            data: x.join(""),
            xfa: null
          }];
        }
        async _getAppearance(e, t, a) {
          let i = this.hasFieldFlag(r.AnnotationFieldFlag.PASSWORD);
          if (!a || i) return null;
          let s = a.get(this.data.id);
          let o = s && s.value;
          if (void 0 === o) return null;
          if ("" === (o = o.trim())) return "";
          let l = -1;
          this.data.multiLine && (l = o.split(/\r\n|\r|\n/).length);
          let c = this.data.rect[3] - this.data.rect[1];
          let h = this.data.rect[2] - this.data.rect[0];
          this._defaultAppearance || (this.data.defaultAppearanceData = n.parseDefaultAppearance(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
          let u = await this._getFontData(e, t);
          let [d, f] = this._computeFontSize(c - 2, h - 4, o, u, l);
          let g = u.descent;
          isNaN(g) && (g = 0);
          let p = 2 + Math.abs(g) * f;
          let m = this.data.textAlignment;
          if (this.data.multiLine) return this._getMultilineAppearance(d, o, u, f, h, c, m, 2, p);
          let b = u.encodeString(o).join("");
          if (this.data.comb) return this._getCombAppearance(d, u, b, h, 2, p);
          if (0 === m || m > 2) return "/Tx BMC q BT " + d + ` 1 0 0 1 2 ${p} Tm (${r.escapeString(b)}) Tj` + " ET Q EMC";
          let y = this._renderText(b, u, f, h, m, 2, p);
          return "/Tx BMC q BT " + d + ` 1 0 0 1 0 0 Tm ${y}` + " ET Q EMC";
        }
        async _getFontData(e, t) {
          let a = new f.OperatorList();
          let r = {
            font: null,
            clone() {
              return this;
            }
          };
          let {
            fontName,
            fontSize
          } = this.data.defaultAppearanceData;
          await e.handleSetFont(this._fieldResources.mergedResources, [fontName && s.Name.get(fontName), fontSize], null, a, t, r, null);
          return r.font;
        }
        _getTextWidth(e, t) {
          return t.charsToGlyphs(e).reduce((e, t) => e + t.width, 0) / 1e3;
        }
        _computeFontSize(e, t, a, r, i) {
          let {
            fontSize
          } = this.data.defaultAppearanceData;
          if (!fontSize) {
            let o = e => Math.floor(100 * e) / 100;
            if (-1 === i) s = o(Math.min(e / 1.35, t / this._getTextWidth(a, r))); else {
              let n = a.split(/\r\n?|\n/);
              let l = [];
              for (let e of n) {
                let t = r.encodeString(e).join("");
                let a = r.charsToGlyphs(t);
                let i = r.getCharPositions(t);
                l.push({
                  line: t,
                  glyphs: a,
                  positions: i
                });
              }
              let c = a => {
                let i = 0;
                for (let n of l) if ((i += this._splitLine(null, r, a, t, n).length * a) > e) return !0;
                return !1;
              };
              let h = 1.35 * (s = 12);
              let u = Math.round(e / h);
              for (u = Math.max(u, i); ;) {
                if (c(s = o((h = e / u) / 1.35))) {
                  u++;
                  continue;
                }
                break;
              }
            }
            let {
              fontName,
              fontColor
            } = this.data.defaultAppearanceData;
            this._defaultAppearance = n.createDefaultAppearance({
              fontSize,
              fontName,
              fontColor
            });
          }
          return [this._defaultAppearance, fontSize];
        }
        _renderText(e, t, a, i, n, s, o) {
          let l;
          let c = this._getTextWidth(e, t) * a;
          l = (l = 1 === n ? (i - c) / 2 : 2 === n ? i - c - s : s).toFixed(2);
          o = o.toFixed(2);
          return `${l} ${o} Td (${r.escapeString(e)}) Tj`;
        }
        _getSaveFieldResources(e) {
          let {
            localResources,
            appearanceResources,
            acroFormResources
          } = this._fieldResources;
          let i = this.data.defaultAppearanceData && this.data.defaultAppearanceData.fontName;
          if (!i) return localResources || s.Dict.empty;
          for (let e of [localResources, appearanceResources]) if (e instanceof s.Dict) {
            let t = e.get("Font");
            if (t instanceof s.Dict && t.has(i)) return e;
          }
          if (acroFormResources instanceof s.Dict) {
            let a = acroFormResources.get("Font");
            if (a instanceof s.Dict && a.has(i)) {
              let r = new s.Dict(e);
              r.set(i, a.getRaw(i));
              let n = new s.Dict(e);
              n.set("Font", r);
              return s.Dict.merge({
                xref: e,
                dictArray: [n, localResources],
                mergeSubDicts: !0
              });
            }
          }
          return localResources || s.Dict.empty;
        }
        getFieldObject() {
          return null;
        }
      }
      class v extends A {
        constructor(e) {
          super(e);
          this._hasText = !0;
          let t = e.dict;
          "string" != typeof this.data.fieldValue && (this.data.fieldValue = "");
          let a = i.getInheritableProperty({
            dict: t,
            key: "Q"
          });
          (!Number.isInteger(a) || a < 0 || a > 2) && (a = null);
          this.data.textAlignment = a;
          let n = i.getInheritableProperty({
            dict: t,
            key: "MaxLen"
          });
          (!Number.isInteger(n) || n < 0) && (n = null);
          this.data.maxLen = n;
          this.data.multiLine = this.hasFieldFlag(r.AnnotationFieldFlag.MULTILINE);
          this.data.comb = this.hasFieldFlag(r.AnnotationFieldFlag.COMB) && !this.hasFieldFlag(r.AnnotationFieldFlag.MULTILINE) && !this.hasFieldFlag(r.AnnotationFieldFlag.PASSWORD) && !this.hasFieldFlag(r.AnnotationFieldFlag.FILESELECT) && null !== this.data.maxLen;
        }
        _getCombAppearance(e, t, a, i, n, s) {
          let o = (i / this.data.maxLen).toFixed(2);
          let l = [];
          for (let [e, i] of t.getCharPositions(a)) l.push(`(${r.escapeString(a.substring(e, i))}) Tj`);
          let c = l.join(` ${o} 0 Td `);
          return "/Tx BMC q BT " + e + ` 1 0 0 1 ${n} ${s} Tm ${c}` + " ET Q EMC";
        }
        _getMultilineAppearance(e, t, a, r, i, n, s, o, l) {
          let c = t.split(/\r\n?|\n/);
          let h = [];
          let u = i - 2 * o;
          for (let e of c) for (let t of this._splitLine(e, a, r, u)) {
            let e = 0 === h.length ? o : 0;
            h.push(this._renderText(t, a, r, i, s, e, -r));
          }
          let d = h.join("\n");
          return "/Tx BMC q BT " + e + ` 1 0 0 1 0 ${n} Tm ${d}` + " ET Q EMC";
        }
        _splitLine(e, t, a, r, i = {}) {
          e = i.line || t.encodeString(e).join("");
          let n = i.glyphs || t.charsToGlyphs(e);
          if (n.length <= 1) return [e];
          let s = i.positions || t.getCharPositions(e);
          let o = a / 1e3;
          let l = [];
          let c = -1;
          let h = -1;
          let u = -1;
          let d = 0;
          let f = 0;
          for (function () {
            let t = 0;
            let a = n.length;
          }(); t < a; t++) {
            let [a, i] = s[t];
            let g = n[t];
            let p = g.width * o;
            " " === g.unicode ? f + p > r ? (l.push(e.substring(d, a)), d = a, f = p, c = -1, u = -1) : (f += p, c = a, h = i, u = t) : f + p > r ? -1 !== c ? (l.push(e.substring(d, h)), d = h, t = u + 1, c = -1, f = 0) : (l.push(e.substring(d, a)), d = a, f = p) : f += p;
          }
          d < e.length && l.push(e.substring(d, e.length));
          return l;
        }
        getFieldObject() {
          return {
            id: this.data.id,
            value: this.data.fieldValue,
            defaultValue: this.data.defaultFieldValue,
            multiline: this.data.multiLine,
            password: this.hasFieldFlag(r.AnnotationFieldFlag.PASSWORD),
            charLimit: this.data.maxLen,
            comb: this.data.comb,
            editable: !this.data.readOnly,
            hidden: this.data.hidden,
            name: this.data.fieldName,
            rect: this.data.rect,
            actions: this.data.actions,
            page: this.data.pageIndex,
            strokeColor: this.data.borderColor,
            fillColor: this.data.backgroundColor,
            type: "text"
          };
        }
      }
      class C extends A {
        constructor(e) {
          super(e);
          this.checkedAppearance = null;
          this.uncheckedAppearance = null;
          this.data.checkBox = !this.hasFieldFlag(r.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(r.AnnotationFieldFlag.PUSHBUTTON);
          this.data.radioButton = this.hasFieldFlag(r.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(r.AnnotationFieldFlag.PUSHBUTTON);
          this.data.pushButton = this.hasFieldFlag(r.AnnotationFieldFlag.PUSHBUTTON);
          this.data.isTooltipOnly = !1;
          this.data.checkBox ? this._processCheckBox(e) : this.data.radioButton ? this._processRadioButton(e) : this.data.pushButton ? (this.data.hasOwnCanvas = !0, this._processPushButton(e)) : r.warn("Invalid field flags for button widget annotation");
        }
        async getOperatorList(e, t, a, r, i) {
          if (this.data.pushButton) return super.getOperatorList(e, t, a, !1, i);
          let n = null;
          if (i) {
            let e = i.get(this.data.id);
            n = e ? e.value : null;
          }
          if (null === n) {
            if (this.appearance) return super.getOperatorList(e, t, a, r, i);
            n = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue;
          }
          let s = n ? this.checkedAppearance : this.uncheckedAppearance;
          if (s) {
            let n = this.appearance;
            this.appearance = s;
            let o = super.getOperatorList(e, t, a, r, i);
            this.appearance = n;
            return o;
          }
          return new f.OperatorList();
        }
        async save(e, t, a) {
          return this.data.checkBox ? this._saveCheckbox(e, t, a) : this.data.radioButton ? this._saveRadioButton(e, t, a) : null;
        }
        async _saveCheckbox(e, t, a) {
          if (!a) return null;
          let i = a.get(this.data.id);
          let n = i && i.value;
          if (void 0 === n || this.data.fieldValue === this.data.exportValue === n) return null;
          let o = e.xref.fetchIfRef(this.ref);
          if (!(o instanceof s.Dict)) return null;
          let l = {
            path: r.stringToPDFString(o.get("T") || ""),
            value: n ? this.data.exportValue : ""
          };
          let c = s.Name.get(n ? this.data.exportValue : "Off");
          o.set("V", c);
          o.set("AS", c);
          o.set("M", `D:${r.getModificationDate()}`);
          let h = e.xref.encrypt;
          let u = null;
          h && (u = h.createCipherTransform(this.ref.num, this.ref.gen));
          let d = [`${this.ref.num} ${this.ref.gen} obj
`];
          p.writeDict(o, d, u);
          d.push("\nendobj\n");
          return [{
            ref: this.ref,
            data: d.join(""),
            xfa: l
          }];
        }
        async _saveRadioButton(e, t, a) {
          if (!a) return null;
          let i = a.get(this.data.id);
          let n = i && i.value;
          if (void 0 === n || this.data.fieldValue === this.data.buttonValue === n) return null;
          let o = e.xref.fetchIfRef(this.ref);
          if (!(o instanceof s.Dict)) return null;
          let l = {
            path: r.stringToPDFString(o.get("T") || ""),
            value: n ? this.data.buttonValue : ""
          };
          let c = s.Name.get(n ? this.data.buttonValue : "Off");
          let h = null;
          let u = e.xref.encrypt;
          if (n) {
            if (this.parent instanceof s.Ref) {
              let t = e.xref.fetch(this.parent);
              let a = null;
              u && (a = u.createCipherTransform(this.parent.num, this.parent.gen));
              t.set("V", c);
              h = [`${this.parent.num} ${this.parent.gen} obj
`];
              p.writeDict(t, h, a);
              h.push("\nendobj\n");
            } else this.parent instanceof s.Dict && this.parent.set("V", c);
          }
          o.set("AS", c);
          o.set("M", `D:${r.getModificationDate()}`);
          let d = null;
          u && (d = u.createCipherTransform(this.ref.num, this.ref.gen));
          let f = [`${this.ref.num} ${this.ref.gen} obj
`];
          p.writeDict(o, f, d);
          f.push("\nendobj\n");
          let g = [{
            ref: this.ref,
            data: f.join(""),
            xfa: l
          }];
          null !== h && g.push({
            ref: this.parent,
            data: h.join(""),
            xfa: null
          });
          return g;
        }
        _getDefaultCheckedAppearance(e, t) {
          let a;
          let i;
          let n = this.data.rect[2] - this.data.rect[0];
          let o = this.data.rect[3] - this.data.rect[1];
          let l = .8 * Math.min(n, o);
          "check" === t ? (a = {
            width: .755 * l,
            height: .705 * l
          }, i = "3") : "disc" === t ? (a = {
            width: .791 * l,
            height: .705 * l
          }, i = "l") : r.unreachable(`_getDefaultCheckedAppearance - unsupported type: ${t}`);
          let c = (n - a.width) / 2;
          let h = (o - a.height) / 2;
          let u = `q BT /PdfJsZaDb ${l} Tf 0 g ${c} ${h} Td (${i}) Tj ET Q`;
          let d = new s.Dict(e.xref);
          d.set("FormType", 1);
          d.set("Subtype", s.Name.get("Form"));
          d.set("Type", s.Name.get("XObject"));
          d.set("BBox", [0, 0, n, o]);
          d.set("Matrix", [1, 0, 0, 1, 0, 0]);
          d.set("Length", u.length);
          let f = new s.Dict(e.xref);
          let p = new s.Dict(e.xref);
          p.set("PdfJsZaDb", this.fallbackFontDict);
          f.set("Font", p);
          d.set("Resources", f);
          this.checkedAppearance = new g.StringStream(u);
          this.checkedAppearance.dict = d;
          this._streams.push(this.checkedAppearance);
        }
        _processCheckBox(e) {
          let t = e.dict.get("AP");
          if (!(t instanceof s.Dict)) return;
          let a = t.get("N");
          if (!(a instanceof s.Dict)) return;
          let r = this._decodeFormValue(e.dict.get("AS"));
          "string" == typeof r && (this.data.fieldValue = r);
          let i = null !== this.data.fieldValue && "Off" !== this.data.fieldValue ? this.data.fieldValue : "Yes";
          let n = a.getKeys();
          if (0 === n.length) n.push("Off", i); else if (1 === n.length) "Off" === n[0] ? n.push(i) : n.unshift("Off"); else if (n.includes(i)) {
            n.length = 0;
            n.push("Off", i);
          } else {
            let e = n.find(e => "Off" !== e);
            n.length = 0;
            n.push("Off", e);
          }
          n.includes(this.data.fieldValue) || (this.data.fieldValue = "Off");
          this.data.exportValue = n[1];
          this.checkedAppearance = a.get(this.data.exportValue) || null;
          this.uncheckedAppearance = a.get("Off") || null;
          this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e, "check");
          this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance);
          this._fallbackFontDict = this.fallbackFontDict;
        }
        _processRadioButton(e) {
          this.data.fieldValue = this.data.buttonValue = null;
          let t = e.dict.get("Parent");
          if (t instanceof s.Dict) {
            this.parent = e.dict.getRaw("Parent");
            let a = t.get("V");
            a instanceof s.Name && (this.data.fieldValue = this._decodeFormValue(a));
          }
          let a = e.dict.get("AP");
          if (!(a instanceof s.Dict)) return;
          let r = a.get("N");
          if (r instanceof s.Dict) {
            for (let e of r.getKeys()) if ("Off" !== e) {
              this.data.buttonValue = this._decodeFormValue(e);
              break;
            }
            this.checkedAppearance = r.get(this.data.buttonValue) || null;
            this.uncheckedAppearance = r.get("Off") || null;
            this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e, "disc");
            this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance);
            this._fallbackFontDict = this.fallbackFontDict;
          }
        }
        _processPushButton(e) {
          if (!e.dict.has("A") && !e.dict.has("AA") && !this.data.alternativeText) {
            r.warn("Push buttons without action dictionaries are not supported");
            return;
          }
          this.data.isTooltipOnly = !e.dict.has("A") && !e.dict.has("AA");
          c.Catalog.parseDestDictionary({
            destDict: e.dict,
            resultObj: this.data,
            docBaseUrl: e.pdfManager.docBaseUrl
          });
        }
        getFieldObject() {
          let e;
          let t = "button";
          this.data.checkBox ? (t = "checkbox", e = this.data.exportValue) : this.data.radioButton && (t = "radiobutton", e = this.data.buttonValue);
          return {
            id: this.data.id,
            value: this.data.fieldValue || "Off",
            defaultValue: this.data.defaultFieldValue,
            exportValues: e,
            editable: !this.data.readOnly,
            name: this.data.fieldName,
            rect: this.data.rect,
            hidden: this.data.hidden,
            actions: this.data.actions,
            page: this.data.pageIndex,
            strokeColor: this.data.borderColor,
            fillColor: this.data.backgroundColor,
            type: t
          };
        }
        get fallbackFontDict() {
          let e = new s.Dict();
          e.set("BaseFont", s.Name.get("ZapfDingbats"));
          e.set("Type", s.Name.get("FallbackType"));
          e.set("Subtype", s.Name.get("FallbackType"));
          e.set("Encoding", s.Name.get("ZapfDingbatsEncoding"));
          return r.shadow(this, "fallbackFontDict", e);
        }
      }
      class O extends A {
        constructor(e) {
          super(e);
          this.data.options = [];
          let t = i.getInheritableProperty({
            dict: e.dict,
            key: "Opt"
          });
          if (Array.isArray(t)) {
            let a = e.xref;
            for (function () {
              let e = 0;
              let r = t.length;
            }(); e < r; e++) {
              let r = a.fetchIfRef(t[e]);
              let i = Array.isArray(r);
              this.data.options[e] = {
                exportValue: this._decodeFormValue(i ? a.fetchIfRef(r[0]) : r),
                displayValue: this._decodeFormValue(i ? a.fetchIfRef(r[1]) : r)
              };
            }
          }
          "string" == typeof this.data.fieldValue ? this.data.fieldValue = [this.data.fieldValue] : this.data.fieldValue || (this.data.fieldValue = []);
          this.data.combo = this.hasFieldFlag(r.AnnotationFieldFlag.COMBO);
          this.data.multiSelect = this.hasFieldFlag(r.AnnotationFieldFlag.MULTISELECT);
          this._hasText = !0;
        }
        getFieldObject() {
          let e = this.data.combo ? "combobox" : "listbox";
          let t = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
          return {
            id: this.data.id,
            value: t,
            defaultValue: this.data.defaultFieldValue,
            editable: !this.data.readOnly,
            name: this.data.fieldName,
            rect: this.data.rect,
            numItems: this.data.fieldValue.length,
            multipleSelection: this.data.multiSelect,
            hidden: this.data.hidden,
            actions: this.data.actions,
            items: this.data.options,
            page: this.data.pageIndex,
            strokeColor: this.data.borderColor,
            fillColor: this.data.backgroundColor,
            type: e
          };
        }
      }
      class F extends A {
        constructor(e) {
          super(e);
          this.data.fieldValue = null;
        }
        getFieldObject() {
          return {
            id: this.data.id,
            value: null,
            page: this.data.pageIndex,
            type: "signature"
          };
        }
      }
      class I extends k {
        constructor(e) {
          super(e);
          let t = e.dict;
          this.data.annotationType = r.AnnotationType.TEXT;
          this.data.hasAppearance ? this.data.name = "NoIcon" : (this.data.rect[1] = this.data.rect[3] - 22, this.data.rect[2] = this.data.rect[0] + 22, this.data.name = t.has("Name") ? t.get("Name").name : "Note");
          t.has("State") ? (this.data.state = t.get("State") || null, this.data.stateModel = t.get("StateModel") || null) : (this.data.state = null, this.data.stateModel = null);
        }
      }
      class T extends x {
        constructor(e) {
          super(e);
          this.data.annotationType = r.AnnotationType.LINK;
          let t = y(e.dict, this.rectangle);
          t && (this.data.quadPoints = t);
          c.Catalog.parseDestDictionary({
            destDict: e.dict,
            resultObj: this.data,
            docBaseUrl: e.pdfManager.docBaseUrl
          });
        }
      }
      class M extends x {
        constructor(e) {
          super(e);
          this.data.annotationType = r.AnnotationType.POPUP;
          let t = e.dict.get("Parent");
          if (!t) {
            r.warn("Popup annotation has a missing or invalid parent annotation.");
            return;
          }
          let a = t.get("Subtype");
          this.data.parentType = a instanceof s.Name ? a.name : null;
          let i = e.dict.getRaw("Parent");
          this.data.parentId = i instanceof s.Ref ? i.toString() : null;
          let n = t.getArray("Rect");
          Array.isArray(n) && 4 === n.length ? this.data.parentRect = r.Util.normalizeRect(n) : this.data.parentRect = [0, 0, 0, 0];
          let o = t.get("RT");
          if (s.isName(o, r.AnnotationReplyType.GROUP) && (t = t.get("IRT")), t.has("M") ? (this.setModificationDate(t.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, t.has("C") ? (this.setColor(t.getArray("C")), this.data.color = this.color) : this.data.color = null, !this.viewable) {
            let e = t.get("F");
            this._isViewable(e) && this.setFlags(e);
          }
          this.setTitle(t.get("T"));
          this.data.titleObj = this._title;
          this.setContents(t.get("Contents"));
          this.data.contentsObj = this._contents;
          t.has("RC") && (this.data.richText = m.XFAFactory.getRichTextAsHtml(t.get("RC")));
        }
      }
      class P extends k {
        constructor(e) {
          super(e);
          this.data.annotationType = r.AnnotationType.FREETEXT;
        }
      }
      class E extends k {
        constructor(e) {
          super(e);
          this.data.annotationType = r.AnnotationType.LINE;
          let t = e.dict.getArray("L");
          if (this.data.lineCoordinates = r.Util.normalizeRect(t), !this.appearance) {
            let a = this.color ? Array.from(this.color).map(e => e / 255) : [0, 0, 0];
            let i = e.dict.get("CA");
            let n = null;
            let s = e.dict.getArray("IC");
            s && (n = (s = b(s, null)) ? Array.from(s).map(e => e / 255) : null);
            let o = n ? i : null;
            let l = this.borderStyle.width || 1;
            let c = 2 * l;
            let h = [this.data.lineCoordinates[0] - c, this.data.lineCoordinates[1] - c, this.data.lineCoordinates[2] + c, this.data.lineCoordinates[3] + c];
            r.Util.intersect(this.rectangle, h) || (this.rectangle = h);
            this._setDefaultAppearance({
              xref: e.xref,
              extra: `${l} w`,
              strokeColor: a,
              fillColor: n,
              strokeAlpha: i,
              fillAlpha: o,
              pointsCallback: (e, a) => (e.push(`${t[0]} ${t[1]} m`, `${t[2]} ${t[3]} l`, "S"), [a[0].x - l, a[1].x + l, a[3].y - l, a[1].y + l])
            });
          }
        }
      }
      class N extends k {
        constructor(e) {
          if (super(e), this.data.annotationType = r.AnnotationType.SQUARE, !this.appearance) {
            let t = this.color ? Array.from(this.color).map(e => e / 255) : [0, 0, 0];
            let a = e.dict.get("CA");
            let r = null;
            let i = e.dict.getArray("IC");
            i && (r = (i = b(i, null)) ? Array.from(i).map(e => e / 255) : null);
            let n = r ? a : null;
            if (0 === this.borderStyle.width && !r) return;
            this._setDefaultAppearance({
              xref: e.xref,
              extra: `${this.borderStyle.width} w`,
              strokeColor: t,
              fillColor: r,
              strokeAlpha: a,
              fillAlpha: n,
              pointsCallback: (e, t) => {
                let a = t[2].x + this.borderStyle.width / 2;
                let i = t[2].y + this.borderStyle.width / 2;
                let n = t[3].x - t[2].x - this.borderStyle.width;
                let s = t[1].y - t[3].y - this.borderStyle.width;
                e.push(`${a} ${i} ${n} ${s} re`);
                r ? e.push("B") : e.push("S");
                return [t[0].x, t[1].x, t[3].y, t[1].y];
              }
            });
          }
        }
      }
      class B extends k {
        constructor(e) {
          if (super(e), this.data.annotationType = r.AnnotationType.CIRCLE, !this.appearance) {
            let t = this.color ? Array.from(this.color).map(e => e / 255) : [0, 0, 0];
            let a = e.dict.get("CA");
            let r = null;
            let i = e.dict.getArray("IC");
            i && (r = (i = b(i, null)) ? Array.from(i).map(e => e / 255) : null);
            let n = r ? a : null;
            if (0 === this.borderStyle.width && !r) return;
            let s = 4 / 3 * Math.tan(Math.PI / 8);
            this._setDefaultAppearance({
              xref: e.xref,
              extra: `${this.borderStyle.width} w`,
              strokeColor: t,
              fillColor: r,
              strokeAlpha: a,
              fillAlpha: n,
              pointsCallback: (e, t) => {
                let a = t[0].x + this.borderStyle.width / 2;
                let i = t[0].y - this.borderStyle.width / 2;
                let n = t[3].x - this.borderStyle.width / 2;
                let o = t[3].y + this.borderStyle.width / 2;
                let l = a + (n - a) / 2;
                let c = i + (o - i) / 2;
                let h = (n - a) / 2 * s;
                let u = (o - i) / 2 * s;
                e.push(`${l} ${o} m`, `${l + h} ${o} ${n} ${c + u} ${n} ${c} c`, `${n} ${c - u} ${l + h} ${i} ${l} ${i} c`, `${l - h} ${i} ${a} ${c - u} ${a} ${c} c`, `${a} ${c + u} ${l - h} ${o} ${l} ${o} c`, "h");
                r ? e.push("B") : e.push("S");
                return [t[0].x, t[1].x, t[3].y, t[1].y];
              }
            });
          }
        }
      }
      class D extends k {
        constructor(e) {
          super(e);
          this.data.annotationType = r.AnnotationType.POLYLINE;
          this.data.vertices = [];
          let t = e.dict.getArray("Vertices");
          if (!Array.isArray(t)) return;
          for (function () {
            let e = 0;
            let a = t.length;
          }(); e < a; e += 2) this.data.vertices.push({
            x: t[e],
            y: t[e + 1]
          });
          if (!this.appearance) {
            let t = this.color ? Array.from(this.color).map(e => e / 255) : [0, 0, 0];
            let a = e.dict.get("CA");
            let i = this.borderStyle.width || 1;
            let n = 2 * i;
            let s = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let e of this.data.vertices) {
              s[0] = Math.min(s[0], e.x - n);
              s[1] = Math.min(s[1], e.y - n);
              s[2] = Math.max(s[2], e.x + n);
              s[3] = Math.max(s[3], e.y + n);
            }
            r.Util.intersect(this.rectangle, s) || (this.rectangle = s);
            this._setDefaultAppearance({
              xref: e.xref,
              extra: `${i} w`,
              strokeColor: t,
              strokeAlpha: a,
              pointsCallback: (e, t) => {
                let a = this.data.vertices;
                for (function () {
                  let t = 0;
                  let r = a.length;
                }(); t < r; t++) e.push(`${a[t].x} ${a[t].y} ${0 === t ? "m" : "l"}`);
                e.push("S");
                return [t[0].x, t[1].x, t[3].y, t[1].y];
              }
            });
          }
        }
      }
      class L extends D {
        constructor(e) {
          super(e);
          this.data.annotationType = r.AnnotationType.POLYGON;
        }
      }
      class R extends k {
        constructor(e) {
          super(e);
          this.data.annotationType = r.AnnotationType.CARET;
        }
      }
      class $ extends k {
        constructor(e) {
          super(e);
          this.data.annotationType = r.AnnotationType.INK;
          this.data.inkLists = [];
          let t = e.dict.getArray("InkList");
          if (!Array.isArray(t)) return;
          let a = e.xref;
          for (function () {
            let e = 0;
            let r = t.length;
          }(); e < r; ++e) {
            this.data.inkLists.push([]);
            for (function () {
              let r = 0;
              let i = t[e].length;
            }(); r < i; r += 2) this.data.inkLists[e].push({
              x: a.fetchIfRef(t[e][r]),
              y: a.fetchIfRef(t[e][r + 1])
            });
          }
          if (!this.appearance) {
            let t = this.color ? Array.from(this.color).map(e => e / 255) : [0, 0, 0];
            let a = e.dict.get("CA");
            let i = this.borderStyle.width || 1;
            let n = 2 * i;
            let s = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let e of this.data.inkLists) for (let t of e) {
              s[0] = Math.min(s[0], t.x - n);
              s[1] = Math.min(s[1], t.y - n);
              s[2] = Math.max(s[2], t.x + n);
              s[3] = Math.max(s[3], t.y + n);
            }
            r.Util.intersect(this.rectangle, s) || (this.rectangle = s);
            this._setDefaultAppearance({
              xref: e.xref,
              extra: `${i} w`,
              strokeColor: t,
              strokeAlpha: a,
              pointsCallback: (e, t) => {
                for (let t of this.data.inkLists) {
                  for (function () {
                    let a = 0;
                    let r = t.length;
                  }(); a < r; a++) e.push(`${t[a].x} ${t[a].y} ${0 === a ? "m" : "l"}`);
                  e.push("S");
                }
                return [t[0].x, t[1].x, t[3].y, t[1].y];
              }
            });
          }
        }
      }
      class j extends k {
        constructor(e) {
          if (super(e), this.data.annotationType = r.AnnotationType.HIGHLIGHT, this.data.quadPoints = y(e.dict, null)) {
            let t = this.appearance && this.appearance.dict.get("Resources");
            if (!this.appearance || !(t && t.has("ExtGState"))) {
              this.appearance && r.warn("HighlightAnnotation - ignoring built-in appearance stream.");
              let t = this.color ? Array.from(this.color).map(e => e / 255) : [1, 1, 0];
              let a = e.dict.get("CA");
              this._setDefaultAppearance({
                xref: e.xref,
                fillColor: t,
                blendMode: "Multiply",
                fillAlpha: a,
                pointsCallback: (e, t) => (e.push(`${t[0].x} ${t[0].y} m`, `${t[1].x} ${t[1].y} l`, `${t[3].x} ${t[3].y} l`, `${t[2].x} ${t[2].y} l`, "f"), [t[0].x, t[1].x, t[3].y, t[1].y])
              });
            }
          } else this.data.hasPopup = !1;
        }
      }
      class _ extends k {
        constructor(e) {
          if (super(e), this.data.annotationType = r.AnnotationType.UNDERLINE, this.data.quadPoints = y(e.dict, null)) {
            if (!this.appearance) {
              let t = this.color ? Array.from(this.color).map(e => e / 255) : [0, 0, 0];
              let a = e.dict.get("CA");
              this._setDefaultAppearance({
                xref: e.xref,
                extra: "[] 0 d 1 w",
                strokeColor: t,
                strokeAlpha: a,
                pointsCallback: (e, t) => (e.push(`${t[2].x} ${t[2].y} m`, `${t[3].x} ${t[3].y} l`, "S"), [t[0].x, t[1].x, t[3].y, t[1].y])
              });
            }
          } else this.data.hasPopup = !1;
        }
      }
      class U extends k {
        constructor(e) {
          if (super(e), this.data.annotationType = r.AnnotationType.SQUIGGLY, this.data.quadPoints = y(e.dict, null)) {
            if (!this.appearance) {
              let t = this.color ? Array.from(this.color).map(e => e / 255) : [0, 0, 0];
              let a = e.dict.get("CA");
              this._setDefaultAppearance({
                xref: e.xref,
                extra: "[] 0 d 1 w",
                strokeColor: t,
                strokeAlpha: a,
                pointsCallback: (e, t) => {
                  let a = (t[0].y - t[2].y) / 6;
                  let r = a;
                  let i = t[2].x;
                  let n = t[2].y;
                  let s = t[3].x;
                  e.push(`${i} ${n + r} m`);
                  do {
                    i += 2;
                    r = 0 === r ? a : 0;
                    e.push(`${i} ${n + r} l`);
                  } while (i < s);
                  e.push("S");
                  return [t[2].x, s, n - 2 * a, n + 2 * a];
                }
              });
            }
          } else this.data.hasPopup = !1;
        }
      }
      class X extends k {
        constructor(e) {
          if (super(e), this.data.annotationType = r.AnnotationType.STRIKEOUT, this.data.quadPoints = y(e.dict, null)) {
            if (!this.appearance) {
              let t = this.color ? Array.from(this.color).map(e => e / 255) : [0, 0, 0];
              let a = e.dict.get("CA");
              this._setDefaultAppearance({
                xref: e.xref,
                extra: "[] 0 d 1 w",
                strokeColor: t,
                strokeAlpha: a,
                pointsCallback: (e, t) => (e.push(`${(t[0].x + t[2].x) / 2} ${(t[0].y + t[2].y) / 2} m`, `${(t[1].x + t[3].x) / 2} ${(t[1].y + t[3].y) / 2} l`, "S"), [t[0].x, t[1].x, t[3].y, t[1].y])
              });
            }
          } else this.data.hasPopup = !1;
        }
      }
      class H extends k {
        constructor(e) {
          super(e);
          this.data.annotationType = r.AnnotationType.STAMP;
        }
      }
      class q extends k {
        constructor(e) {
          super(e);
          let t = new u.FileSpec(e.dict.get("FS"), e.xref);
          this.data.annotationType = r.AnnotationType.FILEATTACHMENT;
          this.data.file = t.serializable;
        }
      }
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.createDefaultAppearance = function ({
        fontSize: e,
        fontName: t,
        fontColor: a
      }) {
        let r;
        r = a.every(e => 0 === e) ? "0 g" : Array.from(a).map(e => (e / 255).toFixed(2)).join(" ") + " rg";
        return `/${n.escapePDFName(t)} ${e} Tf ${r}`;
      };
      t.parseDefaultAppearance = function (e) {
        return new c(e).parse();
      };
      var r = a(2);
      var i = a(24);
      var n = a(8);
      var s = a(25);
      var o = a(5);
      var l = a(10);
      class c extends s.EvaluatorPreprocessor {
        constructor(e) {
          super(new l.StringStream(e));
        }
        parse() {
          let e = {
            fn: 0,
            args: []
          };
          let t = {
            fontSize: 0,
            fontName: "",
            fontColor: new Uint8ClampedArray(3)
          };
          try {
            for (; e.args.length = 0, this.read(e);) {
              if (0 !== this.savedStatesDepth) continue;
              let {
                fn,
                args
              } = e;
              switch (0 | fn) {
                case r.OPS.setFont:
                  let [s, l] = args;
                  s instanceof o.Name && (t.fontName = s.name);
                  "number" == typeof l && l > 0 && (t.fontSize = l);
                  break;
                case r.OPS.setFillRGBColor:
                  i.ColorSpace.singletons.rgb.getRgbItem(args, 0, t.fontColor, 0);
                  break;
                case r.OPS.setFillGray:
                  i.ColorSpace.singletons.gray.getRgbItem(args, 0, t.fontColor, 0);
                  break;
                case r.OPS.setFillColorSpace:
                  i.ColorSpace.singletons.cmyk.getRgbItem(args, 0, t.fontColor, 0);
              }
            }
          } catch (e) {
            r.warn(`parseDefaultAppearance - ignoring errors: "${e}".`);
          }
          return t;
        }
      }
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.ColorSpace = void 0;
      var r = a(2);
      var i = a(5);
      var n = a(9);
      var s = a(8);
      class o {
        constructor(e, t) {
          this.constructor === o && r.unreachable("Cannot initialize ColorSpace.");
          this.name = e;
          this.numComps = t;
        }
        getRgb(e, t) {
          let a = new Uint8ClampedArray(3);
          this.getRgbItem(e, t, a, 0);
          return a;
        }
        getRgbItem(e, t, a, i) {
          r.unreachable("Should not call ColorSpace.getRgbItem");
        }
        getRgbBuffer(e, t, a, i, n, s, o) {
          r.unreachable("Should not call ColorSpace.getRgbBuffer");
        }
        getOutputLength(e, t) {
          r.unreachable("Should not call ColorSpace.getOutputLength");
        }
        isPassthrough(e) {
          return !1;
        }
        isDefaultDecode(e, t) {
          return o.isDefaultDecode(e, this.numComps);
        }
        fillRgb(e, t, a, r, i, n, s, o, l) {
          let c = t * a;
          let h = null;
          let u = 1 << s;
          let d = a !== i || t !== r;
          if (this.isPassthrough(s)) h = o; else if (1 === this.numComps && c > u && "DeviceGray" !== this.name && "DeviceRGB" !== this.name) {
            let t = s <= 8 ? new Uint8Array(u) : new Uint16Array(u);
            for (let e = 0; e < u; e++) t[e] = e;
            let a = new Uint8ClampedArray(3 * u);
            if (this.getRgbBuffer(t, 0, u, a, 0, s, 0), d) {
              h = new Uint8Array(3 * c);
              let e = 0;
              for (let t = 0; t < c; ++t) {
                let r = 3 * o[t];
                h[e++] = a[r];
                h[e++] = a[r + 1];
                h[e++] = a[r + 2];
              }
            } else {
              let t = 0;
              for (let r = 0; r < c; ++r) {
                let i = 3 * o[r];
                e[t++] = a[i];
                e[t++] = a[i + 1];
                e[t++] = a[i + 2];
                t += l;
              }
            }
          } else d ? (h = new Uint8ClampedArray(3 * c), this.getRgbBuffer(o, 0, c, h, 0, s, 0)) : this.getRgbBuffer(o, 0, r * n, e, 0, s, l);
          if (h) {
            if (d) !function (e, t, a, r, i, n, s) {
              s = 1 !== s ? 0 : s;
              let o = a / i;
              let l = r / n;
              let c = 0;
              let h;
              let u = new Uint16Array(i);
              let d = 3 * a;
              for (let e = 0; e < i; e++) u[e] = 3 * Math.floor(e * o);
              for (let a = 0; a < n; a++) {
                let r = Math.floor(a * l) * d;
                for (let a = 0; a < i; a++) {
                  h = r + u[a];
                  t[c++] = e[h++];
                  t[c++] = e[h++];
                  t[c++] = e[h++];
                  c += s;
                }
              }
            }(h, e, t, a, r, i, l); else {
              let t = 0;
              let a = 0;
              for (function () {
                let i = 0;
                let s = r * n;
              }(); i < s; i++) {
                e[t++] = h[a++];
                e[t++] = h[a++];
                e[t++] = h[a++];
                t += l;
              }
            }
          }
        }
        get usesZeroToOneRange() {
          return r.shadow(this, "usesZeroToOneRange", !0);
        }
        static _cache(e, t, a, r) {
          let n;
          let s;
          if (!a) throw Error('ColorSpace._cache - expected "localColorSpaceCache" argument.');
          if (!r) throw Error('ColorSpace._cache - expected "parsedColorSpace" argument.');
          e instanceof i.Ref && (s = e, e = t.fetch(e));
          e instanceof i.Name && (n = e.name);
          (n || s) && a.set(n, s, r);
        }
        static getCached(e, t, a) {
          if (!a) throw Error('ColorSpace.getCached - expected "localColorSpaceCache" argument.');
          if (e instanceof i.Ref) {
            let r = a.getByRef(e);
            if (r) return r;
            try {
              e = t.fetch(e);
            } catch (e) {
              if (e instanceof s.MissingDataException) throw e;
            }
          }
          if (e instanceof i.Name) {
            let t = a.getByName(e.name);
            if (t) return t;
          }
          return null;
        }
        static async parseAsync({
          cs: e,
          xref: t,
          resources: a = null,
          pdfFunctionFactory: r,
          localColorSpaceCache: i
        }) {
          let n = this._parse(e, t, a, r);
          this._cache(e, t, i, n);
          return n;
        }
        static parse({
          cs: e,
          xref: t,
          resources: a = null,
          pdfFunctionFactory: r,
          localColorSpaceCache: i
        }) {
          let n = this.getCached(e, t, i);
          if (n) return n;
          let s = this._parse(e, t, a, r);
          this._cache(e, t, i, s);
          return s;
        }
        static _parse(e, t, a = null, n) {
          if ((e = t.fetchIfRef(e)) instanceof i.Name) switch (e.name) {
            case "G":
            case "DeviceGray":
              return this.singletons.gray;
            case "RGB":
            case "DeviceRGB":
              return this.singletons.rgb;
            case "CMYK":
            case "DeviceCMYK":
              return this.singletons.cmyk;
            case "Pattern":
              return new c(null);
            default:
              if (a instanceof i.Dict) {
                let r = a.get("ColorSpace");
                if (r instanceof i.Dict) {
                  let s = r.get(e.name);
                  if (s) {
                    if (s instanceof i.Name) return this._parse(s, t, a, n);
                    e = s;
                    break;
                  }
                }
              }
              throw new r.FormatError(`Unrecognized ColorSpace: ${e.name}`);
          }
          if (Array.isArray(e)) {
            let i;
            let s;
            let o;
            let u;
            let d;
            let f;
            let b = t.fetchIfRef(e[0]).name;
            switch (b) {
              case "G":
              case "DeviceGray":
                return this.singletons.gray;
              case "RGB":
              case "DeviceRGB":
                return this.singletons.rgb;
              case "CMYK":
              case "DeviceCMYK":
                return this.singletons.cmyk;
              case "CalGray":
                return new g(u = (i = t.fetchIfRef(e[1])).getArray("WhitePoint"), d = i.getArray("BlackPoint"), i.get("Gamma"));
              case "CalRGB":
                u = (i = t.fetchIfRef(e[1])).getArray("WhitePoint");
                return new p(u, d = i.getArray("BlackPoint"), i.getArray("Gamma"), i.getArray("Matrix"));
              case "ICCBased":
                let y = t.fetchIfRef(e[1]).dict;
                s = y.get("N");
                let w = y.get("Alternate");
                if (w) {
                  let e = this._parse(w, t, a, n);
                  if (e.numComps === s) return e;
                  r.warn("ICCBased color space: Ignoring incorrect /Alternate entry.");
                }
                if (1 === s) return this.singletons.gray;
                if (3 === s) return this.singletons.rgb;
                if (4 === s) return this.singletons.cmyk;
                break;
              case "Pattern":
                (o = e[1] || null) && (o = this._parse(o, t, a, n));
                return new c(o);
              case "I":
              case "Indexed":
                return new h(o = this._parse(e[1], t, a, n), t.fetchIfRef(e[2]) + 1, t.fetchIfRef(e[3]));
              case "Separation":
              case "DeviceN":
                let x = t.fetchIfRef(e[1]);
                return new l(s = Array.isArray(x) ? x.length : 1, o = this._parse(e[2], t, a, n), n.create(e[3]));
              case "Lab":
                return new m(u = (i = t.fetchIfRef(e[1])).getArray("WhitePoint"), d = i.getArray("BlackPoint"), i.getArray("Range"));
              default:
                throw new r.FormatError(`Unimplemented ColorSpace object: ${b}`);
            }
          }
          throw new r.FormatError(`Unrecognized ColorSpace object: ${e}`);
        }
        static isDefaultDecode(e, t) {
          if (!Array.isArray(e)) return !0;
          if (2 * t !== e.length) {
            r.warn("The decode map is not the correct length");
            return !0;
          }
          for (function () {
            let t = 0;
            let a = e.length;
          }(); t < a; t += 2) if (0 !== e[t] || 1 !== e[t + 1]) return !1;
          return !0;
        }
        static get singletons() {
          return r.shadow(this, "singletons", {
            get gray() {
              return r.shadow(this, "gray", new u());
            },
            get rgb() {
              return r.shadow(this, "rgb", new d());
            },
            get cmyk() {
              return r.shadow(this, "cmyk", new f());
            }
          });
        }
      }
      t.ColorSpace = o;
      class l extends o {
        constructor(e, t, a) {
          super("Alternate", e);
          this.base = t;
          this.tintFn = a;
          this.tmpBuf = new Float32Array(t.numComps);
        }
        getRgbItem(e, t, a, r) {
          let i = this.tmpBuf;
          this.tintFn(e, t, i, 0);
          this.base.getRgbItem(i, 0, a, r);
        }
        getRgbBuffer(e, t, a, r, i, n, s) {
          let o;
          let l;
          let c = this.tintFn;
          let h = this.base;
          let u = 1 / ((1 << n) - 1);
          let d = h.numComps;
          let f = h.usesZeroToOneRange;
          let g = (h.isPassthrough(8) || !f) && 0 === s;
          let p = g ? i : 0;
          let m = g ? r : new Uint8ClampedArray(d * a);
          let b = this.numComps;
          let y = new Float32Array(b);
          let w = new Float32Array(d);
          for (o = 0; o < a; o++) {
            for (l = 0; l < b; l++) y[l] = e[t++] * u;
            if (c(y, 0, w, 0), f) for (l = 0; l < d; l++) m[p++] = 255 * w[l]; else {
              h.getRgbItem(w, 0, m, p);
              p += d;
            }
          }
          g || h.getRgbBuffer(m, 0, a, r, i, 8, s);
        }
        getOutputLength(e, t) {
          return this.base.getOutputLength(e * this.base.numComps / this.numComps, t);
        }
      }
      class c extends o {
        constructor(e) {
          super("Pattern", null);
          this.base = e;
        }
        isDefaultDecode(e, t) {
          r.unreachable("Should not call PatternCS.isDefaultDecode");
        }
      }
      class h extends o {
        constructor(e, t, a) {
          this.lookup = new Uint8Array(i);
          super("Indexed", 1);
          this.base = e;
          this.highVal = t;
          let i = e.numComps * t;
          if (a instanceof n.BaseStream) {
            let e = a.getBytes(i);
            this.lookup.set(e);
          } else if ("string" == typeof a) for (let e = 0; e < i; ++e) this.lookup[e] = 255 & a.charCodeAt(e); else throw new r.FormatError(`IndexedCS - unrecognized lookup table: ${a}`);
        }
        getRgbItem(e, t, a, r) {
          let i = this.base.numComps;
          let n = e[t] * i;
          this.base.getRgbBuffer(this.lookup, n, 1, a, r, 8, 0);
        }
        getRgbBuffer(e, t, a, r, i, n, s) {
          let o = this.base;
          let l = o.numComps;
          let c = o.getOutputLength(l, s);
          let h = this.lookup;
          for (let n = 0; n < a; ++n) {
            let a = e[t++] * l;
            o.getRgbBuffer(h, a, 1, r, i, 8, s);
            i += c;
          }
        }
        getOutputLength(e, t) {
          return this.base.getOutputLength(e * this.base.numComps, t);
        }
        isDefaultDecode(e, t) {
          return !Array.isArray(e) || (2 !== e.length ? (r.warn("Decode map length is not correct"), !0) : !Number.isInteger(t) || t < 1 ? (r.warn("Bits per component is not correct"), !0) : 0 === e[0] && e[1] === (1 << t) - 1);
        }
      }
      class u extends o {
        constructor() {
          super("DeviceGray", 1);
        }
        getRgbItem(e, t, a, r) {
          let i = 255 * e[t];
          a[r] = a[r + 1] = a[r + 2] = i;
        }
        getRgbBuffer(e, t, a, r, i, n, s) {
          let o = 255 / ((1 << n) - 1);
          let l = t;
          let c = i;
          for (let t = 0; t < a; ++t) {
            let t = o * e[l++];
            r[c++] = t;
            r[c++] = t;
            r[c++] = t;
            c += s;
          }
        }
        getOutputLength(e, t) {
          return e * (3 + t);
        }
      }
      class d extends o {
        constructor() {
          super("DeviceRGB", 3);
        }
        getRgbItem(e, t, a, r) {
          a[r] = 255 * e[t];
          a[r + 1] = 255 * e[t + 1];
          a[r + 2] = 255 * e[t + 2];
        }
        getRgbBuffer(e, t, a, r, i, n, s) {
          if (8 === n && 0 === s) {
            r.set(e.subarray(t, t + 3 * a), i);
            return;
          }
          let o = 255 / ((1 << n) - 1);
          let l = t;
          let c = i;
          for (let t = 0; t < a; ++t) {
            r[c++] = o * e[l++];
            r[c++] = o * e[l++];
            r[c++] = o * e[l++];
            c += s;
          }
        }
        getOutputLength(e, t) {
          return e * (3 + t) / 3 | 0;
        }
        isPassthrough(e) {
          return 8 === e;
        }
      }
      let f = function () {
        function e(e, t, a, r, i) {
          let n = e[t] * a;
          let s = e[t + 1] * a;
          let o = e[t + 2] * a;
          let l = e[t + 3] * a;
          r[i] = 255 + n * (-4.387332384609988 * n + 54.48615194189176 * s + 18.82290502165302 * o + 212.25662451639585 * l + -285.2331026137004) + s * (1.7149763477362134 * s - 5.6096736904047315 * o + -17.873870861415444 * l - 5.497006427196366) + o * (-2.5217340131683033 * o - 21.248923337353073 * l + 17.5119270841813) + l * (-21.86122147463605 * l - 189.48180835922747);
          r[i + 1] = 255 + n * (8.841041422036149 * n + 60.118027045597366 * s + 6.871425592049007 * o + 31.159100130055922 * l + -79.2970844816548) + s * (-15.310361306967817 * s + 17.575251261109482 * o + 131.35250912493976 * l - 190.9453302588951) + o * (4.444339102852739 * o + 9.8632861493405 * l - 24.86741582555878) + l * (-20.737325471181034 * l - 187.80453709719578);
          r[i + 2] = 255 + n * (.8842522430003296 * n + 8.078677503112928 * s + 30.89978309703729 * o - .23883238689178934 * l + -14.183576799673286) + s * (10.49593273432072 * s + 63.02378494754052 * o + 50.606957656360734 * l - 112.23884253719248) + o * (.03296041114873217 * o + 115.60384449646641 * l + -193.58209356861505) + l * (-22.33816807309886 * l - 180.12613974708367);
        }
        return class extends o {
          constructor() {
            super("DeviceCMYK", 4);
          }
          getRgbItem(t, a, r, i) {
            e(t, a, 1, r, i);
          }
          getRgbBuffer(t, a, r, i, n, s, o) {
            let l = 1 / ((1 << s) - 1);
            for (let s = 0; s < r; s++) {
              e(t, a, l, i, n);
              a += 4;
              n += 3 + o;
            }
          }
          getOutputLength(e, t) {
            return e / 4 * (3 + t) | 0;
          }
        };
      }();
      let g = function () {
        function e(e, t, a, r, i, n) {
          let s = t[a] * n;
          let o = s ** e.G;
          let l = Math.max(295.8 * (e.YW * o) ** .3333333333333333 - 40.8, 0);
          r[i] = l;
          r[i + 1] = l;
          r[i + 2] = l;
        }
        return class extends o {
          constructor(e, t, a) {
            if (super("CalGray", 1), !e) throw new r.FormatError("WhitePoint missing - required for color space CalGray");
            if (t = t || [0, 0, 0], a = a || 1, this.XW = e[0], this.YW = e[1], this.ZW = e[2], this.XB = t[0], this.YB = t[1], this.ZB = t[2], this.G = a, this.XW < 0 || this.ZW < 0 || 1 !== this.YW) throw new r.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
            (this.XB < 0 || this.YB < 0 || this.ZB < 0) && (r.info(`Invalid BlackPoint for ${this.name}, falling back to default.`), this.XB = this.YB = this.ZB = 0);
            (0 !== this.XB || 0 !== this.YB || 0 !== this.ZB) && r.warn(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`);
            this.G < 1 && (r.info(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`), this.G = 1);
          }
          getRgbItem(t, a, r, i) {
            e(this, t, a, r, i, 1);
          }
          getRgbBuffer(t, a, r, i, n, s, o) {
            let l = 1 / ((1 << s) - 1);
            for (let s = 0; s < r; ++s) {
              e(this, t, a, i, n, l);
              a += 1;
              n += 3 + o;
            }
          }
          getOutputLength(e, t) {
            return e * (3 + t);
          }
        };
      }();
      let p = function () {
        let e = new Float32Array([.8951, .2664, -.1614, -.7502, 1.7135, .0367, .0389, -.0685, 1.0296]);
        let t = new Float32Array([.9869929, -.1470543, .1599627, .4323053, .5183603, .0492912, -.0085287, .0400428, .9684867]);
        let a = new Float32Array([3.2404542, -1.5371385, -.4985314, -.969266, 1.8760108, .041556, .0556434, -.2040259, 1.0572252]);
        let i = new Float32Array([1, 1, 1]);
        let n = new Float32Array(3);
        let s = new Float32Array(3);
        let l = new Float32Array(3);
        let c = (24 / 116) ** 3 / 8;
        function h(e, t, a) {
          a[0] = e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
          a[1] = e[3] * t[0] + e[4] * t[1] + e[5] * t[2];
          a[2] = e[6] * t[0] + e[7] * t[1] + e[8] * t[2];
        }
        function u(e) {
          return e <= .0031308 ? d(0, 1, 12.92 * e) : e >= .99554525 ? 1 : d(0, 1, 1.055 * e ** (1 / 2.4) - .055);
        }
        function d(e, t, a) {
          return Math.max(e, Math.min(t, a));
        }
        function f(e) {
          return e < 0 ? -f(-e) : e > 8 ? ((e + 16) / 116) ** 3 : e * c;
        }
        function g(r, o, c, g, p, m) {
          let b = d(0, 1, o[c] * m);
          let y = d(0, 1, o[c + 1] * m);
          let w = d(0, 1, o[c + 2] * m);
          let x = 1 === b ? 1 : b ** r.GR;
          let S = 1 === y ? 1 : y ** r.GG;
          let k = 1 === w ? 1 : w ** r.GB;
          let A = r.MXA * x + r.MXB * S + r.MXC * k;
          let v = r.MYA * x + r.MYB * S + r.MYC * k;
          let C = r.MZA * x + r.MZB * S + r.MZC * k;
          s[0] = A;
          s[1] = v;
          s[2] = C;
          (function (a, r, i) {
            if (1 === a[0] && 1 === a[2]) {
              i[0] = r[0];
              i[1] = r[1];
              i[2] = r[2];
              return;
            }
            h(e, r, i);
            n[0] = 1 * i[0] / a[0];
            n[1] = 1 * i[1] / a[1];
            n[2] = 1 * i[2] / a[2];
            h(t, n, i);
          })(r.whitePoint, s, l);
          (function (e, t, a) {
            if (0 === e[0] && 0 === e[1] && 0 === e[2]) {
              a[0] = t[0];
              a[1] = t[1];
              a[2] = t[2];
              return;
            }
            let r = f(0);
            let i = f(e[0]);
            let n = f(e[1]);
            let s = f(e[2]);
            let o = (1 - r) / (1 - i);
            let l = (1 - r) / (1 - n);
            let c = (1 - r) / (1 - s);
            a[0] = t[0] * o + (1 - o);
            a[1] = t[1] * l + (1 - l);
            a[2] = t[2] * c + (1 - c);
          })(r.blackPoint, l, s);
          h(e, s, l);
          n[0] = .95047 * l[0] / i[0];
          n[1] = 1 * l[1] / i[1];
          n[2] = 1.08883 * l[2] / i[2];
          h(t, n, l);
          h(a, l, s);
          g[p] = 255 * u(s[0]);
          g[p + 1] = 255 * u(s[1]);
          g[p + 2] = 255 * u(s[2]);
        }
        return class extends o {
          constructor(e, t, a, i) {
            if (super("CalRGB", 3), !e) throw new r.FormatError("WhitePoint missing - required for color space CalRGB");
            t = t || new Float32Array(3);
            a = a || new Float32Array([1, 1, 1]);
            i = i || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
            let n = e[0];
            let s = e[1];
            let o = e[2];
            this.whitePoint = e;
            let l = t[0];
            let c = t[1];
            let h = t[2];
            if (this.blackPoint = t, this.GR = a[0], this.GG = a[1], this.GB = a[2], this.MXA = i[0], this.MYA = i[1], this.MZA = i[2], this.MXB = i[3], this.MYB = i[4], this.MZB = i[5], this.MXC = i[6], this.MYC = i[7], this.MZC = i[8], n < 0 || o < 0 || 1 !== s) throw new r.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
            (l < 0 || c < 0 || h < 0) && (r.info(`Invalid BlackPoint for ${this.name} [${l}, ${c}, ${h}], falling back to default.`), this.blackPoint = new Float32Array(3));
            (this.GR < 0 || this.GG < 0 || this.GB < 0) && (r.info(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`), this.GR = this.GG = this.GB = 1);
          }
          getRgbItem(e, t, a, r) {
            g(this, e, t, a, r, 1);
          }
          getRgbBuffer(e, t, a, r, i, n, s) {
            let o = 1 / ((1 << n) - 1);
            for (let n = 0; n < a; ++n) {
              g(this, e, t, r, i, o);
              t += 3;
              i += 3 + s;
            }
          }
          getOutputLength(e, t) {
            return e * (3 + t) / 3 | 0;
          }
        };
      }();
      let m = function () {
        function e(e) {
          return e >= 6 / 29 ? e ** 3 : 108 / 841 * (e - 4 / 29);
        }
        function t(t, a, r, i, n, s) {
          let o;
          let l;
          let c;
          let h = a[r];
          let u = a[r + 1];
          let d = a[r + 2];
          if (!1 !== i) {
            var f;
            var g;
            var p;
            var m;
            h = 0 + 100 * h / i;
            f = u;
            u = (g = t.amin) + f * (t.amax - g) / i;
            p = d;
            d = (m = t.bmin) + p * (t.bmax - m) / i;
          }
          u > t.amax ? u = t.amax : u < t.amin && (u = t.amin);
          d > t.bmax ? d = t.bmax : d < t.bmin && (d = t.bmin);
          let b = (h + 16) / 116;
          let y = b + u / 500;
          let w = b - d / 200;
          let x = t.XW * e(y);
          let S = t.YW * e(b);
          let k = t.ZW * e(w);
          t.ZW < 1 ? (o = 3.1339 * x + -1.617 * S + -.4906 * k, l = -.9785 * x + 1.916 * S + .0333 * k, c = .072 * x + -.229 * S + 1.4057 * k) : (o = 3.2406 * x + -1.5372 * S + -.4986 * k, l = -.9689 * x + 1.8758 * S + .0415 * k, c = .0557 * x + -.204 * S + 1.057 * k);
          n[s] = 255 * Math.sqrt(o);
          n[s + 1] = 255 * Math.sqrt(l);
          n[s + 2] = 255 * Math.sqrt(c);
        }
        return class extends o {
          constructor(e, t, a) {
            if (super("Lab", 3), !e) throw new r.FormatError("WhitePoint missing - required for color space Lab");
            if (t = t || [0, 0, 0], a = a || [-100, 100, -100, 100], this.XW = e[0], this.YW = e[1], this.ZW = e[2], this.amin = a[0], this.amax = a[1], this.bmin = a[2], this.bmax = a[3], this.XB = t[0], this.YB = t[1], this.ZB = t[2], this.XW < 0 || this.ZW < 0 || 1 !== this.YW) throw new r.FormatError("Invalid WhitePoint components, no fallback available");
            (this.XB < 0 || this.YB < 0 || this.ZB < 0) && (r.info("Invalid BlackPoint, falling back to default"), this.XB = this.YB = this.ZB = 0);
            (this.amin > this.amax || this.bmin > this.bmax) && (r.info("Invalid Range, falling back to defaults"), this.amin = -100, this.amax = 100, this.bmin = -100, this.bmax = 100);
          }
          getRgbItem(e, a, r, i) {
            t(this, e, a, !1, r, i);
          }
          getRgbBuffer(e, a, r, i, n, s, o) {
            let l = (1 << s) - 1;
            for (let s = 0; s < r; s++) {
              t(this, e, a, l, i, n);
              a += 3;
              n += 3 + o;
            }
          }
          getOutputLength(e, t) {
            return e * (3 + t) / 3 | 0;
          }
          isDefaultDecode(e, t) {
            return !0;
          }
          get usesZeroToOneRange() {
            return r.shadow(this, "usesZeroToOneRange", !1);
          }
        };
      }();
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.PartialEvaluator = t.EvaluatorPreprocessor = void 0;
      var r = a(2);
      var i = a(26);
      var n = a(5);
      var s = a(44);
      var o = a(18);
      var l = a(19);
      var c = a(47);
      var h = a(21);
      var u = a(56);
      var d = a(12);
      var f = a(48);
      var g = a(57);
      var p = a(27);
      var m = a(59);
      var b = a(10);
      var y = a(9);
      var w = a(60);
      var x = a(24);
      var S = a(29);
      var k = a(20);
      var A = a(8);
      var v = a(51);
      var C = a(61);
      var O = a(62);
      var F = a(63);
      let I = Object.freeze({
        maxImageSize: -1,
        disableFontFace: !1,
        ignoreErrors: !1,
        isEvalSupported: !0,
        fontExtraProperties: !1,
        useSystemFonts: !0,
        cMapUrl: null,
        standardFontDataUrl: null
      });
      let T = {
        TILING: 1,
        SHADING: 2
      };
      let M = Promise.resolve();
      class P {
        static get TIME_SLOT_DURATION_MS() {
          return r.shadow(this, "TIME_SLOT_DURATION_MS", 20);
        }
        static get CHECK_TIME_EVERY() {
          return r.shadow(this, "CHECK_TIME_EVERY", 100);
        }
        constructor() {
          this.reset();
        }
        check() {
          return !(++this.checked < P.CHECK_TIME_EVERY) && (this.checked = 0, this.endTime <= Date.now());
        }
        reset() {
          this.endTime = Date.now() + P.TIME_SLOT_DURATION_MS;
          this.checked = 0;
        }
      }
      class E {
        constructor({
          xref: e,
          handler: t,
          pageIndex: a,
          idFactory: r,
          fontCache: i,
          builtInCMapCache: n,
          standardFontDataCache: s,
          globalImageCache: o,
          options: l = null
        }) {
          this.xref = e;
          this.handler = t;
          this.pageIndex = a;
          this.idFactory = r;
          this.fontCache = i;
          this.builtInCMapCache = n;
          this.standardFontDataCache = s;
          this.globalImageCache = o;
          this.options = l || I;
          this.parsingType3Font = !1;
          this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
        }
        get _pdfFunctionFactory() {
          let e = new g.PDFFunctionFactory({
            xref: this.xref,
            isEvalSupported: this.options.isEvalSupported
          });
          return r.shadow(this, "_pdfFunctionFactory", e);
        }
        clone(e = null) {
          let t = Object.create(this);
          t.options = Object.assign(Object.create(null), this.options, e);
          return t;
        }
        hasBlendModes(e, t) {
          if (!(e instanceof n.Dict) || e.objId && t.has(e.objId)) return !1;
          let a = new n.RefSet(t);
          e.objId && a.put(e.objId);
          let i = [e];
          let s = this.xref;
          for (; i.length;) {
            let e = i.shift();
            let t = e.get("ExtGState");
            if (t instanceof n.Dict) for (let e of t.getRawValues()) {
              if (e instanceof n.Ref) {
                if (a.has(e)) continue;
                try {
                  e = s.fetch(e);
                } catch (t) {
                  a.put(e);
                  r.info(`hasBlendModes - ignoring ExtGState: "${t}".`);
                  continue;
                }
              }
              if (!(e instanceof n.Dict)) continue;
              e.objId && a.put(e.objId);
              let t = e.get("BM");
              if (t instanceof n.Name) {
                if ("Normal" !== t.name) return !0;
                continue;
              }
              if (void 0 !== t && Array.isArray(t)) {
                for (let e of t) if (e instanceof n.Name && "Normal" !== e.name) return !0;
              }
            }
            let o = e.get("XObject");
            if (o instanceof n.Dict) for (let e of o.getRawValues()) {
              if (e instanceof n.Ref) {
                if (a.has(e)) continue;
                try {
                  e = s.fetch(e);
                } catch (t) {
                  a.put(e);
                  r.info(`hasBlendModes - ignoring XObject: "${t}".`);
                  continue;
                }
              }
              if (!(e instanceof y.BaseStream)) continue;
              e.dict.objId && a.put(e.dict.objId);
              let t = e.dict.get("Resources");
              !(!(t instanceof n.Dict) || t.objId && a.has(t.objId)) && (i.push(t), t.objId && a.put(t.objId));
            }
          }
          a.forEach(e => {
            t.put(e);
          });
          return !1;
        }
        async fetchBuiltInCMap(e) {
          let t;
          let a = this.builtInCMapCache.get(e);
          if (a) return a;
          if (null !== this.options.cMapUrl) {
            let a = `${this.options.cMapUrl}${e}.bcmap`;
            let i = await fetch(a);
            if (!i.ok) throw Error(`fetchBuiltInCMap: failed to fetch file "${a}" with "${i.statusText}".`);
            t = {
              cMapData: new Uint8Array(await i.arrayBuffer()),
              compressionType: r.CMapCompressionType.BINARY
            };
          } else t = await this.handler.sendWithPromise("FetchBuiltInCMap", {
            name: e
          });
          t.compressionType !== r.CMapCompressionType.NONE && this.builtInCMapCache.set(e, t);
          return t;
        }
        async fetchStandardFontData(e) {
          let t;
          let a = this.standardFontDataCache.get(e);
          if (a) return new b.Stream(a);
          if (this.options.useSystemFonts && "Symbol" !== e && "ZapfDingbats" !== e) return null;
          let i = c.getFontNameToFileMap()[e];
          if (null !== this.options.standardFontDataUrl) {
            let e = `${this.options.standardFontDataUrl}${i}`;
            let a = await fetch(e);
            a.ok ? t = await a.arrayBuffer() : r.warn(`fetchStandardFontData: failed to fetch file "${e}" with "${a.statusText}".`);
          } else try {
            t = await this.handler.sendWithPromise("FetchStandardFontData", {
              filename: i
            });
          } catch (e) {
            r.warn(`fetchStandardFontData: failed to fetch file "${i}" with "${e}".`);
          }
          return t ? (this.standardFontDataCache.set(e, t), new b.Stream(t)) : null;
        }
        async buildFormXObject(e, t, a, i, s, o, l) {
          let c;
          let h;
          let u = t.dict;
          let d = u.getArray("Matrix");
          let f = u.getArray("BBox");
          f = Array.isArray(f) && 4 === f.length ? r.Util.normalizeRect(f) : null;
          u.has("OC") && (c = await this.parseMarkedContentProps(u.get("OC"), e));
          void 0 !== c && i.addOp(r.OPS.beginMarkedContentProps, ["OC", c]);
          let g = u.get("Group");
          if (g) {
            h = {
              matrix: d,
              bbox: f,
              smask: a,
              isolated: !1,
              knockout: !1
            };
            let t = g.get("S");
            let s = null;
            if (n.isName(t, "Transparency") && (h.isolated = g.get("I") || !1, h.knockout = g.get("K") || !1, g.has("CS"))) {
              let t = g.getRaw("CS");
              s = x.ColorSpace.getCached(t, this.xref, l) || (await this.parseColorSpace({
                cs: t,
                resources: e,
                localColorSpaceCache: l
              }));
            }
            a && a.backdrop && (s = s || x.ColorSpace.singletons.rgb, a.backdrop = s.getRgb(a.backdrop, 0));
            i.addOp(r.OPS.beginGroup, [h]);
          }
          let p = g ? [d, null] : [d, f];
          i.addOp(r.OPS.paintFormXObjectBegin, p);
          return this.getOperatorList({
            stream: t,
            task: s,
            resources: u.get("Resources") || e,
            operatorList: i,
            initialState: o
          }).then(function () {
            i.addOp(r.OPS.paintFormXObjectEnd, []);
            g && i.addOp(r.OPS.endGroup, [h]);
            void 0 !== c && i.addOp(r.OPS.endMarkedContent, []);
          });
        }
        _sendImgData(e, t, a = !1) {
          let r = t ? [t.data.buffer] : null;
          return this.parsingType3Font || a ? this.handler.send("commonobj", [e, "Image", t], r) : this.handler.send("obj", [e, this.pageIndex, "Image", t], r);
        }
        async buildPaintImageXObject({
          resources: e,
          image: t,
          isInline: a = !1,
          operatorList: i,
          cacheKey: n,
          localImageCache: s,
          localColorSpaceCache: o
        }) {
          let l;
          let c;
          let h;
          let u = t.dict;
          let d = u.objId;
          let f = u.get("W", "Width");
          let g = u.get("H", "Height");
          if (!(f && "number" == typeof f) || !(g && "number" == typeof g)) {
            r.warn("Image dimensions are missing, or not numbers.");
            return;
          }
          let p = this.options.maxImageSize;
          if (-1 !== p && f * g > p) {
            r.warn("Image exceeded maximum allowed size and was removed.");
            return;
          }
          u.has("OC") && (l = await this.parseMarkedContentProps(u.get("OC"), e));
          void 0 !== l && i.addOp(r.OPS.beginMarkedContentProps, ["OC", l]);
          let m = u.get("IM", "ImageMask") || !1;
          let b = u.get("I", "Interpolate");
          if (m) {
            let e = f + 7 >> 3;
            let a = t.getBytes(e * g, !0);
            let o = u.getArray("D", "Decode");
            (c = F.PDFImage.createMask({
              imgArray: a,
              width: f,
              height: g,
              imageIsFromDecodeStream: t instanceof S.DecodeStream,
              inverseDecode: !!o && o[0] > 0,
              interpolate: b
            })).cached = !!n;
            h = [c];
            i.addOp(r.OPS.paintImageMaskXObject, h);
            n && s.set(n, d, {
              fn: r.OPS.paintImageMaskXObject,
              args: h
            });
            void 0 !== l && i.addOp(r.OPS.endMarkedContent, []);
            return;
          }
          let y = u.get("SM", "SMask") || !1;
          let w = u.get("Mask") || !1;
          if (a && !y && !w && f + g < 200) {
            c = new F.PDFImage({
              xref: this.xref,
              res: e,
              image: t,
              isInline: a,
              pdfFunctionFactory: this._pdfFunctionFactory,
              localColorSpaceCache: o
            }).createImageData(!0);
            i.addOp(r.OPS.paintInlineImageXObject, [c]);
            void 0 !== l && i.addOp(r.OPS.endMarkedContent, []);
            return;
          }
          let x = `img_${this.idFactory.createObjId()}`;
          let k = !1;
          this.parsingType3Font ? x = `${this.idFactory.getDocId()}_type3_${x}` : d && (k = this.globalImageCache.shouldCache(d, this.pageIndex)) && (x = `${this.idFactory.getDocId()}_${x}`);
          i.addDependency(x);
          h = [x, f, g];
          F.PDFImage.buildImage({
            xref: this.xref,
            res: e,
            image: t,
            isInline: a,
            pdfFunctionFactory: this._pdfFunctionFactory,
            localColorSpaceCache: o
          }).then(e => (c = e.createImageData(!1), n && d && k && this.globalImageCache.addByteSize(d, c.data.length), this._sendImgData(x, c, k))).catch(e => (r.warn(`Unable to decode image "${x}": "${e}".`), this._sendImgData(x, null, k)));
          i.addOp(r.OPS.paintImageXObject, h);
          n && (s.set(n, d, {
            fn: r.OPS.paintImageXObject,
            args: h
          }), d && (r.assert(!a, "Cannot cache an inline image globally."), this.globalImageCache.addPageIndex(d, this.pageIndex), k && this.globalImageCache.setData(d, {
            objId: x,
            fn: r.OPS.paintImageXObject,
            args: h,
            byteSize: 0
          })));
          void 0 !== l && i.addOp(r.OPS.endMarkedContent, []);
        }
        handleSMask(e, t, a, r, i, n) {
          let s = e.get("G");
          let o = {
            subtype: e.get("S").name,
            backdrop: e.get("BC")
          };
          let l = e.get("TR");
          if (g.isPDFFunction(l)) {
            let e = this._pdfFunctionFactory.create(l);
            let t = new Uint8Array(256);
            let a = new Float32Array(1);
            for (let r = 0; r < 256; r++) {
              a[0] = r / 255;
              e(a, 0, a, 0);
              t[r] = 255 * a[0] | 0;
            }
            o.transferMap = t;
          }
          return this.buildFormXObject(t, s, o, a, r, i.state.clone(), n);
        }
        handleTransferFunction(e) {
          let t;
          if (Array.isArray(e)) t = e; else {
            if (!g.isPDFFunction(e)) return null;
            t = [e];
          }
          let a = [];
          let r = 0;
          let i = 0;
          for (let e of t) {
            let t = this.xref.fetchIfRef(e);
            if (r++, n.isName(t, "Identity")) {
              a.push(null);
              continue;
            }
            if (!g.isPDFFunction(t)) return null;
            let s = this._pdfFunctionFactory.create(t);
            let o = new Uint8Array(256);
            let l = new Float32Array(1);
            for (let e = 0; e < 256; e++) {
              l[0] = e / 255;
              s(l, 0, l, 0);
              o[e] = 255 * l[0] | 0;
            }
            a.push(o);
            i++;
          }
          return (1 === r || 4 === r) && 0 !== i ? a : null;
        }
        handleTilingType(e, t, a, i, s, o, l, c) {
          let h = new O.OperatorList();
          let d = n.Dict.merge({
            xref: this.xref,
            dictArray: [s.get("Resources"), a]
          });
          return this.getOperatorList({
            stream: i,
            task: l,
            resources: d,
            operatorList: h
          }).then(function () {
            let a = h.getIR();
            let r = u.getTilingPatternIR(a, s, t);
            o.addDependencies(h.dependencies);
            o.addOp(e, r);
            s.objId && c.set(null, s.objId, {
              operatorListIR: a,
              dict: s
            });
          }).catch(e => {
            if (!(e instanceof r.AbortException)) {
              if (this.options.ignoreErrors) {
                this.handler.send("UnsupportedFeature", {
                  featureId: r.UNSUPPORTED_FEATURES.errorTilingPattern
                });
                r.warn(`handleTilingType - ignoring pattern: "${e}".`);
                return;
              }
              throw e;
            }
          });
        }
        handleSetFont(e, t, a, i, o, l, c = null, h = null) {
          let u = t && t[0] instanceof n.Name ? t[0].name : null;
          return this.loadFont(u, a, e, c, h).then(t => t.font.isType3Font ? t.loadType3Data(this, e, o).then(function () {
            i.addDependencies(t.type3Dependencies);
            return t;
          }).catch(e => (this.handler.send("UnsupportedFeature", {
            featureId: r.UNSUPPORTED_FEATURES.errorFontLoadType3
          }), new N({
            loadedName: "g_font_error",
            font: new s.ErrorFont(`Type3 font load error: ${e}`),
            dict: t.font,
            evaluatorOptions: this.options
          }))) : t).then(e => (l.font = e.font, e.send(this.handler), e.loadedName));
        }
        handleText(e, t) {
          let a = t.font;
          let i = a.charsToGlyphs(e);
          a.data && (t.textRenderingMode & r.TextRenderingMode.ADD_TO_PATH_FLAG || "Pattern" === t.fillColorSpace.name || a.disableFontFace || this.options.disableFontFace) && E.buildFontPaths(a, i, this.handler, this.options);
          return i;
        }
        ensureStateFont(e) {
          if (e.font) return;
          let t = new r.FormatError("Missing setFont (Tf) operator before text rendering operator.");
          if (this.options.ignoreErrors) {
            this.handler.send("UnsupportedFeature", {
              featureId: r.UNSUPPORTED_FEATURES.errorFontState
            });
            r.warn(`ensureStateFont: "${t}".`);
            return;
          }
          throw t;
        }
        async setGState({
          resources: e,
          gState: t,
          operatorList: a,
          cacheKey: i,
          task: s,
          stateManager: o,
          localGStateCache: l,
          localColorSpaceCache: c
        }) {
          let h = t.objId;
          let u = !0;
          let d = [];
          let f = t.getKeys();
          let g = Promise.resolve();
          for (function () {
            let i = 0;
            let l = f.length;
          }(); i < l; i++) {
            let l = f[i];
            let h = t.get(l);
            switch (l) {
              case "Type":
                break;
              case "LW":
              case "LC":
              case "LJ":
              case "ML":
              case "D":
              case "RI":
              case "FL":
              case "CA":
              case "ca":
                d.push([l, h]);
                break;
              case "Font":
                u = !1;
                g = g.then(() => this.handleSetFont(e, null, h[0], a, s, o.state).then(function (e) {
                  a.addDependency(e);
                  d.push([l, [e, h[1]]]);
                }));
                break;
              case "BM":
                d.push([l, function e(t, a = !1) {
                  if (Array.isArray(t)) {
                    for (function () {
                      let a = 0;
                      let r = t.length;
                    }(); a < r; a++) {
                      let r = e(t[a], !0);
                      if (r) return r;
                    }
                    r.warn(`Unsupported blend mode Array: ${t}`);
                    return "source-over";
                  }
                  if (!(t instanceof n.Name)) return a ? null : "source-over";
                  switch (t.name) {
                    case "Normal":
                    case "Compatible":
                      return "source-over";
                    case "Multiply":
                      return "multiply";
                    case "Screen":
                      return "screen";
                    case "Overlay":
                      return "overlay";
                    case "Darken":
                      return "darken";
                    case "Lighten":
                      return "lighten";
                    case "ColorDodge":
                      return "color-dodge";
                    case "ColorBurn":
                      return "color-burn";
                    case "HardLight":
                      return "hard-light";
                    case "SoftLight":
                      return "soft-light";
                    case "Difference":
                      return "difference";
                    case "Exclusion":
                      return "exclusion";
                    case "Hue":
                      return "hue";
                    case "Saturation":
                      return "saturation";
                    case "Color":
                      return "color";
                    case "Luminosity":
                      return "luminosity";
                  }
                  return a ? null : (r.warn(`Unsupported blend mode: ${t.name}`), "source-over");
                }(h)]);
                break;
              case "SMask":
                if (n.isName(h, "None")) {
                  d.push([l, !1]);
                  break;
                }
                h instanceof n.Dict ? (u = !1, g = g.then(() => this.handleSMask(h, e, a, s, o, c)), d.push([l, !0])) : r.warn("Unsupported SMask type");
                break;
              case "TR":
                let p = this.handleTransferFunction(h);
                d.push([l, p]);
                break;
              case "OP":
              case "op":
              case "OPM":
              case "BG":
              case "BG2":
              case "UCR":
              case "UCR2":
              case "TR2":
              case "HT":
              case "SM":
              case "SA":
              case "AIS":
              case "TK":
                r.info("graphic state operator " + l);
                break;
              default:
                r.info("Unknown graphic state operator " + l);
            }
          }
          return g.then(function () {
            d.length > 0 && a.addOp(r.OPS.setGState, [d]);
            u && l.set(i, h, d);
          });
        }
        loadFont(e, t, a, i = null, l = null) {
          let c;
          let h;
          let u;
          let d = async () => new N({
            loadedName: "g_font_error",
            font: new s.ErrorFont(`Font "${e}" is not available.`),
            dict: t,
            evaluatorOptions: this.options
          });
          let f = this.xref;
          if (t) {
            if (!(t instanceof n.Ref)) throw new r.FormatError('The "font" object should be a reference.');
            c = t;
          } else {
            let t = a.get("Font");
            t && (c = t.getRaw(e));
          }
          if (!c) {
            let a = `Font "${e || t && t.toString()}" is not available`;
            if (!this.options.ignoreErrors && !this.parsingType3Font) {
              r.warn(`${a}.`);
              return d();
            }
            this.handler.send("UnsupportedFeature", {
              featureId: r.UNSUPPORTED_FEATURES.errorFontMissing
            });
            r.warn(`${a} -- attempting to fallback to a default font.`);
            c = i || E.fallbackFontDict;
          }
          if (this.parsingType3Font && this.type3FontRefs.has(c)) return d();
          if (this.fontCache.has(c)) return this.fontCache.get(c);
          if (!((t = f.fetchIfRef(c)) instanceof n.Dict)) return d();
          if (t.cacheKey && this.fontCache.has(t.cacheKey)) return this.fontCache.get(t.cacheKey);
          let g = r.createPromiseCapability();
          try {
            (h = this.preEvaluateFont(t)).cssFontInfo = l;
          } catch (e) {
            r.warn(`loadFont - preEvaluateFont failed: "${e}".`);
            return d();
          }
          let {
            descriptor,
            hash
          } = h;
          let b = c instanceof n.Ref;
          if (b && (u = `f${c.toString()}`), hash && descriptor instanceof n.Dict) {
            descriptor.fontAliases || (descriptor.fontAliases = Object.create(null));
            let e = descriptor.fontAliases;
            if (e[hash]) {
              let t = e[hash].aliasRef;
              if (b && t && this.fontCache.has(t)) {
                this.fontCache.putAlias(c, t);
                return this.fontCache.get(c);
              }
            } else e[hash] = {
              fontID: this.idFactory.createFontId()
            };
            b && (e[hash].aliasRef = c);
            u = e[hash].fontID;
          }
          b ? this.fontCache.put(c, g.promise) : (u || (u = this.idFactory.createFontId()), t.cacheKey = `cacheKey_${u}`, this.fontCache.put(t.cacheKey, g.promise));
          r.assert(u && u.startsWith("f"), 'The "fontID" must be (correctly) defined.');
          t.loadedName = `${this.idFactory.getDocId()}_${u}`;
          this.translateFont(h).then(e => {
            void 0 !== e.fontType && f.stats.addFontType(e.fontType);
            g.resolve(new N({
              loadedName: t.loadedName,
              font: e,
              dict: t,
              evaluatorOptions: this.options
            }));
          }).catch(e => {
            this.handler.send("UnsupportedFeature", {
              featureId: r.UNSUPPORTED_FEATURES.errorFontTranslate
            });
            r.warn(`loadFont - translateFont failed: "${e}".`);
            try {
              let e = descriptor && descriptor.get("FontFile3");
              let t = e && e.get("Subtype");
              let a = o.getFontType(h.type, t && t.name);
              void 0 !== a && f.stats.addFontType(a);
            } catch (e) { }
            g.resolve(new N({
              loadedName: t.loadedName,
              font: new s.ErrorFont(e instanceof Error ? e.message : e),
              dict: t,
              evaluatorOptions: this.options
            }));
          });
          return g.promise;
        }
        buildPath(e, t, a, i = !1) {
          let n = e.length - 1;
          if (a || (a = []), n < 0 || e.fnArray[n] !== r.OPS.constructPath) {
            i && (r.warn(`Encountered path operator "${t}" inside of a text object.`), e.addOp(r.OPS.save, null));
            e.addOp(r.OPS.constructPath, [[t], a]);
            i && e.addOp(r.OPS.restore, null);
          } else {
            let r = e.argsArray[n];
            r[0].push(t);
            Array.prototype.push.apply(r[1], a);
          }
        }
        parseColorSpace({
          cs: e,
          resources: t,
          localColorSpaceCache: a
        }) {
          return x.ColorSpace.parseAsync({
            cs: e,
            xref: this.xref,
            resources: t,
            pdfFunctionFactory: this._pdfFunctionFactory,
            localColorSpaceCache: a
          }).catch(e => {
            if (e instanceof r.AbortException) return null;
            if (this.options.ignoreErrors) {
              this.handler.send("UnsupportedFeature", {
                featureId: r.UNSUPPORTED_FEATURES.errorColorSpace
              });
              r.warn(`parseColorSpace - ignoring ColorSpace: "${e}".`);
              return null;
            }
            throw e;
          });
        }
        parseShading({
          shading: e,
          resources: t,
          localColorSpaceCache: a,
          localShadingPatternCache: r
        }) {
          let i = r.get(e);
          if (!i) {
            let n = u.Pattern.parseShading(e, this.xref, t, this.handler, this._pdfFunctionFactory, a).getIR();
            i = `pattern_${this.idFactory.createObjId()}`;
            r.set(e, i);
            this.handler.send("obj", [i, this.pageIndex, "Pattern", n]);
          }
          return i;
        }
        handleColorN(e, t, a, i, s, o, l, c, h, d) {
          let f = a.pop();
          if (f instanceof n.Name) {
            let g = s.getRaw(f.name);
            let p = g instanceof n.Ref && h.getByRef(g);
            if (p) try {
              let r = i.base ? i.base.getRgb(a, 0) : null;
              let n = u.getTilingPatternIR(p.operatorListIR, p.dict, r);
              e.addOp(t, n);
              return;
            } catch (e) { }
            let m = this.xref.fetchIfRef(g);
            if (m) {
              let n = m instanceof y.BaseStream ? m.dict : m;
              let s = n.get("PatternType");
              if (s === T.TILING) {
                let r = i.base ? i.base.getRgb(a, 0) : null;
                return this.handleTilingType(t, r, o, m, n, e, l, h);
              }
              if (s === T.SHADING) {
                let a = n.get("Shading");
                let r = n.getArray("Matrix");
                let i = this.parseShading({
                  shading: a,
                  resources: o,
                  localColorSpaceCache: c,
                  localShadingPatternCache: d
                });
                e.addOp(t, ["Shading", i, r]);
                return;
              }
              throw new r.FormatError(`Unknown PatternType: ${s}`);
            }
          }
          throw new r.FormatError(`Unknown PatternName: ${f}`);
        }
        _parseVisibilityExpression(e, t, a) {
          if (++t > 10) {
            r.warn("Visibility expression is too deeply nested");
            return;
          }
          let i = e.length;
          let s = this.xref.fetchIfRef(e[0]);
          if (i < 2 || !(s instanceof n.Name)) {
            r.warn("Invalid visibility expression");
            return;
          }
          switch (s.name) {
            case "And":
            case "Or":
            case "Not":
              a.push(s.name);
              break;
            default:
              r.warn(`Invalid operator ${s.name} in visibility expression`);
              return;
          }
          for (let r = 1; r < i; r++) {
            let i = e[r];
            let s = this.xref.fetchIfRef(i);
            if (Array.isArray(s)) {
              let e = [];
              a.push(e);
              this._parseVisibilityExpression(s, t, e);
            } else i instanceof n.Ref && a.push(i.toString());
          }
        }
        async parseMarkedContentProps(e, t) {
          let a;
          if (e instanceof n.Name) a = t.get("Properties").get(e.name); else if (e instanceof n.Dict) a = e; else throw new r.FormatError("Optional content properties malformed.");
          let i = a.get("Type").name;
          if ("OCG" === i) return {
            type: i,
            id: a.objId
          };
          if ("OCMD" === i) {
            let e = a.get("VE");
            if (Array.isArray(e)) {
              let t = [];
              if (this._parseVisibilityExpression(e, 0, t), t.length > 0) return {
                type: "OCMD",
                expression: t
              };
            }
            let t = a.get("OCGs");
            if (Array.isArray(t) || t instanceof n.Dict) {
              let e = [];
              if (Array.isArray(t)) for (let a of t) e.push(a.toString()); else e.push(t.objId);
              return {
                type: i,
                ids: e,
                policy: a.get("P") instanceof n.Name ? a.get("P").name : null,
                expression: null
              };
            }
            if (t instanceof n.Ref) return {
              type: i,
              id: t.toString()
            };
          }
          return null;
        }
        getOperatorList({
          stream: e,
          task: t,
          resources: a,
          operatorList: i,
          initialState: s = null,
          fallbackFontDict: o = null
        }) {
          if (a = a || n.Dict.empty, s = s || new L(), !i) throw Error('getOperatorList: missing "operatorList" parameter');
          let l = this;
          let c = this.xref;
          let h = !1;
          let u = new m.LocalImageCache();
          let d = new m.LocalColorSpaceCache();
          let f = new m.LocalGStateCache();
          let g = new m.LocalTilingPatternCache();
          let p = new Map();
          let b = a.get("XObject") || n.Dict.empty;
          let w = a.get("Pattern") || n.Dict.empty;
          let S = new B(s);
          let k = new R(e, c, S);
          let A = new P();
          function v(e) {
            for (function () {
              let e = 0;
              let t = k.savedStatesDepth;
            }(); e < t; e++) i.addOp(r.OPS.restore, []);
          }
          return new Promise(function e(s, m) {
            let C;
            let O;
            let F;
            let I;
            let T;
            let P;
            let E = function (t) {
              Promise.all([t, i.ready]).then(function () {
                try {
                  e(s, m);
                } catch (e) {
                  m(e);
                }
              }, m);
            };
            t.ensureNotTerminated();
            A.reset();
            let N = {};
            for (; !(C = A.check()) && (N.args = null, k.read(N));) {
              let e = N.args;
              let s = N.fn;
              switch (0 | s) {
                case r.OPS.paintXObject:
                  if (P = e[0] instanceof n.Name, T = e[0].name, P) {
                    let t = u.getByName(T);
                    if (t) {
                      i.addOp(t.fn, t.args);
                      e = null;
                      continue;
                    }
                  }
                  E(new Promise(function (e, s) {
                    if (!P) throw new r.FormatError("XObject must be referred to by name.");
                    let o = b.getRaw(T);
                    if (o instanceof n.Ref) {
                      let t = u.getByRef(o);
                      if (t) {
                        i.addOp(t.fn, t.args);
                        e();
                        return;
                      }
                      let a = l.globalImageCache.getData(o, l.pageIndex);
                      if (a) {
                        i.addDependency(a.objId);
                        i.addOp(a.fn, a.args);
                        e();
                        return;
                      }
                      o = c.fetch(o);
                    }
                    if (!(o instanceof y.BaseStream)) throw new r.FormatError("XObject should be a stream");
                    let h = o.dict.get("Subtype");
                    if (!(h instanceof n.Name)) throw new r.FormatError("XObject should have a Name subtype");
                    if ("Form" === h.name) {
                      S.save();
                      l.buildFormXObject(a, o, null, i, t, S.state.clone(), d).then(function () {
                        S.restore();
                        e();
                      }, s);
                      return;
                    }
                    if ("Image" === h.name) {
                      l.buildPaintImageXObject({
                        resources: a,
                        image: o,
                        operatorList: i,
                        cacheKey: T,
                        localImageCache: u,
                        localColorSpaceCache: d
                      }).then(e, s);
                      return;
                    }
                    if ("PS" === h.name) r.info("Ignored XObject subtype PS"); else throw new r.FormatError(`Unhandled XObject subtype ${h.name}`);
                    e();
                  }).catch(function (e) {
                    if (!(e instanceof r.AbortException)) {
                      if (l.options.ignoreErrors) {
                        l.handler.send("UnsupportedFeature", {
                          featureId: r.UNSUPPORTED_FEATURES.errorXObject
                        });
                        r.warn(`getOperatorList - ignoring XObject: "${e}".`);
                        return;
                      }
                      throw e;
                    }
                  }));
                  return;
                case r.OPS.setFont:
                  var B = e[1];
                  E(l.handleSetFont(a, e, null, i, t, S.state, o).then(function (e) {
                    i.addDependency(e);
                    i.addOp(r.OPS.setFont, [e, B]);
                  }));
                  return;
                case r.OPS.beginText:
                  h = !0;
                  break;
                case r.OPS.endText:
                  h = !1;
                  break;
                case r.OPS.endInlineImage:
                  var D = e[0].cacheKey;
                  if (D) {
                    let t = u.getByName(D);
                    if (t) {
                      i.addOp(t.fn, t.args);
                      e = null;
                      continue;
                    }
                  }
                  E(l.buildPaintImageXObject({
                    resources: a,
                    image: e[0],
                    isInline: !0,
                    operatorList: i,
                    cacheKey: D,
                    localImageCache: u,
                    localColorSpaceCache: d
                  }));
                  return;
                case r.OPS.showText:
                  if (!S.state.font) {
                    l.ensureStateFont(S.state);
                    continue;
                  }
                  e[0] = l.handleText(e[0], S.state);
                  break;
                case r.OPS.showSpacedText:
                  if (!S.state.font) {
                    l.ensureStateFont(S.state);
                    continue;
                  }
                  var L = e[0];
                  var R = [];
                  var $ = L.length;
                  var j = S.state;
                  for (O = 0; O < $; ++O) {
                    let e = L[O];
                    "string" == typeof e ? Array.prototype.push.apply(R, l.handleText(e, j)) : "number" == typeof e && R.push(e);
                  }
                  e[0] = R;
                  s = r.OPS.showText;
                  break;
                case r.OPS.nextLineShowText:
                  if (!S.state.font) {
                    l.ensureStateFont(S.state);
                    continue;
                  }
                  i.addOp(r.OPS.nextLine);
                  e[0] = l.handleText(e[0], S.state);
                  s = r.OPS.showText;
                  break;
                case r.OPS.nextLineSetSpacingShowText:
                  if (!S.state.font) {
                    l.ensureStateFont(S.state);
                    continue;
                  }
                  i.addOp(r.OPS.nextLine);
                  i.addOp(r.OPS.setWordSpacing, [e.shift()]);
                  i.addOp(r.OPS.setCharSpacing, [e.shift()]);
                  e[0] = l.handleText(e[0], S.state);
                  s = r.OPS.showText;
                  break;
                case r.OPS.setTextRenderingMode:
                  S.state.textRenderingMode = e[0];
                  break;
                case r.OPS.setFillColorSpace:
                  {
                    let t = x.ColorSpace.getCached(e[0], c, d);
                    if (t) {
                      S.state.fillColorSpace = t;
                      continue;
                    }
                    E(l.parseColorSpace({
                      cs: e[0],
                      resources: a,
                      localColorSpaceCache: d
                    }).then(function (e) {
                      e && (S.state.fillColorSpace = e);
                    }));
                    return;
                  }
                case r.OPS.setStrokeColorSpace:
                  {
                    let t = x.ColorSpace.getCached(e[0], c, d);
                    if (t) {
                      S.state.strokeColorSpace = t;
                      continue;
                    }
                    E(l.parseColorSpace({
                      cs: e[0],
                      resources: a,
                      localColorSpaceCache: d
                    }).then(function (e) {
                      e && (S.state.strokeColorSpace = e);
                    }));
                    return;
                  }
                case r.OPS.setFillColor:
                  e = (I = S.state.fillColorSpace).getRgb(e, 0);
                  s = r.OPS.setFillRGBColor;
                  break;
                case r.OPS.setStrokeColor:
                  e = (I = S.state.strokeColorSpace).getRgb(e, 0);
                  s = r.OPS.setStrokeRGBColor;
                  break;
                case r.OPS.setFillGray:
                  S.state.fillColorSpace = x.ColorSpace.singletons.gray;
                  e = x.ColorSpace.singletons.gray.getRgb(e, 0);
                  s = r.OPS.setFillRGBColor;
                  break;
                case r.OPS.setStrokeGray:
                  S.state.strokeColorSpace = x.ColorSpace.singletons.gray;
                  e = x.ColorSpace.singletons.gray.getRgb(e, 0);
                  s = r.OPS.setStrokeRGBColor;
                  break;
                case r.OPS.setFillCMYKColor:
                  S.state.fillColorSpace = x.ColorSpace.singletons.cmyk;
                  e = x.ColorSpace.singletons.cmyk.getRgb(e, 0);
                  s = r.OPS.setFillRGBColor;
                  break;
                case r.OPS.setStrokeCMYKColor:
                  S.state.strokeColorSpace = x.ColorSpace.singletons.cmyk;
                  e = x.ColorSpace.singletons.cmyk.getRgb(e, 0);
                  s = r.OPS.setStrokeRGBColor;
                  break;
                case r.OPS.setFillRGBColor:
                  S.state.fillColorSpace = x.ColorSpace.singletons.rgb;
                  e = x.ColorSpace.singletons.rgb.getRgb(e, 0);
                  break;
                case r.OPS.setStrokeRGBColor:
                  S.state.strokeColorSpace = x.ColorSpace.singletons.rgb;
                  e = x.ColorSpace.singletons.rgb.getRgb(e, 0);
                  break;
                case r.OPS.setFillColorN:
                  if ("Pattern" === (I = S.state.fillColorSpace).name) {
                    E(l.handleColorN(i, r.OPS.setFillColorN, e, I, w, a, t, d, g, p));
                    return;
                  }
                  e = I.getRgb(e, 0);
                  s = r.OPS.setFillRGBColor;
                  break;
                case r.OPS.setStrokeColorN:
                  if ("Pattern" === (I = S.state.strokeColorSpace).name) {
                    E(l.handleColorN(i, r.OPS.setStrokeColorN, e, I, w, a, t, d, g, p));
                    return;
                  }
                  e = I.getRgb(e, 0);
                  s = r.OPS.setStrokeRGBColor;
                  break;
                case r.OPS.shadingFill:
                  var _ = a.get("Shading");
                  if (!_) throw new r.FormatError("No shading resource found");
                  var U = _.get(e[0].name);
                  if (!U) throw new r.FormatError("No shading object found");
                  e = [l.parseShading({
                    shading: U,
                    resources: a,
                    localColorSpaceCache: d,
                    localShadingPatternCache: p
                  })];
                  s = r.OPS.shadingFill;
                  break;
                case r.OPS.setGState:
                  if (P = e[0] instanceof n.Name, T = e[0].name, P) {
                    let t = f.getByName(T);
                    if (t) {
                      t.length > 0 && i.addOp(r.OPS.setGState, [t]);
                      e = null;
                      continue;
                    }
                  }
                  E(new Promise(function (e, s) {
                    if (!P) throw new r.FormatError("GState must be referred to by name.");
                    let o = a.get("ExtGState");
                    if (!(o instanceof n.Dict)) throw new r.FormatError("ExtGState should be a dictionary.");
                    let c = o.get(T);
                    if (!(c instanceof n.Dict)) throw new r.FormatError("GState should be a dictionary.");
                    l.setGState({
                      resources: a,
                      gState: c,
                      operatorList: i,
                      cacheKey: T,
                      task: t,
                      stateManager: S,
                      localGStateCache: f,
                      localColorSpaceCache: d
                    }).then(e, s);
                  }).catch(function (e) {
                    if (!(e instanceof r.AbortException)) {
                      if (l.options.ignoreErrors) {
                        l.handler.send("UnsupportedFeature", {
                          featureId: r.UNSUPPORTED_FEATURES.errorExtGState
                        });
                        r.warn(`getOperatorList - ignoring ExtGState: "${e}".`);
                        return;
                      }
                      throw e;
                    }
                  }));
                  return;
                case r.OPS.moveTo:
                case r.OPS.lineTo:
                case r.OPS.curveTo:
                case r.OPS.curveTo2:
                case r.OPS.curveTo3:
                case r.OPS.closePath:
                case r.OPS.rectangle:
                  l.buildPath(i, s, e, h);
                  continue;
                case r.OPS.markPoint:
                case r.OPS.markPointProps:
                case r.OPS.beginCompat:
                case r.OPS.endCompat:
                  continue;
                case r.OPS.beginMarkedContentProps:
                  if (!(e[0] instanceof n.Name)) {
                    r.warn(`Expected name for beginMarkedContentProps arg0=${e[0]}`);
                    continue;
                  }
                  if ("OC" === e[0].name) {
                    E(l.parseMarkedContentProps(e[1], a).then(e => {
                      i.addOp(r.OPS.beginMarkedContentProps, ["OC", e]);
                    }).catch(e => {
                      if (!(e instanceof r.AbortException)) {
                        if (l.options.ignoreErrors) {
                          l.handler.send("UnsupportedFeature", {
                            featureId: r.UNSUPPORTED_FEATURES.errorMarkedContent
                          });
                          r.warn(`getOperatorList - ignoring beginMarkedContentProps: "${e}".`);
                          return;
                        }
                        throw e;
                      }
                    }));
                    return;
                  }
                  e = [e[0].name, e[1] instanceof n.Dict ? e[1].get("MCID") : null];
                  break;
                case r.OPS.beginMarkedContent:
                case r.OPS.endMarkedContent:
                default:
                  if (null !== e) {
                    for (O = 0, F = e.length; O < F && !(e[O] instanceof n.Dict); O++);
                    if (O < F) {
                      r.warn("getOperatorList - ignoring operator: " + s);
                      continue;
                    }
                  }
              }
              i.addOp(s, e);
            }
            if (C) {
              E(M);
              return;
            }
            v();
            s();
          }).catch(e => {
            if (!(e instanceof r.AbortException)) {
              if (this.options.ignoreErrors) {
                this.handler.send("UnsupportedFeature", {
                  featureId: r.UNSUPPORTED_FEATURES.errorOperatorList
                });
                r.warn(`getOperatorList - ignoring errors during "${t.name}" task: "${e}".`);
                v();
                return;
              }
              throw e;
            }
          });
        }
        getTextContent({
          stream: e,
          task: t,
          resources: a,
          stateManager: i = null,
          combineTextItems: s = !1,
          includeMarkedContent: o = !1,
          sink: l,
          seenStyles: c = new Set(),
          viewBox: u
        }) {
          let d;
          a = a || n.Dict.empty;
          i = i || new B(new D());
          let f = h.getNormalizedUnicodes();
          let g = {
            items: [],
            styles: Object.create(null)
          };
          let p = {
            initialized: !1,
            str: [],
            totalWidth: 0,
            totalHeight: 0,
            width: 0,
            height: 0,
            vertical: !1,
            prevTransform: null,
            textAdvanceScale: 0,
            spaceInFlowMin: 0,
            spaceInFlowMax: 0,
            trackingSpaceMin: 1 / 0,
            negativeSpaceMax: -1 / 0,
            transform: null,
            fontName: null,
            hasEOL: !1
          };
          let b = this;
          let x = this.xref;
          let S = [];
          let k = null;
          let A = new m.LocalImageCache();
          let v = new m.LocalGStateCache();
          let C = new R(e, x, i);
          function O() {
            let e = d.font;
            let t = [d.fontSize * d.textHScale, 0, 0, d.fontSize, 0, d.textRise];
            if (e.isType3Font && (d.fontSize <= 1 || e.isCharBBox) && !r.isArrayEqual(d.fontMatrix, r.FONT_IDENTITY_MATRIX)) {
              let a = e.bbox[3] - e.bbox[1];
              a > 0 && (t[3] *= a * d.fontMatrix[3]);
            }
            return r.Util.transform(d.ctm, r.Util.transform(d.textMatrix, t));
          }
          function F(e, i) {
            return b.loadFont(e, i, a).then(function (e) {
              return e.font.isType3Font ? e.loadType3Data(b, a, t).catch(function () { }).then(function () {
                return e;
              }) : e;
            }).then(function (e) {
              d.font = e.font;
              d.fontMatrix = e.font.fontMatrix || r.FONT_IDENTITY_MATRIX;
            });
          }
          function I(e, t, a) {
            let r = Math.hypot(a[0], a[1]);
            return [(a[0] * e + a[1] * t) / r, (a[2] * e + a[3] * t) / r];
          }
          function T({
            chars: e,
            extraSpacing: t
          }) {
            let a = d.font;
            if (!e) {
              let e = d.charSpacing + t;
              e && (a.vertical ? d.translateTextMatrix(0, -e) : d.translateTextMatrix(e * d.textHScale, 0));
              return;
            }
            let r = a.charsToGlyphs(e);
            let i = d.fontMatrix[0] * d.fontSize;
            for (function () {
              let e = 0;
              let n = r.length;
            }(); e < n; e++) {
              let o = r[e];
              if (o.isInvisibleFormatMark) continue;
              let l = d.charSpacing + (e + 1 === n ? t : 0);
              let m = o.width;
              a.vertical && (m = o.vmetric ? o.vmetric[0] : -m);
              let b = m * i;
              if (o.isWhitespace && (0 === e || e + 1 === n || r[e - 1].isWhitespace || r[e + 1].isWhitespace || t)) {
                a.vertical ? (l += -b + d.wordSpacing, d.translateTextMatrix(0, -l)) : (l += b + d.wordSpacing, d.translateTextMatrix(l * d.textHScale, 0));
                continue;
              }
              if (!function () {
                let e = O();
                let t = e[4];
                let a = e[5];
                let r = t - u[0];
                let i = a - u[1];
                if (r < 0 || r > u[2] || i < 0 || i > u[3]) return !1;
                if (!s || !d.font || !p.prevTransform) return !0;
                let n = p.prevTransform[4];
                let o = p.prevTransform[5];
                if (n === t && o === a) return !0;
                let l = -1;
                switch (e[0] && 0 === e[1] && 0 === e[2] ? l = e[0] > 0 ? 0 : 180 : e[1] && 0 === e[0] && 0 === e[3] && (l = e[1] > 0 ? 90 : 270), l) {
                  case 0:
                    break;
                  case 90:
                    [t, a] = [a, t];
                    [n, o] = [o, n];
                    break;
                  case 180:
                    [t, a, n, o] = [-t, -a, -n, -o];
                    break;
                  case 270:
                    [t, a] = [-a, -t];
                    [n, o] = [-o, -n];
                    break;
                  default:
                    [t, a] = I(t, a, e);
                    [n, o] = I(n, o, p.prevTransform);
                }
                if (d.font.vertical) {
                  let e = (o - a) / p.textAdvanceScale;
                  let r = t - n;
                  let i = Math.sign(p.height);
                  e < i * p.negativeSpaceMax ? Math.abs(r) > .5 * p.width ? E() : L() : Math.abs(r) > p.width ? E() : e <= i * p.trackingSpaceMin ? p.height += e : N(e, p.prevTransform, i) || (0 === p.str.length ? g.items.push({
                    str: " ",
                    dir: "ltr",
                    width: 0,
                    height: Math.abs(e),
                    transform: p.prevTransform,
                    fontName: p.fontName,
                    hasEOL: !1
                  }) : p.height += e);
                  return !0;
                }
                let c = (t - n) / p.textAdvanceScale;
                let h = a - o;
                let f = Math.sign(p.width);
                c < f * p.negativeSpaceMax ? Math.abs(h) > .5 * p.height ? E() : L() : Math.abs(h) > p.height ? E() : c <= f * p.trackingSpaceMin ? p.width += c : N(c, p.prevTransform, f) || (0 === p.str.length ? g.items.push({
                  str: " ",
                  dir: "ltr",
                  width: Math.abs(c),
                  height: 0,
                  transform: p.prevTransform,
                  fontName: p.fontName,
                  hasEOL: !1
                }) : p.width += c);
                return !0;
              }()) continue;
              let y = function () {
                if (p.initialized) return p;
                let e = d.font;
                let t = e.loadedName;
                c.has(t) || (c.add(t), g.styles[t] = {
                  fontFamily: e.fallbackName,
                  ascent: e.ascent,
                  descent: e.descent,
                  vertical: e.vertical
                });
                p.fontName = t;
                let a = p.transform = O();
                e.vertical ? (p.width = p.totalWidth = Math.hypot(a[0], a[1]), p.height = p.totalHeight = 0, p.vertical = !0) : (p.width = p.totalWidth = 0, p.height = p.totalHeight = Math.hypot(a[2], a[3]), p.vertical = !1);
                let r = Math.hypot(d.textLineMatrix[0], d.textLineMatrix[1]);
                let i = Math.hypot(d.ctm[0], d.ctm[1]);
                p.textAdvanceScale = i * r;
                p.trackingSpaceMin = .1 * d.fontSize;
                p.negativeSpaceMax = -.2 * d.fontSize;
                p.spaceInFlowMin = .1 * d.fontSize;
                p.spaceInFlowMax = .6 * d.fontSize;
                p.hasEOL = !1;
                p.initialized = !0;
                return p;
              }();
              if (o.isZeroWidthDiacritic && (b = 0), a.vertical ? (d.translateTextMatrix(0, b), b = Math.abs(b), y.height += b) : (b *= d.textHScale, d.translateTextMatrix(b, 0), y.width += b), b && (y.prevTransform = O()), o.isWhitespace) y.str.push(" "); else {
                let e = o.unicode;
                e = f[e] || e;
                e = h.reverseIfRtl(e);
                y.str.push(e);
              }
              l && (a.vertical ? d.translateTextMatrix(0, -l) : d.translateTextMatrix(l * d.textHScale, 0));
            }
          }
          function E() {
            p.initialized ? (p.hasEOL = !0, L()) : g.items.push({
              str: "",
              dir: "ltr",
              width: 0,
              height: 0,
              transform: O(),
              fontName: d.font.loadedName,
              hasEOL: !0
            });
          }
          function N(e, t, a) {
            if (a * p.spaceInFlowMin <= e && e <= a * p.spaceInFlowMax) {
              p.initialized && p.str.push(" ");
              return !1;
            }
            let r = p.fontName;
            let i = 0;
            p.vertical && (i = e, e = 0);
            L();
            g.items.push({
              str: " ",
              dir: "ltr",
              width: Math.abs(e),
              height: Math.abs(i),
              transform: t || O(),
              fontName: r,
              hasEOL: !1
            });
            return !0;
          }
          function L() {
            p.initialized && p.str && (p.vertical ? p.totalHeight += p.height * p.textAdvanceScale : p.totalWidth += p.width * p.textAdvanceScale, g.items.push(function (e) {
              let t = e.str.join("");
              let a = w.bidi(t, -1, e.vertical);
              return {
                str: a.str,
                dir: a.dir,
                width: Math.abs(e.totalWidth),
                height: Math.abs(e.totalHeight),
                transform: e.transform,
                fontName: e.fontName,
                hasEOL: e.hasEOL
              };
            }(p)), p.initialized = !1, p.str.length = 0);
          }
          function $(e = !1) {
            let t = g.items.length;
            0 === t || e && t < 10 || (l.enqueue(g, t), g.items = [], g.styles = Object.create(null));
          }
          let j = new P();
          return new Promise(function e(h, f) {
            let m = function (t) {
              $(!0);
              Promise.all([t, l.ready]).then(function () {
                try {
                  e(h, f);
                } catch (e) {
                  f(e);
                }
              }, f);
            };
            t.ensureNotTerminated();
            j.reset();
            let w = {};
            let O;
            let I = [];
            for (; !(O = j.check()) && (I.length = 0, w.args = I, C.read(w));) {
              d = i.state;
              let e = w.fn;
              switch (I = w.args, 0 | e) {
                case r.OPS.setFont:
                  var P = I[0].name;
                  var E = I[1];
                  if (d.font && P === d.fontName && E === d.fontSize) break;
                  L();
                  d.fontName = P;
                  d.fontSize = E;
                  m(F(P, null));
                  return;
                case r.OPS.setTextRise:
                  d.textRise = I[0];
                  break;
                case r.OPS.setHScale:
                  d.textHScale = I[0] / 100;
                  break;
                case r.OPS.setLeading:
                  d.leading = I[0];
                  break;
                case r.OPS.moveText:
                  d.translateTextLineMatrix(I[0], I[1]);
                  d.textMatrix = d.textLineMatrix.slice();
                  break;
                case r.OPS.setLeadingMoveText:
                  d.leading = -I[1];
                  d.translateTextLineMatrix(I[0], I[1]);
                  d.textMatrix = d.textLineMatrix.slice();
                  break;
                case r.OPS.nextLine:
                  d.carriageReturn();
                  break;
                case r.OPS.setTextMatrix:
                  d.setTextMatrix(I[0], I[1], I[2], I[3], I[4], I[5]);
                  d.setTextLineMatrix(I[0], I[1], I[2], I[3], I[4], I[5]);
                  (function () {
                    if (!p.initialized) return;
                    let e = Math.hypot(d.textLineMatrix[0], d.textLineMatrix[1]);
                    let t = Math.hypot(d.ctm[0], d.ctm[1]) * e;
                    t !== p.textAdvanceScale && (p.vertical ? (p.totalHeight += p.height * p.textAdvanceScale, p.height = 0) : (p.totalWidth += p.width * p.textAdvanceScale, p.width = 0), p.textAdvanceScale = t);
                  })();
                  break;
                case r.OPS.setCharSpacing:
                  d.charSpacing = I[0];
                  break;
                case r.OPS.setWordSpacing:
                  d.wordSpacing = I[0];
                  break;
                case r.OPS.beginText:
                  d.textMatrix = r.IDENTITY_MATRIX.slice();
                  d.textLineMatrix = r.IDENTITY_MATRIX.slice();
                  break;
                case r.OPS.showSpacedText:
                  if (!i.state.font) {
                    b.ensureStateFont(i.state);
                    continue;
                  }
                  let h = (d.font.vertical ? 1 : -1) * d.fontSize / 1e3;
                  let f = I[0];
                  for (function () {
                    let e = 0;
                    let t = f.length;
                  }(); e < t - 1; e++) {
                    let t = f[e];
                    if ("string" == typeof t) S.push(t); else if ("number" == typeof t && 0 !== t) {
                      let e = S.join("");
                      S.length = 0;
                      T({
                        chars: e,
                        extraSpacing: t * h
                      });
                    }
                  }
                  let C = f[f.length - 1];
                  if ("string" == typeof C && S.push(C), S.length > 0) {
                    let e = S.join("");
                    S.length = 0;
                    T({
                      chars: e,
                      extraSpacing: 0
                    });
                  }
                  break;
                case r.OPS.showText:
                  if (!i.state.font) {
                    b.ensureStateFont(i.state);
                    continue;
                  }
                  T({
                    chars: I[0],
                    extraSpacing: 0
                  });
                  break;
                case r.OPS.nextLineShowText:
                  if (!i.state.font) {
                    b.ensureStateFont(i.state);
                    continue;
                  }
                  d.carriageReturn();
                  T({
                    chars: I[0],
                    extraSpacing: 0
                  });
                  break;
                case r.OPS.nextLineSetSpacingShowText:
                  if (!i.state.font) {
                    b.ensureStateFont(i.state);
                    continue;
                  }
                  d.wordSpacing = I[0];
                  d.charSpacing = I[1];
                  d.carriageReturn();
                  T({
                    chars: I[2],
                    extraSpacing: 0
                  });
                  break;
                case r.OPS.paintXObject:
                  L();
                  k || (k = a.get("XObject") || n.Dict.empty);
                  var N = I[0] instanceof n.Name;
                  var D = I[0].name;
                  if (N && A.getByName(D)) break;
                  m(new Promise(function (e, h) {
                    if (!N) throw new r.FormatError("XObject must be referred to by name.");
                    let d = k.getRaw(D);
                    if (d instanceof n.Ref) {
                      if (A.getByRef(d) || b.globalImageCache.getData(d, b.pageIndex)) {
                        e();
                        return;
                      }
                      d = x.fetch(d);
                    }
                    if (!(d instanceof y.BaseStream)) throw new r.FormatError("XObject should be a stream");
                    let f = d.dict.get("Subtype");
                    if (!(f instanceof n.Name)) throw new r.FormatError("XObject should have a Name subtype");
                    if ("Form" !== f.name) {
                      A.set(D, d.dict.objId, !0);
                      e();
                      return;
                    }
                    let g = new B(i.state.clone());
                    let p = d.dict.getArray("Matrix");
                    Array.isArray(p) && 6 === p.length && g.transform(p);
                    $();
                    let m = {
                      enqueueInvoked: !1,
                      enqueue(e, t) {
                        this.enqueueInvoked = !0;
                        l.enqueue(e, t);
                      },
                      get desiredSize() {
                        return l.desiredSize;
                      },
                      get ready() {
                        return l.ready;
                      }
                    };
                    b.getTextContent({
                      stream: d,
                      task: t,
                      resources: d.dict.get("Resources") || a,
                      stateManager: g,
                      combineTextItems: s,
                      includeMarkedContent: o,
                      sink: m,
                      seenStyles: c,
                      viewBox: u
                    }).then(function () {
                      m.enqueueInvoked || A.set(D, d.dict.objId, !0);
                      e();
                    }, h);
                  }).catch(function (e) {
                    if (!(e instanceof r.AbortException)) {
                      if (b.options.ignoreErrors) {
                        r.warn(`getTextContent - ignoring XObject: "${e}".`);
                        return;
                      }
                      throw e;
                    }
                  }));
                  return;
                case r.OPS.setGState:
                  if (N = I[0] instanceof n.Name, D = I[0].name, N && v.getByName(D)) break;
                  m(new Promise(function (e, t) {
                    if (!N) throw new r.FormatError("GState must be referred to by name.");
                    let i = a.get("ExtGState");
                    if (!(i instanceof n.Dict)) throw new r.FormatError("ExtGState should be a dictionary.");
                    let s = i.get(D);
                    if (!(s instanceof n.Dict)) throw new r.FormatError("GState should be a dictionary.");
                    let o = s.get("Font");
                    if (!o) {
                      v.set(D, s.objId, !0);
                      e();
                      return;
                    }
                    L();
                    d.fontName = null;
                    d.fontSize = o[1];
                    F(null, o[0]).then(e, t);
                  }).catch(function (e) {
                    if (!(e instanceof r.AbortException)) {
                      if (b.options.ignoreErrors) {
                        r.warn(`getTextContent - ignoring ExtGState: "${e}".`);
                        return;
                      }
                      throw e;
                    }
                  }));
                  return;
                case r.OPS.beginMarkedContent:
                  o && g.items.push({
                    type: "beginMarkedContent",
                    tag: I[0] instanceof n.Name ? I[0].name : null
                  });
                  break;
                case r.OPS.beginMarkedContentProps:
                  if (o) {
                    L();
                    let e = null;
                    I[1] instanceof n.Dict && (e = I[1].get("MCID"));
                    g.items.push({
                      type: "beginMarkedContentProps",
                      id: Number.isInteger(e) ? `${b.idFactory.getPageObjId()}_mcid${e}` : null,
                      tag: I[0] instanceof n.Name ? I[0].name : null
                    });
                  }
                  break;
                case r.OPS.endMarkedContent:
                  o && (L(), g.items.push({
                    type: "endMarkedContent"
                  }));
              }
              if (g.items.length >= l.desiredSize) {
                O = !0;
                break;
              }
            }
            if (O) {
              m(M);
              return;
            }
            L();
            $();
            h();
          }).catch(e => {
            if (!(e instanceof r.AbortException)) {
              if (this.options.ignoreErrors) {
                r.warn(`getTextContent - ignoring errors during "${t.name}" task: "${e}".`);
                L();
                $();
                return;
              }
              throw e;
            }
          });
        }
        extractDataStructures(e, t, a) {
          let i;
          let s;
          let c = this.xref;
          let h = this.readToUnicode(a.toUnicode || e.get("ToUnicode") || t.get("ToUnicode"));
          if (a.composite) {
            let t = e.get("CIDSystemInfo");
            t instanceof n.Dict && (a.cidSystemInfo = {
              registry: r.stringToPDFString(t.get("Registry")),
              ordering: r.stringToPDFString(t.get("Ordering")),
              supplement: t.get("Supplement")
            });
            let s = e.get("CIDToGIDMap");
            s instanceof y.BaseStream && (i = s.getBytes());
          }
          let u = [];
          let d = null;
          if (e.has("Encoding")) {
            if ((s = e.get("Encoding")) instanceof n.Dict) {
              if (d = (d = s.get("BaseEncoding")) instanceof n.Name ? d.name : null, s.has("Differences")) {
                let e = s.get("Differences");
                let t = 0;
                for (function () {
                  let a = 0;
                  let i = e.length;
                }(); a < i; a++) {
                  let i = c.fetchIfRef(e[a]);
                  if ("number" == typeof i) t = i; else if (i instanceof n.Name) u[t++] = i.name; else throw new r.FormatError(`Invalid entry in 'Differences' array: ${i}`);
                }
              }
            } else if (s instanceof n.Name) d = s.name; else throw new r.FormatError("Encoding is not a Name nor a Dict");
            "MacRomanEncoding" !== d && "MacExpertEncoding" !== d && "WinAnsiEncoding" !== d && (d = null);
          }
          if (d) a.defaultEncoding = l.getEncoding(d); else {
            let e = !!(a.flags & o.FontFlags.Symbolic);
            let t = !!(a.flags & o.FontFlags.Nonsymbolic);
            s = l.StandardEncoding;
            "TrueType" !== a.type || t || (s = l.WinAnsiEncoding);
            e && (s = l.MacRomanEncoding, (!a.file || a.isInternalFont) && (/Symbol/i.test(a.name) ? s = l.SymbolSetEncoding : /Dingbats|Wingdings/i.test(a.name) && (s = l.ZapfDingbatsEncoding)));
            a.defaultEncoding = s;
          }
          a.differences = u;
          a.baseEncodingName = d;
          a.hasEncoding = !!d || u.length > 0;
          a.dict = e;
          return h.then(e => (a.toUnicode = e, this.buildToUnicode(a))).then(e => (a.toUnicode = e, i && (a.cidToGidMap = this.readCidToGidMap(i, e)), a));
        }
        _simpleFontToUnicode(e, t = !1) {
          r.assert(!e.composite, "Must be a simple font.");
          let a = [];
          let i = e.defaultEncoding.slice();
          let n = e.baseEncodingName;
          let s = e.differences;
          for (let e in s) {
            let t = s[e];
            ".notdef" !== t && (i[e] = t);
          }
          let o = k.getGlyphsUnicode();
          for (let r in i) {
            let s = i[r];
            if ("" !== s) {
              if (void 0 === o[s]) {
                let i = 0;
                switch (s[0]) {
                  case "G":
                    3 === s.length && (i = parseInt(s.substring(1), 16));
                    break;
                  case "g":
                    5 === s.length && (i = parseInt(s.substring(1), 16));
                    break;
                  case "C":
                  case "c":
                    if (s.length >= 3 && s.length <= 4) {
                      let a = s.substring(1);
                      if (t) {
                        i = parseInt(a, 16);
                        break;
                      }
                      if (Number.isNaN(i = +a) && Number.isInteger(parseInt(a, 16))) return this._simpleFontToUnicode(e, !0);
                    }
                    break;
                  default:
                    let c = h.getUnicodeForGlyph(s, o);
                    -1 !== c && (i = c);
                }
                if (i > 0 && i <= 1114111 && Number.isInteger(i)) {
                  if (n && i === +r) {
                    let e = l.getEncoding(n);
                    if (e && (s = e[r])) {
                      a[r] = String.fromCharCode(o[s]);
                      continue;
                    }
                  }
                  a[r] = String.fromCodePoint(i);
                }
                continue;
              }
              a[r] = String.fromCharCode(o[s]);
            }
          }
          return a;
        }
        async buildToUnicode(e) {
          if (e.hasIncludedToUnicodeMap = !!e.toUnicode && e.toUnicode.length > 0, e.hasIncludedToUnicodeMap) {
            !e.composite && e.hasEncoding && (e.fallbackToUnicode = this._simpleFontToUnicode(e));
            return e.toUnicode;
          }
          if (!e.composite) return new f.ToUnicodeMap(this._simpleFontToUnicode(e));
          if (e.composite && (e.cMap.builtInCMap && !(e.cMap instanceof i.IdentityCMap) || "Adobe" === e.cidSystemInfo.registry && ("GB1" === e.cidSystemInfo.ordering || "CNS1" === e.cidSystemInfo.ordering || "Japan1" === e.cidSystemInfo.ordering || "Korea1" === e.cidSystemInfo.ordering))) {
            let {
              registry,
              ordering
            } = e.cidSystemInfo;
            let s = n.Name.get(`${registry}-${ordering}-UCS2`);
            let o = await i.CMapFactory.create({
              encoding: s,
              fetchBuiltInCMap: this._fetchBuiltInCMapBound,
              useCMap: null
            });
            let l = [];
            e.cMap.forEach(function (e, t) {
              if (t > 65535) throw new r.FormatError("Max size of CID is 65,535");
              let a = o.lookup(t);
              a && (l[e] = String.fromCharCode((a.charCodeAt(0) << 8) + a.charCodeAt(1)));
            });
            return new f.ToUnicodeMap(l);
          }
          return new f.IdentityToUnicodeMap(e.firstChar, e.lastChar);
        }
        readToUnicode(e) {
          return e ? e instanceof n.Name ? i.CMapFactory.create({
            encoding: e,
            fetchBuiltInCMap: this._fetchBuiltInCMapBound,
            useCMap: null
          }).then(function (e) {
            return e instanceof i.IdentityCMap ? new f.IdentityToUnicodeMap(0, 65535) : new f.ToUnicodeMap(e.getMap());
          }) : e instanceof y.BaseStream ? i.CMapFactory.create({
            encoding: e,
            fetchBuiltInCMap: this._fetchBuiltInCMapBound,
            useCMap: null
          }).then(function (e) {
            if (e instanceof i.IdentityCMap) return new f.IdentityToUnicodeMap(0, 65535);
            let t = Array(e.length);
            e.forEach(function (e, a) {
              if ("number" == typeof a) {
                t[e] = String.fromCodePoint(a);
                return;
              }
              let r = [];
              for (let e = 0; e < a.length; e += 2) {
                let t = a.charCodeAt(e) << 8 | a.charCodeAt(e + 1);
                if ((63488 & t) != 55296) {
                  r.push(t);
                  continue;
                }
                e += 2;
                let i = a.charCodeAt(e) << 8 | a.charCodeAt(e + 1);
                r.push(((1023 & t) << 10) + (1023 & i) + 65536);
              }
              t[e] = String.fromCodePoint.apply(String, r);
            });
            return new f.ToUnicodeMap(t);
          }, e => {
            if (e instanceof r.AbortException) return null;
            if (this.options.ignoreErrors) {
              this.handler.send("UnsupportedFeature", {
                featureId: r.UNSUPPORTED_FEATURES.errorFontToUnicode
              });
              r.warn(`readToUnicode - ignoring ToUnicode data: "${e}".`);
              return null;
            }
            throw e;
          }) : Promise.resolve(null) : Promise.resolve(null);
        }
        readCidToGidMap(e, t) {
          let a = [];
          for (function () {
            let r = 0;
            let i = e.length;
          }(); r < i; r++) {
            let i = e[r++] << 8 | e[r];
            let n = r >> 1;
            (0 !== i || t.has(n)) && (a[n] = i);
          }
          return a;
        }
        extractWidths(e, t, a) {
          let r;
          let i;
          let s;
          let l;
          let c;
          let h;
          let u;
          let d;
          let f = this.xref;
          let g = [];
          let p = 0;
          let m = [];
          if (a.composite) {
            if (p = e.has("DW") ? e.get("DW") : 1e3, d = e.get("W")) for (i = 0, s = d.length; i < s; i++) if (h = f.fetchIfRef(d[i++]), Array.isArray(u = f.fetchIfRef(d[i]))) for (l = 0, c = u.length; l < c; l++) g[h++] = f.fetchIfRef(u[l]); else {
              let e = f.fetchIfRef(d[++i]);
              for (l = h; l <= u; l++) g[l] = e;
            }
            if (a.vertical) {
              let t = e.getArray("DW2") || [880, -1e3];
              if (r = [t[1], .5 * p, t[0]], t = e.get("W2")) for (i = 0, s = t.length; i < s; i++) if (h = f.fetchIfRef(t[i++]), Array.isArray(u = f.fetchIfRef(t[i]))) for (l = 0, c = u.length; l < c; l++) m[h++] = [f.fetchIfRef(u[l++]), f.fetchIfRef(u[l++]), f.fetchIfRef(u[l])]; else {
                let e = [f.fetchIfRef(t[++i]), f.fetchIfRef(t[++i]), f.fetchIfRef(t[++i])];
                for (l = h; l <= u; l++) m[l] = e;
              }
            }
          } else {
            let r = a.firstChar;
            if (d = e.get("Widths")) {
              for (i = 0, l = r, s = d.length; i < s; i++) g[l++] = f.fetchIfRef(d[i]);
              p = parseFloat(t.get("MissingWidth")) || 0;
            } else {
              let t = e.get("BaseFont");
              if (t instanceof n.Name) {
                let e = this.getBaseFontMetrics(t.name);
                g = this.buildCharCodeToWidth(e.widths, a);
                p = e.defaultWidth;
              }
            }
          }
          let b = !0;
          let y = p;
          for (let e in g) {
            let t = g[e];
            if (t) {
              if (!y) {
                y = t;
                continue;
              }
              if (y !== t) {
                b = !1;
                break;
              }
            }
          }
          b && (a.flags |= o.FontFlags.FixedPitch);
          a.defaultWidth = p;
          a.widths = g;
          a.defaultVMetrics = r;
          a.vmetrics = m;
        }
        isSerifFont(e) {
          let t = e.split("-")[0];
          return t in c.getSerifFonts() || -1 !== t.search(/serif/gi);
        }
        getBaseFontMetrics(e) {
          let t = 0;
          let a = Object.create(null);
          let r = !1;
          let i = c.getStdFontMap()[e] || e;
          let n = v.getMetrics();
          i in n || (i = this.isSerifFont(e) ? "Times-Roman" : "Helvetica");
          let s = n[i];
          "number" == typeof s ? (t = s, r = !0) : a = s();
          return {
            defaultWidth: t,
            monospace: r,
            widths: a
          };
        }
        buildCharCodeToWidth(e, t) {
          let a = Object.create(null);
          let r = t.differences;
          let i = t.defaultEncoding;
          for (let t = 0; t < 256; t++) {
            if (t in r && e[r[t]]) {
              a[t] = e[r[t]];
              continue;
            }
            if (t in i && e[i[t]]) {
              a[t] = e[i[t]];
              continue;
            }
          }
          return a;
        }
        preEvaluateFont(e) {
          let t;
          let a;
          let i = e;
          let s = e.get("Subtype");
          if (!(s instanceof n.Name)) throw new r.FormatError("invalid font Subtype");
          let o = !1;
          if ("Type0" === s.name) {
            let t = e.get("DescendantFonts");
            if (!t) throw new r.FormatError("Descendant fonts are not specified");
            if (!((e = Array.isArray(t) ? this.xref.fetchIfRef(t[0]) : t) instanceof n.Dict)) throw new r.FormatError("Descendant font is not a dictionary.");
            if (!((s = e.get("Subtype")) instanceof n.Name)) throw new r.FormatError("invalid font Subtype");
            o = !0;
          }
          let l = e.get("FirstChar") || 0;
          let c = e.get("LastChar") || (o ? 65535 : 255);
          let h = e.get("FontDescriptor");
          if (h) {
            t = new C.MurmurHash3_64();
            let r = i.getRaw("Encoding");
            if (r instanceof n.Name) t.update(r.name); else if (r instanceof n.Ref) t.update(r.toString()); else if (r instanceof n.Dict) {
              for (let e of r.getRawValues()) if (e instanceof n.Name) t.update(e.name); else if (e instanceof n.Ref) t.update(e.toString()); else if (Array.isArray(e)) {
                let a = e.length;
                let r = Array(a);
                for (let t = 0; t < a; t++) {
                  let a = e[t];
                  a instanceof n.Name ? r[t] = a.name : ("number" == typeof a || a instanceof n.Ref) && (r[t] = a.toString());
                }
                t.update(r.join());
              }
            }
            if (t.update(`${l}-${c}`), (a = e.get("ToUnicode") || i.get("ToUnicode")) instanceof y.BaseStream) {
              let e = a.str || a;
              let r = e.buffer ? new Uint8Array(e.buffer.buffer, 0, e.bufferLength) : new Uint8Array(e.bytes.buffer, e.start, e.end - e.start);
              t.update(r);
            } else a instanceof n.Name && t.update(a.name);
            let s = e.get("Widths") || i.get("Widths");
            if (Array.isArray(s)) {
              let e = [];
              for (let t of s) ("number" == typeof t || t instanceof n.Ref) && e.push(t.toString());
              t.update(e.join());
            }
            if (o) {
              t.update("compositeFont");
              let a = e.get("W") || i.get("W");
              if (Array.isArray(a)) {
                let e = [];
                for (let t of a) if ("number" == typeof t || t instanceof n.Ref) e.push(t.toString()); else if (Array.isArray(t)) {
                  let a = [];
                  for (let e of t) ("number" == typeof e || e instanceof n.Ref) && a.push(e.toString());
                  e.push(`[${a.join()}]`);
                }
                t.update(e.join());
              }
              let r = e.getRaw("CIDToGIDMap") || i.getRaw("CIDToGIDMap");
              r instanceof n.Name ? t.update(r.name) : r instanceof n.Ref ? t.update(r.toString()) : r instanceof y.BaseStream && t.update(r.peekBytes());
            }
          }
          return {
            descriptor: h,
            dict: e,
            baseDict: i,
            composite: o,
            type: s.name,
            firstChar: l,
            lastChar: c,
            toUnicode: a,
            hash: t ? t.hexdigest() : ""
          };
        }
        async translateFont({
          descriptor: e,
          dict: t,
          baseDict: a,
          composite: l,
          type: h,
          firstChar: u,
          lastChar: f,
          toUnicode: g,
          cssFontInfo: p
        }) {
          let m;
          let y;
          let w;
          let x;
          let S;
          let k;
          let A = "Type3" === h;
          if (!e) {
            if (A) {
              (e = new n.Dict(null)).set("FontName", n.Name.get(h));
              e.set("FontBBox", t.getArray("FontBBox") || [0, 0, 0, 0]);
            } else {
              let e = t.get("BaseFont");
              if (!(e instanceof n.Name)) throw new r.FormatError("Base font is not specified");
              e = e.name.replace(/[,_]/g, "-");
              let i = this.getBaseFontMetrics(e);
              let l = e.split("-")[0];
              let d = (this.isSerifFont(l) ? o.FontFlags.Serif : 0) | (i.monospace ? o.FontFlags.FixedPitch : 0) | (c.getSymbolsFonts()[l] ? o.FontFlags.Symbolic : o.FontFlags.Nonsymbolic);
              m = {
                type: h,
                name: e,
                loadedName: a.loadedName,
                widths: i.widths,
                defaultWidth: i.defaultWidth,
                isSimulatedFlags: !0,
                flags: d,
                firstChar: u,
                lastChar: f,
                toUnicode: g,
                xHeight: 0,
                capHeight: 0,
                italicAngle: 0,
                isType3Font: A
              };
              let p = t.get("Widths");
              let b = c.getStandardFontName(e);
              let y = null;
              b && (m.isStandardFont = !0, y = await this.fetchStandardFontData(b), m.isInternalFont = !!y);
              return this.extractDataStructures(t, t, m).then(t => {
                if (p) {
                  let e = [];
                  let a = u;
                  for (function () {
                    let t = 0;
                    let r = p.length;
                  }(); t < r; t++) e[a++] = this.xref.fetchIfRef(p[t]);
                  t.widths = e;
                } else t.widths = this.buildCharCodeToWidth(i.widths, t);
                return new s.Font(e, y, t);
              });
            }
          }
          let v = e.get("FontName");
          let C = t.get("BaseFont");
          if ("string" == typeof v && (v = n.Name.get(v)), "string" == typeof C && (C = n.Name.get(C)), !A) {
            let e = v && v.name;
            let t = C && C.name;
            e !== t && (r.info(`The FontDescriptor's FontName is "${e}" but should be the same as the Font's BaseFont "${t}".`), e && t && t.startsWith(e) && (v = C));
          }
          if (!((v = v || C) instanceof n.Name)) throw new r.FormatError("invalid font name");
          try {
            y = e.get("FontFile", "FontFile2", "FontFile3");
          } catch (e) {
            if (!this.options.ignoreErrors) throw e;
            r.warn(`translateFont - fetching "${v.name}" font file: "${e}".`);
            y = new b.NullStream();
          }
          let O = !1;
          let F = !1;
          let I = null;
          if (y) {
            if (y.dict) {
              let e = y.dict.get("Subtype");
              e instanceof n.Name && (w = e.name);
              x = y.dict.get("Length1");
              S = y.dict.get("Length2");
              k = y.dict.get("Length3");
            }
          } else if (p) {
            let e = d.getXfaFontName(v.name);
            e && (p.fontFamily = `${p.fontFamily}-PdfJS-XFA`, p.metrics = e.metrics || null, I = e.factors || null, F = !!(y = await this.fetchStandardFontData(e.name)), a = t = d.getXfaFontDict(v.name), l = !0);
          } else if (!A) {
            let e = c.getStandardFontName(v.name);
            e && (O = !0, F = !!(y = await this.fetchStandardFontData(e)));
          }
          if (m = {
            type: h,
            name: v.name,
            subtype: w,
            file: y,
            length1: x,
            length2: S,
            length3: k,
            isStandardFont: O,
            isInternalFont: F,
            loadedName: a.loadedName,
            composite: l,
            fixedPitch: !1,
            fontMatrix: t.getArray("FontMatrix") || r.FONT_IDENTITY_MATRIX,
            firstChar: u,
            lastChar: f,
            toUnicode: g,
            bbox: e.getArray("FontBBox") || t.getArray("FontBBox"),
            ascent: e.get("Ascent"),
            descent: e.get("Descent"),
            xHeight: e.get("XHeight") || 0,
            capHeight: e.get("CapHeight") || 0,
            flags: e.get("Flags"),
            italicAngle: e.get("ItalicAngle") || 0,
            isType3Font: A,
            cssFontInfo: p,
            scaleFactors: I
          }, l) {
            let e = a.get("Encoding");
            e instanceof n.Name && (m.cidEncoding = e.name);
            let t = await i.CMapFactory.create({
              encoding: e,
              fetchBuiltInCMap: this._fetchBuiltInCMapBound,
              useCMap: null
            });
            m.cMap = t;
            m.vertical = m.cMap.vertical;
          }
          return this.extractDataStructures(t, a, m).then(a => (this.extractWidths(t, e, a), new s.Font(v.name, y, a)));
        }
        static buildFontPaths(e, t, a, i) {
          function n(t) {
            let n = `${e.loadedName}_path_${t}`;
            try {
              if (e.renderer.hasBuiltPath(t)) return;
              a.send("commonobj", [n, "FontPath", e.renderer.getPathJs(t)]);
            } catch (e) {
              if (i.ignoreErrors) {
                a.send("UnsupportedFeature", {
                  featureId: r.UNSUPPORTED_FEATURES.errorFontBuildPath
                });
                r.warn(`buildFontPaths - ignoring ${n} glyph: "${e}".`);
                return;
              }
              throw e;
            }
          }
          for (let e of t) {
            n(e.fontChar);
            let t = e.accent;
            t && t.fontChar && n(t.fontChar);
          }
        }
        static get fallbackFontDict() {
          let e = new n.Dict();
          e.set("BaseFont", n.Name.get("PDFJS-FallbackFont"));
          e.set("Type", n.Name.get("FallbackType"));
          e.set("Subtype", n.Name.get("FallbackType"));
          e.set("Encoding", n.Name.get("WinAnsiEncoding"));
          return r.shadow(this, "fallbackFontDict", e);
        }
      }
      t.PartialEvaluator = E;
      class N {
        constructor({
          loadedName: e,
          font: t,
          dict: a,
          evaluatorOptions: r
        }) {
          this.loadedName = e;
          this.font = t;
          this.dict = a;
          this._evaluatorOptions = r || I;
          this.type3Loaded = null;
          this.type3Dependencies = t.isType3Font ? new Set() : null;
          this.sent = !1;
        }
        send(e) {
          this.sent || (this.sent = !0, e.send("commonobj", [this.loadedName, "Font", this.font.exportData(this._evaluatorOptions.fontExtraProperties)]));
        }
        fallback(e) {
          this.font.data && (this.font.disableFontFace = !0, E.buildFontPaths(this.font, this.font.glyphCacheValues, e, this._evaluatorOptions));
        }
        loadType3Data(e, t, a) {
          if (this.type3Loaded) return this.type3Loaded;
          if (!this.font.isType3Font) throw Error("Must be a Type3 font.");
          let i = e.clone({
            ignoreErrors: !1
          });
          i.parsingType3Font = !0;
          let s = new n.RefSet(e.type3FontRefs);
          this.dict.objId && !s.has(this.dict.objId) && s.put(this.dict.objId);
          i.type3FontRefs = s;
          let o = this.font;
          let l = this.type3Dependencies;
          let c = Promise.resolve();
          let h = this.dict.get("CharProcs");
          let u = this.dict.get("Resources") || t;
          let d = Object.create(null);
          let f = !o.bbox || r.isArrayEqual(o.bbox, [0, 0, 0, 0]);
          for (let e of h.getKeys()) c = c.then(() => {
            let t = h.get(e);
            let n = new O.OperatorList();
            return i.getOperatorList({
              stream: t,
              task: a,
              resources: u,
              operatorList: n
            }).then(() => {
              for (let t of (n.fnArray[0] === r.OPS.setCharWidthAndBounds && this._removeType3ColorOperators(n, f), d[e] = n.getIR(), n.dependencies)) l.add(t);
            }).catch(function (t) {
              r.warn(`Type3 font resource "${e}" is not available.`);
              let a = new O.OperatorList();
              d[e] = a.getIR();
            });
          });
          this.type3Loaded = c.then(() => {
            o.charProcOperatorList = d;
            this._bbox && (o.isCharBBox = !0, o.bbox = this._bbox);
          });
          return this.type3Loaded;
        }
        _removeType3ColorOperators(e, t = !1) {
          if (t) {
            this._bbox || (this._bbox = [1 / 0, 1 / 0, -1 / 0, -1 / 0]);
            let t = r.Util.normalizeRect(e.argsArray[0].slice(2));
            this._bbox[0] = Math.min(this._bbox[0], t[0]);
            this._bbox[1] = Math.min(this._bbox[1], t[1]);
            this._bbox[2] = Math.max(this._bbox[2], t[2]);
            this._bbox[3] = Math.max(this._bbox[3], t[3]);
          }
          let a = 1;
          let i = e.length;
          for (; a < i;) {
            switch (e.fnArray[a]) {
              case r.OPS.setStrokeColorSpace:
              case r.OPS.setFillColorSpace:
              case r.OPS.setStrokeColor:
              case r.OPS.setStrokeColorN:
              case r.OPS.setFillColor:
              case r.OPS.setFillColorN:
              case r.OPS.setStrokeGray:
              case r.OPS.setFillGray:
              case r.OPS.setStrokeRGBColor:
              case r.OPS.setFillRGBColor:
              case r.OPS.setStrokeCMYKColor:
              case r.OPS.setFillCMYKColor:
              case r.OPS.shadingFill:
              case r.OPS.setRenderingIntent:
                e.fnArray.splice(a, 1);
                e.argsArray.splice(a, 1);
                i--;
                continue;
              case r.OPS.setGState:
                let [t] = e.argsArray[a];
                let n = 0;
                let s = t.length;
                for (; n < s;) {
                  let [e] = t[n];
                  switch (e) {
                    case "TR":
                    case "TR2":
                    case "HT":
                    case "BG":
                    case "BG2":
                    case "UCR":
                    case "UCR2":
                      t.splice(n, 1);
                      s--;
                      continue;
                  }
                  n++;
                }
            }
            a++;
          }
        }
      }
      class B {
        constructor(e = new L()) {
          this.state = e;
          this.stateStack = [];
        }
        save() {
          let e = this.state;
          this.stateStack.push(this.state);
          this.state = e.clone();
        }
        restore() {
          let e = this.stateStack.pop();
          e && (this.state = e);
        }
        transform(e) {
          this.state.ctm = r.Util.transform(this.state.ctm, e);
        }
      }
      class D {
        constructor() {
          this.ctm = new Float32Array(r.IDENTITY_MATRIX);
          this.fontName = null;
          this.fontSize = 0;
          this.font = null;
          this.fontMatrix = r.FONT_IDENTITY_MATRIX;
          this.textMatrix = r.IDENTITY_MATRIX.slice();
          this.textLineMatrix = r.IDENTITY_MATRIX.slice();
          this.charSpacing = 0;
          this.wordSpacing = 0;
          this.leading = 0;
          this.textHScale = 1;
          this.textRise = 0;
        }
        setTextMatrix(e, t, a, r, i, n) {
          let s = this.textMatrix;
          s[0] = e;
          s[1] = t;
          s[2] = a;
          s[3] = r;
          s[4] = i;
          s[5] = n;
        }
        setTextLineMatrix(e, t, a, r, i, n) {
          let s = this.textLineMatrix;
          s[0] = e;
          s[1] = t;
          s[2] = a;
          s[3] = r;
          s[4] = i;
          s[5] = n;
        }
        translateTextMatrix(e, t) {
          let a = this.textMatrix;
          a[4] = a[0] * e + a[2] * t + a[4];
          a[5] = a[1] * e + a[3] * t + a[5];
        }
        translateTextLineMatrix(e, t) {
          let a = this.textLineMatrix;
          a[4] = a[0] * e + a[2] * t + a[4];
          a[5] = a[1] * e + a[3] * t + a[5];
        }
        carriageReturn() {
          this.translateTextLineMatrix(0, -this.leading);
          this.textMatrix = this.textLineMatrix.slice();
        }
        clone() {
          let e = Object.create(this);
          e.textMatrix = this.textMatrix.slice();
          e.textLineMatrix = this.textLineMatrix.slice();
          e.fontMatrix = this.fontMatrix.slice();
          return e;
        }
      }
      class L {
        constructor() {
          this.ctm = new Float32Array(r.IDENTITY_MATRIX);
          this.font = null;
          this.textRenderingMode = r.TextRenderingMode.FILL;
          this.fillColorSpace = x.ColorSpace.singletons.gray;
          this.strokeColorSpace = x.ColorSpace.singletons.gray;
        }
        clone() {
          return Object.create(this);
        }
      }
      class R {
        static get opMap() {
          let e = A.getLookupTableFactory(function (e) {
            e.w = {
              id: r.OPS.setLineWidth,
              numArgs: 1,
              variableArgs: !1
            };
            e.J = {
              id: r.OPS.setLineCap,
              numArgs: 1,
              variableArgs: !1
            };
            e.j = {
              id: r.OPS.setLineJoin,
              numArgs: 1,
              variableArgs: !1
            };
            e.M = {
              id: r.OPS.setMiterLimit,
              numArgs: 1,
              variableArgs: !1
            };
            e.d = {
              id: r.OPS.setDash,
              numArgs: 2,
              variableArgs: !1
            };
            e.ri = {
              id: r.OPS.setRenderingIntent,
              numArgs: 1,
              variableArgs: !1
            };
            e.i = {
              id: r.OPS.setFlatness,
              numArgs: 1,
              variableArgs: !1
            };
            e.gs = {
              id: r.OPS.setGState,
              numArgs: 1,
              variableArgs: !1
            };
            e.q = {
              id: r.OPS.save,
              numArgs: 0,
              variableArgs: !1
            };
            e.Q = {
              id: r.OPS.restore,
              numArgs: 0,
              variableArgs: !1
            };
            e.cm = {
              id: r.OPS.transform,
              numArgs: 6,
              variableArgs: !1
            };
            e.m = {
              id: r.OPS.moveTo,
              numArgs: 2,
              variableArgs: !1
            };
            e.l = {
              id: r.OPS.lineTo,
              numArgs: 2,
              variableArgs: !1
            };
            e.c = {
              id: r.OPS.curveTo,
              numArgs: 6,
              variableArgs: !1
            };
            e.v = {
              id: r.OPS.curveTo2,
              numArgs: 4,
              variableArgs: !1
            };
            e.y = {
              id: r.OPS.curveTo3,
              numArgs: 4,
              variableArgs: !1
            };
            e.h = {
              id: r.OPS.closePath,
              numArgs: 0,
              variableArgs: !1
            };
            e.re = {
              id: r.OPS.rectangle,
              numArgs: 4,
              variableArgs: !1
            };
            e.S = {
              id: r.OPS.stroke,
              numArgs: 0,
              variableArgs: !1
            };
            e.s = {
              id: r.OPS.closeStroke,
              numArgs: 0,
              variableArgs: !1
            };
            e.f = {
              id: r.OPS.fill,
              numArgs: 0,
              variableArgs: !1
            };
            e.F = {
              id: r.OPS.fill,
              numArgs: 0,
              variableArgs: !1
            };
            e["f*"] = {
              id: r.OPS.eoFill,
              numArgs: 0,
              variableArgs: !1
            };
            e.B = {
              id: r.OPS.fillStroke,
              numArgs: 0,
              variableArgs: !1
            };
            e["B*"] = {
              id: r.OPS.eoFillStroke,
              numArgs: 0,
              variableArgs: !1
            };
            e.b = {
              id: r.OPS.closeFillStroke,
              numArgs: 0,
              variableArgs: !1
            };
            e["b*"] = {
              id: r.OPS.closeEOFillStroke,
              numArgs: 0,
              variableArgs: !1
            };
            e.n = {
              id: r.OPS.endPath,
              numArgs: 0,
              variableArgs: !1
            };
            e.W = {
              id: r.OPS.clip,
              numArgs: 0,
              variableArgs: !1
            };
            e["W*"] = {
              id: r.OPS.eoClip,
              numArgs: 0,
              variableArgs: !1
            };
            e.BT = {
              id: r.OPS.beginText,
              numArgs: 0,
              variableArgs: !1
            };
            e.ET = {
              id: r.OPS.endText,
              numArgs: 0,
              variableArgs: !1
            };
            e.Tc = {
              id: r.OPS.setCharSpacing,
              numArgs: 1,
              variableArgs: !1
            };
            e.Tw = {
              id: r.OPS.setWordSpacing,
              numArgs: 1,
              variableArgs: !1
            };
            e.Tz = {
              id: r.OPS.setHScale,
              numArgs: 1,
              variableArgs: !1
            };
            e.TL = {
              id: r.OPS.setLeading,
              numArgs: 1,
              variableArgs: !1
            };
            e.Tf = {
              id: r.OPS.setFont,
              numArgs: 2,
              variableArgs: !1
            };
            e.Tr = {
              id: r.OPS.setTextRenderingMode,
              numArgs: 1,
              variableArgs: !1
            };
            e.Ts = {
              id: r.OPS.setTextRise,
              numArgs: 1,
              variableArgs: !1
            };
            e.Td = {
              id: r.OPS.moveText,
              numArgs: 2,
              variableArgs: !1
            };
            e.TD = {
              id: r.OPS.setLeadingMoveText,
              numArgs: 2,
              variableArgs: !1
            };
            e.Tm = {
              id: r.OPS.setTextMatrix,
              numArgs: 6,
              variableArgs: !1
            };
            e["T*"] = {
              id: r.OPS.nextLine,
              numArgs: 0,
              variableArgs: !1
            };
            e.Tj = {
              id: r.OPS.showText,
              numArgs: 1,
              variableArgs: !1
            };
            e.TJ = {
              id: r.OPS.showSpacedText,
              numArgs: 1,
              variableArgs: !1
            };
            e["'"] = {
              id: r.OPS.nextLineShowText,
              numArgs: 1,
              variableArgs: !1
            };
            e['"'] = {
              id: r.OPS.nextLineSetSpacingShowText,
              numArgs: 3,
              variableArgs: !1
            };
            e.d0 = {
              id: r.OPS.setCharWidth,
              numArgs: 2,
              variableArgs: !1
            };
            e.d1 = {
              id: r.OPS.setCharWidthAndBounds,
              numArgs: 6,
              variableArgs: !1
            };
            e.CS = {
              id: r.OPS.setStrokeColorSpace,
              numArgs: 1,
              variableArgs: !1
            };
            e.cs = {
              id: r.OPS.setFillColorSpace,
              numArgs: 1,
              variableArgs: !1
            };
            e.SC = {
              id: r.OPS.setStrokeColor,
              numArgs: 4,
              variableArgs: !0
            };
            e.SCN = {
              id: r.OPS.setStrokeColorN,
              numArgs: 33,
              variableArgs: !0
            };
            e.sc = {
              id: r.OPS.setFillColor,
              numArgs: 4,
              variableArgs: !0
            };
            e.scn = {
              id: r.OPS.setFillColorN,
              numArgs: 33,
              variableArgs: !0
            };
            e.G = {
              id: r.OPS.setStrokeGray,
              numArgs: 1,
              variableArgs: !1
            };
            e.g = {
              id: r.OPS.setFillGray,
              numArgs: 1,
              variableArgs: !1
            };
            e.RG = {
              id: r.OPS.setStrokeRGBColor,
              numArgs: 3,
              variableArgs: !1
            };
            e.rg = {
              id: r.OPS.setFillRGBColor,
              numArgs: 3,
              variableArgs: !1
            };
            e.K = {
              id: r.OPS.setStrokeCMYKColor,
              numArgs: 4,
              variableArgs: !1
            };
            e.k = {
              id: r.OPS.setFillCMYKColor,
              numArgs: 4,
              variableArgs: !1
            };
            e.sh = {
              id: r.OPS.shadingFill,
              numArgs: 1,
              variableArgs: !1
            };
            e.BI = {
              id: r.OPS.beginInlineImage,
              numArgs: 0,
              variableArgs: !1
            };
            e.ID = {
              id: r.OPS.beginImageData,
              numArgs: 0,
              variableArgs: !1
            };
            e.EI = {
              id: r.OPS.endInlineImage,
              numArgs: 1,
              variableArgs: !1
            };
            e.Do = {
              id: r.OPS.paintXObject,
              numArgs: 1,
              variableArgs: !1
            };
            e.MP = {
              id: r.OPS.markPoint,
              numArgs: 1,
              variableArgs: !1
            };
            e.DP = {
              id: r.OPS.markPointProps,
              numArgs: 2,
              variableArgs: !1
            };
            e.BMC = {
              id: r.OPS.beginMarkedContent,
              numArgs: 1,
              variableArgs: !1
            };
            e.BDC = {
              id: r.OPS.beginMarkedContentProps,
              numArgs: 2,
              variableArgs: !1
            };
            e.EMC = {
              id: r.OPS.endMarkedContent,
              numArgs: 0,
              variableArgs: !1
            };
            e.BX = {
              id: r.OPS.beginCompat,
              numArgs: 0,
              variableArgs: !1
            };
            e.EX = {
              id: r.OPS.endCompat,
              numArgs: 0,
              variableArgs: !1
            };
            e.BM = null;
            e.BD = null;
            e.$$true = null;
            e.fa = null;
            e.fal = null;
            e.fals = null;
            e.$$false = null;
            e.nu = null;
            e.nul = null;
            e.$$null = null;
          });
          return r.shadow(this, "opMap", e());
        }
        static get MAX_INVALID_PATH_OPS() {
          return r.shadow(this, "MAX_INVALID_PATH_OPS", 10);
        }
        constructor(e, t, a = new B()) {
          this.parser = new p.Parser({
            lexer: new p.Lexer(e, R.opMap),
            xref: t
          });
          this.stateManager = a;
          this.nonProcessedArgs = [];
          this._numInvalidPathOPS = 0;
        }
        get savedStatesDepth() {
          return this.stateManager.stateStack.length;
        }
        read(e) {
          let t = e.args;
          for (; ;) {
            let a = this.parser.getObj();
            if (a instanceof n.Cmd) {
              let i = a.cmd;
              let n = R.opMap[i];
              if (!n) {
                r.warn(`Unknown command "${i}".`);
                continue;
              }
              let s = n.id;
              let o = n.numArgs;
              let l = null !== t ? t.length : 0;
              if (n.variableArgs) l > o && r.info(`Command ${i}: expected [0, ${o}] args, but received ${l} args.`); else {
                if (l !== o) {
                  let e = this.nonProcessedArgs;
                  for (; l > o;) {
                    e.push(t.shift());
                    l--;
                  }
                  for (; l < o && 0 !== e.length;) {
                    null === t && (t = []);
                    t.unshift(e.pop());
                    l++;
                  }
                }
                if (l < o) {
                  let e = `command ${i}: expected ${o} args, but received ${l} args.`;
                  if (s >= r.OPS.moveTo && s <= r.OPS.endPath && ++this._numInvalidPathOPS > R.MAX_INVALID_PATH_OPS) throw new r.FormatError(`Invalid ${e}`);
                  r.warn(`Skipping ${e}`);
                  null !== t && (t.length = 0);
                  continue;
                }
              }
              this.preprocessCommand(s, t);
              e.fn = s;
              e.args = t;
              return !0;
            }
            if (a === n.EOF) return !1;
            if (null !== a && (null === t && (t = []), t.push(a), t.length > 33)) throw new r.FormatError("Too many arguments");
          }
        }
        preprocessCommand(e, t) {
          switch (0 | e) {
            case r.OPS.save:
              this.stateManager.save();
              break;
            case r.OPS.restore:
              this.stateManager.restore();
              break;
            case r.OPS.transform:
              this.stateManager.transform(t);
          }
        }
      }
      t.EvaluatorPreprocessor = R;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.IdentityCMap = t.CMapFactory = t.CMap = void 0;
      var r = a(2);
      var i = a(5);
      var n = a(9);
      var s = a(27);
      var o = a(8);
      var l = a(10);
      let c = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"];
      class h {
        constructor(e = !1) {
          this.codespaceRanges = [[], [], [], []];
          this.numCodespaceRanges = 0;
          this._map = [];
          this.name = "";
          this.vertical = !1;
          this.useCMap = null;
          this.builtInCMap = e;
        }
        addCodespaceRange(e, t, a) {
          this.codespaceRanges[e - 1].push(t, a);
          this.numCodespaceRanges++;
        }
        mapCidRange(e, t, a) {
          if (t - e > 0xffffff) throw Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
          for (; e <= t;) this._map[e++] = a++;
        }
        mapBfRange(e, t, a) {
          if (t - e > 0xffffff) throw Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
          let r = a.length - 1;
          for (; e <= t;) {
            this._map[e++] = a;
            let t = a.charCodeAt(r) + 1;
            if (t > 255) {
              a = a.substring(0, r - 1) + String.fromCharCode(a.charCodeAt(r - 1) + 1) + "\0";
              continue;
            }
            a = a.substring(0, r) + String.fromCharCode(t);
          }
        }
        mapBfRangeToArray(e, t, a) {
          if (t - e > 0xffffff) throw Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
          let r = a.length;
          let i = 0;
          for (; e <= t && i < r;) {
            this._map[e] = a[i++];
            ++e;
          }
        }
        mapOne(e, t) {
          this._map[e] = t;
        }
        lookup(e) {
          return this._map[e];
        }
        contains(e) {
          return void 0 !== this._map[e];
        }
        forEach(e) {
          let t = this._map;
          let a = t.length;
          if (a <= 65536) for (let r = 0; r < a; r++) void 0 !== t[r] && e(r, t[r]); else for (let a in t) e(a, t[a]);
        }
        charCodeOf(e) {
          let t = this._map;
          if (t.length <= 65536) return t.indexOf(e);
          for (let a in t) if (t[a] === e) return 0 | a;
          return -1;
        }
        getMap() {
          return this._map;
        }
        readCharCode(e, t, a) {
          let r = 0;
          let i = this.codespaceRanges;
          for (function () {
            let n = 0;
            let s = i.length;
          }(); n < s; n++) {
            r = (r << 8 | e.charCodeAt(t + n)) >>> 0;
            let s = i[n];
            for (function () {
              let e = 0;
              let t = s.length;
            }(); e < t;) {
              let t = s[e++];
              let i = s[e++];
              if (r >= t && r <= i) {
                a.charcode = r;
                a.length = n + 1;
                return;
              }
            }
          }
          a.charcode = 0;
          a.length = 1;
        }
        getCharCodeLength(e) {
          let t = this.codespaceRanges;
          for (function () {
            let a = 0;
            let r = t.length;
          }(); a < r; a++) {
            let r = t[a];
            for (function () {
              let t = 0;
              let i = r.length;
            }(); t < i;) {
              let i = r[t++];
              let n = r[t++];
              if (e >= i && e <= n) return a + 1;
            }
          }
          return 1;
        }
        get length() {
          return this._map.length;
        }
        get isIdentityCMap() {
          if (!("Identity-H" === this.name || "Identity-V" === this.name) || 65536 !== this._map.length) return !1;
          for (let e = 0; e < 65536; e++) if (this._map[e] !== e) return !1;
          return !0;
        }
      }
      t.CMap = h;
      class u extends h {
        constructor(e, t) {
          super();
          this.vertical = e;
          this.addCodespaceRange(t, 0, 65535);
        }
        mapCidRange(e, t, a) {
          r.unreachable("should not call mapCidRange");
        }
        mapBfRange(e, t, a) {
          r.unreachable("should not call mapBfRange");
        }
        mapBfRangeToArray(e, t, a) {
          r.unreachable("should not call mapBfRangeToArray");
        }
        mapOne(e, t) {
          r.unreachable("should not call mapCidOne");
        }
        lookup(e) {
          return Number.isInteger(e) && e <= 65535 ? e : void 0;
        }
        contains(e) {
          return Number.isInteger(e) && e <= 65535;
        }
        forEach(e) {
          for (let t = 0; t <= 65535; t++) e(t, t);
        }
        charCodeOf(e) {
          return Number.isInteger(e) && e <= 65535 ? e : -1;
        }
        getMap() {
          let e = Array(65536);
          for (let t = 0; t <= 65535; t++) e[t] = t;
          return e;
        }
        get length() {
          return 65536;
        }
        get isIdentityCMap() {
          r.unreachable("should not access .isIdentityCMap");
        }
      }
      t.IdentityCMap = u;
      let d = function () {
        function e(e, t) {
          let a = 0;
          for (let r = 0; r <= t; r++) a = a << 8 | e[r];
          return a >>> 0;
        }
        function t(e, t) {
          return 1 === t ? String.fromCharCode(e[0], e[1]) : 3 === t ? String.fromCharCode(e[0], e[1], e[2], e[3]) : String.fromCharCode.apply(null, e.subarray(0, t + 1));
        }
        function a(e, t, a) {
          let r = 0;
          for (let i = a; i >= 0; i--) {
            r += e[i] + t[i];
            e[i] = 255 & r;
            r >>= 8;
          }
        }
        function i(e, t) {
          let a = 1;
          for (let r = t; r >= 0 && a > 0; r--) {
            a += e[r];
            e[r] = 255 & a;
            a >>= 8;
          }
        }
        class n {
          constructor(e) {
            this.buffer = e;
            this.pos = 0;
            this.end = e.length;
            this.tmpBuf = new Uint8Array(19);
          }
          readByte() {
            return this.pos >= this.end ? -1 : this.buffer[this.pos++];
          }
          readNumber() {
            let e;
            let t = 0;
            do {
              let a = this.readByte();
              if (a < 0) throw new r.FormatError("unexpected EOF in bcmap");
              e = !(128 & a);
              t = t << 7 | 127 & a;
            } while (!e);
            return t;
          }
          readSigned() {
            let e = this.readNumber();
            return 1 & e ? ~(e >>> 1) : e >>> 1;
          }
          readHex(e, t) {
            e.set(this.buffer.subarray(this.pos, this.pos + t + 1));
            this.pos += t + 1;
          }
          readHexNumber(e, t) {
            let a;
            let i = this.tmpBuf;
            let n = 0;
            do {
              let e = this.readByte();
              if (e < 0) throw new r.FormatError("unexpected EOF in bcmap");
              a = !(128 & e);
              i[n++] = 127 & e;
            } while (!a);
            let s = t;
            let o = 0;
            let l = 0;
            for (; s >= 0;) {
              for (; l < 8 && i.length > 0;) {
                o |= i[--n] << l;
                l += 7;
              }
              e[s] = 255 & o;
              s--;
              o >>= 8;
              l -= 8;
            }
          }
          readHexSigned(e, t) {
            this.readHexNumber(e, t);
            let a = 1 & e[t] ? 255 : 0;
            let r = 0;
            for (let i = 0; i <= t; i++) {
              r = (1 & r) << 8 | e[i];
              e[i] = r >> 1 ^ a;
            }
          }
          readString() {
            let e = this.readNumber();
            let t = "";
            for (let a = 0; a < e; a++) t += String.fromCharCode(this.readNumber());
            return t;
          }
        }
        return class {
          async process(r, s, o) {
            let l;
            let c;
            let h = new n(r);
            let u = h.readByte();
            s.vertical = !!(1 & u);
            let d = null;
            let f = new Uint8Array(16);
            let g = new Uint8Array(16);
            let p = new Uint8Array(16);
            let m = new Uint8Array(16);
            let b = new Uint8Array(16);
            for (; (c = h.readByte()) >= 0;) {
              let r = c >> 5;
              if (7 === r) {
                switch (31 & c) {
                  case 0:
                    h.readString();
                    break;
                  case 1:
                    d = h.readString();
                }
                continue;
              }
              let n = !!(16 & c);
              let o = 15 & c;
              if (o + 1 > 16) throw Error("BinaryCMapReader.process: Invalid dataSize.");
              let u = h.readNumber();
              switch (r) {
                case 0:
                  h.readHex(f, o);
                  h.readHexNumber(g, o);
                  a(g, f, o);
                  s.addCodespaceRange(o + 1, e(f, o), e(g, o));
                  for (let t = 1; t < u; t++) {
                    i(g, o);
                    h.readHexNumber(f, o);
                    a(f, g, o);
                    h.readHexNumber(g, o);
                    a(g, f, o);
                    s.addCodespaceRange(o + 1, e(f, o), e(g, o));
                  }
                  break;
                case 1:
                  h.readHex(f, o);
                  h.readHexNumber(g, o);
                  a(g, f, o);
                  h.readNumber();
                  for (let e = 1; e < u; e++) {
                    i(g, o);
                    h.readHexNumber(f, o);
                    a(f, g, o);
                    h.readHexNumber(g, o);
                    a(g, f, o);
                    h.readNumber();
                  }
                  break;
                case 2:
                  h.readHex(p, o);
                  l = h.readNumber();
                  s.mapOne(e(p, o), l);
                  for (let t = 1; t < u; t++) {
                    i(p, o);
                    n || (h.readHexNumber(b, o), a(p, b, o));
                    l = h.readSigned() + (l + 1);
                    s.mapOne(e(p, o), l);
                  }
                  break;
                case 3:
                  h.readHex(f, o);
                  h.readHexNumber(g, o);
                  a(g, f, o);
                  l = h.readNumber();
                  s.mapCidRange(e(f, o), e(g, o), l);
                  for (let t = 1; t < u; t++) {
                    i(g, o);
                    n ? f.set(g) : (h.readHexNumber(f, o), a(f, g, o));
                    h.readHexNumber(g, o);
                    a(g, f, o);
                    l = h.readNumber();
                    s.mapCidRange(e(f, o), e(g, o), l);
                  }
                  break;
                case 4:
                  h.readHex(p, 1);
                  h.readHex(m, o);
                  s.mapOne(e(p, 1), t(m, o));
                  for (let r = 1; r < u; r++) {
                    i(p, 1);
                    n || (h.readHexNumber(b, 1), a(p, b, 1));
                    i(m, o);
                    h.readHexSigned(b, o);
                    a(m, b, o);
                    s.mapOne(e(p, 1), t(m, o));
                  }
                  break;
                case 5:
                  h.readHex(f, 1);
                  h.readHexNumber(g, 1);
                  a(g, f, 1);
                  h.readHex(m, o);
                  s.mapBfRange(e(f, 1), e(g, 1), t(m, o));
                  for (let r = 1; r < u; r++) {
                    i(g, 1);
                    n ? f.set(g) : (h.readHexNumber(f, 1), a(f, g, 1));
                    h.readHexNumber(g, 1);
                    a(g, f, 1);
                    h.readHex(m, o);
                    s.mapBfRange(e(f, 1), e(g, 1), t(m, o));
                  }
                  break;
                default:
                  throw Error(`BinaryCMapReader.process - unknown type: ${r}`);
              }
            }
            return d ? o(d) : s;
          }
        };
      }();
      let f = function () {
        function e(e) {
          let t = 0;
          for (let a = 0; a < e.length; a++) t = t << 8 | e.charCodeAt(a);
          return t >>> 0;
        }
        function t(e) {
          if ("string" != typeof e) throw new r.FormatError("Malformed CMap: expected string.");
        }
        function a(e) {
          if (!Number.isInteger(e)) throw new r.FormatError("Malformed CMap: expected int.");
        }
        async function f(n, s, l, c) {
          let h;
          let u;
          e: for (; ;) try {
            let o = s.getObj();
            if (o === i.EOF) break;
            if (o instanceof i.Name) {
              "WMode" === o.name ? function (e, t) {
                let a = t.getObj();
                Number.isInteger(a) && (e.vertical = !!a);
              }(n, s) : "CMapName" === o.name && function (e, t) {
                let a = t.getObj();
                a instanceof i.Name && (e.name = a.name);
              }(n, s);
              h = o;
            } else if (o instanceof i.Cmd) switch (o.cmd) {
              case "endcmap":
                break e;
              case "usecmap":
                h instanceof i.Name && (u = h.name);
                break;
              case "begincodespacerange":
                !function (t, a) {
                  for (; ;) {
                    let r = a.getObj();
                    if (r === i.EOF) break;
                    if (i.isCmd(r, "endcodespacerange")) return;
                    if ("string" != typeof r) break;
                    let n = e(r);
                    if ("string" != typeof (r = a.getObj())) break;
                    let s = e(r);
                    t.addCodespaceRange(r.length, n, s);
                  }
                  throw new r.FormatError("Invalid codespace range.");
                }(n, s);
                break;
              case "beginbfchar":
                !function (a, r) {
                  for (; ;) {
                    let n = r.getObj();
                    if (n === i.EOF) break;
                    if (i.isCmd(n, "endbfchar")) return;
                    t(n);
                    let s = e(n);
                    t(n = r.getObj());
                    let o = n;
                    a.mapOne(s, o);
                  }
                }(n, s);
                break;
              case "begincidchar":
                !function (r, n) {
                  for (; ;) {
                    let s = n.getObj();
                    if (s === i.EOF) break;
                    if (i.isCmd(s, "endcidchar")) return;
                    t(s);
                    let o = e(s);
                    a(s = n.getObj());
                    let l = s;
                    r.mapOne(o, l);
                  }
                }(n, s);
                break;
              case "beginbfrange":
                !function (a, n) {
                  for (; ;) {
                    let r = n.getObj();
                    if (r === i.EOF) break;
                    if (i.isCmd(r, "endbfrange")) return;
                    t(r);
                    let s = e(r);
                    t(r = n.getObj());
                    let o = e(r);
                    if (Number.isInteger(r = n.getObj()) || "string" == typeof r) {
                      let e = Number.isInteger(r) ? String.fromCharCode(r) : r;
                      a.mapBfRange(s, o, e);
                    } else if (i.isCmd(r, "[")) {
                      r = n.getObj();
                      let e = [];
                      for (; !i.isCmd(r, "]") && r !== i.EOF;) {
                        e.push(r);
                        r = n.getObj();
                      }
                      a.mapBfRangeToArray(s, o, e);
                    } else break;
                  }
                  throw new r.FormatError("Invalid bf range.");
                }(n, s);
                break;
              case "begincidrange":
                !function (r, n) {
                  for (; ;) {
                    let s = n.getObj();
                    if (s === i.EOF) break;
                    if (i.isCmd(s, "endcidrange")) return;
                    t(s);
                    let o = e(s);
                    t(s = n.getObj());
                    let l = e(s);
                    a(s = n.getObj());
                    let c = s;
                    r.mapCidRange(o, l, c);
                  }
                }(n, s);
            }
          } catch (e) {
            if (e instanceof o.MissingDataException) throw e;
            r.warn("Invalid cMap data: " + e);
            continue;
          }
          return (!c && u && (c = u), c) ? g(n, l, c) : n;
        }
        async function g(e, t, a) {
          if (e.useCMap = await p(a, t), 0 === e.numCodespaceRanges) {
            let t = e.useCMap.codespaceRanges;
            for (let a = 0; a < t.length; a++) e.codespaceRanges[a] = t[a].slice();
            e.numCodespaceRanges = e.useCMap.numCodespaceRanges;
          }
          e.useCMap.forEach(function (t, a) {
            e.contains(t) || e.mapOne(t, e.useCMap.lookup(t));
          });
          return e;
        }
        async function p(e, t) {
          if ("Identity-H" === e) return new u(!1, 2);
          if ("Identity-V" === e) return new u(!0, 2);
          if (!c.includes(e)) throw Error("Unknown CMap name: " + e);
          if (!t) throw Error("Built-in CMap parameters are not provided.");
          let {
            cMapData,
            compressionType
          } = await t(e);
          let n = new h(!0);
          if (compressionType === r.CMapCompressionType.BINARY) return new d().process(cMapData, n, e => g(n, t, e));
          if (compressionType === r.CMapCompressionType.NONE) return f(n, new s.Lexer(new l.Stream(cMapData)), t, null);
          throw Error("TODO: Only BINARY/NONE CMap compression is currently supported.");
        }
        return {
          async create(e) {
            let t = e.encoding;
            let a = e.fetchBuiltInCMap;
            let r = e.useCMap;
            if (t instanceof i.Name) return p(t.name, a);
            if (t instanceof n.BaseStream) {
              let e = await f(new h(), new s.Lexer(t), a, r);
              return e.isIdentityCMap ? p(e.name, a) : e;
            }
            throw Error("Encoding required.");
          }
        };
      }();
      t.CMapFactory = f;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.Parser = t.Linearization = t.Lexer = void 0;
      var r = a(2);
      var i = a(5);
      var n = a(8);
      var s = a(28);
      var o = a(30);
      var l = a(31);
      var c = a(33);
      var h = a(34);
      var u = a(37);
      var d = a(39);
      var f = a(41);
      var g = a(10);
      var p = a(42);
      var m = a(43);
      function b(e) {
        let t = e.length;
        let a = 1;
        let r = 0;
        for (let i = 0; i < t; ++i) {
          a += 255 & e[i];
          r += a;
        }
        return r % 65521 << 16 | a % 65521;
      }
      class y {
        constructor({
          lexer: e,
          xref: t,
          allowStreams: a = !1,
          recoveryMode: r = !1
        }) {
          this.lexer = e;
          this.xref = t;
          this.allowStreams = a;
          this.recoveryMode = r;
          this.imageCache = Object.create(null);
          this.refill();
        }
        refill() {
          this.buf1 = this.lexer.getObj();
          this.buf2 = this.lexer.getObj();
        }
        shift() {
          this.buf2 instanceof i.Cmd && "ID" === this.buf2.cmd ? (this.buf1 = this.buf2, this.buf2 = null) : (this.buf1 = this.buf2, this.buf2 = this.lexer.getObj());
        }
        tryShift() {
          try {
            this.shift();
            return !0;
          } catch (e) {
            if (e instanceof n.MissingDataException) throw e;
            return !1;
          }
        }
        getObj(e = null) {
          let t = this.buf1;
          if (this.shift(), t instanceof i.Cmd) switch (t.cmd) {
            case "BI":
              return this.makeInlineImage(e);
            case "[":
              let a = [];
              for (; !i.isCmd(this.buf1, "]") && this.buf1 !== i.EOF;) a.push(this.getObj(e));
              if (this.buf1 === i.EOF) {
                if (this.recoveryMode) return a;
                throw new n.ParserEOFException("End of file inside array.");
              }
              this.shift();
              return a;
            case "<<":
              let s = new i.Dict(this.xref);
              for (; !i.isCmd(this.buf1, ">>") && this.buf1 !== i.EOF;) {
                if (!(this.buf1 instanceof i.Name)) {
                  r.info("Malformed dictionary: key must be a name object");
                  this.shift();
                  continue;
                }
                let t = this.buf1.name;
                if (this.shift(), this.buf1 === i.EOF) break;
                s.set(t, this.getObj(e));
              }
              if (this.buf1 === i.EOF) {
                if (this.recoveryMode) return s;
                throw new n.ParserEOFException("End of file inside dictionary.");
              }
              if (i.isCmd(this.buf2, "stream")) return this.allowStreams ? this.makeStream(s, e) : s;
              this.shift();
              return s;
            default:
              return t;
          }
          if (Number.isInteger(t)) {
            if (Number.isInteger(this.buf1) && i.isCmd(this.buf2, "R")) {
              let e = i.Ref.get(t, this.buf1);
              this.shift();
              this.shift();
              return e;
            }
            return t;
          }
          return "string" == typeof t && e ? e.decryptString(t) : t;
        }
        findDefaultInlineStreamEnd(e) {
          let t = this.lexer;
          let a = e.pos;
          let s = 0;
          let o;
          let l;
          for (; -1 !== (o = e.getByte());) if (0 === s) s = 69 === o ? 1 : 0; else if (1 === s) s = 73 === o ? 2 : 0; else if (r.assert(2 === s, "findDefaultInlineStreamEnd - invalid state."), 32 === o || 10 === o || 13 === o) {
            l = e.pos;
            let a = e.peekBytes(10);
            for (function () {
              let e = 0;
              let t = a.length;
            }(); e < t; e++) if ((0 !== (o = a[e]) || 0 === a[e + 1]) && 10 !== o && 13 !== o && (o < 32 || o > 127)) {
              s = 0;
              break;
            }
            if (2 !== s) continue;
            if (t.knownCommands) {
              let e = t.peekObj();
              e instanceof i.Cmd && !t.knownCommands[e.cmd] && (s = 0);
            } else r.warn("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
            if (2 === s) break;
          } else s = 0;
          -1 === o && (r.warn("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker"), l && (r.warn('... trying to recover by using the last "EI" occurrence.'), e.skip(-(e.pos - l))));
          let c = 4;
          e.skip(-c);
          o = e.peekByte();
          e.skip(c);
          !n.isWhiteSpace(o) && c--;
          return e.pos - c - a;
        }
        findDCTDecodeInlineStreamEnd(e) {
          let t = e.pos;
          let a = !1;
          let i;
          let n;
          for (; -1 !== (i = e.getByte());) if (255 === i) {
            switch (e.getByte()) {
              case 0:
                break;
              case 255:
                e.skip(-1);
                break;
              case 217:
                a = !0;
                break;
              case 192:
              case 193:
              case 194:
              case 195:
              case 197:
              case 198:
              case 199:
              case 201:
              case 202:
              case 203:
              case 205:
              case 206:
              case 207:
              case 196:
              case 204:
              case 218:
              case 219:
              case 220:
              case 221:
              case 222:
              case 223:
              case 224:
              case 225:
              case 226:
              case 227:
              case 228:
              case 229:
              case 230:
              case 231:
              case 232:
              case 233:
              case 234:
              case 235:
              case 236:
              case 237:
              case 238:
              case 239:
              case 254:
                (n = e.getUint16()) > 2 ? e.skip(n - 2) : e.skip(-2);
            }
            if (a) break;
          }
          let s = e.pos - t;
          return -1 === i ? (r.warn("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead."), e.skip(-s), this.findDefaultInlineStreamEnd(e)) : (this.inlineStreamSkipEI(e), s);
        }
        findASCII85DecodeInlineStreamEnd(e) {
          let t;
          let a = e.pos;
          for (; -1 !== (t = e.getByte());) if (126 === t) {
            let a = e.pos;
            for (t = e.peekByte(); n.isWhiteSpace(t);) {
              e.skip();
              t = e.peekByte();
            }
            if (62 === t) {
              e.skip();
              break;
            }
            if (e.pos > a) {
              let t = e.peekBytes(2);
              if (69 === t[0] && 73 === t[1]) break;
            }
          }
          let i = e.pos - a;
          return -1 === t ? (r.warn("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead."), e.skip(-i), this.findDefaultInlineStreamEnd(e)) : (this.inlineStreamSkipEI(e), i);
        }
        findASCIIHexDecodeInlineStreamEnd(e) {
          let t;
          let a = e.pos;
          for (; -1 !== (t = e.getByte()) && 62 !== t;);
          let i = e.pos - a;
          return -1 === t ? (r.warn("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead."), e.skip(-i), this.findDefaultInlineStreamEnd(e)) : (this.inlineStreamSkipEI(e), i);
        }
        inlineStreamSkipEI(e) {
          let t = 0;
          let a;
          for (; -1 !== (a = e.getByte());) if (0 === t) t = 69 === a ? 1 : 0; else if (1 === t) t = 73 === a ? 2 : 0; else if (2 === t) break;
        }
        makeInlineImage(e) {
          let t;
          let a;
          let n;
          let s;
          let o = this.lexer;
          let l = o.stream;
          let c = new i.Dict(this.xref);
          for (; !i.isCmd(this.buf1, "ID") && this.buf1 !== i.EOF;) {
            if (!(this.buf1 instanceof i.Name)) throw new r.FormatError("Dictionary key must be a name object");
            let t = this.buf1.name;
            if (this.shift(), this.buf1 === i.EOF) break;
            c.set(t, this.getObj(e));
          }
          -1 !== o.beginInlineImagePos && (t = l.pos - o.beginInlineImagePos);
          let h = c.get("F", "Filter");
          if (h instanceof i.Name) a = h.name; else if (Array.isArray(h)) {
            let e = this.xref.fetchIfRef(h[0]);
            e instanceof i.Name && (a = e.name);
          }
          let u = l.pos;
          switch (a) {
            case "DCT":
            case "DCTDecode":
              n = this.findDCTDecodeInlineStreamEnd(l);
              break;
            case "A85":
            case "ASCII85Decode":
              n = this.findASCII85DecodeInlineStreamEnd(l);
              break;
            case "AHx":
            case "ASCIIHexDecode":
              n = this.findASCIIHexDecodeInlineStreamEnd(l);
              break;
            default:
              n = this.findDefaultInlineStreamEnd(l);
          }
          let d = l.makeSubStream(u, n, c);
          if (n < 1e3 && t < 5552) {
            let e = d.getBytes();
            d.reset();
            let a = l.pos;
            l.pos = o.beginInlineImagePos;
            let r = l.getBytes(t);
            l.pos = a;
            s = b(e) + "_" + b(r);
            let n = this.imageCache[s];
            if (void 0 !== n) {
              this.buf2 = i.Cmd.get("EI");
              this.shift();
              n.reset();
              return n;
            }
          }
          e && (d = e.createStream(d, n));
          (d = this.filter(d, c, n)).dict = c;
          void 0 !== s && (d.cacheKey = `inline_${n}_${s}`, this.imageCache[s] = d);
          this.buf2 = i.Cmd.get("EI");
          this.shift();
          return d;
        }
        _findStreamLength(e, t) {
          let {
            stream
          } = this.lexer;
          stream.pos = e;
          let r = t.length;
          for (; stream.pos < stream.end;) {
            let i = stream.peekBytes(2048);
            let n = i.length - r;
            if (n <= 0) break;
            let s = 0;
            for (; s < n;) {
              let n = 0;
              for (; n < r && i[s + n] === t[n];) n++;
              if (n >= r) {
                stream.pos += s;
                return stream.pos - e;
              }
              s++;
            }
            stream.pos += n;
          }
          return -1;
        }
        makeStream(e, t) {
          let a = this.lexer;
          let s = a.stream;
          a.skipToNextLine();
          let o = s.pos - 1;
          let l = e.get("Length");
          if (Number.isInteger(l) || (r.info(`Bad length "${l && l.toString()}" in stream.`), l = 0), s.pos = o + l, a.nextChar(), this.tryShift() && i.isCmd(this.buf2, "endstream")) this.shift(); else {
            let e = new Uint8Array([101, 110, 100, 115, 116, 114, 101, 97, 109]);
            let t = this._findStreamLength(o, e);
            if (t < 0) {
              for (let a = 1; a <= 1; a++) {
                let i = e.length - a;
                let l = e.slice(0, i);
                let c = this._findStreamLength(o, l);
                if (c >= 0) {
                  let e = s.peekBytes(i + 1)[i];
                  if (!n.isWhiteSpace(e)) break;
                  r.info(`Found "${r.bytesToString(l)}" when searching for endstream command.`);
                  t = c;
                  break;
                }
              }
              if (t < 0) throw new r.FormatError("Missing endstream command.");
            }
            l = t;
            a.nextChar();
            this.shift();
            this.shift();
          }
          this.shift();
          s = s.makeSubStream(o, l, e);
          t && (s = t.createStream(s, l));
          (s = this.filter(s, e, l)).dict = e;
          return s;
        }
        filter(e, t, a) {
          let n = t.get("F", "Filter");
          let s = t.get("DP", "DecodeParms");
          if (n instanceof i.Name) {
            Array.isArray(s) && r.warn("/DecodeParms should not be an Array, when /Filter is a Name.");
            return this.makeFilter(e, n.name, a, s);
          }
          let o = a;
          if (Array.isArray(n)) {
            let t = n;
            let a = s;
            for (function () {
              let l = 0;
              let c = t.length;
            }(); l < c; ++l) {
              if (!((n = this.xref.fetchIfRef(t[l])) instanceof i.Name)) throw new r.FormatError(`Bad filter name "${n}"`);
              s = null;
              Array.isArray(a) && l in a && (s = this.xref.fetchIfRef(a[l]));
              e = this.makeFilter(e, n.name, o, s);
              o = null;
            }
          }
          return e;
        }
        makeFilter(e, t, a, i) {
          if (0 === a) {
            r.warn(`Empty "${t}" stream.`);
            return new g.NullStream();
          }
          let b = this.xref.stats;
          try {
            switch (t) {
              case "Fl":
              case "FlateDecode":
                if (b.addStreamType(r.StreamType.FLATE), i) return new p.PredictorStream(new c.FlateStream(e, a), a, i);
                return new c.FlateStream(e, a);
              case "LZW":
              case "LZWDecode":
                b.addStreamType(r.StreamType.LZW);
                let n = 1;
                if (i) {
                  i.has("EarlyChange") && (n = i.get("EarlyChange"));
                  return new p.PredictorStream(new f.LZWStream(e, a, n), a, i);
                }
                return new f.LZWStream(e, a, n);
              case "DCT":
              case "DCTDecode":
                b.addStreamType(r.StreamType.DCT);
                return new u.JpegStream(e, a, i);
              case "JPX":
              case "JPXDecode":
                b.addStreamType(r.StreamType.JPX);
                return new d.JpxStream(e, a, i);
              case "A85":
              case "ASCII85Decode":
                b.addStreamType(r.StreamType.A85);
                return new s.Ascii85Stream(e, a);
              case "AHx":
              case "ASCIIHexDecode":
                b.addStreamType(r.StreamType.AHX);
                return new o.AsciiHexStream(e, a);
              case "CCF":
              case "CCITTFaxDecode":
                b.addStreamType(r.StreamType.CCF);
                return new l.CCITTFaxStream(e, a, i);
              case "RL":
              case "RunLengthDecode":
                b.addStreamType(r.StreamType.RLX);
                return new m.RunLengthStream(e, a);
              case "JBIG2Decode":
                b.addStreamType(r.StreamType.JBIG);
                return new h.Jbig2Stream(e, a, i);
            }
            r.warn(`Filter "${t}" is not supported.`);
            return e;
          } catch (e) {
            if (e instanceof n.MissingDataException) throw e;
            r.warn(`Invalid stream: "${e}"`);
            return new g.NullStream();
          }
        }
      }
      t.Parser = y;
      let w = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      function x(e) {
        return e >= 48 && e <= 57 ? 15 & e : e >= 65 && e <= 70 || e >= 97 && e <= 102 ? (15 & e) + 9 : -1;
      }
      class S {
        constructor(e, t = null) {
          this.stream = e;
          this.nextChar();
          this.strBuf = [];
          this.knownCommands = t;
          this._hexStringNumWarn = 0;
          this.beginInlineImagePos = -1;
        }
        nextChar() {
          return this.currentChar = this.stream.getByte();
        }
        peekChar() {
          return this.stream.peekByte();
        }
        getNumber() {
          let e = this.currentChar;
          let t = !1;
          let a = 0;
          let i = 0;
          if (45 === e ? (i = -1, 45 === (e = this.nextChar()) && (e = this.nextChar())) : 43 === e && (i = 1, e = this.nextChar()), 10 === e || 13 === e) do e = this.nextChar(); while (10 === e || 13 === e);
          if (46 === e && (a = 10, e = this.nextChar()), e < 48 || e > 57) {
            if (n.isWhiteSpace(e) || -1 === e) {
              if (10 === a && 0 === i) {
                r.warn("Lexer.getNumber - treating a single decimal point as zero.");
                return 0;
              }
              if (0 === a && -1 === i) {
                r.warn("Lexer.getNumber - treating a single minus sign as zero.");
                return 0;
              }
            }
            throw new r.FormatError(`Invalid number: ${String.fromCharCode(e)} (charCode ${e})`);
          }
          i = i || 1;
          let s = e - 48;
          let o = 0;
          let l = 1;
          for (; (e = this.nextChar()) >= 0;) if (e >= 48 && e <= 57) {
            let r = e - 48;
            t ? o = 10 * o + r : (0 !== a && (a *= 10), s = 10 * s + r);
          } else if (46 === e) {
            if (0 === a) a = 1; else break;
          } else if (45 === e) r.warn("Badly formatted number: minus sign in the middle"); else if (69 === e || 101 === e) {
            if (43 === (e = this.peekChar()) || 45 === e) {
              l = 45 === e ? -1 : 1;
              this.nextChar();
            } else if (e < 48 || e > 57) break;
            t = !0;
          } else break;
          0 !== a && (s /= a);
          t && (s *= 10 ** (l * o));
          return i * s;
        }
        getString() {
          let e = 1;
          let t = !1;
          let a = this.strBuf;
          a.length = 0;
          let i = this.nextChar();
          for (; ;) {
            let n = !1;
            switch (0 | i) {
              case -1:
                r.warn("Unterminated string");
                t = !0;
                break;
              case 40:
                ++e;
                a.push("(");
                break;
              case 41:
                0 == --e ? (this.nextChar(), t = !0) : a.push(")");
                break;
              case 92:
                switch (i = this.nextChar()) {
                  case -1:
                    r.warn("Unterminated string");
                    t = !0;
                    break;
                  case 110:
                    a.push("\n");
                    break;
                  case 114:
                    a.push("\r");
                    break;
                  case 116:
                    a.push("	");
                    break;
                  case 98:
                    a.push("\b");
                    break;
                  case 102:
                    a.push("\f");
                    break;
                  case 92:
                  case 40:
                  case 41:
                  default:
                    a.push(String.fromCharCode(i));
                    break;
                  case 48:
                  case 49:
                  case 50:
                  case 51:
                  case 52:
                  case 53:
                  case 54:
                  case 55:
                    let s = 15 & i;
                    i = this.nextChar();
                    n = !0;
                    i >= 48 && i <= 55 && (s = (s << 3) + (15 & i), (i = this.nextChar()) >= 48 && i <= 55 && (n = !1, s = (s << 3) + (15 & i)));
                    a.push(String.fromCharCode(s));
                    break;
                  case 13:
                    10 === this.peekChar() && this.nextChar();
                  case 10:
                }
                break;
              default:
                a.push(String.fromCharCode(i));
            }
            if (t) break;
            n || (i = this.nextChar());
          }
          return a.join("");
        }
        getName() {
          let e;
          let t;
          let a = this.strBuf;
          for (a.length = 0; (e = this.nextChar()) >= 0 && !w[e];) if (35 === e) {
            if (w[e = this.nextChar()]) {
              r.warn("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number.");
              a.push("#");
              break;
            }
            let i = x(e);
            if (-1 !== i) {
              t = e;
              let n = x(e = this.nextChar());
              if (-1 === n) {
                if (r.warn(`Lexer_getName: Illegal digit (${String.fromCharCode(e)}) in hexadecimal number.`), a.push("#", String.fromCharCode(t)), w[e]) break;
                a.push(String.fromCharCode(e));
                continue;
              }
              a.push(String.fromCharCode(i << 4 | n));
            } else a.push("#", String.fromCharCode(e));
          } else a.push(String.fromCharCode(e));
          a.length > 127 && r.warn(`Name token is longer than allowed by the spec: ${a.length}`);
          return i.Name.get(a.join(""));
        }
        _hexStringWarn(e) {
          if (5 == this._hexStringNumWarn++) {
            r.warn("getHexString - ignoring additional invalid characters.");
            return;
          }
          this._hexStringNumWarn > 5 || r.warn(`getHexString - ignoring invalid character: ${e}`);
        }
        getHexString() {
          let e;
          let t;
          let a = this.strBuf;
          a.length = 0;
          let i = this.currentChar;
          let n = !0;
          for (this._hexStringNumWarn = 0; ;) {
            if (i < 0) {
              r.warn("Unterminated hex string");
              break;
            }
            if (62 === i) {
              this.nextChar();
              break;
            }
            if (1 === w[i]) {
              i = this.nextChar();
              continue;
            }
            if (n) {
              if (-1 === (e = x(i))) {
                this._hexStringWarn(i);
                i = this.nextChar();
                continue;
              }
            } else {
              if (-1 === (t = x(i))) {
                this._hexStringWarn(i);
                i = this.nextChar();
                continue;
              }
              a.push(String.fromCharCode(e << 4 | t));
            }
            n = !n;
            i = this.nextChar();
          }
          return a.join("");
        }
        getObj() {
          let e = !1;
          let t = this.currentChar;
          for (; ;) {
            if (t < 0) return i.EOF;
            if (e) (10 === t || 13 === t) && (e = !1); else if (37 === t) e = !0; else if (1 !== w[t]) break;
            t = this.nextChar();
          }
          switch (0 | t) {
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 43:
            case 45:
            case 46:
              return this.getNumber();
            case 40:
              return this.getString();
            case 47:
              return this.getName();
            case 91:
              this.nextChar();
              return i.Cmd.get("[");
            case 93:
              this.nextChar();
              return i.Cmd.get("]");
            case 60:
              if (60 === (t = this.nextChar())) {
                this.nextChar();
                return i.Cmd.get("<<");
              }
              return this.getHexString();
            case 62:
              if (62 === (t = this.nextChar())) {
                this.nextChar();
                return i.Cmd.get(">>");
              }
              return i.Cmd.get(">");
            case 123:
              this.nextChar();
              return i.Cmd.get("{");
            case 125:
              this.nextChar();
              return i.Cmd.get("}");
            case 41:
              this.nextChar();
              return new r.FormatError(`Illegal character: ${t}`);
          }
          let a = String.fromCharCode(t);
          if (t < 32 || t > 127) {
            let e = this.peekChar();
            if (e >= 32 && e <= 127) {
              this.nextChar();
              return i.Cmd.get(a);
            }
          }
          let n = this.knownCommands;
          let s = n && void 0 !== n[a];
          for (; (t = this.nextChar()) >= 0 && !w[t];) {
            let e = a + String.fromCharCode(t);
            if (s && void 0 === n[e]) break;
            if (128 === a.length) throw new r.FormatError(`Command token too long: ${a.length}`);
            a = e;
            s = n && void 0 !== n[a];
          }
          return "true" === a || "false" !== a && ("null" === a ? null : ("BI" === a && (this.beginInlineImagePos = this.stream.pos), i.Cmd.get(a)));
        }
        peekObj() {
          let e;
          let t = this.stream.pos;
          let a = this.currentChar;
          let i = this.beginInlineImagePos;
          try {
            e = this.getObj();
          } catch (e) {
            if (e instanceof n.MissingDataException) throw e;
            r.warn(`peekObj: ${e}`);
          }
          this.stream.pos = t;
          this.currentChar = a;
          this.beginInlineImagePos = i;
          return e;
        }
        skipToNextLine() {
          let e = this.currentChar;
          for (; e >= 0;) {
            if (13 === e) {
              10 === (e = this.nextChar()) && this.nextChar();
              break;
            }
            if (10 === e) {
              this.nextChar();
              break;
            }
            e = this.nextChar();
          }
        }
      }
      t.Lexer = S;
      t.Linearization = class {
        static create(e) {
          let t;
          let a;
          function r(e, t, a = !1) {
            let i = e.get(t);
            if (Number.isInteger(i) && (a ? i >= 0 : i > 0)) return i;
            throw Error(`The "${t}" parameter in the linearization dictionary is invalid.`);
          }
          let n = new y({
            lexer: new S(e),
            xref: null
          });
          let s = n.getObj();
          let o = n.getObj();
          let l = n.getObj();
          let c = n.getObj();
          if (!(Number.isInteger(s) && Number.isInteger(o) && i.isCmd(l, "obj") && c instanceof i.Dict && "number" == typeof (t = c.get("Linearized")) && t > 0)) return null;
          if ((a = r(c, "L")) !== e.length) throw Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
          return {
            length: a,
            hints: function (e) {
              let t;
              let a = e.get("H");
              if (Array.isArray(a) && (2 === (t = a.length) || 4 === t)) {
                for (let e = 0; e < t; e++) {
                  let t = a[e];
                  if (!(Number.isInteger(t) && t > 0)) throw Error(`Hint (${e}) in the linearization dictionary is invalid.`);
                }
                return a;
              }
              throw Error("Hint array in the linearization dictionary is invalid.");
            }(c),
            objectNumberFirst: r(c, "O"),
            endFirst: r(c, "E"),
            numPages: r(c, "N"),
            mainXRefEntriesOffset: r(c, "T"),
            pageFirst: c.has("P") ? r(c, "P", !0) : 0
          };
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.Ascii85Stream = void 0;
      var r = a(29);
      var i = a(8);
      class n extends r.DecodeStream {
        constructor(e, t) {
          t && (t *= .8);
          super(t);
          this.str = e;
          this.dict = e.dict;
          this.input = new Uint8Array(5);
        }
        readBlock() {
          let e;
          let t;
          let a = this.str;
          let r = a.getByte();
          for (; i.isWhiteSpace(r);) r = a.getByte();
          if (-1 === r || 126 === r) {
            this.eof = !0;
            return;
          }
          let n = this.bufferLength;
          if (122 === r) {
            for (t = 0, e = this.ensureBuffer(n + 4); t < 4; ++t) e[n + t] = 0;
            this.bufferLength += 4;
          } else {
            let s = this.input;
            for (t = 1, s[0] = r; t < 5; ++t) {
              for (r = a.getByte(); i.isWhiteSpace(r);) r = a.getByte();
              if (s[t] = r, -1 === r || 126 === r) break;
            }
            if (e = this.ensureBuffer(n + t - 1), this.bufferLength += t - 1, t < 5) {
              for (; t < 5; ++t) s[t] = 117;
              this.eof = !0;
            }
            let o = 0;
            for (t = 0; t < 5; ++t) o = 85 * o + (s[t] - 33);
            for (t = 3; t >= 0; --t) {
              e[n + t] = 255 & o;
              o >>= 8;
            }
          }
        }
      }
      t.Ascii85Stream = n;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.StreamsSequenceStream = t.DecodeStream = void 0;
      var r = a(9);
      var i = a(10);
      let n = new Uint8Array(0);
      class s extends r.BaseStream {
        constructor(e) {
          this._rawMinBufferLength = e || 0;
          this.pos = 0;
          this.bufferLength = 0;
          this.eof = !1;
          this.buffer = n;
          this.minBufferLength = 512;
          if (super(), e) for (; this.minBufferLength < e;) this.minBufferLength *= 2;
        }
        get isEmpty() {
          for (; !this.eof && 0 === this.bufferLength;) this.readBlock();
          return 0 === this.bufferLength;
        }
        ensureBuffer(e) {
          let t = this.buffer;
          if (e <= t.byteLength) return t;
          let a = this.minBufferLength;
          for (; a < e;) a *= 2;
          let r = new Uint8Array(a);
          r.set(t);
          return this.buffer = r;
        }
        getByte() {
          let e = this.pos;
          for (; this.bufferLength <= e;) {
            if (this.eof) return -1;
            this.readBlock();
          }
          return this.buffer[this.pos++];
        }
        getBytes(e, t = !1) {
          let a;
          let r = this.pos;
          if (e) {
            for (this.ensureBuffer(r + e), a = r + e; !this.eof && this.bufferLength < a;) this.readBlock();
            let t = this.bufferLength;
            a > t && (a = t);
          } else {
            for (; !this.eof;) this.readBlock();
            a = this.bufferLength;
          }
          this.pos = a;
          let i = this.buffer.subarray(r, a);
          return !t || i instanceof Uint8ClampedArray ? i : new Uint8ClampedArray(i);
        }
        reset() {
          this.pos = 0;
        }
        makeSubStream(e, t, a = null) {
          if (void 0 === t) for (; !this.eof;) this.readBlock(); else {
            let a = e + t;
            for (; this.bufferLength <= a && !this.eof;) this.readBlock();
          }
          return new i.Stream(this.buffer, e, t, a);
        }
        getBaseStreams() {
          return this.str ? this.str.getBaseStreams() : null;
        }
      }
      t.DecodeStream = s;
      t.StreamsSequenceStream = class extends s {
        constructor(e, t = null) {
          let a = 0;
          for (let t of e) a += t instanceof s ? t._rawMinBufferLength : t.length;
          super(a);
          this.streams = e;
          this._onError = t;
        }
        readBlock() {
          let e;
          let t = this.streams;
          if (0 === t.length) {
            this.eof = !0;
            return;
          }
          let a = t.shift();
          try {
            e = a.getBytes();
          } catch (e) {
            if (this._onError) {
              this._onError(e, a.dict && a.dict.objId);
              return;
            }
            throw e;
          }
          let r = this.bufferLength;
          let i = r + e.length;
          this.ensureBuffer(i).set(e, r);
          this.bufferLength = i;
        }
        getBaseStreams() {
          let e = [];
          for (let t of this.streams) {
            let a = t.getBaseStreams();
            a && e.push(...a);
          }
          return e.length > 0 ? e : null;
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.AsciiHexStream = void 0;
      var r = a(29);
      class i extends r.DecodeStream {
        constructor(e, t) {
          t && (t *= .5);
          super(t);
          this.str = e;
          this.dict = e.dict;
          this.firstDigit = -1;
        }
        readBlock() {
          let e = this.str.getBytes(8e3);
          if (!e.length) {
            this.eof = !0;
            return;
          }
          let t = e.length + 1 >> 1;
          let a = this.ensureBuffer(this.bufferLength + t);
          let r = this.bufferLength;
          let i = this.firstDigit;
          for (let t of e) {
            let e;
            if (t >= 48 && t <= 57) e = 15 & t; else if (t >= 65 && t <= 70 || t >= 97 && t <= 102) e = (15 & t) + 9; else {
              if (62 !== t) continue;
              this.eof = !0;
              break;
            }
            i < 0 ? i = e : (a[r++] = i << 4 | e, i = -1);
          }
          i >= 0 && this.eof && (a[r++] = i << 4, i = -1);
          this.firstDigit = i;
          this.bufferLength = r;
        }
      }
      t.AsciiHexStream = i;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.CCITTFaxStream = void 0;
      var r = a(32);
      var i = a(29);
      var n = a(5);
      class s extends i.DecodeStream {
        constructor(e, t, a) {
          super(t);
          this.str = e;
          this.dict = e.dict;
          a instanceof n.Dict || (a = n.Dict.empty);
          this.ccittFaxDecoder = new r.CCITTFaxDecoder({
            next: () => e.getByte()
          }, {
            K: a.get("K"),
            EndOfLine: a.get("EndOfLine"),
            EncodedByteAlign: a.get("EncodedByteAlign"),
            Columns: a.get("Columns"),
            Rows: a.get("Rows"),
            EndOfBlock: a.get("EndOfBlock"),
            BlackIs1: a.get("BlackIs1")
          });
        }
        readBlock() {
          for (; !this.eof;) {
            let e = this.ccittFaxDecoder.readNextChar();
            if (-1 === e) {
              this.eof = !0;
              return;
            }
            this.ensureBuffer(this.bufferLength + 1);
            this.buffer[this.bufferLength++] = e;
          }
        }
      }
      t.CCITTFaxStream = s;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.CCITTFaxDecoder = void 0;
      var r = a(2);
      let i = [[-1, -1], [-1, -1], [7, 8], [7, 7], [6, 6], [6, 6], [6, 5], [6, 5], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]];
      let n = [[-1, -1], [12, -2], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]];
      let s = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]];
      let o = [[-1, -1], [-1, -1], [12, -2], [12, -2], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]];
      let l = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]];
      let c = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
      t.CCITTFaxDecoder = class {
        constructor(e, t = {}) {
          let a;
          if (!e || "function" != typeof e.next) throw Error('CCITTFaxDecoder - invalid "source" parameter.');
          this.source = e;
          this.eof = !1;
          this.encoding = t.K || 0;
          this.eoline = t.EndOfLine || !1;
          this.byteAlign = t.EncodedByteAlign || !1;
          this.columns = t.Columns || 1728;
          this.rows = t.Rows || 0;
          let r = t.EndOfBlock;
          for (null == r && (r = !0), this.eoblock = r, this.black = t.BlackIs1 || !1, this.codingLine = new Uint32Array(this.columns + 1), this.refLine = new Uint32Array(this.columns + 2), this.codingLine[0] = this.columns, this.codingPos = 0, this.row = 0, this.nextLine2D = this.encoding < 0, this.inputBits = 0, this.inputBuf = 0, this.outputBits = 0, this.rowsDone = !1; 0 === (a = this._lookBits(12));) this._eatBits(1);
          1 === a && this._eatBits(12);
          this.encoding > 0 && (this.nextLine2D = !this._lookBits(1), this._eatBits(1));
        }
        readNextChar() {
          let e;
          let t;
          let a;
          let i;
          let n;
          if (this.eof) return -1;
          let s = this.refLine;
          let o = this.codingLine;
          let l = this.columns;
          if (0 === this.outputBits) {
            let a;
            let n;
            let c;
            if (this.rowsDone && (this.eof = !0), this.eof) return -1;
            if (this.err = !1, this.nextLine2D) {
              for (i = 0; o[i] < l; ++i) s[i] = o[i];
              for (s[i++] = l, s[i] = l, o[0] = 0, this.codingPos = 0, e = 0, t = 0; o[this.codingPos] < l;) switch (a = this._getTwoDimCode()) {
                case 0:
                  this._addPixels(s[e + 1], t);
                  s[e + 1] < l && (e += 2);
                  break;
                case 1:
                  if (a = n = 0, t) {
                    do a += c = this._getBlackCode(); while (c >= 64);
                    do n += c = this._getWhiteCode(); while (c >= 64);
                  } else {
                    do a += c = this._getWhiteCode(); while (c >= 64);
                    do n += c = this._getBlackCode(); while (c >= 64);
                  }
                  for (this._addPixels(o[this.codingPos] + a, t), o[this.codingPos] < l && this._addPixels(o[this.codingPos] + n, 1 ^ t); s[e] <= o[this.codingPos] && s[e] < l;) e += 2;
                  break;
                case 7:
                  if (this._addPixels(s[e] + 3, t), t ^= 1, o[this.codingPos] < l) for (++e; s[e] <= o[this.codingPos] && s[e] < l;) e += 2;
                  break;
                case 5:
                  if (this._addPixels(s[e] + 2, t), t ^= 1, o[this.codingPos] < l) for (++e; s[e] <= o[this.codingPos] && s[e] < l;) e += 2;
                  break;
                case 3:
                  if (this._addPixels(s[e] + 1, t), t ^= 1, o[this.codingPos] < l) for (++e; s[e] <= o[this.codingPos] && s[e] < l;) e += 2;
                  break;
                case 2:
                  if (this._addPixels(s[e], t), t ^= 1, o[this.codingPos] < l) for (++e; s[e] <= o[this.codingPos] && s[e] < l;) e += 2;
                  break;
                case 8:
                  if (this._addPixelsNeg(s[e] - 3, t), t ^= 1, o[this.codingPos] < l) for (e > 0 ? --e : ++e; s[e] <= o[this.codingPos] && s[e] < l;) e += 2;
                  break;
                case 6:
                  if (this._addPixelsNeg(s[e] - 2, t), t ^= 1, o[this.codingPos] < l) for (e > 0 ? --e : ++e; s[e] <= o[this.codingPos] && s[e] < l;) e += 2;
                  break;
                case 4:
                  if (this._addPixelsNeg(s[e] - 1, t), t ^= 1, o[this.codingPos] < l) for (e > 0 ? --e : ++e; s[e] <= o[this.codingPos] && s[e] < l;) e += 2;
                  break;
                case -1:
                  this._addPixels(l, 0);
                  this.eof = !0;
                  break;
                default:
                  r.info("bad 2d code");
                  this._addPixels(l, 0);
                  this.err = !0;
              }
            } else for (o[0] = 0, this.codingPos = 0, t = 0; o[this.codingPos] < l;) {
              if (a = 0, t) do a += c = this._getBlackCode(); while (c >= 64); else do a += c = this._getWhiteCode(); while (c >= 64);
              this._addPixels(o[this.codingPos] + a, t);
              t ^= 1;
            }
            let h = !1;
            if (this.byteAlign && (this.inputBits &= -8), this.eoblock || this.row !== this.rows - 1) {
              if (a = this._lookBits(12), this.eoline) for (; -1 !== a && 1 !== a;) {
                this._eatBits(1);
                a = this._lookBits(12);
              } else for (; 0 === a;) {
                this._eatBits(1);
                a = this._lookBits(12);
              }
              1 === a ? (this._eatBits(12), h = !0) : -1 === a && (this.eof = !0);
            } else this.rowsDone = !0;
            if (this.eof || !(this.encoding > 0) || this.rowsDone || (this.nextLine2D = !this._lookBits(1), this._eatBits(1)), this.eoblock && h && this.byteAlign) {
              if (1 === (a = this._lookBits(12))) {
                if (this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1)), this.encoding >= 0) for (i = 0; i < 4; ++i) {
                  1 !== (a = this._lookBits(12)) && r.info("bad rtc code: " + a);
                  this._eatBits(12);
                  this.encoding > 0 && (this._lookBits(1), this._eatBits(1));
                }
                this.eof = !0;
              }
            } else if (this.err && this.eoline) {
              for (; ;) {
                if (-1 === (a = this._lookBits(13))) {
                  this.eof = !0;
                  return -1;
                }
                if (a >> 1 == 1) break;
                this._eatBits(1);
              }
              this._eatBits(12);
              this.encoding > 0 && (this._eatBits(1), this.nextLine2D = !(1 & a));
            }
            o[0] > 0 ? this.outputBits = o[this.codingPos = 0] : this.outputBits = o[this.codingPos = 1];
            this.row++;
          }
          if (this.outputBits >= 8) {
            n = 1 & this.codingPos ? 0 : 255;
            this.outputBits -= 8;
            0 === this.outputBits && o[this.codingPos] < l && (this.codingPos++, this.outputBits = o[this.codingPos] - o[this.codingPos - 1]);
          } else {
            a = 8;
            n = 0;
            do {
              if ("number" != typeof this.outputBits) throw new r.FormatError('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
              this.outputBits > a ? (n <<= a, 1 & this.codingPos || (n |= 255 >> 8 - a), this.outputBits -= a, a = 0) : (n <<= this.outputBits, 1 & this.codingPos || (n |= 255 >> 8 - this.outputBits), a -= this.outputBits, this.outputBits = 0, o[this.codingPos] < l ? (this.codingPos++, this.outputBits = o[this.codingPos] - o[this.codingPos - 1]) : a > 0 && (n <<= a, a = 0));
            } while (a);
          }
          this.black && (n ^= 255);
          return n;
        }
        _addPixels(e, t) {
          let a = this.codingLine;
          let i = this.codingPos;
          e > a[i] && (e > this.columns && (r.info("row is wrong length"), this.err = !0, e = this.columns), 1 & i ^ t && ++i, a[i] = e);
          this.codingPos = i;
        }
        _addPixelsNeg(e, t) {
          let a = this.codingLine;
          let i = this.codingPos;
          if (e > a[i]) {
            e > this.columns && (r.info("row is wrong length"), this.err = !0, e = this.columns);
            1 & i ^ t && ++i;
            a[i] = e;
          } else if (e < a[i]) {
            for (e < 0 && (r.info("invalid code"), this.err = !0, e = 0); i > 0 && e < a[i - 1];) --i;
            a[i] = e;
          }
          this.codingPos = i;
        }
        _findTableCode(e, t, a, r) {
          let i = r || 0;
          for (let r = e; r <= t; ++r) {
            let e = this._lookBits(r);
            if (-1 === e) return [!0, 1, !1];
            if (r < t && (e <<= t - r), !i || e >= i) {
              let t = a[e - i];
              if (t[0] === r) {
                this._eatBits(r);
                return [!0, t[1], !0];
              }
            }
          }
          return [!1, 0, !1];
        }
        _getTwoDimCode() {
          let e;
          if (this.eoblock) {
            if ((e = i[this._lookBits(7)]) && e[0] > 0) {
              this._eatBits(e[0]);
              return e[1];
            }
          } else {
            let e = this._findTableCode(1, 7, i);
            if (e[0] && e[2]) return e[1];
          }
          r.info("Bad two dim code");
          return -1;
        }
        _getWhiteCode() {
          let e;
          let t = 0;
          if (this.eoblock) {
            if (-1 === (t = this._lookBits(12))) return 1;
            if ((e = t >> 5 == 0 ? n[t] : s[t >> 3])[0] > 0) {
              this._eatBits(e[0]);
              return e[1];
            }
          } else {
            let e = this._findTableCode(1, 9, s);
            if (e[0] || (e = this._findTableCode(11, 12, n))[0]) return e[1];
          }
          r.info("bad white code");
          this._eatBits(1);
          return 1;
        }
        _getBlackCode() {
          let e;
          let t;
          if (this.eoblock) {
            if (-1 === (e = this._lookBits(13))) return 1;
            if ((t = e >> 7 == 0 ? o[e] : e >> 9 == 0 && e >> 7 != 0 ? l[(e >> 1) - 64] : c[e >> 7])[0] > 0) {
              this._eatBits(t[0]);
              return t[1];
            }
          } else {
            let e = this._findTableCode(2, 6, c);
            if (e[0] || (e = this._findTableCode(7, 12, l, 64))[0] || (e = this._findTableCode(10, 13, o))[0]) return e[1];
          }
          r.info("bad black code");
          this._eatBits(1);
          return 1;
        }
        _lookBits(e) {
          let t;
          for (; this.inputBits < e;) {
            if (-1 === (t = this.source.next())) {
              if (0 === this.inputBits) return -1;
              return this.inputBuf << e - this.inputBits & 65535 >> 16 - e;
            }
            this.inputBuf = this.inputBuf << 8 | t;
            this.inputBits += 8;
          }
          return this.inputBuf >> this.inputBits - e & 65535 >> 16 - e;
        }
        _eatBits(e) {
          (this.inputBits -= e) < 0 && (this.inputBits = 0);
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.FlateStream = void 0;
      var r = a(29);
      var i = a(2);
      let n = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
      let s = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]);
      let o = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]);
      let l = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9];
      let c = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
      class h extends r.DecodeStream {
        constructor(e, t) {
          super(t);
          this.str = e;
          this.dict = e.dict;
          let a = e.getByte();
          let r = e.getByte();
          if (-1 === a || -1 === r) throw new i.FormatError(`Invalid header in flate stream: ${a}, ${r}`);
          if ((15 & a) != 8) throw new i.FormatError(`Unknown compression method in flate stream: ${a}, ${r}`);
          if (((a << 8) + r) % 31 != 0) throw new i.FormatError(`Bad FCHECK in flate stream: ${a}, ${r}`);
          if (32 & r) throw new i.FormatError(`FDICT bit set in flate stream: ${a}, ${r}`);
          this.codeSize = 0;
          this.codeBuf = 0;
        }
        getBits(e) {
          let t;
          let a = this.str;
          let r = this.codeSize;
          let n = this.codeBuf;
          for (; r < e;) {
            if (-1 === (t = a.getByte())) throw new i.FormatError("Bad encoding in flate stream");
            n |= t << r;
            r += 8;
          }
          t = n & (1 << e) - 1;
          this.codeBuf = n >> e;
          this.codeSize = r -= e;
          return t;
        }
        getCode(e) {
          let t;
          let a = this.str;
          let r = e[0];
          let n = e[1];
          let s = this.codeSize;
          let o = this.codeBuf;
          for (; s < n && -1 !== (t = a.getByte());) {
            o |= t << s;
            s += 8;
          }
          let l = r[o & (1 << n) - 1];
          let c = l >> 16;
          if (c < 1 || s < c) throw new i.FormatError("Bad encoding in flate stream");
          this.codeBuf = o >> c;
          this.codeSize = s - c;
          return 65535 & l;
        }
        generateHuffmanTable(e) {
          let t;
          let a = e.length;
          let r = 0;
          for (t = 0; t < a; ++t) e[t] > r && (r = e[t]);
          let i = 1 << r;
          let n = new Int32Array(i);
          for (function () {
            let s = 1;
            let o = 0;
            let l = 2;
          }(); s <= r; ++s, o <<= 1, l <<= 1) for (let r = 0; r < a; ++r) if (e[r] === s) {
            let e = 0;
            let a = o;
            for (t = 0; t < s; ++t) {
              e = e << 1 | 1 & a;
              a >>= 1;
            }
            for (t = e; t < i; t += l) n[t] = s << 16 | r;
            ++o;
          }
          return [n, r];
        }
        readBlock() {
          let e;
          let t;
          let a;
          let r;
          let h = this.str;
          let u = this.getBits(3);
          if (1 & u && (this.eof = !0), 0 == (u >>= 1)) {
            let t;
            if (-1 === (t = h.getByte())) throw new i.FormatError("Bad block header in flate stream");
            let a = t;
            if (-1 === (t = h.getByte()) || (a |= t << 8, -1 === (t = h.getByte()))) throw new i.FormatError("Bad block header in flate stream");
            let r = t;
            if (-1 === (t = h.getByte())) throw new i.FormatError("Bad block header in flate stream");
            if ((r |= t << 8) != (65535 & ~a) && (0 !== a || 0 !== r)) throw new i.FormatError("Bad uncompressed block length in flate stream");
            this.codeBuf = 0;
            this.codeSize = 0;
            let n = this.bufferLength;
            let s = n + a;
            if (e = this.ensureBuffer(s), this.bufferLength = s, 0 === a) -1 === h.peekByte() && (this.eof = !0); else {
              let t = h.getBytes(a);
              e.set(t, n);
              t.length < a && (this.eof = !0);
            }
            return;
          }
          if (1 === u) {
            a = l;
            r = c;
          } else if (2 === u) {
            let e;
            let i;
            let s;
            let o;
            let l = this.getBits(5) + 257;
            let c = this.getBits(5) + 1;
            let h = this.getBits(4) + 4;
            let u = new Uint8Array(n.length);
            for (e = 0; e < h; ++e) u[n[e]] = this.getBits(3);
            let d = this.generateHuffmanTable(u);
            t = 0;
            e = 0;
            let f = l + c;
            let g = new Uint8Array(f);
            for (; e < f;) {
              let a = this.getCode(d);
              if (16 === a) {
                i = 2;
                s = 3;
                o = t;
              } else if (17 === a) {
                i = 3;
                s = 3;
                o = t = 0;
              } else if (18 === a) {
                i = 7;
                s = 11;
                o = t = 0;
              } else {
                g[e++] = t = a;
                continue;
              }
              let r = this.getBits(i) + s;
              for (; r-- > 0;) g[e++] = o;
            }
            a = this.generateHuffmanTable(g.subarray(0, l));
            r = this.generateHuffmanTable(g.subarray(l, f));
          } else throw new i.FormatError("Unknown block type in flate stream");
          let d = (e = this.buffer) ? e.length : 0;
          let f = this.bufferLength;
          for (; ;) {
            let i = this.getCode(a);
            if (i < 256) {
              f + 1 >= d && (d = (e = this.ensureBuffer(f + 1)).length);
              e[f++] = i;
              continue;
            }
            if (256 === i) {
              this.bufferLength = f;
              return;
            }
            i -= 257;
            let n = (i = s[i]) >> 16;
            n > 0 && (n = this.getBits(n));
            t = (65535 & i) + n;
            (n = (i = o[i = this.getCode(r)]) >> 16) > 0 && (n = this.getBits(n));
            let l = (65535 & i) + n;
            f + t >= d && (d = (e = this.ensureBuffer(f + t)).length);
            for (let a = 0; a < t; ++a, ++f) e[f] = e[f - l];
          }
        }
      }
      t.FlateStream = h;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.Jbig2Stream = void 0;
      var r = a(9);
      var i = a(29);
      var n = a(5);
      var s = a(35);
      var o = a(2);
      class l extends i.DecodeStream {
        constructor(e, t, a) {
          super(t);
          this.stream = e;
          this.dict = e.dict;
          this.maybeLength = t;
          this.params = a;
        }
        get bytes() {
          return o.shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
        }
        ensureBuffer(e) { }
        readBlock() {
          if (this.eof) return;
          let e = new s.Jbig2Image();
          let t = [];
          if (this.params instanceof n.Dict) {
            let e = this.params.get("JBIG2Globals");
            if (e instanceof r.BaseStream) {
              let a = e.getBytes();
              t.push({
                data: a,
                start: 0,
                end: a.length
              });
            }
          }
          t.push({
            data: this.bytes,
            start: 0,
            end: this.bytes.length
          });
          let a = e.parseChunks(t);
          let i = a.length;
          for (let e = 0; e < i; e++) a[e] ^= 255;
          this.buffer = a;
          this.bufferLength = i;
          this.eof = !0;
        }
      }
      t.Jbig2Stream = l;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.Jbig2Image = void 0;
      var r = a(2);
      var i = a(8);
      var n = a(36);
      var s = a(32);
      class o extends r.BaseException {
        constructor(e) {
          super(`JBIG2 error: ${e}`, "Jbig2Error");
        }
      }
      class l {
        getContexts(e) {
          return e in this ? this[e] : this[e] = new Int8Array(65536);
        }
      }
      class c {
        constructor(e, t, a) {
          this.data = e;
          this.start = t;
          this.end = a;
        }
        get decoder() {
          let e = new n.ArithmeticDecoder(this.data, this.start, this.end);
          return r.shadow(this, "decoder", e);
        }
        get contextCache() {
          let e = new l();
          return r.shadow(this, "contextCache", e);
        }
      }
      function h(e, t, a) {
        let r = e.getContexts(t);
        let i = 1;
        function n(e) {
          let t = 0;
          for (let n = 0; n < e; n++) {
            let e = a.readBit(r, i);
            i = i < 256 ? i << 1 | e : (i << 1 | e) & 511 | 256;
            t = t << 1 | e;
          }
          return t >>> 0;
        }
        let s = n(1);
        let o = n(1) ? n(1) ? n(1) ? n(1) ? n(1) ? n(32) + 4436 : n(12) + 340 : n(8) + 84 : n(6) + 20 : n(4) + 4 : n(2);
        return 0 === s ? o : o > 0 ? -o : null;
      }
      function u(e, t, a) {
        let r = e.getContexts("IAID");
        let i = 1;
        for (let e = 0; e < a; e++) {
          let e = t.readBit(r, i);
          i = i << 1 | e;
        }
        return a < 31 ? i & (1 << a) - 1 : 0x7fffffff & i;
      }
      let d = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"];
      let f = [[{
        x: -1,
        y: -2
      }, {
        x: 0,
        y: -2
      }, {
        x: 1,
        y: -2
      }, {
        x: -2,
        y: -1
      }, {
        x: -1,
        y: -1
      }, {
        x: 0,
        y: -1
      }, {
        x: 1,
        y: -1
      }, {
        x: 2,
        y: -1
      }, {
        x: -4,
        y: 0
      }, {
        x: -3,
        y: 0
      }, {
        x: -2,
        y: 0
      }, {
        x: -1,
        y: 0
      }], [{
        x: -1,
        y: -2
      }, {
        x: 0,
        y: -2
      }, {
        x: 1,
        y: -2
      }, {
        x: 2,
        y: -2
      }, {
        x: -2,
        y: -1
      }, {
        x: -1,
        y: -1
      }, {
        x: 0,
        y: -1
      }, {
        x: 1,
        y: -1
      }, {
        x: 2,
        y: -1
      }, {
        x: -3,
        y: 0
      }, {
        x: -2,
        y: 0
      }, {
        x: -1,
        y: 0
      }], [{
        x: -1,
        y: -2
      }, {
        x: 0,
        y: -2
      }, {
        x: 1,
        y: -2
      }, {
        x: -2,
        y: -1
      }, {
        x: -1,
        y: -1
      }, {
        x: 0,
        y: -1
      }, {
        x: 1,
        y: -1
      }, {
        x: -2,
        y: 0
      }, {
        x: -1,
        y: 0
      }], [{
        x: -3,
        y: -1
      }, {
        x: -2,
        y: -1
      }, {
        x: -1,
        y: -1
      }, {
        x: 0,
        y: -1
      }, {
        x: 1,
        y: -1
      }, {
        x: -4,
        y: 0
      }, {
        x: -3,
        y: 0
      }, {
        x: -2,
        y: 0
      }, {
        x: -1,
        y: 0
      }]];
      let g = [{
        coding: [{
          x: 0,
          y: -1
        }, {
          x: 1,
          y: -1
        }, {
          x: -1,
          y: 0
        }],
        reference: [{
          x: 0,
          y: -1
        }, {
          x: 1,
          y: -1
        }, {
          x: -1,
          y: 0
        }, {
          x: 0,
          y: 0
        }, {
          x: 1,
          y: 0
        }, {
          x: -1,
          y: 1
        }, {
          x: 0,
          y: 1
        }, {
          x: 1,
          y: 1
        }]
      }, {
        coding: [{
          x: -1,
          y: -1
        }, {
          x: 0,
          y: -1
        }, {
          x: 1,
          y: -1
        }, {
          x: -1,
          y: 0
        }],
        reference: [{
          x: 0,
          y: -1
        }, {
          x: -1,
          y: 0
        }, {
          x: 0,
          y: 0
        }, {
          x: 1,
          y: 0
        }, {
          x: 0,
          y: 1
        }, {
          x: 1,
          y: 1
        }]
      }];
      let p = [39717, 1941, 229, 405];
      let m = [32, 8];
      function b(e, t, a, r, i, n, s, o) {
        let l;
        let c;
        if (e) return E(new M(o.data, o.start, o.end), t, a, !1);
        if (0 === r && !n && !i && 4 === s.length && 3 === s[0].x && -1 === s[0].y && -3 === s[1].x && -1 === s[1].y && 2 === s[2].x && -2 === s[2].y && -2 === s[3].x && -2 === s[3].y) return function (e, t, a) {
          let r;
          let i;
          let n;
          let s;
          let o;
          let l;
          let c;
          let h = a.decoder;
          let u = a.contextCache.getContexts("GB");
          let d = [];
          for (i = 0; i < t; i++) for (n = 0, o = d[i] = new Uint8Array(e), l = i < 1 ? o : d[i - 1], r = (c = i < 2 ? o : d[i - 2])[0] << 13 | c[1] << 12 | c[2] << 11 | l[0] << 7 | l[1] << 6 | l[2] << 5 | l[3] << 4; n < e; n++) {
            o[n] = s = h.readBit(u, r);
            r = (31735 & r) << 1 | (n + 3 < e ? c[n + 3] << 11 : 0) | (n + 4 < e ? l[n + 4] << 4 : 0) | s;
          }
          return d;
        }(t, a, o);
        let h = !!n;
        let u = f[r].concat(s);
        u.sort(function (e, t) {
          return e.y - t.y || e.x - t.x;
        });
        let d = u.length;
        let g = new Int8Array(d);
        let m = new Int8Array(d);
        let b = [];
        let y = 0;
        let w = 0;
        let x = 0;
        let S = 0;
        for (c = 0; c < d; c++) {
          g[c] = u[c].x;
          m[c] = u[c].y;
          w = Math.min(w, u[c].x);
          x = Math.max(x, u[c].x);
          S = Math.min(S, u[c].y);
          c < d - 1 && u[c].y === u[c + 1].y && u[c].x === u[c + 1].x - 1 ? y |= 1 << d - 1 - c : b.push(c);
        }
        let k = b.length;
        let A = new Int8Array(k);
        let v = new Int8Array(k);
        let C = new Uint16Array(k);
        for (l = 0; l < k; l++) {
          c = b[l];
          A[l] = u[c].x;
          v[l] = u[c].y;
          C[l] = 1 << d - 1 - c;
        }
        let O = -w;
        let F = -S;
        let I = t - x;
        let T = p[r];
        let P = new Uint8Array(t);
        let N = [];
        let B = o.decoder;
        let D = o.contextCache.getContexts("GB");
        let L = 0;
        let R;
        let $;
        let j;
        let _ = 0;
        let U;
        let X;
        for (let e = 0; e < a; e++) {
          if (i && (L ^= B.readBit(D, T))) {
            N.push(P);
            continue;
          }
          for (P = new Uint8Array(P), N.push(P), R = 0; R < t; R++) {
            if (h && n[e][R]) {
              P[R] = 0;
              continue;
            }
            if (R >= O && R < I && e >= F) for (c = 0, _ = _ << 1 & y; c < k; c++) {
              $ = e + v[c];
              j = R + A[c];
              (U = N[$][j]) && (_ |= U = C[c]);
            } else for (c = 0, _ = 0, X = d - 1; c < d; c++, X--) (j = R + g[c]) >= 0 && j < t && ($ = e + m[c]) >= 0 && (U = N[$][j]) && (_ |= U << X);
            let a = B.readBit(D, _);
            P[R] = a;
          }
        }
        return N;
      }
      function y(e, t, a, r, i, n, s, l, c) {
        let h;
        let u = g[a].coding;
        0 === a && (u = u.concat([l[0]]));
        let d = u.length;
        let f = new Int32Array(d);
        let p = new Int32Array(d);
        for (h = 0; h < d; h++) {
          f[h] = u[h].x;
          p[h] = u[h].y;
        }
        let b = g[a].reference;
        0 === a && (b = b.concat([l[1]]));
        let y = b.length;
        let w = new Int32Array(y);
        let x = new Int32Array(y);
        for (h = 0; h < y; h++) {
          w[h] = b[h].x;
          x[h] = b[h].y;
        }
        let S = r[0].length;
        let k = r.length;
        let A = m[a];
        let v = [];
        let C = c.decoder;
        let O = c.contextCache.getContexts("GR");
        let F = 0;
        for (let a = 0; a < t; a++) {
          if (s && (F ^= C.readBit(O, A))) throw new o("prediction is not supported");
          let t = new Uint8Array(e);
          v.push(t);
          for (let s = 0; s < e; s++) {
            let o;
            let l;
            let c = 0;
            for (h = 0; h < d; h++) {
              o = a + p[h];
              l = s + f[h];
              o < 0 || l < 0 || l >= e ? c <<= 1 : c = c << 1 | v[o][l];
            }
            for (h = 0; h < y; h++) {
              o = a + x[h] - n;
              l = s + w[h] - i;
              o < 0 || o >= k || l < 0 || l >= S ? c <<= 1 : c = c << 1 | r[o][l];
            }
            let u = C.readBit(O, c);
            t[s] = u;
          }
        }
        return v;
      }
      function w(e, t, a, r, i, n, s, l, c, d, f, g, p, m, b, w, x, S, k) {
        let A;
        let v;
        if (e && t) throw new o("refinement with Huffman is not supported");
        let C = [];
        for (A = 0; A < r; A++) {
          if (v = new Uint8Array(a), i) for (let e = 0; e < a; e++) v[e] = i;
          C.push(v);
        }
        let O = x.decoder;
        let F = x.contextCache;
        let I = e ? -m.tableDeltaT.decode(k) : -h(F, "IADT", O);
        let T = 0;
        for (A = 0; A < n;) {
          I += e ? m.tableDeltaT.decode(k) : h(F, "IADT", O);
          let r = T += e ? m.tableFirstS.decode(k) : h(F, "IAFS", O);
          for (; ;) {
            let i;
            let n;
            let T;
            let M = 0;
            s > 1 && (M = e ? k.readBits(S) : h(F, "IAIT", O));
            let P = s * I + M;
            let E = e ? m.symbolIDTable.decode(k) : u(F, O, c);
            let N = t && (e ? k.readBit() : h(F, "IARI", O));
            let B = l[E];
            let D = B[0].length;
            let L = B.length;
            if (N) {
              let e = h(F, "IARDW", O);
              let t = h(F, "IARDH", O);
              let a = h(F, "IARDX", O);
              let r = h(F, "IARDY", O);
              D += e;
              L += t;
              B = y(D, L, b, B, (e >> 1) + a, (t >> 1) + r, !1, w, x);
            }
            let R = P - (1 & g ? 0 : L - 1);
            let $ = r - (2 & g ? D - 1 : 0);
            if (d) {
              for (i = 0; i < L; i++) {
                if (!(v = C[$ + i])) continue;
                T = B[i];
                let e = Math.min(a - R, D);
                switch (p) {
                  case 0:
                    for (n = 0; n < e; n++) v[R + n] |= T[n];
                    break;
                  case 2:
                    for (n = 0; n < e; n++) v[R + n] ^= T[n];
                    break;
                  default:
                    throw new o(`operator ${p} is not supported`);
                }
              }
              r += L - 1;
            } else {
              for (n = 0; n < L; n++) if (v = C[R + n]) switch (T = B[n], p) {
                case 0:
                  for (i = 0; i < D; i++) v[$ + i] |= T[i];
                  break;
                case 2:
                  for (i = 0; i < D; i++) v[$ + i] ^= T[i];
                  break;
                default:
                  throw new o(`operator ${p} is not supported`);
              }
              r += D - 1;
            }
            A++;
            let j = e ? m.tableDeltaS.decode(k) : h(F, "IADS", O);
            if (null === j) break;
            r += j + f;
          }
        }
        return C;
      }
      function x(e, t, a, r) {
        let n = [];
        let s = a;
        for (; s < r;) {
          let a = function (e, t) {
            let a;
            let r;
            let n = {};
            n.number = i.readUint32(e, t);
            let s = e[t + 4];
            let l = 63 & s;
            if (!d[l]) throw new o("invalid segment type: " + l);
            n.type = l;
            n.typeName = d[l];
            n.deferredNonRetain = !!(128 & s);
            let c = e[t + 5];
            let h = c >> 5 & 7;
            let u = [31 & c];
            let f = t + 6;
            if (7 === c) {
              h = 0x1fffffff & i.readUint32(e, f - 1);
              f += 3;
              let t = h + 7 >> 3;
              for (u[0] = e[f++]; --t > 0;) u.push(e[f++]);
            } else if (5 === c || 6 === c) throw new o("invalid referred-to flags");
            n.retainBits = u;
            let g = 4;
            n.number <= 256 ? g = 1 : n.number <= 65536 && (g = 2);
            let p = [];
            for (a = 0; a < h; a++) {
              let t;
              t = 1 === g ? e[f] : 2 === g ? i.readUint16(e, f) : i.readUint32(e, f);
              p.push(t);
              f += g;
            }
            if (n.referredTo = p, 64 & s ? (n.pageAssociation = i.readUint32(e, f), f += 4) : n.pageAssociation = e[f++], n.length = i.readUint32(e, f), f += 4, 0xffffffff === n.length) {
              if (38 === l) {
                let t = S(e, f);
                let i = e[f + k];
                let s = new Uint8Array(6);
                for (1 & i || (s[0] = 255, s[1] = 172), s[2] = t.height >>> 24 & 255, s[3] = t.height >> 16 & 255, s[4] = t.height >> 8 & 255, s[5] = 255 & t.height, a = f, r = e.length; a < r; a++) {
                  let t = 0;
                  for (; t < 6 && s[t] === e[a + t];) t++;
                  if (6 === t) {
                    n.length = a + 6;
                    break;
                  }
                }
                if (0xffffffff === n.length) throw new o("segment end was not found");
              } else throw new o("invalid unknown segment length");
            }
            n.headerEnd = f;
            return n;
          }(t, s);
          s = a.headerEnd;
          let r = {
            header: a,
            data: t
          };
          if (e.randomAccess || (r.start = s, s += a.length, r.end = s), n.push(r), 51 === a.type) break;
        }
        if (e.randomAccess) for (function () {
          let e = 0;
          let t = n.length;
        }(); e < t; e++) {
          n[e].start = s;
          s += n[e].header.length;
          n[e].end = s;
        }
        return n;
      }
      function S(e, t) {
        return {
          width: i.readUint32(e, t),
          height: i.readUint32(e, t + 4),
          x: i.readUint32(e, t + 8),
          y: i.readUint32(e, t + 12),
          combinationOperator: 7 & e[t + 16]
        };
      }
      let k = 17;
      function A(e, t) {
        for (function () {
          let a = 0;
          let r = e.length;
        }(); a < r; a++) !function (e, t) {
          let a;
          let r;
          let n;
          let s;
          let l = e.header;
          let c = e.data;
          let h = e.end;
          let u = e.start;
          switch (l.type) {
            case 0:
              let d = {};
              let f = i.readUint16(c, u);
              if (d.huffman = !!(1 & f), d.refinement = !!(2 & f), d.huffmanDHSelector = f >> 2 & 3, d.huffmanDWSelector = f >> 4 & 3, d.bitmapSizeSelector = f >> 6 & 1, d.aggregationInstancesSelector = f >> 7 & 1, d.bitmapCodingContextUsed = !!(256 & f), d.bitmapCodingContextRetained = !!(512 & f), d.template = f >> 10 & 3, d.refinementTemplate = f >> 12 & 1, u += 2, !d.huffman) {
                for (n = 0, s = 0 === d.template ? 4 : 1, r = []; n < s; n++) {
                  r.push({
                    x: i.readInt8(c, u),
                    y: i.readInt8(c, u + 1)
                  });
                  u += 2;
                }
                d.at = r;
              }
              if (d.refinement && !d.refinementTemplate) {
                for (n = 0, r = []; n < 2; n++) {
                  r.push({
                    x: i.readInt8(c, u),
                    y: i.readInt8(c, u + 1)
                  });
                  u += 2;
                }
                d.refinementAt = r;
              }
              d.numberOfExportedSymbols = i.readUint32(c, u);
              u += 4;
              d.numberOfNewSymbols = i.readUint32(c, u);
              u += 4;
              a = [d, l.number, l.referredTo, c, u, h];
              break;
            case 6:
            case 7:
              let g = {};
              g.info = S(c, u);
              u += k;
              let p = i.readUint16(c, u);
              if (u += 2, g.huffman = !!(1 & p), g.refinement = !!(2 & p), g.logStripSize = p >> 2 & 3, g.stripSize = 1 << g.logStripSize, g.referenceCorner = p >> 4 & 3, g.transposed = !!(64 & p), g.combinationOperator = p >> 7 & 3, g.defaultPixelValue = p >> 9 & 1, g.dsOffset = p << 17 >> 27, g.refinementTemplate = p >> 15 & 1, g.huffman) {
                let e = i.readUint16(c, u);
                u += 2;
                g.huffmanFS = 3 & e;
                g.huffmanDS = e >> 2 & 3;
                g.huffmanDT = e >> 4 & 3;
                g.huffmanRefinementDW = e >> 6 & 3;
                g.huffmanRefinementDH = e >> 8 & 3;
                g.huffmanRefinementDX = e >> 10 & 3;
                g.huffmanRefinementDY = e >> 12 & 3;
                g.huffmanRefinementSizeSelector = !!(16384 & e);
              }
              if (g.refinement && !g.refinementTemplate) {
                for (n = 0, r = []; n < 2; n++) {
                  r.push({
                    x: i.readInt8(c, u),
                    y: i.readInt8(c, u + 1)
                  });
                  u += 2;
                }
                g.refinementAt = r;
              }
              g.numberOfSymbolInstances = i.readUint32(c, u);
              u += 4;
              a = [g, l.referredTo, c, u, h];
              break;
            case 16:
              let m = {};
              let b = c[u++];
              m.mmr = !!(1 & b);
              m.template = b >> 1 & 3;
              m.patternWidth = c[u++];
              m.patternHeight = c[u++];
              m.maxPatternIndex = i.readUint32(c, u);
              u += 4;
              a = [m, l.number, c, u, h];
              break;
            case 22:
            case 23:
              let y = {};
              y.info = S(c, u);
              u += k;
              let w = c[u++];
              y.mmr = !!(1 & w);
              y.template = w >> 1 & 3;
              y.enableSkip = !!(8 & w);
              y.combinationOperator = w >> 4 & 7;
              y.defaultPixelValue = w >> 7 & 1;
              y.gridWidth = i.readUint32(c, u);
              u += 4;
              y.gridHeight = i.readUint32(c, u);
              u += 4;
              y.gridOffsetX = 0xffffffff & i.readUint32(c, u);
              u += 4;
              y.gridOffsetY = 0xffffffff & i.readUint32(c, u);
              u += 4;
              y.gridVectorX = i.readUint16(c, u);
              u += 2;
              y.gridVectorY = i.readUint16(c, u);
              u += 2;
              a = [y, l.referredTo, c, u, h];
              break;
            case 38:
            case 39:
              let x = {};
              x.info = S(c, u);
              u += k;
              let A = c[u++];
              if (x.mmr = !!(1 & A), x.template = A >> 1 & 3, x.prediction = !!(8 & A), !x.mmr) {
                for (n = 0, s = 0 === x.template ? 4 : 1, r = []; n < s; n++) {
                  r.push({
                    x: i.readInt8(c, u),
                    y: i.readInt8(c, u + 1)
                  });
                  u += 2;
                }
                x.at = r;
              }
              a = [x, c, u, h];
              break;
            case 48:
              let v = {
                width: i.readUint32(c, u),
                height: i.readUint32(c, u + 4),
                resolutionX: i.readUint32(c, u + 8),
                resolutionY: i.readUint32(c, u + 12)
              };
              0xffffffff === v.height && delete v.height;
              let C = c[u + 16];
              i.readUint16(c, u + 17);
              v.lossless = !!(1 & C);
              v.refinement = !!(2 & C);
              v.defaultPixelValue = C >> 2 & 1;
              v.combinationOperator = C >> 3 & 3;
              v.requiresBuffer = !!(32 & C);
              v.combinationOperatorOverride = !!(64 & C);
              a = [v];
              break;
            case 49:
            case 50:
            case 51:
            case 62:
              break;
            case 53:
              a = [l.number, c, u, h];
              break;
            default:
              throw new o(`segment type ${l.typeName}(${l.type}) is not implemented`);
          }
          let O = "on" + l.typeName;
          O in t && t[O].apply(t, a);
        }(e[a], t);
      }
      class v {
        onPageInformation(e) {
          this.currentPageInfo = e;
          let t = new Uint8ClampedArray((e.width + 7 >> 3) * e.height);
          if (e.defaultPixelValue) for (function () {
            let e = 0;
            let a = t.length;
          }(); e < a; e++) t[e] = 255;
          this.buffer = t;
        }
        drawBitmap(e, t) {
          let a;
          let r;
          let i;
          let n;
          let s = this.currentPageInfo;
          let l = e.width;
          let c = e.height;
          let h = s.width + 7 >> 3;
          let u = s.combinationOperatorOverride ? e.combinationOperator : s.combinationOperator;
          let d = this.buffer;
          let f = 128 >> (7 & e.x);
          let g = e.y * h + (e.x >> 3);
          switch (u) {
            case 0:
              for (a = 0; a < c; a++) {
                for (r = 0, i = f, n = g; r < l; r++) {
                  t[a][r] && (d[n] |= i);
                  !(i >>= 1) && (i = 128, n++);
                }
                g += h;
              }
              break;
            case 2:
              for (a = 0; a < c; a++) {
                for (r = 0, i = f, n = g; r < l; r++) {
                  t[a][r] && (d[n] ^= i);
                  !(i >>= 1) && (i = 128, n++);
                }
                g += h;
              }
              break;
            default:
              throw new o(`operator ${u} is not supported`);
          }
        }
        onImmediateGenericRegion(e, t, a, r) {
          let i = e.info;
          let n = new c(t, a, r);
          let s = b(e.mmr, i.width, i.height, e.template, e.prediction, null, e.at, n);
          this.drawBitmap(i, s);
        }
        onImmediateLosslessGenericRegion() {
          this.onImmediateGenericRegion.apply(this, arguments);
        }
        onSymbolDictionary(e, t, a, r, n, s) {
          let l;
          let d;
          e.huffman && (l = function (e, t, a) {
            let r;
            let i = 0;
            let n;
            let s;
            switch (e.huffmanDHSelector) {
              case 0:
              case 1:
                n = T(e.huffmanDHSelector + 4);
                break;
              case 3:
                n = P(i, t, a);
                i++;
                break;
              default:
                throw new o("invalid Huffman DH selector");
            }
            switch (e.huffmanDWSelector) {
              case 0:
              case 1:
                s = T(e.huffmanDWSelector + 2);
                break;
              case 3:
                s = P(i, t, a);
                i++;
                break;
              default:
                throw new o("invalid Huffman DW selector");
            }
            e.bitmapSizeSelector ? (r = P(i, t, a), i++) : r = T(1);
            return {
              tableDeltaHeight: n,
              tableDeltaWidth: s,
              tableBitmapSize: r,
              tableAggregateInstances: e.aggregationInstancesSelector ? P(i, t, a) : T(1)
            };
          }(e, a, this.customTables), d = new M(r, n, s));
          let f = this.symbols;
          f || (this.symbols = f = {});
          let g = [];
          for (function () {
            let e = 0;
            let t = a.length;
          }(); e < t; e++) {
            let t = f[a[e]];
            t && (g = g.concat(t));
          }
          let p = new c(r, n, s);
          f[t] = function (e, t, a, r, n, s, l, c, d, f, g, p) {
            let m;
            let x;
            if (e && t) throw new o("symbol refinement with Huffman is not supported");
            let S = [];
            let k = 0;
            let A = i.log2(a.length + r);
            let v = g.decoder;
            let C = g.contextCache;
            for (e && (m = T(1), x = [], A = Math.max(A, 1)); S.length < r;) {
              k += e ? s.tableDeltaHeight.decode(p) : h(C, "IADH", v);
              let r = 0;
              let i = 0;
              let n = e ? x.length : 0;
              for (; ;) {
                let n;
                let o = e ? s.tableDeltaWidth.decode(p) : h(C, "IADW", v);
                if (null === o) break;
                if (r += o, i += r, t) {
                  let i = h(C, "IAAI", v);
                  if (i > 1) n = w(e, t, r, k, 0, i, 1, a.concat(S), A, 0, 0, 1, 0, s, d, f, g, 0, p); else {
                    let e = u(C, v, A);
                    let t = h(C, "IARDX", v);
                    let i = h(C, "IARDY", v);
                    n = y(r, k, d, e < a.length ? a[e] : S[e - a.length], t, i, !1, f, g);
                  }
                  S.push(n);
                } else e ? x.push(r) : (n = b(!1, r, k, l, !1, null, c, g), S.push(n));
              }
              if (e && !t) {
                let e;
                let t = s.tableBitmapSize.decode(p);
                if (p.byteAlign(), 0 === t) e = function (e, t, a) {
                  let r = [];
                  for (let i = 0; i < a; i++) {
                    let a = new Uint8Array(t);
                    r.push(a);
                    for (let r = 0; r < t; r++) a[r] = e.readBit();
                    e.byteAlign();
                  }
                  return r;
                }(p, i, k); else {
                  let a = p.end;
                  let r = p.position + t;
                  p.end = r;
                  e = E(p, i, k, !1);
                  p.end = a;
                  p.position = r;
                }
                let a = x.length;
                if (n === a - 1) S.push(e); else {
                  let t;
                  let r;
                  let i = 0;
                  let s;
                  let o;
                  for (t = n; t < a; t++) {
                    for (r = 0, s = i + x[t], o = []; r < k; r++) o.push(e[r].subarray(i, s));
                    S.push(o);
                    i = s;
                  }
                }
              }
            }
            let O = [];
            let F = [];
            let I = !1;
            let M;
            let P;
            let N = a.length + r;
            for (; F.length < N;) {
              let t = e ? m.decode(p) : h(C, "IAEX", v);
              for (; t--;) F.push(I);
              I = !I;
            }
            for (M = 0, P = a.length; M < P; M++) F[M] && O.push(a[M]);
            for (let e = 0; e < r; M++, e++) F[M] && O.push(S[e]);
            return O;
          }(e.huffman, e.refinement, g, e.numberOfNewSymbols, e.numberOfExportedSymbols, l, e.template, e.at, e.refinementTemplate, e.refinementAt, p, d);
        }
        onImmediateTextRegion(e, t, a, r, n) {
          let s;
          let l;
          let h = e.info;
          let u = this.symbols;
          let d = [];
          for (function () {
            let e = 0;
            let a = t.length;
          }(); e < a; e++) {
            let a = u[t[e]];
            a && (d = d.concat(a));
          }
          let f = i.log2(d.length);
          e.huffman && (l = new M(a, r, n), s = function (e, t, a, r, i) {
            let n = [];
            for (let e = 0; e <= 34; e++) {
              let t = i.readBits(4);
              n.push(new C([e, t, 0, 0]));
            }
            let s = new F(n, !1);
            n.length = 0;
            for (let e = 0; e < r;) {
              let t = s.decode(i);
              if (t >= 32) {
                let a;
                let r;
                let s;
                switch (t) {
                  case 32:
                    if (0 === e) throw new o("no previous value in symbol ID table");
                    r = i.readBits(2) + 3;
                    a = n[e - 1].prefixLength;
                    break;
                  case 33:
                    r = i.readBits(3) + 3;
                    a = 0;
                    break;
                  case 34:
                    r = i.readBits(7) + 11;
                    a = 0;
                    break;
                  default:
                    throw new o("invalid code length in symbol ID table");
                }
                for (s = 0; s < r; s++) {
                  n.push(new C([e, a, 0, 0]));
                  e++;
                }
              } else {
                n.push(new C([e, t, 0, 0]));
                e++;
              }
            }
            i.byteAlign();
            let l = new F(n, !1);
            let c = 0;
            let h;
            let u;
            let d;
            switch (e.huffmanFS) {
              case 0:
              case 1:
                h = T(e.huffmanFS + 6);
                break;
              case 3:
                h = P(c, t, a);
                c++;
                break;
              default:
                throw new o("invalid Huffman FS selector");
            }
            switch (e.huffmanDS) {
              case 0:
              case 1:
              case 2:
                u = T(e.huffmanDS + 8);
                break;
              case 3:
                u = P(c, t, a);
                c++;
                break;
              default:
                throw new o("invalid Huffman DS selector");
            }
            switch (e.huffmanDT) {
              case 0:
              case 1:
              case 2:
                d = T(e.huffmanDT + 11);
                break;
              case 3:
                d = P(c, t, a);
                c++;
                break;
              default:
                throw new o("invalid Huffman DT selector");
            }
            if (e.refinement) throw new o("refinement with Huffman is not supported");
            return {
              symbolIDTable: l,
              tableFirstS: h,
              tableDeltaS: u,
              tableDeltaT: d
            };
          }(e, t, this.customTables, d.length, l));
          let g = new c(a, r, n);
          let p = w(e.huffman, e.refinement, h.width, h.height, e.defaultPixelValue, e.numberOfSymbolInstances, e.stripSize, d, f, e.transposed, e.dsOffset, e.referenceCorner, e.combinationOperator, s, e.refinementTemplate, e.refinementAt, g, e.logStripSize, l);
          this.drawBitmap(h, p);
        }
        onImmediateLosslessTextRegion() {
          this.onImmediateTextRegion.apply(this, arguments);
        }
        onPatternDictionary(e, t, a, r, i) {
          let n = this.patterns;
          n || (this.patterns = n = {});
          let s = new c(a, r, i);
          n[t] = function (e, t, a, r, i, n) {
            let s = [];
            e || (s.push({
              x: -t,
              y: 0
            }), 0 === i && s.push({
              x: -3,
              y: -1
            }, {
              x: 2,
              y: -2
            }, {
              x: -2,
              y: -2
            }));
            let o = b(e, (r + 1) * t, a, i, !1, null, s, n);
            let l = [];
            for (let e = 0; e <= r; e++) {
              let r = [];
              let i = t * e;
              let n = i + t;
              for (let e = 0; e < a; e++) r.push(o[e].subarray(i, n));
              l.push(r);
            }
            return l;
          }(e.mmr, e.patternWidth, e.patternHeight, e.maxPatternIndex, e.template, s);
        }
        onImmediateHalftoneRegion(e, t, a, r, n) {
          let s = this.patterns[t[0]];
          let l = e.info;
          let h = new c(a, r, n);
          let u = function (e, t, a, r, n, s, l, c, h, u, d, f, g, p, m) {
            let y;
            let w;
            let x;
            let S;
            let k;
            let A;
            let v;
            let C;
            let O;
            let F;
            let I;
            let T;
            let P;
            let N;
            if (l) throw new o("skip is not supported");
            if (0 !== c) throw new o(`operator "${c}" is not supported in halftone region`);
            let B = [];
            for (y = 0; y < n; y++) {
              if (x = new Uint8Array(r), s) for (w = 0; w < r; w++) x[w] = s;
              B.push(x);
            }
            let D = t.length;
            let L = t[0];
            let R = L[0].length;
            let $ = L.length;
            let j = i.log2(D);
            let _ = [];
            e || (_.push({
              x: a <= 1 ? 3 : 2,
              y: -1
            }), 0 === a && _.push({
              x: -3,
              y: -1
            }, {
              x: 2,
              y: -2
            }, {
              x: -2,
              y: -2
            }));
            let U = [];
            for (e && (S = new M(m.data, m.start, m.end)), y = j - 1; y >= 0; y--) {
              k = e ? E(S, h, u, !0) : b(!1, h, u, a, !1, null, _, m);
              U[y] = k;
            }
            for (A = 0; A < u; A++) for (v = 0; v < h; v++) {
              for (C = 0, O = 0, w = j - 1; w >= 0; w--) {
                C ^= U[w][A][v];
                O |= C << w;
              }
              if (F = t[O], I = d + A * p + v * g >> 8, T = f + A * g - v * p >> 8, I >= 0 && I + R <= r && T >= 0 && T + $ <= n) for (y = 0; y < $; y++) for (w = 0, N = B[T + y], P = F[y]; w < R; w++) N[I + w] |= P[w]; else {
                let e;
                let t;
                for (y = 0; y < $; y++) if (!((t = T + y) < 0) && !(t >= n)) for (w = 0, N = B[t], P = F[y]; w < R; w++) (e = I + w) >= 0 && e < r && (N[e] |= P[w]);
              }
            }
            return B;
          }(e.mmr, s, e.template, l.width, l.height, e.defaultPixelValue, e.enableSkip, e.combinationOperator, e.gridWidth, e.gridHeight, e.gridOffsetX, e.gridOffsetY, e.gridVectorX, e.gridVectorY, h);
          this.drawBitmap(l, u);
        }
        onImmediateLosslessHalftoneRegion() {
          this.onImmediateHalftoneRegion.apply(this, arguments);
        }
        onTables(e, t, a, r) {
          let n = this.customTables;
          n || (this.customTables = n = {});
          n[e] = function (e, t, a) {
            let r = e[t];
            let n = 0xffffffff & i.readUint32(e, t + 1);
            let s = 0xffffffff & i.readUint32(e, t + 5);
            let o = new M(e, t + 9, a);
            let l = (r >> 1 & 7) + 1;
            let c = (r >> 4 & 7) + 1;
            let h = [];
            let u;
            let d;
            let f = n;
            do {
              u = o.readBits(l);
              d = o.readBits(c);
              h.push(new C([f, u, d, 0]));
              f += 1 << d;
            } while (f < s);
            u = o.readBits(l);
            h.push(new C([n - 1, u, 32, 0, "lower"]));
            u = o.readBits(l);
            h.push(new C([s, u, 32, 0]));
            1 & r && (u = o.readBits(l), h.push(new C([u, 0])));
            return new F(h, !1);
          }(t, a, r);
        }
      }
      class C {
        constructor(e) {
          2 === e.length ? (this.isOOB = !0, this.rangeLow = 0, this.prefixLength = e[0], this.rangeLength = 0, this.prefixCode = e[1], this.isLowerRange = !1) : (this.isOOB = !1, this.rangeLow = e[0], this.prefixLength = e[1], this.rangeLength = e[2], this.prefixCode = e[3], this.isLowerRange = "lower" === e[4]);
        }
      }
      class O {
        constructor(e) {
          this.children = [];
          e ? (this.isLeaf = !0, this.rangeLength = e.rangeLength, this.rangeLow = e.rangeLow, this.isLowerRange = e.isLowerRange, this.isOOB = e.isOOB) : this.isLeaf = !1;
        }
        buildTree(e, t) {
          let a = e.prefixCode >> t & 1;
          if (t <= 0) this.children[a] = new O(e); else {
            let r = this.children[a];
            r || (this.children[a] = r = new O(null));
            r.buildTree(e, t - 1);
          }
        }
        decodeNode(e) {
          if (this.isLeaf) {
            if (this.isOOB) return null;
            let t = e.readBits(this.rangeLength);
            return this.rangeLow + (this.isLowerRange ? -t : t);
          }
          let t = this.children[e.readBit()];
          if (!t) throw new o("invalid Huffman data");
          return t.decodeNode(e);
        }
      }
      class F {
        constructor(e, t) {
          t || this.assignPrefixCodes(e);
          this.rootNode = new O(null);
          for (function () {
            let t = 0;
            let a = e.length;
          }(); t < a; t++) {
            let a = e[t];
            a.prefixLength > 0 && this.rootNode.buildTree(a, a.prefixLength - 1);
          }
        }
        decode(e) {
          return this.rootNode.decodeNode(e);
        }
        assignPrefixCodes(e) {
          let t = e.length;
          let a = 0;
          for (let r = 0; r < t; r++) a = Math.max(a, e[r].prefixLength);
          let r = new Uint32Array(a + 1);
          for (let a = 0; a < t; a++) r[e[a].prefixLength]++;
          let i = 1;
          let n = 0;
          let s;
          let o;
          let l;
          for (r[0] = 0; i <= a;) {
            for (s = n = n + r[i - 1] << 1, o = 0; o < t;) {
              (l = e[o]).prefixLength === i && (l.prefixCode = s, s++);
              o++;
            }
            i++;
          }
        }
      }
      let I = {};
      function T(e) {
        let t;
        let a = I[e];
        if (a) return a;
        switch (e) {
          case 1:
            t = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];
            break;
          case 2:
            t = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];
            break;
          case 3:
            t = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, "lower"], [75, 7, 32, 126], [6, 62]];
            break;
          case 4:
            t = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];
            break;
          case 5:
            t = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, "lower"], [76, 6, 32, 62]];
            break;
          case 6:
            t = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, "lower"], [2048, 6, 32, 63]];
            break;
          case 7:
            t = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, "lower"], [2048, 5, 32, 31]];
            break;
          case 8:
            t = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, "lower"], [1670, 9, 32, 511], [2, 1]];
            break;
          case 9:
            t = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, "lower"], [3339, 9, 32, 511], [2, 0]];
            break;
          case 10:
            t = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, "lower"], [4166, 8, 32, 255], [2, 2]];
            break;
          case 11:
            t = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];
            break;
          case 12:
            t = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];
            break;
          case 13:
            t = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];
            break;
          case 14:
            t = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
            break;
          case 15:
            t = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, "lower"], [25, 7, 32, 127]];
            break;
          default:
            throw new o(`standard table B.${e} does not exist`);
        }
        for (function () {
          let e = 0;
          let a = t.length;
        }(); e < a; e++) t[e] = new C(t[e]);
        a = new F(t, !0);
        I[e] = a;
        return a;
      }
      class M {
        constructor(e, t, a) {
          this.data = e;
          this.start = t;
          this.end = a;
          this.position = t;
          this.shift = -1;
          this.currentByte = 0;
        }
        readBit() {
          if (this.shift < 0) {
            if (this.position >= this.end) throw new o("end of data while reading bit");
            this.currentByte = this.data[this.position++];
            this.shift = 7;
          }
          let e = this.currentByte >> this.shift & 1;
          this.shift--;
          return e;
        }
        readBits(e) {
          let t = 0;
          let a;
          for (a = e - 1; a >= 0; a--) t |= this.readBit() << a;
          return t;
        }
        byteAlign() {
          this.shift = -1;
        }
        next() {
          return this.position >= this.end ? -1 : this.data[this.position++];
        }
      }
      function P(e, t, a) {
        let r = 0;
        for (function () {
          let i = 0;
          let n = t.length;
        }(); i < n; i++) {
          let n = a[t[i]];
          if (n) {
            if (e === r) return n;
            r++;
          }
        }
        throw new o("can't find custom Huffman table");
      }
      function E(e, t, a, r) {
        let i = new s.CCITTFaxDecoder(e, {
          K: -1,
          Columns: t,
          Rows: a,
          BlackIs1: !0,
          EndOfBlock: r
        });
        let n = [];
        let o;
        let l = !1;
        for (let e = 0; e < a; e++) {
          let e = new Uint8Array(t);
          n.push(e);
          let a = -1;
          for (let r = 0; r < t; r++) {
            a < 0 && (-1 === (o = i.readNextChar()) && (o = 0, l = !0), a = 7);
            e[r] = o >> a & 1;
            a--;
          }
        }
        if (r && !l) for (let e = 0; e < 5 && -1 !== i.readNextChar(); e++);
        return n;
      }
      t.Jbig2Image = class {
        parseChunks(e) {
          return function (e) {
            let t = new v();
            for (function () {
              let a = 0;
              let r = e.length;
            }(); a < r; a++) {
              let r = e[a];
              A(x({}, r.data, r.start, r.end), t);
            }
            return t.buffer;
          }(e);
        }
        parse(e) {
          let {
            imgData,
            width,
            height
          } = function (e) {
            let t = e.length;
            let a = 0;
            if (151 !== e[0] || 74 !== e[a + 1] || 66 !== e[a + 2] || 50 !== e[a + 3] || 13 !== e[a + 4] || 10 !== e[a + 5] || 26 !== e[a + 6] || 10 !== e[a + 7]) throw new o("parseJbig2 - invalid header.");
            let r = Object.create(null);
            a += 8;
            let n = e[a++];
            r.randomAccess = !(1 & n);
            2 & n || (r.numberOfPages = i.readUint32(e, a), a += 4);
            let s = x(r, e, a, t);
            let l = new v();
            A(s, l);
            let {
              width: _width,
              height: _height
            } = l.currentPageInfo;
            let u = l.buffer;
            let d = new Uint8ClampedArray(_width * _height);
            let f = 0;
            let g = 0;
            for (let e = 0; e < _height; e++) {
              let e = 0;
              let t;
              for (let a = 0; a < _width; a++) {
                e || (e = 128, t = u[g++]);
                d[f++] = t & e ? 0 : 255;
                e >>= 1;
              }
            }
            return {
              imgData: d,
              width: _width,
              height: _height
            };
          }(e);
          this.width = width;
          this.height = height;
          return imgData;
        }
      };
    }, (e, t) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.ArithmeticDecoder = void 0;
      let a = [{
        qe: 22017,
        nmps: 1,
        nlps: 1,
        switchFlag: 1
      }, {
        qe: 13313,
        nmps: 2,
        nlps: 6,
        switchFlag: 0
      }, {
        qe: 6145,
        nmps: 3,
        nlps: 9,
        switchFlag: 0
      }, {
        qe: 2753,
        nmps: 4,
        nlps: 12,
        switchFlag: 0
      }, {
        qe: 1313,
        nmps: 5,
        nlps: 29,
        switchFlag: 0
      }, {
        qe: 545,
        nmps: 38,
        nlps: 33,
        switchFlag: 0
      }, {
        qe: 22017,
        nmps: 7,
        nlps: 6,
        switchFlag: 1
      }, {
        qe: 21505,
        nmps: 8,
        nlps: 14,
        switchFlag: 0
      }, {
        qe: 18433,
        nmps: 9,
        nlps: 14,
        switchFlag: 0
      }, {
        qe: 14337,
        nmps: 10,
        nlps: 14,
        switchFlag: 0
      }, {
        qe: 12289,
        nmps: 11,
        nlps: 17,
        switchFlag: 0
      }, {
        qe: 9217,
        nmps: 12,
        nlps: 18,
        switchFlag: 0
      }, {
        qe: 7169,
        nmps: 13,
        nlps: 20,
        switchFlag: 0
      }, {
        qe: 5633,
        nmps: 29,
        nlps: 21,
        switchFlag: 0
      }, {
        qe: 22017,
        nmps: 15,
        nlps: 14,
        switchFlag: 1
      }, {
        qe: 21505,
        nmps: 16,
        nlps: 14,
        switchFlag: 0
      }, {
        qe: 20737,
        nmps: 17,
        nlps: 15,
        switchFlag: 0
      }, {
        qe: 18433,
        nmps: 18,
        nlps: 16,
        switchFlag: 0
      }, {
        qe: 14337,
        nmps: 19,
        nlps: 17,
        switchFlag: 0
      }, {
        qe: 13313,
        nmps: 20,
        nlps: 18,
        switchFlag: 0
      }, {
        qe: 12289,
        nmps: 21,
        nlps: 19,
        switchFlag: 0
      }, {
        qe: 10241,
        nmps: 22,
        nlps: 19,
        switchFlag: 0
      }, {
        qe: 9217,
        nmps: 23,
        nlps: 20,
        switchFlag: 0
      }, {
        qe: 8705,
        nmps: 24,
        nlps: 21,
        switchFlag: 0
      }, {
        qe: 7169,
        nmps: 25,
        nlps: 22,
        switchFlag: 0
      }, {
        qe: 6145,
        nmps: 26,
        nlps: 23,
        switchFlag: 0
      }, {
        qe: 5633,
        nmps: 27,
        nlps: 24,
        switchFlag: 0
      }, {
        qe: 5121,
        nmps: 28,
        nlps: 25,
        switchFlag: 0
      }, {
        qe: 4609,
        nmps: 29,
        nlps: 26,
        switchFlag: 0
      }, {
        qe: 4353,
        nmps: 30,
        nlps: 27,
        switchFlag: 0
      }, {
        qe: 2753,
        nmps: 31,
        nlps: 28,
        switchFlag: 0
      }, {
        qe: 2497,
        nmps: 32,
        nlps: 29,
        switchFlag: 0
      }, {
        qe: 2209,
        nmps: 33,
        nlps: 30,
        switchFlag: 0
      }, {
        qe: 1313,
        nmps: 34,
        nlps: 31,
        switchFlag: 0
      }, {
        qe: 1089,
        nmps: 35,
        nlps: 32,
        switchFlag: 0
      }, {
        qe: 673,
        nmps: 36,
        nlps: 33,
        switchFlag: 0
      }, {
        qe: 545,
        nmps: 37,
        nlps: 34,
        switchFlag: 0
      }, {
        qe: 321,
        nmps: 38,
        nlps: 35,
        switchFlag: 0
      }, {
        qe: 273,
        nmps: 39,
        nlps: 36,
        switchFlag: 0
      }, {
        qe: 133,
        nmps: 40,
        nlps: 37,
        switchFlag: 0
      }, {
        qe: 73,
        nmps: 41,
        nlps: 38,
        switchFlag: 0
      }, {
        qe: 37,
        nmps: 42,
        nlps: 39,
        switchFlag: 0
      }, {
        qe: 21,
        nmps: 43,
        nlps: 40,
        switchFlag: 0
      }, {
        qe: 9,
        nmps: 44,
        nlps: 41,
        switchFlag: 0
      }, {
        qe: 5,
        nmps: 45,
        nlps: 42,
        switchFlag: 0
      }, {
        qe: 1,
        nmps: 45,
        nlps: 43,
        switchFlag: 0
      }, {
        qe: 22017,
        nmps: 46,
        nlps: 46,
        switchFlag: 0
      }];
      t.ArithmeticDecoder = class {
        constructor(e, t, a) {
          this.data = e;
          this.bp = t;
          this.dataEnd = a;
          this.chigh = e[t];
          this.clow = 0;
          this.byteIn();
          this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127;
          this.clow = this.clow << 7 & 65535;
          this.ct -= 7;
          this.a = 32768;
        }
        byteIn() {
          let e = this.data;
          let t = this.bp;
          255 === e[t] ? e[t + 1] > 143 ? (this.clow += 65280, this.ct = 8) : (t++, this.clow += e[t] << 9, this.ct = 7, this.bp = t) : (t++, this.clow += t < this.dataEnd ? e[t] << 8 : 65280, this.ct = 8, this.bp = t);
          this.clow > 65535 && (this.chigh += this.clow >> 16, this.clow &= 65535);
        }
        readBit(e, t) {
          let r;
          let i = e[t] >> 1;
          let n = 1 & e[t];
          let s = a[i];
          let o = s.qe;
          let l = this.a - o;
          if (this.chigh < o) l < o ? (l = o, r = n, i = s.nmps) : (l = o, r = 1 ^ n, 1 === s.switchFlag && (n = r), i = s.nlps); else {
            if (this.chigh -= o, (32768 & l) != 0) {
              this.a = l;
              return n;
            }
            l < o ? (r = 1 ^ n, 1 === s.switchFlag && (n = r), i = s.nlps) : (r = n, i = s.nmps);
          }
          do {
            0 === this.ct && this.byteIn();
            l <<= 1;
            this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1;
            this.clow = this.clow << 1 & 65535;
            this.ct--;
          } while ((32768 & l) == 0);
          this.a = l;
          e[t] = i << 1 | n;
          return r;
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.JpegStream = void 0;
      var r = a(29);
      var i = a(5);
      var n = a(38);
      var s = a(2);
      class o extends r.DecodeStream {
        constructor(e, t, a) {
          let r;
          for (; -1 !== (r = e.getByte());) if (255 === r) {
            e.skip(-1);
            break;
          }
          super(t);
          this.stream = e;
          this.dict = e.dict;
          this.maybeLength = t;
          this.params = a;
        }
        get bytes() {
          return s.shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
        }
        ensureBuffer(e) { }
        readBlock() {
          if (this.eof) return;
          let e = {
            decodeTransform: void 0,
            colorTransform: void 0
          };
          let t = this.dict.getArray("D", "Decode");
          if (this.forceRGB && Array.isArray(t)) {
            let a = this.dict.get("BPC", "BitsPerComponent") || 8;
            let r = t.length;
            let i = new Int32Array(r);
            let n = !1;
            let s = (1 << a) - 1;
            for (let e = 0; e < r; e += 2) {
              i[e] = (t[e + 1] - t[e]) * 256 | 0;
              i[e + 1] = t[e] * s | 0;
              (256 !== i[e] || 0 !== i[e + 1]) && (n = !0);
            }
            n && (e.decodeTransform = i);
          }
          if (this.params instanceof i.Dict) {
            let t = this.params.get("ColorTransform");
            Number.isInteger(t) && (e.colorTransform = t);
          }
          let a = new n.JpegImage(e);
          a.parse(this.bytes);
          let r = a.getData({
            width: this.drawWidth,
            height: this.drawHeight,
            forceRGB: this.forceRGB,
            isSourcePDF: !0
          });
          this.buffer = r;
          this.bufferLength = r.length;
          this.eof = !0;
        }
      }
      t.JpegStream = o;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.JpegImage = void 0;
      var r = a(2);
      var i = a(8);
      class n extends r.BaseException {
        constructor(e) {
          super(`JPEG error: ${e}`, "JpegError");
        }
      }
      class s extends r.BaseException {
        constructor(e, t) {
          super(e, "DNLMarkerError");
          this.scanLines = t;
        }
      }
      class o extends r.BaseException {
        constructor(e) {
          super(e, "EOIMarkerError");
        }
      }
      let l = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
      function c(e, t, a) {
        return 64 * ((e.blocksPerLine + 1) * t + a);
      }
      function h(e, t, a = t) {
        let r = e.length - 1;
        let n = a < t ? a : t;
        if (t >= r) return null;
        let s = i.readUint16(e, t);
        if (s >= 65472 && s <= 65534) return {
          invalid: null,
          marker: s,
          offset: t
        };
        let o = i.readUint16(e, n);
        for (; !(o >= 65472 && o <= 65534);) {
          if (++n >= r) return null;
          o = i.readUint16(e, n);
        }
        return {
          invalid: s.toString(16),
          marker: o,
          offset: n
        };
      }
      t.JpegImage = class {
        constructor({
          decodeTransform: e = null,
          colorTransform: t = -1
        } = {}) {
          this._decodeTransform = e;
          this._colorTransform = t;
        }
        parse(e, {
          dnlScanLines: t = null
        } = {}) {
          let a;
          let u;
          let d = 0;
          let f = null;
          let g = null;
          let p = 0;
          let m = [];
          let b = [];
          let y = [];
          let w = i.readUint16(e, d);
          if (d += 2, 65496 !== w) throw new n("SOI not found");
          w = i.readUint16(e, d);
          d += 2;
          t: for (; 65497 !== w;) {
            let x;
            let S;
            let k;
            switch (w) {
              case 65504:
              case 65505:
              case 65506:
              case 65507:
              case 65508:
              case 65509:
              case 65510:
              case 65511:
              case 65512:
              case 65513:
              case 65514:
              case 65515:
              case 65516:
              case 65517:
              case 65518:
              case 65519:
              case 65534:
                let A = function () {
                  let t = i.readUint16(e, d);
                  let a = (d += 2) + t - 2;
                  let n = h(e, a, d);
                  n && n.invalid && (r.warn("readDataBlock - incorrect length, current marker is: " + n.invalid), a = n.offset);
                  let s = e.subarray(d, a);
                  d += s.length;
                  return s;
                }();
                65504 === w && 74 === A[0] && 70 === A[1] && 73 === A[2] && 70 === A[3] && 0 === A[4] && (f = {
                  version: {
                    major: A[5],
                    minor: A[6]
                  },
                  densityUnits: A[7],
                  xDensity: A[8] << 8 | A[9],
                  yDensity: A[10] << 8 | A[11],
                  thumbWidth: A[12],
                  thumbHeight: A[13],
                  thumbData: A.subarray(14, 14 + 3 * A[12] * A[13])
                });
                65518 === w && 65 === A[0] && 100 === A[1] && 111 === A[2] && 98 === A[3] && 101 === A[4] && (g = {
                  version: A[5] << 8 | A[6],
                  flags0: A[7] << 8 | A[8],
                  flags1: A[9] << 8 | A[10],
                  transformCode: A[11]
                });
                break;
              case 65499:
                let v = i.readUint16(e, d) + (d += 2) - 2;
                for (; d < v;) {
                  let t = e[d++];
                  let a = new Uint16Array(64);
                  if (t >> 4 == 0) for (S = 0; S < 64; S++) a[l[S]] = e[d++]; else if (t >> 4 == 1) for (S = 0; S < 64; S++) {
                    a[l[S]] = i.readUint16(e, d);
                    d += 2;
                  } else throw new n("DQT - invalid table spec");
                  m[15 & t] = a;
                }
                break;
              case 65472:
              case 65473:
              case 65474:
                if (a) throw new n("Only single frame JPEGs supported");
                d += 2;
                (a = {}).extended = 65473 === w;
                a.progressive = 65474 === w;
                a.precision = e[d++];
                let C = i.readUint16(e, d);
                d += 2;
                a.scanLines = t || C;
                a.samplesPerLine = i.readUint16(e, d);
                d += 2;
                a.components = [];
                a.componentIds = {};
                let O = e[d++];
                let F = 0;
                let I = 0;
                for (x = 0; x < O; x++) {
                  let t = e[d];
                  let r = e[d + 1] >> 4;
                  let i = 15 & e[d + 1];
                  F < r && (F = r);
                  I < i && (I = i);
                  let n = e[d + 2];
                  k = a.components.push({
                    h: r,
                    v: i,
                    quantizationId: n,
                    quantizationTable: null
                  });
                  a.componentIds[t] = k - 1;
                  d += 3;
                }
                a.maxH = F;
                a.maxV = I;
                (function (e) {
                  let t = Math.ceil(e.samplesPerLine / 8 / e.maxH);
                  let a = Math.ceil(e.scanLines / 8 / e.maxV);
                  for (function () {
                    let r = 0;
                    let i = e.components.length;
                  }(); r < i; r++) {
                    let i = e.components[r];
                    let n = Math.ceil(Math.ceil(e.samplesPerLine / 8) * i.h / e.maxH);
                    let s = Math.ceil(Math.ceil(e.scanLines / 8) * i.v / e.maxV);
                    let o = t * i.h;
                    let l = 64 * (a * i.v) * (o + 1);
                    i.blockData = new Int16Array(l);
                    i.blocksPerLine = n;
                    i.blocksPerColumn = s;
                  }
                  e.mcusPerLine = t;
                  e.mcusPerColumn = a;
                })(a);
                break;
              case 65476:
                let T = i.readUint16(e, d);
                for (d += 2, x = 2; x < T;) {
                  let t = e[d++];
                  let a = new Uint8Array(16);
                  let r = 0;
                  for (S = 0; S < 16; S++, d++) r += a[S] = e[d];
                  let i = new Uint8Array(r);
                  for (S = 0; S < r; S++, d++) i[S] = e[d];
                  x += 17 + r;
                  (t >> 4 == 0 ? y : b)[15 & t] = function (e, t) {
                    let a = 0;
                    let r;
                    let i;
                    let n = 16;
                    for (; n > 0 && !e[n - 1];) n--;
                    let s = [{
                      children: [],
                      index: 0
                    }];
                    let o = s[0];
                    let l;
                    for (r = 0; r < n; r++) {
                      for (i = 0; i < e[r]; i++) {
                        for ((o = s.pop()).children[o.index] = t[a]; o.index > 0;) o = s.pop();
                        for (o.index++, s.push(o); s.length <= r;) {
                          s.push(l = {
                            children: [],
                            index: 0
                          });
                          o.children[o.index] = l.children;
                          o = l;
                        }
                        a++;
                      }
                      r + 1 < n && (s.push(l = {
                        children: [],
                        index: 0
                      }), o.children[o.index] = l.children, o = l);
                    }
                    return s[0].children;
                  }(a, i);
                }
                break;
              case 65501:
                d += 2;
                u = i.readUint16(e, d);
                d += 2;
                break;
              case 65498:
                let M = 1 == ++p && !t;
                d += 2;
                let P = e[d++];
                let E = [];
                for (x = 0; x < P; x++) {
                  let t = e[d++];
                  let r = a.componentIds[t];
                  let i = a.components[r];
                  i.index = t;
                  let n = e[d++];
                  i.huffmanTableDC = y[n >> 4];
                  i.huffmanTableAC = b[15 & n];
                  E.push(i);
                }
                let N = e[d++];
                let B = e[d++];
                let D = e[d++];
                try {
                  let t = function (e, t, a, u, d, f, g, p, m, b = !1) {
                    let y;
                    let w;
                    let x;
                    let S;
                    let k;
                    let A;
                    let v;
                    let C;
                    let O;
                    let F = a.mcusPerLine;
                    let I = a.progressive;
                    let T = t;
                    let M = 0;
                    let P = 0;
                    function E() {
                      if (P > 0) {
                        P--;
                        return M >> P & 1;
                      }
                      if (255 === (M = e[t++])) {
                        let r = e[t++];
                        if (r) {
                          if (220 === r && b) {
                            t += 2;
                            let r = i.readUint16(e, t);
                            if (t += 2, r > 0 && r !== a.scanLines) throw new s("Found DNL marker (0xFFDC) while parsing scan data", r);
                          } else if (217 === r) {
                            if (b) {
                              let e = j * (8 === a.precision ? 8 : 0);
                              if (e > 0 && Math.round(a.scanLines / e) >= 10) throw new s("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", e);
                            }
                            throw new o("Found EOI marker (0xFFD9) while parsing scan data");
                          }
                          throw new n(`unexpected marker ${(M << 8 | r).toString(16)}`);
                        }
                      }
                      P = 7;
                      return M >>> 7;
                    }
                    function N(e) {
                      let t = e;
                      for (; ;) {
                        switch (typeof (t = t[E()])) {
                          case "number":
                            return t;
                          case "object":
                            continue;
                        }
                        throw new n("invalid huffman sequence");
                      }
                    }
                    function B(e) {
                      let t = 0;
                      for (; e > 0;) {
                        t = t << 1 | E();
                        e--;
                      }
                      return t;
                    }
                    function D(e) {
                      if (1 === e) return 1 === E() ? 1 : -1;
                      let t = B(e);
                      return t >= 1 << e - 1 ? t : t + (-1 << e) + 1;
                    }
                    let L = 0;
                    let R = 0;
                    let $;
                    let j = 0;
                    let _ = u.length;
                    A = I ? 0 === f ? 0 === p ? function (e, t) {
                      let a = N(e.huffmanTableDC);
                      let r = 0 === a ? 0 : D(a) << m;
                      e.blockData[t] = e.pred += r;
                    } : function (e, t) {
                      e.blockData[t] |= E() << m;
                    } : 0 === p ? function (e, t) {
                      if (L > 0) {
                        L--;
                        return;
                      }
                      let a = f;
                      for (; a <= g;) {
                        let r = N(e.huffmanTableAC);
                        let i = 15 & r;
                        let n = r >> 4;
                        if (0 === i) {
                          if (n < 15) {
                            L = B(n) + (1 << n) - 1;
                            break;
                          }
                          a += 16;
                          continue;
                        }
                        let s = l[a += n];
                        e.blockData[t + s] = D(i) * (1 << m);
                        a++;
                      }
                    } : function (e, t) {
                      let a;
                      let r;
                      let i = f;
                      let s = 0;
                      for (; i <= g;) {
                        let o = t + l[i];
                        let c = e.blockData[o] < 0 ? -1 : 1;
                        switch (R) {
                          case 0:
                            if (a = 15 & (r = N(e.huffmanTableAC)), s = r >> 4, 0 === a) s < 15 ? (L = B(s) + (1 << s), R = 4) : (s = 16, R = 1); else {
                              if (1 !== a) throw new n("invalid ACn encoding");
                              $ = D(a);
                              R = s ? 2 : 3;
                            }
                            continue;
                          case 1:
                          case 2:
                            e.blockData[o] ? e.blockData[o] += c * (E() << m) : 0 == --s && (R = 2 === R ? 3 : 0);
                            break;
                          case 3:
                            e.blockData[o] ? e.blockData[o] += c * (E() << m) : (e.blockData[o] = $ << m, R = 0);
                            break;
                          case 4:
                            e.blockData[o] && (e.blockData[o] += c * (E() << m));
                        }
                        i++;
                      }
                      4 === R && 0 == --L && (R = 0);
                    } : function (e, t) {
                      let a = N(e.huffmanTableDC);
                      let r = 0 === a ? 0 : D(a);
                      e.blockData[t] = e.pred += r;
                      let i = 1;
                      for (; i < 64;) {
                        let a = N(e.huffmanTableAC);
                        let r = 15 & a;
                        let n = a >> 4;
                        if (0 === r) {
                          if (n < 15) break;
                          i += 16;
                          continue;
                        }
                        let s = l[i += n];
                        e.blockData[t + s] = D(r);
                        i++;
                      }
                    };
                    let U = 0;
                    let X;
                    for (v = 1 === _ ? u[0].blocksPerLine * u[0].blocksPerColumn : F * a.mcusPerColumn; U <= v;) {
                      let a = d ? Math.min(v - U, d) : v;
                      if (a > 0) {
                        for (w = 0; w < _; w++) u[w].pred = 0;
                        if (L = 0, 1 === _) for (k = 0, y = u[0]; k < a; k++) {
                          (function (e, t, a) {
                            j = a / e.blocksPerLine | 0;
                            let r = a % e.blocksPerLine;
                            let i = c(e, j, r);
                            t(e, i);
                          })(y, A, U);
                          U++;
                        } else for (k = 0; k < a; k++) {
                          for (w = 0; w < _; w++) for (x = 0, C = (y = u[w]).h, O = y.v; x < O; x++) for (S = 0; S < C; S++) !function (e, t, a, r, i) {
                            j = (a / F | 0) * e.v + r;
                            let n = a % F * e.h + i;
                            let s = c(e, j, n);
                            t(e, s);
                          }(y, A, U, x, S);
                          U++;
                        }
                      }
                      if (P = 0, !(X = h(e, t))) break;
                      if (X.invalid) {
                        let e = a > 0 ? "unexpected" : "excessive";
                        r.warn(`decodeScan - ${e} MCU data, current marker is: ${X.invalid}`);
                        t = X.offset;
                      }
                      if (X.marker >= 65488 && X.marker <= 65495) t += 2; else break;
                    }
                    return t - T;
                  }(e, d, a, E, u, N, B, D >> 4, 15 & D, M);
                  d += t;
                } catch (t) {
                  if (t instanceof s) {
                    r.warn(`${t.message} -- attempting to re-parse the JPEG image.`);
                    return this.parse(e, {
                      dnlScanLines: t.scanLines
                    });
                  }
                  if (t instanceof o) {
                    r.warn(`${t.message} -- ignoring the rest of the image data.`);
                    break t;
                  }
                  throw t;
                }
                break;
              case 65500:
                d += 4;
                break;
              case 65535:
                255 !== e[d] && d--;
                break;
              default:
                let L = h(e, d - 2, d - 3);
                if (L && L.invalid) {
                  r.warn("JpegImage.parse - unexpected data, current marker is: " + L.invalid);
                  d = L.offset;
                  break;
                }
                if (!L || d >= e.length - 1) {
                  r.warn("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
                  break t;
                }
                throw new n("JpegImage.parse - unknown marker: " + w.toString(16));
            }
            w = i.readUint16(e, d);
            d += 2;
          }
          this.width = a.samplesPerLine;
          this.height = a.scanLines;
          this.jfif = f;
          this.adobe = g;
          this.components = [];
          for (function () {
            let e = 0;
            let t = a.components.length;
          }(); e < t; e++) {
            let t = a.components[e];
            let r = m[t.quantizationId];
            r && (t.quantizationTable = r);
            this.components.push({
              index: t.index,
              output: function (e, t) {
                let a = t.blocksPerLine;
                let r = t.blocksPerColumn;
                let i = new Int16Array(64);
                for (let e = 0; e < r; e++) for (let r = 0; r < a; r++) {
                  let a = c(t, e, r);
                  !function (e, t, a) {
                    let r;
                    let i;
                    let s;
                    let o;
                    let l;
                    let c;
                    let h;
                    let u;
                    let d;
                    let f;
                    let g;
                    let p;
                    let m;
                    let b;
                    let y;
                    let w;
                    let x;
                    let S = e.quantizationTable;
                    let k = e.blockData;
                    if (!S) throw new n("missing required Quantization Table.");
                    for (let e = 0; e < 64; e += 8) {
                      if (d = k[t + e], f = k[t + e + 1], g = k[t + e + 2], p = k[t + e + 3], m = k[t + e + 4], b = k[t + e + 5], y = k[t + e + 6], w = k[t + e + 7], d *= S[e], (f | g | p | m | b | y | w) == 0) {
                        x = 5793 * d + 512 >> 10;
                        a[e] = x;
                        a[e + 1] = x;
                        a[e + 2] = x;
                        a[e + 3] = x;
                        a[e + 4] = x;
                        a[e + 5] = x;
                        a[e + 6] = x;
                        a[e + 7] = x;
                        continue;
                      }
                      f *= S[e + 1];
                      g *= S[e + 2];
                      p *= S[e + 3];
                      m *= S[e + 4];
                      b *= S[e + 5];
                      y *= S[e + 6];
                      w *= S[e + 7];
                      r = 5793 * d + 128 >> 8;
                      i = 5793 * m + 128 >> 8;
                      s = g;
                      o = y;
                      l = 2896 * (f - w) + 128 >> 8;
                      u = 2896 * (f + w) + 128 >> 8;
                      c = p << 4;
                      h = b << 4;
                      i = (r = r + i + 1 >> 1) - i;
                      x = 3784 * s + 1567 * o + 128 >> 8;
                      s = 1567 * s - 3784 * o + 128 >> 8;
                      o = x;
                      h = (l = l + h + 1 >> 1) - h;
                      c = (u = u + c + 1 >> 1) - c;
                      o = (r = r + o + 1 >> 1) - o;
                      s = (i = i + s + 1 >> 1) - s;
                      x = 2276 * l + 3406 * u + 2048 >> 12;
                      l = 3406 * l - 2276 * u + 2048 >> 12;
                      u = x;
                      x = 799 * c + 4017 * h + 2048 >> 12;
                      c = 4017 * c - 799 * h + 2048 >> 12;
                      h = x;
                      a[e] = r + u;
                      a[e + 7] = r - u;
                      a[e + 1] = i + h;
                      a[e + 6] = i - h;
                      a[e + 2] = s + c;
                      a[e + 5] = s - c;
                      a[e + 3] = o + l;
                      a[e + 4] = o - l;
                    }
                    for (let e = 0; e < 8; ++e) {
                      if (d = a[e], f = a[e + 8], g = a[e + 16], p = a[e + 24], m = a[e + 32], (f | g | p | m | (b = a[e + 40]) | (y = a[e + 48]) | (w = a[e + 56])) == 0) {
                        x = (x = 5793 * d + 8192 >> 14) < -2040 ? 0 : x >= 2024 ? 255 : x + 2056 >> 4;
                        k[t + e] = x;
                        k[t + e + 8] = x;
                        k[t + e + 16] = x;
                        k[t + e + 24] = x;
                        k[t + e + 32] = x;
                        k[t + e + 40] = x;
                        k[t + e + 48] = x;
                        k[t + e + 56] = x;
                        continue;
                      }
                      r = 5793 * d + 2048 >> 12;
                      i = 5793 * m + 2048 >> 12;
                      s = g;
                      o = y;
                      l = 2896 * (f - w) + 2048 >> 12;
                      u = 2896 * (f + w) + 2048 >> 12;
                      c = p;
                      h = b;
                      i = (r = (r + i + 1 >> 1) + 4112) - i;
                      x = 3784 * s + 1567 * o + 2048 >> 12;
                      s = 1567 * s - 3784 * o + 2048 >> 12;
                      o = x;
                      h = (l = l + h + 1 >> 1) - h;
                      c = (u = u + c + 1 >> 1) - c;
                      o = (r = r + o + 1 >> 1) - o;
                      s = (i = i + s + 1 >> 1) - s;
                      x = 2276 * l + 3406 * u + 2048 >> 12;
                      l = 3406 * l - 2276 * u + 2048 >> 12;
                      u = x;
                      x = 799 * c + 4017 * h + 2048 >> 12;
                      c = 4017 * c - 799 * h + 2048 >> 12;
                      h = x;
                      d = r + u;
                      w = r - u;
                      f = i + h;
                      y = i - h;
                      g = s + c;
                      b = s - c;
                      d < 16 ? d = 0 : d >= 4080 ? d = 255 : d >>= 4;
                      f < 16 ? f = 0 : f >= 4080 ? f = 255 : f >>= 4;
                      g < 16 ? g = 0 : g >= 4080 ? g = 255 : g >>= 4;
                      (p = o + l) < 16 ? p = 0 : p >= 4080 ? p = 255 : p >>= 4;
                      (m = o - l) < 16 ? m = 0 : m >= 4080 ? m = 255 : m >>= 4;
                      b < 16 ? b = 0 : b >= 4080 ? b = 255 : b >>= 4;
                      y < 16 ? y = 0 : y >= 4080 ? y = 255 : y >>= 4;
                      w < 16 ? w = 0 : w >= 4080 ? w = 255 : w >>= 4;
                      k[t + e] = d;
                      k[t + e + 8] = f;
                      k[t + e + 16] = g;
                      k[t + e + 24] = p;
                      k[t + e + 32] = m;
                      k[t + e + 40] = b;
                      k[t + e + 48] = y;
                      k[t + e + 56] = w;
                    }
                  }(t, a, i);
                }
                return t.blockData;
              }(0, t),
              scaleX: t.h / a.maxH,
              scaleY: t.v / a.maxV,
              blocksPerLine: t.blocksPerLine,
              blocksPerColumn: t.blocksPerColumn
            });
          }
          this.numComponents = this.components.length;
        }
        _getLinearizedBlockData(e, t, a = !1) {
          let r;
          let i;
          let n;
          let s;
          let o;
          let l;
          let c;
          let h;
          let u;
          let d;
          let f;
          let g;
          let p = this.width / e;
          let m = this.height / t;
          let b = 0;
          let y = this.components.length;
          let w = e * t * y;
          let x = new Uint8ClampedArray(w);
          let S = new Uint32Array(e);
          for (c = 0; c < y; c++) {
            if (i = (r = this.components[c]).scaleX * p, n = r.scaleY * m, b = c, f = r.output, s = r.blocksPerLine + 1 << 3, i !== g) {
              for (o = 0; o < e; o++) {
                h = 0 | o * i;
                S[o] = (0xfffffff8 & h) << 3 | 7 & h;
              }
              g = i;
            }
            for (l = 0; l < t; l++) for (o = 0, d = s * (0xfffffff8 & (h = 0 | l * n)) | (7 & h) << 3; o < e; o++) {
              x[b] = f[d + S[o]];
              b += y;
            }
          }
          let k = this._decodeTransform;
          if (a || 4 !== y || k || (k = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255])), k) for (c = 0; c < w;) for (h = 0, u = 0; h < y; h++, c++, u += 2) x[c] = (x[c] * k[u] >> 8) + k[u + 1];
          return x;
        }
        get _isColorConversionNeeded() {
          return this.adobe ? !!this.adobe.transformCode : 3 === this.numComponents ? 0 !== this._colorTransform && (82 !== this.components[0].index || 71 !== this.components[1].index || 66 !== this.components[2].index) : 1 === this._colorTransform;
        }
        _convertYccToRgb(e) {
          let t;
          let a;
          let r;
          for (function () {
            let i = 0;
            let n = e.length;
          }(); i < n; i += 3) {
            t = e[i];
            a = e[i + 1];
            r = e[i + 2];
            e[i] = t - 179.456 + 1.402 * r;
            e[i + 1] = t + 135.459 - .344 * a - .714 * r;
            e[i + 2] = t - 226.816 + 1.772 * a;
          }
          return e;
        }
        _convertYcckToRgb(e) {
          let t;
          let a;
          let r;
          let i;
          let n = 0;
          for (function () {
            let s = 0;
            let o = e.length;
          }(); s < o; s += 4) {
            t = e[s];
            a = e[s + 1];
            r = e[s + 2];
            i = e[s + 3];
            e[n++] = -122.67195406894 + a * (-660635669420364e-19 * a + 437130475926232e-18 * r - 54080610064599e-18 * t + 48449797120281e-17 * i - .154362151871126) + r * (-957964378445773e-18 * r + 817076911346625e-18 * t - .00477271405408747 * i + 1.53380253221734) + t * (961250184130688e-18 * t - .00266257332283933 * i + .48357088451265) + i * (-336197177618394e-18 * i + .484791561490776);
            e[n++] = 107.268039397724 + a * (219927104525741e-19 * a - 640992018297945e-18 * r + 659397001245577e-18 * t + 426105652938837e-18 * i - .176491792462875) + r * (-778269941513683e-18 * r + .00130872261408275 * t + 770482631801132e-18 * i - .151051492775562) + t * (.00126935368114843 * t - .00265090189010898 * i + .25802910206845) + i * (-318913117588328e-18 * i - .213742400323665);
            e[n++] = -20.810012546947 + a * (-570115196973677e-18 * a - 263409051004589e-19 * r + .0020741088115012 * t - .00288260236853442 * i + .814272968359295) + r * (-153496057440975e-19 * r - 132689043961446e-18 * t + 560833691242812e-18 * i - .195152027534049) + t * (.00174418132927582 * t - .00255243321439347 * i + .116935020465145) + i * (-343531996510555e-18 * i + .24165260232407);
          }
          return e.subarray(0, n);
        }
        _convertYcckToCmyk(e) {
          let t;
          let a;
          let r;
          for (function () {
            let i = 0;
            let n = e.length;
          }(); i < n; i += 4) {
            t = e[i];
            a = e[i + 1];
            r = e[i + 2];
            e[i] = 434.456 - t - 1.402 * r;
            e[i + 1] = 119.541 - t + .344 * a + .714 * r;
            e[i + 2] = 481.816 - t - 1.772 * a;
          }
          return e;
        }
        _convertCmykToRgb(e) {
          let t;
          let a;
          let r;
          let i;
          let n = 0;
          for (function () {
            let s = 0;
            let o = e.length;
          }(); s < o; s += 4) {
            t = e[s];
            a = e[s + 1];
            r = e[s + 2];
            i = e[s + 3];
            e[n++] = 255 + t * (-6747147073602441e-20 * t + 8379262121013727e-19 * a + 2894718188643294e-19 * r + .003264231057537806 * i - 1.1185611867203937) + a * (26374107616089405e-21 * a - 8626949158638572e-20 * r - 2748769067499491e-19 * i - .02155688794978967) + r * (-3878099212869363e-20 * r - 3267808279485286e-19 * i + .0686742238595345) - i * (3361971776183937e-19 * i + .7430659151342254);
            e[n++] = 255 + t * (13596372813588848e-20 * t + 924537132573585e-18 * a + 10567359618683593e-20 * r + 4791864687436512e-19 * i - .3109689587515875) + a * (-23545346108370344e-20 * a + 2702845253534714e-19 * r + .0020200308977307156 * i - .7488052167015494) + r * (6834815998235662e-20 * r + 15168452363460973e-20 * i - .09751927774728933) - i * (3189131175883281e-19 * i + .7364883807733168);
            e[n++] = 255 + t * (13598650411385307e-21 * t + 12423956175490851e-20 * a + 4751985097583589e-19 * r - 36729317476630422e-22 * i - .05562186980264034) + a * (16141380598724676e-20 * a + 9692239130725186e-19 * r + 7782692450036253e-19 * i - .44015232367526463) + r * (5068882914068769e-22 * r + .0017778369011375071 * i - .7591454649749609) - i * (3435319965105553e-19 * i + .7063770186160144);
          }
          return e.subarray(0, n);
        }
        getData({
          width: e,
          height: t,
          forceRGB: a = !1,
          isSourcePDF: r = !1
        }) {
          if (this.numComponents > 4) throw new n("Unsupported color mode");
          let i = this._getLinearizedBlockData(e, t, r);
          if (1 === this.numComponents && a) {
            let e = i.length;
            let t = new Uint8ClampedArray(3 * e);
            let a = 0;
            for (let r = 0; r < e; r++) {
              let e = i[r];
              t[a++] = e;
              t[a++] = e;
              t[a++] = e;
            }
            return t;
          }
          if (3 === this.numComponents && this._isColorConversionNeeded) return this._convertYccToRgb(i);
          if (4 === this.numComponents) {
            if (this._isColorConversionNeeded) return a ? this._convertYcckToRgb(i) : this._convertYcckToCmyk(i);
            if (a) return this._convertCmykToRgb(i);
          }
          return i;
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.JpxStream = void 0;
      var r = a(29);
      var i = a(40);
      var n = a(2);
      class s extends r.DecodeStream {
        constructor(e, t, a) {
          super(t);
          this.stream = e;
          this.dict = e.dict;
          this.maybeLength = t;
          this.params = a;
        }
        get bytes() {
          return n.shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
        }
        ensureBuffer(e) { }
        readBlock() {
          if (this.eof) return;
          let e = new i.JpxImage();
          e.parse(this.bytes);
          let t = e.width;
          let a = e.height;
          let r = e.componentsCount;
          let n = e.tiles.length;
          if (1 === n) this.buffer = e.tiles[0].items; else {
            let i = new Uint8ClampedArray(t * a * r);
            for (let a = 0; a < n; a++) {
              let n = e.tiles[a];
              let s = n.width;
              let o = n.height;
              let l = n.left;
              let c = n.top;
              let h = n.items;
              let u = 0;
              let d = (t * c + l) * r;
              let f = t * r;
              let g = s * r;
              for (let e = 0; e < o; e++) {
                let e = h.subarray(u, u + g);
                i.set(e, d);
                u += g;
                d += f;
              }
            }
            this.buffer = i;
          }
          this.bufferLength = this.buffer.length;
          this.eof = !0;
        }
      }
      t.JpxStream = s;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.JpxImage = void 0;
      var r = a(2);
      var i = a(8);
      var n = a(36);
      class s extends r.BaseException {
        constructor(e) {
          super(`JPX error: ${e}`, "JpxError");
        }
      }
      let o = {
        LL: 0,
        LH: 1,
        HL: 1,
        HH: 2
      };
      function l(e, t, a) {
        let r;
        let i;
        let n;
        let s;
        let o = a.xcb_;
        let l = a.ycb_;
        let c = 1 << o;
        let h = 1 << l;
        let u = t.tbx0 >> o;
        let d = t.tby0 >> l;
        let f = t.tbx1 + c - 1 >> o;
        let g = t.tby1 + h - 1 >> l;
        let p = t.resolution.precinctParameters;
        let m = [];
        let b = [];
        for (i = d; i < g; i++) for (r = u; r < f; r++) {
          if ((n = {
            cbx: r,
            cby: i,
            tbx0: c * r,
            tby0: h * i,
            tbx1: c * (r + 1),
            tby1: h * (i + 1)
          }).tbx0_ = Math.max(t.tbx0, n.tbx0), n.tby0_ = Math.max(t.tby0, n.tby0), n.tbx1_ = Math.min(t.tbx1, n.tbx1), n.tby1_ = Math.min(t.tby1, n.tby1), s = Math.floor((n.tbx0_ - t.tbx0) / p.precinctWidthInSubband) + Math.floor((n.tby0_ - t.tby0) / p.precinctHeightInSubband) * p.numprecinctswide, n.precinctNumber = s, n.subbandType = t.type, n.Lblock = 3, n.tbx1_ <= n.tbx0_ || n.tby1_ <= n.tby0_) continue;
          m.push(n);
          let e = b[s];
          void 0 !== e ? (r < e.cbxMin ? e.cbxMin = r : r > e.cbxMax && (e.cbxMax = r), i < e.cbyMin ? e.cbxMin = i : i > e.cbyMax && (e.cbyMax = i)) : b[s] = e = {
            cbxMin: r,
            cbyMin: i,
            cbxMax: r,
            cbyMax: i
          };
          n.precinct = e;
        }
        t.codeblockParameters = {
          codeblockWidth: o,
          codeblockHeight: l,
          numcodeblockwide: f - u + 1,
          numcodeblockhigh: g - d + 1
        };
        t.codeblocks = m;
        t.precincts = b;
      }
      function c(e, t, a) {
        let r = [];
        let i = e.subbands;
        for (function () {
          let e = 0;
          let a = i.length;
        }(); e < a; e++) {
          let a = i[e].codeblocks;
          for (function () {
            let e = 0;
            let i = a.length;
          }(); e < i; e++) {
            let i = a[e];
            i.precinctNumber === t && r.push(i);
          }
        }
        return {
          layerNumber: a,
          codeblocks: r
        };
      }
      function h(e) {
        let t = e.SIZ;
        let a = e.currentTile.index;
        let r = e.tiles[a];
        let i = r.codingStyleDefaultParameters.layersCount;
        let n = t.Csiz;
        let o = 0;
        for (let e = 0; e < n; e++) o = Math.max(o, r.components[e].codingStyleParameters.decompositionLevelsCount);
        let l = 0;
        let h = 0;
        let u = 0;
        let d = 0;
        this.nextPacket = function () {
          for (; l < i; l++) {
            for (; h <= o; h++) {
              for (; u < n; u++) {
                let e = r.components[u];
                if (h > e.codingStyleParameters.decompositionLevelsCount) continue;
                let t = e.resolutions[h];
                let a = t.precinctParameters.numprecincts;
                for (; d < a;) {
                  let e = c(t, d, l);
                  d++;
                  return e;
                }
                d = 0;
              }
              u = 0;
            }
            h = 0;
          }
          throw new s("Out of packets");
        };
      }
      function u(e) {
        let t = e.SIZ;
        let a = e.currentTile.index;
        let r = e.tiles[a];
        let i = r.codingStyleDefaultParameters.layersCount;
        let n = t.Csiz;
        let o = 0;
        for (let e = 0; e < n; e++) o = Math.max(o, r.components[e].codingStyleParameters.decompositionLevelsCount);
        let l = 0;
        let h = 0;
        let u = 0;
        let d = 0;
        this.nextPacket = function () {
          for (; l <= o; l++) {
            for (; h < i; h++) {
              for (; u < n; u++) {
                let e = r.components[u];
                if (l > e.codingStyleParameters.decompositionLevelsCount) continue;
                let t = e.resolutions[l];
                let a = t.precinctParameters.numprecincts;
                for (; d < a;) {
                  let e = c(t, d, h);
                  d++;
                  return e;
                }
                d = 0;
              }
              u = 0;
            }
            h = 0;
          }
          throw new s("Out of packets");
        };
      }
      function d(e) {
        let t;
        let a;
        let r;
        let i;
        let n = e.SIZ;
        let o = e.currentTile.index;
        let l = e.tiles[o];
        let h = l.codingStyleDefaultParameters.layersCount;
        let u = n.Csiz;
        let d = 0;
        for (r = 0; r < u; r++) {
          let e = l.components[r];
          d = Math.max(d, e.codingStyleParameters.decompositionLevelsCount);
        }
        let f = new Int32Array(d + 1);
        for (a = 0; a <= d; ++a) {
          let e = 0;
          for (r = 0; r < u; ++r) {
            let t = l.components[r].resolutions;
            a < t.length && (e = Math.max(e, t[a].precinctParameters.numprecincts));
          }
          f[a] = e;
        }
        t = 0;
        a = 0;
        r = 0;
        i = 0;
        this.nextPacket = function () {
          for (; a <= d; a++) {
            for (; i < f[a]; i++) {
              for (; r < u; r++) {
                let e = l.components[r];
                if (a > e.codingStyleParameters.decompositionLevelsCount) continue;
                let n = e.resolutions[a];
                let s = n.precinctParameters.numprecincts;
                if (!(i >= s)) {
                  for (; t < h;) {
                    let e = c(n, i, t);
                    t++;
                    return e;
                  }
                  t = 0;
                }
              }
              r = 0;
            }
            i = 0;
          }
          throw new s("Out of packets");
        };
      }
      function f(e) {
        let t = e.SIZ;
        let a = e.currentTile.index;
        let r = e.tiles[a];
        let i = r.codingStyleDefaultParameters.layersCount;
        let n = t.Csiz;
        let o = m(r);
        let l = 0;
        let h = 0;
        let u = 0;
        let d = 0;
        let f = 0;
        this.nextPacket = function () {
          for (; f < o.maxNumHigh; f++) {
            for (; d < o.maxNumWide; d++) {
              for (; u < n; u++) {
                let e = r.components[u];
                let t = e.codingStyleParameters.decompositionLevelsCount;
                for (; h <= t; h++) {
                  let t = e.resolutions[h];
                  let a = o.components[u].resolutions[h];
                  let r = p(d, f, a, o, t);
                  if (null !== r) {
                    for (; l < i;) {
                      let e = c(t, r, l);
                      l++;
                      return e;
                    }
                    l = 0;
                  }
                }
                h = 0;
              }
              u = 0;
            }
            d = 0;
          }
          throw new s("Out of packets");
        };
      }
      function g(e) {
        let t = e.SIZ;
        let a = e.currentTile.index;
        let r = e.tiles[a];
        let i = r.codingStyleDefaultParameters.layersCount;
        let n = t.Csiz;
        let o = m(r);
        let l = 0;
        let h = 0;
        let u = 0;
        let d = 0;
        let f = 0;
        this.nextPacket = function () {
          for (; u < n; ++u) {
            let e = r.components[u];
            let t = o.components[u];
            let a = e.codingStyleParameters.decompositionLevelsCount;
            for (; f < t.maxNumHigh; f++) {
              for (; d < t.maxNumWide; d++) {
                for (; h <= a; h++) {
                  let a = e.resolutions[h];
                  let r = t.resolutions[h];
                  let n = p(d, f, r, t, a);
                  if (null !== n) {
                    for (; l < i;) {
                      let e = c(a, n, l);
                      l++;
                      return e;
                    }
                    l = 0;
                  }
                }
                h = 0;
              }
              d = 0;
            }
            f = 0;
          }
          throw new s("Out of packets");
        };
      }
      function p(e, t, a, r, i) {
        let n = e * r.minWidth;
        let s = t * r.minHeight;
        if (n % a.width != 0 || s % a.height != 0) return null;
        let o = s / a.width * i.precinctParameters.numprecinctswide;
        return n / a.height + o;
      }
      function m(e) {
        let t = e.components.length;
        let a = Number.MAX_VALUE;
        let r = Number.MAX_VALUE;
        let i = 0;
        let n = 0;
        let s = Array(t);
        for (let o = 0; o < t; o++) {
          let t = e.components[o];
          let l = t.codingStyleParameters.decompositionLevelsCount;
          let c = Array(l + 1);
          let h = Number.MAX_VALUE;
          let u = Number.MAX_VALUE;
          let d = 0;
          let f = 0;
          let g = 1;
          for (let e = l; e >= 0; --e) {
            let a = t.resolutions[e];
            let r = g * a.precinctParameters.precinctWidth;
            let i = g * a.precinctParameters.precinctHeight;
            h = Math.min(h, r);
            u = Math.min(u, i);
            d = Math.max(d, a.precinctParameters.numprecinctswide);
            f = Math.max(f, a.precinctParameters.numprecinctshigh);
            c[e] = {
              width: r,
              height: i
            };
            g <<= 1;
          }
          a = Math.min(a, h);
          r = Math.min(r, u);
          i = Math.max(i, d);
          n = Math.max(n, f);
          s[o] = {
            resolutions: c,
            minWidth: h,
            minHeight: u,
            maxNumWide: d,
            maxNumHigh: f
          };
        }
        return {
          components: s,
          minWidth: a,
          minHeight: r,
          maxNumWide: i,
          maxNumHigh: n
        };
      }
      t.JpxImage = class {
        constructor() {
          this.failOnCorruptedImage = !1;
        }
        parse(e) {
          if (65359 === i.readUint16(e, 0)) {
            this.parseCodestream(e, 0, e.length);
            return;
          }
          let t = e.length;
          let a = 0;
          for (; a < t;) {
            let n = 8;
            let o = i.readUint32(e, a);
            let l = i.readUint32(e, a + 4);
            if (a += n, 1 === o && (o = 0x100000000 * i.readUint32(e, a) + i.readUint32(e, a + 4), a += 8, n += 8), 0 === o && (o = t - a + n), o < n) throw new s("Invalid box field size");
            let c = o - n;
            let h = !0;
            switch (l) {
              case 0x6a703268:
                h = !1;
                break;
              case 0x636f6c72:
                let u = e[a];
                if (1 === u) {
                  let t = i.readUint32(e, a + 3);
                  switch (t) {
                    case 16:
                    case 17:
                    case 18:
                      break;
                    default:
                      r.warn("Unknown colorspace " + t);
                  }
                } else 2 === u && r.info("ICC profile not supported");
                break;
              case 0x6a703263:
                this.parseCodestream(e, a, a + c);
                break;
              case 1783636e3:
                0xd0a870a !== i.readUint32(e, a) && r.warn("Invalid JP2 signature");
                break;
              case 0x6a501a1a:
              case 0x66747970:
              case 0x72726571:
              case 0x72657320:
              case 0x69686472:
                break;
              default:
                let d = String.fromCharCode(l >> 24 & 255, l >> 16 & 255, l >> 8 & 255, 255 & l);
                r.warn(`Unsupported header type ${l} (${d}).`);
            }
            h && (a += c);
          }
        }
        parseImageProperties(e) {
          let t = e.getByte();
          for (; t >= 0;) if (65361 == (t << 8 | (t = e.getByte()))) {
            e.skip(4);
            let t = e.getInt32() >>> 0;
            let a = e.getInt32() >>> 0;
            let r = e.getInt32() >>> 0;
            let i = e.getInt32() >>> 0;
            e.skip(16);
            let n = e.getUint16();
            this.width = t - r;
            this.height = a - i;
            this.componentsCount = n;
            this.bitsPerComponent = 8;
            return;
          }
          throw new s("No size marker found in JPX stream");
        }
        parseCodestream(e, t, a) {
          let c = {};
          let p = !1;
          try {
            let n = t;
            for (; n + 1 < a;) {
              let t = i.readUint16(e, n);
              n += 2;
              let a = 0;
              let o;
              let m;
              let w;
              let x;
              let S;
              let k;
              switch (t) {
                case 65359:
                  c.mainHeader = !0;
                  break;
                case 65497:
                  break;
                case 65361:
                  a = i.readUint16(e, n);
                  let A = {};
                  A.Xsiz = i.readUint32(e, n + 4);
                  A.Ysiz = i.readUint32(e, n + 8);
                  A.XOsiz = i.readUint32(e, n + 12);
                  A.YOsiz = i.readUint32(e, n + 16);
                  A.XTsiz = i.readUint32(e, n + 20);
                  A.YTsiz = i.readUint32(e, n + 24);
                  A.XTOsiz = i.readUint32(e, n + 28);
                  A.YTOsiz = i.readUint32(e, n + 32);
                  let v = i.readUint16(e, n + 36);
                  A.Csiz = v;
                  let C = [];
                  o = n + 38;
                  for (let t = 0; t < v; t++) {
                    let t = {
                      precision: (127 & e[o]) + 1,
                      isSigned: !!(128 & e[o]),
                      XRsiz: e[o + 1],
                      YRsiz: e[o + 2]
                    };
                    o += 3;
                    t.x0 = Math.ceil(A.XOsiz / t.XRsiz);
                    t.x1 = Math.ceil(A.Xsiz / t.XRsiz);
                    t.y0 = Math.ceil(A.YOsiz / t.YRsiz);
                    t.y1 = Math.ceil(A.Ysiz / t.YRsiz);
                    t.width = t.x1 - t.x0;
                    t.height = t.y1 - t.y0;
                    C.push(t);
                  }
                  c.SIZ = A;
                  c.components = C;
                  (function (e, t) {
                    let a;
                    let r = e.SIZ;
                    let i = [];
                    let n = Math.ceil((r.Xsiz - r.XTOsiz) / r.XTsiz);
                    let s = Math.ceil((r.Ysiz - r.YTOsiz) / r.YTsiz);
                    for (let e = 0; e < s; e++) for (let t = 0; t < n; t++) {
                      (a = {}).tx0 = Math.max(r.XTOsiz + t * r.XTsiz, r.XOsiz);
                      a.ty0 = Math.max(r.YTOsiz + e * r.YTsiz, r.YOsiz);
                      a.tx1 = Math.min(r.XTOsiz + (t + 1) * r.XTsiz, r.Xsiz);
                      a.ty1 = Math.min(r.YTOsiz + (e + 1) * r.YTsiz, r.Ysiz);
                      a.width = a.tx1 - a.tx0;
                      a.height = a.ty1 - a.ty0;
                      a.components = [];
                      i.push(a);
                    }
                    e.tiles = i;
                    let o = r.Csiz;
                    for (let e = 0; e < o; e++) {
                      let r = t[e];
                      for (function () {
                        let t = 0;
                        let n = i.length;
                      }(); t < n; t++) {
                        let n = {};
                        a = i[t];
                        n.tcx0 = Math.ceil(a.tx0 / r.XRsiz);
                        n.tcy0 = Math.ceil(a.ty0 / r.YRsiz);
                        n.tcx1 = Math.ceil(a.tx1 / r.XRsiz);
                        n.tcy1 = Math.ceil(a.ty1 / r.YRsiz);
                        n.width = n.tcx1 - n.tcx0;
                        n.height = n.tcy1 - n.tcy0;
                        a.components[e] = n;
                      }
                    }
                  })(c, C);
                  c.QCC = [];
                  c.COC = [];
                  break;
                case 65372:
                  a = i.readUint16(e, n);
                  let O = {};
                  switch (o = n + 2, m = e[o++], 31 & m) {
                    case 0:
                      x = 8;
                      S = !0;
                      break;
                    case 1:
                      x = 16;
                      S = !1;
                      break;
                    case 2:
                      x = 16;
                      S = !0;
                      break;
                    default:
                      throw Error("Invalid SQcd value " + m);
                  }
                  for (O.noQuantization = 8 === x, O.scalarExpounded = S, O.guardBits = m >> 5, w = []; o < a + n;) {
                    let t = {};
                    8 === x ? (t.epsilon = e[o++] >> 3, t.mu = 0) : (t.epsilon = e[o] >> 3, t.mu = (7 & e[o]) << 8 | e[o + 1], o += 2);
                    w.push(t);
                  }
                  O.SPqcds = w;
                  c.mainHeader ? c.QCD = O : (c.currentTile.QCD = O, c.currentTile.QCC = []);
                  break;
                case 65373:
                  let F;
                  a = i.readUint16(e, n);
                  let I = {};
                  switch (o = n + 2, c.SIZ.Csiz < 257 ? F = e[o++] : (F = i.readUint16(e, o), o += 2), m = e[o++], 31 & m) {
                    case 0:
                      x = 8;
                      S = !0;
                      break;
                    case 1:
                      x = 16;
                      S = !1;
                      break;
                    case 2:
                      x = 16;
                      S = !0;
                      break;
                    default:
                      throw Error("Invalid SQcd value " + m);
                  }
                  for (I.noQuantization = 8 === x, I.scalarExpounded = S, I.guardBits = m >> 5, w = []; o < a + n;) {
                    let t = {};
                    8 === x ? (t.epsilon = e[o++] >> 3, t.mu = 0) : (t.epsilon = e[o] >> 3, t.mu = (7 & e[o]) << 8 | e[o + 1], o += 2);
                    w.push(t);
                  }
                  I.SPqcds = w;
                  c.mainHeader ? c.QCC[F] = I : c.currentTile.QCC[F] = I;
                  break;
                case 65362:
                  a = i.readUint16(e, n);
                  let T = {};
                  o = n + 2;
                  let M = e[o++];
                  T.entropyCoderWithCustomPrecincts = !!(1 & M);
                  T.sopMarkerUsed = !!(2 & M);
                  T.ephMarkerUsed = !!(4 & M);
                  T.progressionOrder = e[o++];
                  T.layersCount = i.readUint16(e, o);
                  o += 2;
                  T.multipleComponentTransform = e[o++];
                  T.decompositionLevelsCount = e[o++];
                  T.xcb = (15 & e[o++]) + 2;
                  T.ycb = (15 & e[o++]) + 2;
                  let P = e[o++];
                  if (T.selectiveArithmeticCodingBypass = !!(1 & P), T.resetContextProbabilities = !!(2 & P), T.terminationOnEachCodingPass = !!(4 & P), T.verticallyStripe = !!(8 & P), T.predictableTermination = !!(16 & P), T.segmentationSymbolUsed = !!(32 & P), T.reversibleTransformation = e[o++], T.entropyCoderWithCustomPrecincts) {
                    let t = [];
                    for (; o < a + n;) {
                      let a = e[o++];
                      t.push({
                        PPx: 15 & a,
                        PPy: a >> 4
                      });
                    }
                    T.precinctsSizes = t;
                  }
                  let E = [];
                  T.selectiveArithmeticCodingBypass && E.push("selectiveArithmeticCodingBypass");
                  T.terminationOnEachCodingPass && E.push("terminationOnEachCodingPass");
                  T.verticallyStripe && E.push("verticallyStripe");
                  T.predictableTermination && E.push("predictableTermination");
                  E.length > 0 && (p = !0, r.warn(`JPX: Unsupported COD options (${E.join(", ")}).`));
                  c.mainHeader ? c.COD = T : (c.currentTile.COD = T, c.currentTile.COC = []);
                  break;
                case 65424:
                  a = i.readUint16(e, n);
                  (k = {}).index = i.readUint16(e, n + 2);
                  k.length = i.readUint32(e, n + 4);
                  k.dataEnd = k.length + n - 2;
                  k.partIndex = e[n + 8];
                  k.partsCount = e[n + 9];
                  c.mainHeader = !1;
                  0 === k.partIndex && (k.COD = c.COD, k.COC = c.COC.slice(0), k.QCD = c.QCD, k.QCC = c.QCC.slice(0));
                  c.currentTile = k;
                  break;
                case 65427:
                  k = c.currentTile;
                  0 === k.partIndex && (function (e, t) {
                    let a = e.SIZ.Csiz;
                    let r = e.tiles[t];
                    for (let t = 0; t < a; t++) {
                      let a = r.components[t];
                      let i = void 0 !== e.currentTile.QCC[t] ? e.currentTile.QCC[t] : e.currentTile.QCD;
                      a.quantizationParameters = i;
                      let n = void 0 !== e.currentTile.COC[t] ? e.currentTile.COC[t] : e.currentTile.COD;
                      a.codingStyleParameters = n;
                    }
                    r.codingStyleDefaultParameters = e.currentTile.COD;
                  }(c, k.index), function (e) {
                    let t = e.SIZ;
                    let a = e.currentTile.index;
                    let r = e.tiles[a];
                    let i = t.Csiz;
                    for (let t = 0; t < i; t++) {
                      let a = r.components[t];
                      let i = a.codingStyleParameters.decompositionLevelsCount;
                      let n = [];
                      let s = [];
                      for (let t = 0; t <= i; t++) {
                        let r;
                        let o = function (e, t, a) {
                          let r = t.codingStyleParameters;
                          let i = {};
                          r.entropyCoderWithCustomPrecincts ? (i.PPx = r.precinctsSizes[a].PPx, i.PPy = r.precinctsSizes[a].PPy) : (i.PPx = 15, i.PPy = 15);
                          i.xcb_ = a > 0 ? Math.min(r.xcb, i.PPx - 1) : Math.min(r.xcb, i.PPx);
                          i.ycb_ = a > 0 ? Math.min(r.ycb, i.PPy - 1) : Math.min(r.ycb, i.PPy);
                          return i;
                        }(0, a, t);
                        let c = {};
                        let h = 1 << i - t;
                        if (c.trx0 = Math.ceil(a.tcx0 / h), c.try0 = Math.ceil(a.tcy0 / h), c.trx1 = Math.ceil(a.tcx1 / h), c.try1 = Math.ceil(a.tcy1 / h), c.resLevel = t, function (e, t, a) {
                          let r = 1 << a.PPx;
                          let i = 1 << a.PPy;
                          let n = 0 === t.resLevel;
                          let s = 1 << a.PPx + (n ? 0 : -1);
                          let o = 1 << a.PPy + (n ? 0 : -1);
                          let l = t.trx1 > t.trx0 ? Math.ceil(t.trx1 / r) - Math.floor(t.trx0 / r) : 0;
                          let c = t.try1 > t.try0 ? Math.ceil(t.try1 / i) - Math.floor(t.try0 / i) : 0;
                          t.precinctParameters = {
                            precinctWidth: r,
                            precinctHeight: i,
                            numprecinctswide: l,
                            numprecinctshigh: c,
                            numprecincts: l * c,
                            precinctWidthInSubband: s,
                            precinctHeightInSubband: o
                          };
                        }(0, c, o), n.push(c), 0 === t) {
                          (r = {}).type = "LL";
                          r.tbx0 = Math.ceil(a.tcx0 / h);
                          r.tby0 = Math.ceil(a.tcy0 / h);
                          r.tbx1 = Math.ceil(a.tcx1 / h);
                          r.tby1 = Math.ceil(a.tcy1 / h);
                          r.resolution = c;
                          l(e, r, o);
                          s.push(r);
                          c.subbands = [r];
                        } else {
                          let n = 1 << i - t + 1;
                          let h = [];
                          (r = {}).type = "HL";
                          r.tbx0 = Math.ceil(a.tcx0 / n - .5);
                          r.tby0 = Math.ceil(a.tcy0 / n);
                          r.tbx1 = Math.ceil(a.tcx1 / n - .5);
                          r.tby1 = Math.ceil(a.tcy1 / n);
                          r.resolution = c;
                          l(e, r, o);
                          s.push(r);
                          h.push(r);
                          (r = {}).type = "LH";
                          r.tbx0 = Math.ceil(a.tcx0 / n);
                          r.tby0 = Math.ceil(a.tcy0 / n - .5);
                          r.tbx1 = Math.ceil(a.tcx1 / n);
                          r.tby1 = Math.ceil(a.tcy1 / n - .5);
                          r.resolution = c;
                          l(e, r, o);
                          s.push(r);
                          h.push(r);
                          (r = {}).type = "HH";
                          r.tbx0 = Math.ceil(a.tcx0 / n - .5);
                          r.tby0 = Math.ceil(a.tcy0 / n - .5);
                          r.tbx1 = Math.ceil(a.tcx1 / n - .5);
                          r.tby1 = Math.ceil(a.tcy1 / n - .5);
                          r.resolution = c;
                          l(e, r, o);
                          s.push(r);
                          h.push(r);
                          c.subbands = h;
                        }
                      }
                      a.resolutions = n;
                      a.subbands = s;
                    }
                    let n = r.codingStyleDefaultParameters.progressionOrder;
                    switch (n) {
                      case 0:
                        r.packetsIterator = new h(e);
                        break;
                      case 1:
                        r.packetsIterator = new u(e);
                        break;
                      case 2:
                        r.packetsIterator = new d(e);
                        break;
                      case 3:
                        r.packetsIterator = new f(e);
                        break;
                      case 4:
                        r.packetsIterator = new g(e);
                        break;
                      default:
                        throw new s(`Unsupported progression order ${n}`);
                    }
                  }(c));
                  a = k.dataEnd - n;
                  (function (e, t, a, r) {
                    let n = 0;
                    let o;
                    let l = 0;
                    let c = !1;
                    function h(e) {
                      for (; l < e;) {
                        let e = t[a + n];
                        n++;
                        c ? (o = o << 7 | e, l += 7, c = !1) : (o = o << 8 | e, l += 8);
                        255 === e && (c = !0);
                      }
                      l -= e;
                      return o >>> l & (1 << e) - 1;
                    }
                    function u(e) {
                      return 255 === t[a + n - 1] && t[a + n] === e ? (n += 1, !0) : 255 === t[a + n] && t[a + n + 1] === e && (n += 2, !0);
                    }
                    function d() {
                      l = 0;
                      c && (n++, c = !1);
                    }
                    let f = e.currentTile.index;
                    let g = e.tiles[f];
                    let p = e.COD.sopMarkerUsed;
                    let m = e.COD.ephMarkerUsed;
                    let w = g.packetsIterator;
                    for (; n < r;) {
                      let e;
                      d();
                      p && u(145) && (n += 4);
                      let r = w.nextPacket();
                      if (!h(1)) continue;
                      let o = r.layerNumber;
                      let l = [];
                      for (function () {
                        let t = 0;
                        let a = r.codeblocks.length;
                      }(); t < a; t++) {
                        let a;
                        let n = (e = r.codeblocks[t]).precinct;
                        let c = e.cbx - n.cbxMin;
                        let u = e.cby - n.cbyMin;
                        let d = !1;
                        let f = !1;
                        if (void 0 !== e.included) d = !!h(1); else {
                          let t;
                          if (void 0 !== (n = e.precinct).inclusionTree) t = n.inclusionTree; else {
                            let e = n.cbxMax - n.cbxMin + 1;
                            let r = n.cbyMax - n.cbyMin + 1;
                            t = new y(e, r, o);
                            a = new b(e, r);
                            n.inclusionTree = t;
                            n.zeroBitPlanesTree = a;
                            for (let e = 0; e < o; e++) if (0 !== h(1)) throw new s("Invalid tag tree");
                          }
                          if (t.reset(c, u, o)) for (; ;) if (h(1)) {
                            if (!t.nextLevel()) {
                              e.included = !0;
                              d = f = !0;
                              break;
                            }
                          } else {
                            t.incrementValue(o);
                            break;
                          }
                        }
                        if (!d) continue;
                        if (f) {
                          for ((a = n.zeroBitPlanesTree).reset(c, u); ;) if (h(1)) {
                            if (!a.nextLevel()) break;
                          } else a.incrementValue();
                          e.zeroBitPlanes = a.value;
                        }
                        let g = function () {
                          if (0 === h(1)) return 1;
                          if (0 === h(1)) return 2;
                          let e = h(2);
                          return e < 3 ? e + 3 : (e = h(5)) < 31 ? e + 6 : (e = h(7)) + 37;
                        }();
                        for (; h(1);) e.Lblock++;
                        let p = i.log2(g);
                        let m = h((g < 1 << p ? p - 1 : p) + e.Lblock);
                        l.push({
                          codeblock: e,
                          codingpasses: g,
                          dataLength: m
                        });
                      }
                      for (d(), m && u(146); l.length > 0;) {
                        let r = l.shift();
                        void 0 === (e = r.codeblock).data && (e.data = []);
                        e.data.push({
                          data: t,
                          start: a + n,
                          end: a + n + r.dataLength,
                          codingpasses: r.codingpasses
                        });
                        n += r.dataLength;
                      }
                    }
                  })(c, e, n, a);
                  break;
                case 65363:
                  r.warn("JPX: Codestream code 0xFF53 (COC) is not implemented.");
                case 65365:
                case 65367:
                case 65368:
                case 65380:
                  a = i.readUint16(e, n);
                  break;
                default:
                  throw Error("Unknown codestream code: " + t.toString(16));
              }
              n += a;
            }
          } catch (e) {
            if (p || this.failOnCorruptedImage) throw new s(e.message);
            r.warn(`JPX: Trying to recover from: "${e.message}".`);
          }
          this.tiles = function (e) {
            let t = e.SIZ;
            let a = e.components;
            let r = t.Csiz;
            let i = [];
            for (function () {
              let t = 0;
              let s = e.tiles.length;
            }(); t < s; t++) {
              let s;
              let l;
              let c = e.tiles[t];
              let h = [];
              for (let t = 0; t < r; t++) h[t] = function (e, t, a) {
                let r = t.components[a];
                let i = r.codingStyleParameters;
                let s = r.quantizationParameters;
                let l = i.decompositionLevelsCount;
                let c = s.SPqcds;
                let h = s.scalarExpounded;
                let u = s.guardBits;
                let d = i.segmentationSymbolUsed;
                let f = i.resetContextProbabilities;
                let g = e.components[a].precision;
                let p = i.reversibleTransformation;
                let m = p ? new k() : new S();
                let b = [];
                let y = 0;
                for (let e = 0; e <= l; e++) {
                  let t = r.resolutions[e];
                  let a = t.trx1 - t.trx0;
                  let i = t.try1 - t.try0;
                  let s = new Float32Array(a * i);
                  for (function () {
                    let r = 0;
                    let i = t.subbands.length;
                  }(); r < i; r++) {
                    let i;
                    let l;
                    h ? (i = c[y].mu, l = c[y].epsilon, y++) : (i = c[0].mu, l = c[0].epsilon + (e > 0 ? 1 - e : 0));
                    let m = t.subbands[r];
                    let b = o[m.type];
                    !function (e, t, a, r, i, s, o, l, c) {
                      let h = r.tbx0;
                      let u = r.tby0;
                      let d = r.tbx1 - r.tbx0;
                      let f = r.codeblocks;
                      let g = "H" === r.type.charAt(0) ? 1 : 0;
                      let p = "H" === r.type.charAt(1) ? t : 0;
                      for (function () {
                        let a = 0;
                        let m = f.length;
                      }(); a < m; ++a) {
                        let m;
                        let b;
                        let y;
                        let x;
                        let S;
                        let k;
                        let A = f[a];
                        let v = A.tbx1_ - A.tbx0_;
                        let C = A.tby1_ - A.tby0_;
                        if (0 === v || 0 === C || void 0 === A.data) continue;
                        let O = new w(v, C, A.subbandType, A.zeroBitPlanes, s);
                        let F = 2;
                        let I = A.data;
                        let T = 0;
                        let M = 0;
                        for (m = 0, b = I.length; m < b; m++) {
                          T += (y = I[m]).end - y.start;
                          M += y.codingpasses;
                        }
                        let P = new Uint8Array(T);
                        let E = 0;
                        for (m = 0, b = I.length; m < b; m++) {
                          let e = (y = I[m]).data.subarray(y.start, y.end);
                          P.set(e, E);
                          E += e.length;
                        }
                        let N = new n.ArithmeticDecoder(P, 0, T);
                        for (O.setDecoder(N), m = 0; m < M; m++) {
                          switch (F) {
                            case 0:
                              O.runSignificancePropagationPass();
                              break;
                            case 1:
                              O.runMagnitudeRefinementPass();
                              break;
                            case 2:
                              O.runCleanupPass();
                              l && O.checkSegmentationSymbol();
                          }
                          c && O.reset();
                          F = (F + 1) % 3;
                        }
                        let B = A.tbx0_ - h + (A.tby0_ - u) * d;
                        let D = O.coefficentsSign;
                        let L = O.coefficentsMagnitude;
                        let R = O.bitsDecoded;
                        let $ = o ? 0 : .5;
                        E = 0;
                        let j = "LL" !== r.type;
                        for (m = 0; m < C; m++) {
                          let a = 2 * (B / d | 0) * (t - d) + g + p;
                          for (x = 0; x < v; x++) {
                            if (0 !== (S = L[E])) {
                              S = (S + $) * i;
                              0 !== D[E] && (S = -S);
                              k = R[E];
                              let t = j ? a + (B << 1) : B;
                              o && k >= s ? e[t] = S : e[t] = S * (1 << s - k);
                            }
                            B++;
                            E++;
                          }
                          B += d - v;
                        }
                      }
                    }(s, a, 0, m, p ? 1 : 2 ** (g + b - l) * (1 + i / 2048), u + l - 1, p, d, f);
                  }
                  b.push({
                    width: a,
                    height: i,
                    items: s
                  });
                }
                let x = m.calculate(b, r.tcx0, r.tcy0);
                return {
                  left: r.tcx0,
                  top: r.tcy0,
                  width: x.width,
                  height: x.height,
                  items: x.items
                };
              }(e, c, t);
              let u = h[0];
              let d = new Uint8ClampedArray(u.items.length * r);
              let f = {
                left: u.left,
                top: u.top,
                width: u.width,
                height: u.height,
                items: d
              };
              let g = 0;
              let p;
              let m;
              let b;
              let y;
              let x;
              if (c.codingStyleDefaultParameters.multipleComponentTransform) {
                let e = 4 === r;
                let t = h[0].items;
                let i = h[1].items;
                let n = h[2].items;
                let o = e ? h[3].items : null;
                l = (128 << (s = a[0].precision - 8)) + .5;
                let u = c.components[0];
                let f = r - 3;
                if (m = t.length, u.codingStyleParameters.reversibleTransformation) for (p = 0; p < m; p++, g += f) {
                  b = t[p] + l;
                  y = i[p];
                  let e = b - ((x = n[p]) + y >> 2);
                  d[g++] = e + x >> s;
                  d[g++] = e >> s;
                  d[g++] = e + y >> s;
                } else for (p = 0; p < m; p++, g += f) {
                  b = t[p] + l;
                  y = i[p];
                  x = n[p];
                  d[g++] = b + 1.402 * x >> s;
                  d[g++] = b - .34413 * y - .71414 * x >> s;
                  d[g++] = b + 1.772 * y >> s;
                }
                if (e) for (p = 0, g = 3; p < m; p++, g += 4) d[g] = o[p] + l >> s;
              } else for (let e = 0; e < r; e++) {
                let t = h[e].items;
                for (l = (128 << (s = a[e].precision - 8)) + .5, g = e, p = 0, m = t.length; p < m; p++) {
                  d[g] = t[p] + l >> s;
                  g += r;
                }
              }
              i.push(f);
            }
            return i;
          }(c);
          this.width = c.SIZ.Xsiz - c.SIZ.XOsiz;
          this.height = c.SIZ.Ysiz - c.SIZ.YOsiz;
          this.componentsCount = c.SIZ.Csiz;
        }
      };
      class b {
        constructor(e, t) {
          let a = i.log2(Math.max(e, t)) + 1;
          this.levels = [];
          for (let r = 0; r < a; r++) {
            let a = {
              width: e,
              height: t,
              items: []
            };
            this.levels.push(a);
            e = Math.ceil(e / 2);
            t = Math.ceil(t / 2);
          }
        }
        reset(e, t) {
          let a = 0;
          let r = 0;
          let i;
          for (; a < this.levels.length;) {
            i = this.levels[a];
            let n = e + t * i.width;
            if (void 0 !== i.items[n]) {
              r = i.items[n];
              break;
            }
            i.index = n;
            e >>= 1;
            t >>= 1;
            a++;
          }
          a--;
          (i = this.levels[a]).items[i.index] = r;
          this.currentLevel = a;
          delete this.value;
        }
        incrementValue() {
          let e = this.levels[this.currentLevel];
          e.items[e.index]++;
        }
        nextLevel() {
          let e = this.currentLevel;
          let t = this.levels[e];
          let a = t.items[t.index];
          return --e < 0 ? (this.value = a, !1) : (this.currentLevel = e, (t = this.levels[e]).items[t.index] = a, !0);
        }
      }
      class y {
        constructor(e, t, a) {
          let r = i.log2(Math.max(e, t)) + 1;
          this.levels = [];
          for (let i = 0; i < r; i++) {
            let r = new Uint8Array(e * t);
            for (function () {
              let e = 0;
              let t = r.length;
            }(); e < t; e++) r[e] = a;
            let i = {
              width: e,
              height: t,
              items: r
            };
            this.levels.push(i);
            e = Math.ceil(e / 2);
            t = Math.ceil(t / 2);
          }
        }
        reset(e, t, a) {
          let r = 0;
          for (; r < this.levels.length;) {
            let i = this.levels[r];
            let n = e + t * i.width;
            i.index = n;
            let s = i.items[n];
            if (255 === s) break;
            if (s > a) {
              this.currentLevel = r;
              this.propagateValues();
              return !1;
            }
            e >>= 1;
            t >>= 1;
            r++;
          }
          this.currentLevel = r - 1;
          return !0;
        }
        incrementValue(e) {
          let t = this.levels[this.currentLevel];
          t.items[t.index] = e + 1;
          this.propagateValues();
        }
        propagateValues() {
          let e = this.currentLevel;
          let t = this.levels[e];
          let a = t.items[t.index];
          for (; --e >= 0;) (t = this.levels[e]).items[t.index] = a;
        }
        nextLevel() {
          let e = this.currentLevel;
          let t = this.levels[e];
          let a = t.items[t.index];
          t.items[t.index] = 255;
          return !(--e < 0) && (this.currentLevel = e, (t = this.levels[e]).items[t.index] = a, !0);
        }
      }
      let w = function () {
        let e = new Uint8Array([0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8]);
        let t = new Uint8Array([0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8]);
        let a = new Uint8Array([0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8]);
        return class {
          constructor(r, i, n, s, o) {
            let l;
            let c;
            this.width = r;
            this.height = i;
            l = "HH" === n ? a : "HL" === n ? t : e;
            this.contextLabelTable = l;
            let h = r * i;
            this.neighborsSignificance = new Uint8Array(h);
            this.coefficentsSign = new Uint8Array(h);
            c = o > 14 ? new Uint32Array(h) : o > 6 ? new Uint16Array(h) : new Uint8Array(h);
            this.coefficentsMagnitude = c;
            this.processingFlags = new Uint8Array(h);
            let u = new Uint8Array(h);
            if (0 !== s) for (let e = 0; e < h; e++) u[e] = s;
            this.bitsDecoded = u;
            this.reset();
          }
          setDecoder(e) {
            this.decoder = e;
          }
          reset() {
            this.contexts = new Int8Array(19);
            this.contexts[0] = 8;
            this.contexts[17] = 92;
            this.contexts[18] = 6;
          }
          setNeighborsSignificance(e, t, a) {
            let r;
            let i = this.neighborsSignificance;
            let n = this.width;
            let s = this.height;
            let o = t > 0;
            let l = t + 1 < n;
            e > 0 && (r = a - n, o && (i[r - 1] += 16), l && (i[r + 1] += 16), i[r] += 4);
            e + 1 < s && (r = a + n, o && (i[r - 1] += 16), l && (i[r + 1] += 16), i[r] += 4);
            o && (i[a - 1] += 1);
            l && (i[a + 1] += 1);
            i[a] |= 128;
          }
          runSignificancePropagationPass() {
            let e = this.decoder;
            let t = this.width;
            let a = this.height;
            let r = this.coefficentsMagnitude;
            let i = this.coefficentsSign;
            let n = this.neighborsSignificance;
            let s = this.processingFlags;
            let o = this.contexts;
            let l = this.contextLabelTable;
            let c = this.bitsDecoded;
            for (let h = 0; h < a; h += 4) for (let u = 0; u < t; u++) {
              let d = h * t + u;
              for (let f = 0; f < 4; f++, d += t) {
                let t = h + f;
                if (t >= a) break;
                if (s[d] &= -2, r[d] || !n[d]) continue;
                let g = l[n[d]];
                if (e.readBit(o, g)) {
                  let e = this.decodeSignBit(t, u, d);
                  i[d] = e;
                  r[d] = 1;
                  this.setNeighborsSignificance(t, u, d);
                  s[d] |= 2;
                }
                c[d]++;
                s[d] |= 1;
              }
            }
          }
          decodeSignBit(e, t, a) {
            let r;
            let i;
            let n;
            let s;
            let o;
            let l;
            let c = this.width;
            let h = this.height;
            let u = this.coefficentsMagnitude;
            let d = this.coefficentsSign;
            s = t > 0 && 0 !== u[a - 1];
            t + 1 < c && 0 !== u[a + 1] ? (n = d[a + 1], r = s ? 1 - n - (i = d[a - 1]) : 1 - n - n) : r = s ? 1 - (i = d[a - 1]) - i : 0;
            let f = 3 * r;
            s = e > 0 && 0 !== u[a - c];
            e + 1 < h && 0 !== u[a + c] ? (n = d[a + c], r = s ? 1 - n - (i = d[a - c]) + f : 1 - n - n + f) : r = s ? 1 - (i = d[a - c]) - i + f : f;
            r >= 0 ? (o = 9 + r, l = this.decoder.readBit(this.contexts, o)) : (o = 9 - r, l = 1 ^ this.decoder.readBit(this.contexts, o));
            return l;
          }
          runMagnitudeRefinementPass() {
            let e = this.decoder;
            let t = this.width;
            let a = this.height;
            let r = this.coefficentsMagnitude;
            let i = this.neighborsSignificance;
            let n = this.contexts;
            let s = this.bitsDecoded;
            let o = this.processingFlags;
            let l = t * a;
            let c = 4 * t;
            for (function () {
              let a = 0;
              let h;
            }(); a < l; a = h) {
              h = Math.min(l, a + c);
              for (let l = 0; l < t; l++) for (let c = a + l; c < h; c += t) {
                if (!r[c] || (1 & o[c]) != 0) continue;
                let t = 16;
                (2 & o[c]) != 0 && (o[c] ^= 2, t = 0 == (127 & i[c]) ? 15 : 14);
                let a = e.readBit(n, t);
                r[c] = r[c] << 1 | a;
                s[c]++;
                o[c] |= 1;
              }
            }
          }
          runCleanupPass() {
            let e;
            let t = this.decoder;
            let a = this.width;
            let r = this.height;
            let i = this.neighborsSignificance;
            let n = this.coefficentsMagnitude;
            let s = this.coefficentsSign;
            let o = this.contexts;
            let l = this.contextLabelTable;
            let c = this.bitsDecoded;
            let h = this.processingFlags;
            let u = 2 * a;
            let d = 3 * a;
            for (let f = 0; f < r; f = e) {
              e = Math.min(f + 4, r);
              let g = f * a;
              let p = f + 3 < r;
              for (let r = 0; r < a; r++) {
                let m = g + r;
                let b = p && 0 === h[m] && 0 === h[m + a] && 0 === h[m + u] && 0 === h[m + d] && 0 === i[m] && 0 === i[m + a] && 0 === i[m + u] && 0 === i[m + d];
                let y = 0;
                let w = m;
                let x = f;
                let S;
                if (b) {
                  if (!t.readBit(o, 18)) {
                    c[m]++;
                    c[m + a]++;
                    c[m + u]++;
                    c[m + d]++;
                    continue;
                  }
                  0 != (y = t.readBit(o, 17) << 1 | t.readBit(o, 17)) && (x = f + y, w += y * a);
                  S = this.decodeSignBit(x, r, w);
                  s[w] = S;
                  n[w] = 1;
                  this.setNeighborsSignificance(x, r, w);
                  h[w] |= 2;
                  w = m;
                  for (let e = f; e <= x; e++, w += a) c[w]++;
                  y++;
                }
                for (x = f + y; x < e; x++, w += a) {
                  if (n[w] || (1 & h[w]) != 0) continue;
                  let e = l[i[w]];
                  1 === t.readBit(o, e) && (S = this.decodeSignBit(x, r, w), s[w] = S, n[w] = 1, this.setNeighborsSignificance(x, r, w), h[w] |= 2);
                  c[w]++;
                }
              }
            }
          }
          checkSegmentationSymbol() {
            let e = this.decoder;
            let t = this.contexts;
            if (10 != (e.readBit(t, 17) << 3 | e.readBit(t, 17) << 2 | e.readBit(t, 17) << 1 | e.readBit(t, 17))) throw new s("Invalid segmentation symbol");
          }
        };
      }();
      class x {
        constructor() {
          this.constructor === x && r.unreachable("Cannot initialize Transform.");
        }
        calculate(e, t, a) {
          let r = e[0];
          for (function () {
            let i = 1;
            let n = e.length;
          }(); i < n; i++) r = this.iterate(r, e[i], t, a);
          return r;
        }
        extend(e, t, a) {
          let r = t - 1;
          let i = t + 1;
          let n = t + a - 2;
          let s = t + a;
          e[r--] = e[i++];
          e[s++] = e[n--];
          e[r--] = e[i++];
          e[s++] = e[n--];
          e[r--] = e[i++];
          e[s++] = e[n--];
          e[r] = e[i];
          e[s] = e[n];
        }
        filter(e, t, a) {
          r.unreachable("Abstract method `filter` called");
        }
        iterate(e, t, a, r) {
          let i;
          let n;
          let s;
          let o;
          let l;
          let c;
          let h = e.width;
          let u = e.height;
          let d = e.items;
          let f = t.width;
          let g = t.height;
          let p = t.items;
          for (s = 0, i = 0; i < u; i++) for (n = 0, o = 2 * i * f; n < h; n++, s++, o += 2) p[o] = d[s];
          d = e.items = null;
          let m = new Float32Array(f + 8);
          if (1 === f) {
            if ((1 & a) != 0) for (c = 0, s = 0; c < g; c++, s += f) p[s] *= .5;
          } else for (c = 0, s = 0; c < g; c++, s += f) {
            m.set(p.subarray(s, s + f), 4);
            this.extend(m, 4, f);
            this.filter(m, 4, f);
            p.set(m.subarray(4, 4 + f), s);
          }
          let b = 16;
          let y = [];
          for (i = 0; i < b; i++) y.push(new Float32Array(g + 8));
          let w;
          let x = 0;
          if (e = 4 + g, 1 === g) {
            if ((1 & r) != 0) for (l = 0; l < f; l++) p[l] *= .5;
          } else for (l = 0; l < f; l++) {
            if (0 === x) {
              for (b = Math.min(f - l, b), s = l, o = 4; o < e; s += f, o++) for (w = 0; w < b; w++) y[w][o] = p[s + w];
              x = b;
            }
            let t = y[--x];
            if (this.extend(t, 4, g), this.filter(t, 4, g), 0 === x) for (o = 4, s = l - b + 1; o < e; s += f, o++) for (w = 0; w < b; w++) p[s + w] = y[w][o];
          }
          return {
            width: f,
            height: g,
            items: p
          };
        }
      }
      class S extends x {
        filter(e, t, a) {
          let r;
          let i;
          let n;
          let s;
          let o = a >> 1;
          for (t |= 0, r = t - 3, i = o + 4; i--; r += 2) e[r] *= .8128930661159609;
          for (n = .443506852043971 * e[(r = t - 2) - 1], i = o + 3; i--; r += 2) if (s = .443506852043971 * e[r + 1], e[r] = 1.230174104914001 * e[r] - n - s, i--) {
            r += 2;
            n = .443506852043971 * e[r + 1];
            e[r] = 1.230174104914001 * e[r] - n - s;
          } else break;
          for (n = .882911075530934 * e[(r = t - 1) - 1], i = o + 2; i--; r += 2) if (s = .882911075530934 * e[r + 1], e[r] -= n + s, i--) {
            r += 2;
            n = .882911075530934 * e[r + 1];
            e[r] -= n + s;
          } else break;
          for (n = -.052980118572961 * e[(r = t) - 1], i = o + 1; i--; r += 2) if (s = -.052980118572961 * e[r + 1], e[r] -= n + s, i--) {
            r += 2;
            n = -.052980118572961 * e[r + 1];
            e[r] -= n + s;
          } else break;
          if (0 !== o) for (n = -1.586134342059924 * e[(r = t + 1) - 1], i = o; i--; r += 2) if (s = -1.586134342059924 * e[r + 1], e[r] -= n + s, i--) {
            r += 2;
            n = -1.586134342059924 * e[r + 1];
            e[r] -= n + s;
          } else break;
        }
      }
      class k extends x {
        filter(e, t, a) {
          let r;
          let i;
          let n = a >> 1;
          for (t |= 0, r = t, i = n + 1; i--; r += 2) e[r] -= e[r - 1] + e[r + 1] + 2 >> 2;
          for (r = t + 1, i = n; i--; r += 2) e[r] += e[r - 1] + e[r + 1] >> 1;
        }
      }
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.LZWStream = void 0;
      var r = a(29);
      class i extends r.DecodeStream {
        constructor(e, t, a) {
          super(t);
          this.str = e;
          this.dict = e.dict;
          this.cachedData = 0;
          this.bitsCached = 0;
          let r = {
            earlyChange: a,
            codeLength: 9,
            nextCode: 258,
            dictionaryValues: new Uint8Array(4096),
            dictionaryLengths: new Uint16Array(4096),
            dictionaryPrevCodes: new Uint16Array(4096),
            currentSequence: new Uint8Array(4096),
            currentSequenceLength: 0
          };
          for (let e = 0; e < 256; ++e) {
            r.dictionaryValues[e] = e;
            r.dictionaryLengths[e] = 1;
          }
          this.lzwState = r;
        }
        readBits(e) {
          let t = this.bitsCached;
          let a = this.cachedData;
          for (; t < e;) {
            let e = this.str.getByte();
            if (-1 === e) {
              this.eof = !0;
              return null;
            }
            a = a << 8 | e;
            t += 8;
          }
          this.bitsCached = t -= e;
          this.cachedData = a;
          this.lastCode = null;
          return a >>> t & (1 << e) - 1;
        }
        readBlock() {
          let e;
          let t;
          let a;
          let r = 1024;
          let i = this.lzwState;
          if (!i) return;
          let n = i.earlyChange;
          let s = i.nextCode;
          let o = i.dictionaryValues;
          let l = i.dictionaryLengths;
          let c = i.dictionaryPrevCodes;
          let h = i.codeLength;
          let u = i.prevCode;
          let d = i.currentSequence;
          let f = i.currentSequenceLength;
          let g = 0;
          let p = this.bufferLength;
          let m = this.ensureBuffer(this.bufferLength + r);
          for (e = 0; e < 512; e++) {
            let e = this.readBits(h);
            let i = f > 0;
            if (e < 256) {
              d[0] = e;
              f = 1;
            } else if (e >= 258) {
              if (e < s) for (t = (f = l[e]) - 1, a = e; t >= 0; t--) {
                d[t] = o[a];
                a = c[a];
              } else d[f++] = d[0];
            } else if (256 === e) {
              h = 9;
              s = 258;
              f = 0;
              continue;
            } else {
              this.eof = !0;
              delete this.lzwState;
              break;
            }
            if (i && (c[s] = u, l[s] = l[u] + 1, o[s] = d[0], h = ++s + n & s + n - 1 ? h : 0 | Math.min(Math.log(s + n) / .6931471805599453 + 1, 12)), u = e, r < (g += f)) {
              do r += 512; while (r < g);
              m = this.ensureBuffer(this.bufferLength + r);
            }
            for (t = 0; t < f; t++) m[p++] = d[t];
          }
          i.nextCode = s;
          i.codeLength = h;
          i.prevCode = u;
          i.currentSequenceLength = f;
          this.bufferLength = p;
        }
      }
      t.LZWStream = i;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.PredictorStream = void 0;
      var r = a(29);
      var i = a(5);
      var n = a(2);
      class s extends r.DecodeStream {
        constructor(e, t, a) {
          if (super(t), !(a instanceof i.Dict)) return e;
          let r = this.predictor = a.get("Predictor") || 1;
          if (r <= 1) return e;
          if (2 !== r && (r < 10 || r > 15)) throw new n.FormatError(`Unsupported predictor: ${r}`);
          2 === r ? this.readBlock = this.readBlockTiff : this.readBlock = this.readBlockPng;
          this.str = e;
          this.dict = e.dict;
          let s = this.colors = a.get("Colors") || 1;
          let o = this.bits = a.get("BPC", "BitsPerComponent") || 8;
          let l = this.columns = a.get("Columns") || 1;
          this.pixBytes = s * o + 7 >> 3;
          this.rowBytes = l * s * o + 7 >> 3;
          return this;
        }
        readBlockTiff() {
          let e;
          let t = this.rowBytes;
          let a = this.bufferLength;
          let r = this.ensureBuffer(a + t);
          let i = this.bits;
          let n = this.colors;
          let s = this.str.getBytes(t);
          if (this.eof = !s.length, this.eof) return;
          let o = 0;
          let l = 0;
          let c = 0;
          let h = 0;
          let u = a;
          if (1 === i && 1 === n) for (e = 0; e < t; ++e) {
            let t = s[e] ^ o;
            t ^= t >> 1;
            t ^= t >> 2;
            t ^= t >> 4;
            o = (1 & t) << 7;
            r[u++] = t;
          } else if (8 === i) {
            for (e = 0; e < n; ++e) r[u++] = s[e];
            for (; e < t; ++e) {
              r[u] = r[u - n] + s[e];
              u++;
            }
          } else if (16 === i) {
            let a = 2 * n;
            for (e = 0; e < a; ++e) r[u++] = s[e];
            for (; e < t; e += 2) {
              let t = ((255 & s[e]) << 8) + (255 & s[e + 1]) + ((255 & r[u - a]) << 8) + (255 & r[u - a + 1]);
              r[u++] = t >> 8 & 255;
              r[u++] = 255 & t;
            }
          } else {
            let t = new Uint8Array(n + 1);
            let u = (1 << i) - 1;
            let d = 0;
            let f = a;
            let g = this.columns;
            for (e = 0; e < g; ++e) for (let e = 0; e < n; ++e) {
              c < i && (o = o << 8 | 255 & s[d++], c += 8);
              t[e] = t[e] + (o >> c - i) & u;
              c -= i;
              l = l << i | t[e];
              (h += i) >= 8 && (r[f++] = l >> h - 8 & 255, h -= 8);
            }
            h > 0 && (r[f++] = (l << 8 - h) + (o & (1 << 8 - h) - 1));
          }
          this.bufferLength += t;
        }
        readBlockPng() {
          let e = this.rowBytes;
          let t = this.pixBytes;
          let a = this.str.getByte();
          let r = this.str.getBytes(e);
          if (this.eof = !r.length, this.eof) return;
          let i = this.bufferLength;
          let s = this.ensureBuffer(i + e);
          let o = s.subarray(i - e, i);
          0 === o.length && (o = new Uint8Array(e));
          let l;
          let c = i;
          let h;
          let u;
          switch (a) {
            case 0:
              for (l = 0; l < e; ++l) s[c++] = r[l];
              break;
            case 1:
              for (l = 0; l < t; ++l) s[c++] = r[l];
              for (; l < e; ++l) {
                s[c] = s[c - t] + r[l] & 255;
                c++;
              }
              break;
            case 2:
              for (l = 0; l < e; ++l) s[c++] = o[l] + r[l] & 255;
              break;
            case 3:
              for (l = 0; l < t; ++l) s[c++] = (o[l] >> 1) + r[l];
              for (; l < e; ++l) {
                s[c] = (o[l] + s[c - t] >> 1) + r[l] & 255;
                c++;
              }
              break;
            case 4:
              for (l = 0; l < t; ++l) {
                h = o[l];
                u = r[l];
                s[c++] = h + u;
              }
              for (; l < e; ++l) {
                h = o[l];
                let e = o[l - t];
                let a = s[c - t];
                let i = a + h - e;
                let n = i - a;
                n < 0 && (n = -n);
                let d = i - h;
                d < 0 && (d = -d);
                let f = i - e;
                f < 0 && (f = -f);
                u = r[l];
                n <= d && n <= f ? s[c++] = a + u : d <= f ? s[c++] = h + u : s[c++] = e + u;
              }
              break;
            default:
              throw new n.FormatError(`Unsupported predictor: ${a}`);
          }
          this.bufferLength += e;
        }
      }
      t.PredictorStream = s;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.RunLengthStream = void 0;
      var r = a(29);
      class i extends r.DecodeStream {
        constructor(e, t) {
          super(t);
          this.str = e;
          this.dict = e.dict;
        }
        readBlock() {
          let e;
          let t = this.str.getBytes(2);
          if (!t || t.length < 2 || 128 === t[0]) {
            this.eof = !0;
            return;
          }
          let a = this.bufferLength;
          let r = t[0];
          if (r < 128) {
            if ((e = this.ensureBuffer(a + r + 1))[a++] = t[1], r > 0) {
              let t = this.str.getBytes(r);
              e.set(t, a);
              a += r;
            }
          } else {
            r = 257 - r;
            let i = t[1];
            e = this.ensureBuffer(a + r + 1);
            for (let t = 0; t < r; t++) e[a++] = i;
          }
          this.bufferLength = a;
        }
      }
      t.RunLengthStream = i;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.Font = t.ErrorFont = void 0;
      var r = a(2);
      var i = a(45);
      var n = a(18);
      var s = a(21);
      var o = a(20);
      var l = a(19);
      var c = a(47);
      var h = a(48);
      var u = a(49);
      var d = a(50);
      var f = a(51);
      var g = a(52);
      var p = a(26);
      var m = a(53);
      var b = a(8);
      var y = a(10);
      var w = a(54);
      let x = [[57344, 63743], [1048576, 1114109]];
      let S = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "composite", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "fallbackName", "fontMatrix", "fontType", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "subtype", "type", "vertical"];
      let k = ["cMap", "defaultEncoding", "differences", "isMonospace", "isSerifFont", "isSymbolicFont", "seacMap", "toFontChar", "toUnicode", "vmetrics", "widths"];
      function A(e) {
        if (!e.fontMatrix || e.fontMatrix[0] === r.FONT_IDENTITY_MATRIX[0]) return;
        let t = .001 / e.fontMatrix[0];
        let a = e.widths;
        for (let e in a) a[e] *= t;
        e.defaultWidth *= t;
      }
      function v(e) {
        if (!e.fallbackToUnicode || e.toUnicode instanceof h.IdentityToUnicodeMap) return;
        let t = [];
        for (let a in e.fallbackToUnicode) e.toUnicode.has(a) || (t[a] = e.fallbackToUnicode[a]);
        t.length > 0 && e.toUnicode.amend(t);
      }
      class C {
        constructor(e, t, a, r, i, n, o, l, c) {
          this.originalCharCode = e;
          this.fontChar = t;
          this.unicode = a;
          this.accent = r;
          this.width = i;
          this.vmetric = n;
          this.operatorListId = o;
          this.isSpace = l;
          this.isInFont = c;
          let h = s.getCharUnicodeCategory(a);
          this.isWhitespace = h.isWhitespace;
          this.isZeroWidthDiacritic = h.isZeroWidthDiacritic;
          this.isInvisibleFormatMark = h.isInvisibleFormatMark;
        }
        matchesForCache(e, t, a, r, i, n, s, o, l) {
          return this.originalCharCode === e && this.fontChar === t && this.unicode === a && this.accent === r && this.width === i && this.vmetric === n && this.operatorListId === s && this.isSpace === o && this.isInFont === l;
        }
      }
      function O(e, t, a) {
        e[t + 1] = a;
        e[t] = a >>> 8;
      }
      function F(e, t) {
        let a = (e << 8) + t;
        return 32768 & a ? a - 65536 : a;
      }
      function I(e) {
        return String.fromCharCode(e >> 8 & 255, 255 & e);
      }
      function T(e) {
        e > 32767 ? e = 32767 : e < -32768 && (e = -32768);
        return String.fromCharCode(e >> 8 & 255, 255 & e);
      }
      function M(e) {
        let t = e.peekBytes(4);
        return "ttcf" === r.bytesToString(t);
      }
      function P(e, t) {
        for (let a in t) e[+a] = t[a];
      }
      function E(e, t, a) {
        let r;
        let i = [];
        for (function () {
          let a = 0;
          let n = e.length;
        }(); a < n; a++) -1 !== (r = s.getUnicodeForGlyph(e[a], t)) && (i[a] = r);
        for (let e in a) -1 !== (r = s.getUnicodeForGlyph(a[e], t)) && (i[+e] = r);
        return i;
      }
      function N(e, t, a = !1) {
        switch (t.length) {
          case 1:
            return t.charCodeAt(0);
          case 2:
            return t.charCodeAt(0) << 8 | t.charCodeAt(1);
        }
        let i = `Unsupported CID string (charCode ${e}): "${t}".`;
        if (a) throw new r.FormatError(i);
        r.warn(i);
        return t;
      }
      function B(e, t, a) {
        let i = Object.create(null);
        let n = [];
        let s = 0;
        let o = x[0][0];
        let l = x[s][1];
        for (let c in e) {
          let h = e[c |= 0];
          if (!t(h)) continue;
          if (o > l) {
            if (++s >= x.length) {
              r.warn("Ran out of space in font  use area.");
              break;
            }
            o = x[s][0];
            l = x[s][1];
          }
          let u = o++;
          0 === h && (h = a);
          i[u] = h;
          n[c] = u;
        }
        return {
          toFontChar: n,
          charCodeToGlyphId: i,
          nextAvailableFontCharCode: o
        };
      }
      function D(e, t) {
        let a;
        let i;
        let n;
        let s;
        let o;
        let l;
        let c;
        let h;
        let u = function (e, t) {
          let a = [];
          for (let r in e) e[r] >= t || a.push({
            fontCharCode: 0 | r,
            glyphId: e[r]
          });
          0 === a.length && a.push({
            fontCharCode: 0,
            glyphId: 0
          });
          a.sort(function (e, t) {
            return e.fontCharCode - t.fontCharCode;
          });
          let r = [];
          let i = a.length;
          for (let e = 0; e < i;) {
            let t = a[e].fontCharCode;
            let n = [a[e].glyphId];
            ++e;
            let s = t;
            for (; e < i && s + 1 === a[e].fontCharCode && (n.push(a[e].glyphId), ++s, ++e, 65535 !== s););
            r.push([t, s, n]);
          }
          return r;
        }(e, t);
        let d = u[u.length - 1][1] > 65535 ? 2 : 1;
        let f = "\0\0" + I(d) + "\0\x03\0\x01" + r.string32(4 + 8 * d);
        for (a = u.length - 1; a >= 0 && !(u[a][0] <= 65535); --a);
        let g = a + 1;
        u[a][0] < 65535 && 65535 === u[a][1] && (u[a][1] = 65534);
        let p = u[a][1] < 65535 ? 1 : 0;
        let b = g + p;
        let y = m.OpenTypeFileBuilder.getSearchParams(b, 2);
        let w = "";
        let x = "";
        let S = "";
        let k = "";
        let A = "";
        let v = 0;
        for (a = 0, i = g; a < i; a++) {
          l = (o = u[a])[0];
          c = o[1];
          w += I(l);
          x += I(c);
          let e = !0;
          for (n = 1, s = (h = o[2]).length; n < s; ++n) if (h[n] !== h[n - 1] + 1) {
            e = !1;
            break;
          }
          if (e) {
            S += I(h[0] - l & 65535);
            k += I(0);
          } else {
            let e = (b - a) * 2 + 2 * v;
            for (v += c - l + 1, S += I(0), k += I(e), n = 0, s = h.length; n < s; ++n) A += I(h[n]);
          }
        }
        p > 0 && (x += "\xff\xff", w += "\xff\xff", S += "\0\x01", k += "\0\0");
        let C = "\0\0" + I(2 * b) + I(y.range) + I(y.entry) + I(y.rangeShift) + x + "\0\0" + w + S + k + A;
        let O = "";
        let F = "";
        if (d > 1) {
          for (f += "\0\x03\0\n" + r.string32(4 + 8 * d + 4 + C.length), O = "", a = 0, i = u.length; a < i; a++) {
            l = (o = u[a])[0];
            let e = (h = o[2])[0];
            for (n = 1, s = h.length; n < s; ++n) h[n] !== h[n - 1] + 1 && (c = o[0] + n - 1, O += r.string32(l) + r.string32(c) + r.string32(e), l = c + 1, e = h[n]);
            O += r.string32(l) + r.string32(o[1]) + r.string32(e);
          }
          F = "\0\f\0\0" + r.string32(O.length + 16) + "\0\0\0\0" + r.string32(O.length / 12);
        }
        return f + "\0\x04" + I(C.length + 4) + C + F + O;
      }
      function L(e, t, a) {
        a = a || {
          unitsPerEm: 0,
          yMax: 0,
          yMin: 0,
          ascent: 0,
          descent: 0
        };
        let i = 0;
        let n = 0;
        let o = 0;
        let l = 0;
        let c = null;
        let h = 0;
        if (t) {
          for (let e in t) {
            (c > (e |= 0) || !c) && (c = e);
            h < e && (h = e);
            let t = s.getUnicodeRangeFor(e);
            if (t < 32) i |= 1 << t; else if (t < 64) n |= 1 << t - 32; else if (t < 96) o |= 1 << t - 64; else if (t < 123) l |= 1 << t - 96; else throw new r.FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
          }
          h > 65535 && (h = 65535);
        } else {
          c = 0;
          h = 255;
        }
        let u = e.bbox || [0, 0, 0, 0];
        let d = a.unitsPerEm || 1 / (e.fontMatrix || r.FONT_IDENTITY_MATRIX)[0];
        let f = e.ascentScaled ? 1 : d / 1e3;
        let g = a.ascent || Math.round(f * (e.ascent || u[3]));
        let p = a.descent || Math.round(f * (e.descent || u[1]));
        p > 0 && e.descent > 0 && u[1] < 0 && (p = -p);
        let m = a.yMax || g;
        let b = -a.yMin || -p;
        return "\0\x03\x02$\x01\xf4\0\x05\0\0\x02\x8a\x02\xbb\0\0\0\x8c\x02\x8a\x02\xbb\0\0\x01\xdf\x001\x01\x02\0\0\0\0\x06" + String.fromCharCode(e.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + r.string32(i) + r.string32(n) + r.string32(o) + r.string32(l) + "*21*" + I(e.italicAngle ? 1 : 0) + I(c || e.firstChar) + I(h || e.lastChar) + I(g) + I(p) + "\0d" + I(m) + I(b) + "\0\0\0\0\0\0\0\0" + I(e.xHeight) + I(e.capHeight) + I(0) + I(c || e.firstChar) + "\0\x03";
      }
      function R(e) {
        let t = Math.floor(65536 * e.italicAngle);
        return "\0\x03\0\0" + r.string32(t) + "\0\0\0\0" + r.string32(e.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
      }
      function $(e, t) {
        let a;
        let r;
        let i;
        let n;
        let s;
        t || (t = [[], []]);
        let o = [t[0][0] || "Original licence", t[0][1] || e, t[0][2] || "Unknown", t[0][3] || "uniqueID", t[0][4] || e, t[0][5] || "Version 0.11", t[0][6] || e.replace(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63), t[0][7] || "Unknown", t[0][8] || "Unknown", t[0][9] || "Unknown"];
        let l = [];
        for (a = 0, r = o.length; a < r; a++) {
          s = t[1][a] || o[a];
          let e = [];
          for (i = 0, n = s.length; i < n; i++) e.push(I(s.charCodeAt(i)));
          l.push(e.join(""));
        }
        let c = [o, l];
        let h = ["\0\x01", "\0\x03"];
        let u = ["\0\0", "\0\x01"];
        let d = ["\0\0", "\x04	"];
        let f = o.length * h.length;
        let g = "\0\0" + I(f) + I(12 * f + 6);
        let p = 0;
        for (a = 0, r = h.length; a < r; a++) {
          let e = c[a];
          for (i = 0, n = e.length; i < n; i++) {
            s = e[i];
            g += h[a] + u[a] + d[a] + I(i) + I(s.length) + I(p);
            p += s.length;
          }
        }
        return g + (o.join("") + l.join(""));
      }
      t.Font = class {
        constructor(e, t, a) {
          let i;
          this.name = e;
          this.psName = null;
          this.mimetype = null;
          this.disableFontFace = !1;
          this.loadedName = a.loadedName;
          this.isType3Font = a.isType3Font;
          this.missingFile = !1;
          this.cssFontInfo = a.cssFontInfo;
          this._charsCache = Object.create(null);
          this._glyphCache = Object.create(null);
          let s = !!(a.flags & n.FontFlags.Serif);
          if (!s && !a.isSimulatedFlags) {
            let t = e.replace(/[,_]/g, "-").split("-")[0];
            let a = c.getSerifFonts();
            for (let e of t.split("+")) if (a[e]) {
              s = !0;
              break;
            }
          }
          this.isSerifFont = s;
          this.isSymbolicFont = !!(a.flags & n.FontFlags.Symbolic);
          this.isMonospace = !!(a.flags & n.FontFlags.FixedPitch);
          let o = a.type;
          let l = a.subtype;
          this.type = o;
          this.subtype = l;
          let h = "sans-serif";
          if (this.isMonospace ? h = "monospace" : this.isSerifFont && (h = "serif"), this.fallbackName = h, this.differences = a.differences, this.widths = a.widths, this.defaultWidth = a.defaultWidth, this.composite = a.composite, this.cMap = a.cMap, this.capHeight = a.capHeight / 1e3, this.ascent = a.ascent / 1e3, this.descent = a.descent / 1e3, this.lineHeight = this.ascent - this.descent, this.fontMatrix = a.fontMatrix, this.bbox = a.bbox, this.defaultEncoding = a.defaultEncoding, this.toUnicode = a.toUnicode, this.toFontChar = [], "Type3" === a.type) {
            for (let e = 0; e < 256; e++) this.toFontChar[e] = this.differences[e] || a.defaultEncoding[e];
            this.fontType = r.FontType.TYPE3;
            return;
          }
          if (this.cidEncoding = a.cidEncoding || "", this.vertical = !!a.vertical, this.vertical && (this.vmetrics = a.vmetrics, this.defaultVMetrics = a.defaultVMetrics), !t || t.isEmpty) {
            t && r.warn('Font file is empty in "' + e + '" (' + this.loadedName + ")");
            this.fallbackToSystemFont(a);
            return;
          }
          [o, l] = function (e, {
            type: t,
            subtype: a,
            composite: i
          }) {
            let n;
            let s;
            (function (e) {
              let t = e.peekBytes(4);
              return 65536 === b.readUint32(t, 0) || "true" === r.bytesToString(t);
            })(e) || M(e) ? n = i ? "CIDFontType2" : "TrueType" : function (e) {
              let t = e.peekBytes(4);
              return "OTTO" === r.bytesToString(t);
            }(e) ? n = i ? "CIDFontType2" : "OpenType" : function (e) {
              let t = e.peekBytes(2);
              return 37 === t[0] && 33 === t[1] || 128 === t[0] && 1 === t[1];
            }(e) ? n = i ? "CIDFontType0" : "MMType1" === t ? "MMType1" : "Type1" : function (e) {
              let t = e.peekBytes(4);
              return t[0] >= 1 && t[3] >= 1 && t[3] <= 4;
            }(e) ? i ? (n = "CIDFontType0", s = "CIDFontType0C") : (n = "MMType1" === t ? "MMType1" : "Type1", s = "Type1C") : (r.warn("getFontFileType: Unable to detect correct font file Type/Subtype."), n = t, s = a);
            return [n, s];
          }(t, a);
          (o !== this.type || l !== this.subtype) && r.info(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${o}/${l}.`);
          try {
            switch (o) {
              case "MMType1":
                r.info("MMType1 font (" + e + "), falling back to Type1.");
              case "Type1":
              case "CIDFontType0":
                this.mimetype = "font/opentype";
                let n = "Type1C" === l || "CIDFontType0C" === l ? new u.CFFFont(t, a) : new w.Type1Font(e, t, a);
                A(a);
                i = this.convert(e, n, a);
                break;
              case "OpenType":
              case "TrueType":
              case "CIDFontType2":
                this.mimetype = "font/opentype";
                i = this.checkAndRepair(e, t, a);
                this.isOpenType && (A(a), o = "OpenType");
                break;
              default:
                throw new r.FormatError(`Font ${o} is not supported`);
            }
          } catch (e) {
            r.warn(e);
            this.fallbackToSystemFont(a);
            return;
          }
          v(a);
          this.data = i;
          this.fontType = n.getFontType(o, l, a.isStandardFont);
          this.fontMatrix = a.fontMatrix;
          this.widths = a.widths;
          this.defaultWidth = a.defaultWidth;
          this.toUnicode = a.toUnicode;
          this.seacMap = a.seacMap;
        }
        get renderer() {
          let e = d.FontRendererFactory.create(this, n.SEAC_ANALYSIS_ENABLED);
          return r.shadow(this, "renderer", e);
        }
        exportData(e = !1) {
          let t;
          let a;
          let r = e ? [...S, ...k] : S;
          let i = Object.create(null);
          for (t of r) void 0 !== (a = this[t]) && (i[t] = a);
          return i;
        }
        fallbackToSystemFont(e) {
          this.missingFile = !0;
          let t = this.name;
          let a = this.type;
          let i = this.subtype;
          let u = n.normalizeFontName(t);
          let d = c.getStdFontMap();
          let g = c.getNonStdFontMap();
          let p = !!d[u];
          let m = !!(g[u] && d[g[u]]);
          u = d[u] || g[u] || u;
          let b = f.getFontBasicMetrics()[u];
          b && (isNaN(this.ascent) && (this.ascent = b.ascent / 1e3), isNaN(this.descent) && (this.descent = b.descent / 1e3), isNaN(this.capHeight) && (this.capHeight = b.capHeight / 1e3));
          this.bold = -1 !== u.search(/bold/gi);
          this.italic = -1 !== u.search(/oblique/gi) || -1 !== u.search(/italic/gi);
          this.black = -1 !== t.search(/Black/g);
          let y = -1 !== t.search(/Narrow/g);
          if (this.remeasure = (!p || y) && Object.keys(this.widths).length > 0, (p || m) && "CIDFontType2" === a && this.cidEncoding.startsWith("Identity-")) {
            let a = e.cidToGidMap;
            let r = [];
            if (P(r, c.getGlyphMapForStandardFonts()), /Arial-?Black/i.test(t) ? P(r, c.getSupplementalGlyphMapForArialBlack()) : /Calibri/i.test(t) && P(r, c.getSupplementalGlyphMapForCalibri()), a) {
              for (let e in r) {
                let t = r[e];
                void 0 !== a[t] && (r[+e] = a[t]);
              }
              a.length !== this.toUnicode.length && e.hasIncludedToUnicodeMap && this.toUnicode instanceof h.IdentityToUnicodeMap && this.toUnicode.forEach(function (e, t) {
                void 0 === a[r[e]] && (r[+e] = t);
              });
            }
            this.toUnicode instanceof h.IdentityToUnicodeMap || this.toUnicode.forEach(function (e, t) {
              r[+e] = t;
            });
            this.toFontChar = r;
            this.toUnicode = new h.ToUnicodeMap(r);
          } else if (/Symbol/i.test(u)) this.toFontChar = E(l.SymbolSetEncoding, o.getGlyphsUnicode(), this.differences); else if (/Dingbats/i.test(u)) {
            /Wingdings/i.test(t) && r.warn("Non-embedded Wingdings font, falling back to ZapfDingbats.");
            this.toFontChar = E(l.ZapfDingbatsEncoding, o.getDingbatsGlyphsUnicode(), this.differences);
          } else if (p) {
            let e = E(this.defaultEncoding, o.getGlyphsUnicode(), this.differences);
            "CIDFontType2" !== a || this.cidEncoding.startsWith("Identity-") || this.toUnicode instanceof h.IdentityToUnicodeMap || this.toUnicode.forEach(function (t, a) {
              e[+t] = a;
            });
            this.toFontChar = e;
          } else {
            let e = o.getGlyphsUnicode();
            let a = [];
            this.toUnicode.forEach((t, r) => {
              if (!this.composite) {
                let a = this.differences[t] || this.defaultEncoding[t];
                let i = s.getUnicodeForGlyph(a, e);
                -1 !== i && (r = i);
              }
              a[+t] = r;
            });
            this.composite && this.toUnicode instanceof h.IdentityToUnicodeMap && /Verdana/i.test(t) && P(a, c.getGlyphMapForStandardFonts());
            this.toFontChar = a;
          }
          v(e);
          this.loadedName = u.split("-")[0];
          this.fontType = n.getFontType(a, i, e.isStandardFont);
        }
        checkAndRepair(e, t, a) {
          let s;
          let c;
          let d;
          let f;
          let b = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
          function w(e, t) {
            let a = Object.create(null);
            a["OS/2"] = null;
            a.cmap = null;
            a.head = null;
            a.hhea = null;
            a.hmtx = null;
            a.maxp = null;
            a.name = null;
            a.post = null;
            for (let r = 0; r < t; r++) {
              let t = function (e) {
                let t = e.getString(4);
                let a = e.getInt32() >>> 0;
                let r = e.getInt32() >>> 0;
                let i = e.getInt32() >>> 0;
                let n = e.pos;
                e.pos = e.start ? e.start : 0;
                e.skip(r);
                let s = e.getBytes(i);
                e.pos = n;
                "head" === t && (s[8] = s[9] = s[10] = s[11] = 0, s[17] |= 32);
                return {
                  tag: t,
                  checksum: a,
                  length: i,
                  offset: r,
                  data: s
                };
              }(e);
              b.includes(t.tag) && 0 !== t.length && (a[t.tag] = t);
            }
            return a;
          }
          function x(e) {
            return {
              version: e.getString(4),
              numTables: e.getUint16(),
              searchRange: e.getUint16(),
              entrySelector: e.getUint16(),
              rangeShift: e.getUint16()
            };
          }
          function S(e) {
            let a;
            let r;
            let i = (t.start ? t.start : 0) + e.offset;
            t.pos = i;
            let n = [[], []];
            let s = e.length;
            let o = i + s;
            if (0 !== t.getUint16() || s < 6) return n;
            let l = t.getUint16();
            let c = t.getUint16();
            let h = [];
            for (a = 0; a < l && t.pos + 12 <= o; a++) {
              let e = {
                platform: t.getUint16(),
                encoding: t.getUint16(),
                language: t.getUint16(),
                name: t.getUint16(),
                length: t.getUint16(),
                offset: t.getUint16()
              };
              (1 === e.platform && 0 === e.encoding && 0 === e.language || 3 === e.platform && 1 === e.encoding && 1033 === e.language) && h.push(e);
            }
            for (a = 0, r = h.length; a < r; a++) {
              let e = h[a];
              if (e.length <= 0) continue;
              let r = i + c + e.offset;
              if (r + e.length > o) continue;
              t.pos = r;
              let s = e.name;
              if (e.encoding) {
                let a = "";
                for (function () {
                  let r = 0;
                  let i = e.length;
                }(); r < i; r += 2) a += String.fromCharCode(t.getUint16());
                n[1][s] = a;
              } else n[0][s] = t.getString(e.length);
            }
            return n;
          }
          let k = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
          function v(e, t) {
            let a = e.data;
            let i = 0;
            let n;
            let s;
            let o;
            let l;
            let c;
            let h = 0;
            let u = 0;
            let d = [];
            let f = [];
            let g = [];
            let p = t.tooComplexToFollowFunctions;
            let m = !1;
            let b = 0;
            let y = 0;
            for (let e = a.length; i < e;) {
              let e = a[i++];
              if (64 === e) {
                if (s = a[i++], m || y) i += s; else for (n = 0; n < s; n++) d.push(a[i++]);
              } else if (65 === e) {
                if (s = a[i++], m || y) i += 2 * s; else for (n = 0; n < s; n++) {
                  o = a[i++];
                  d.push(o << 8 | a[i++]);
                }
              } else if ((248 & e) == 176) {
                if (s = e - 176 + 1, m || y) i += s; else for (n = 0; n < s; n++) d.push(a[i++]);
              } else if ((248 & e) == 184) {
                if (s = e - 184 + 1, m || y) i += 2 * s; else for (n = 0; n < s; n++) {
                  o = a[i++];
                  d.push(o << 8 | a[i++]);
                }
              } else if (43 !== e || p) {
                if (44 !== e || p) {
                  if (45 === e) {
                    if (m) {
                      m = !1;
                      h = i;
                    } else {
                      if (!(c = f.pop())) {
                        r.warn("TT: ENDF bad stack");
                        t.hintsValid = !1;
                        return;
                      }
                      l = g.pop();
                      a = c.data;
                      i = c.i;
                      t.functionsStackDeltas[l] = d.length - c.stackTop;
                    }
                  } else if (137 === e) {
                    (m || y) && (r.warn("TT: nested IDEFs not allowed"), p = !0);
                    m = !0;
                    u = i;
                  } else if (88 === e) ++b; else if (27 === e) y = b; else if (89 === e) {
                    y === b && (y = 0);
                    --b;
                  } else if (28 === e && !m && !y) {
                    let e = d[d.length - 1];
                    e > 0 && (i += e - 1);
                  }
                } else {
                  (m || y) && (r.warn("TT: nested FDEFs not allowed"), p = !0);
                  m = !0;
                  u = i;
                  l = d.pop();
                  t.functionsDefined[l] = {
                    data: a,
                    i
                  };
                }
              } else if (!m && !y) {
                if (isNaN(l = d[d.length - 1])) r.info("TT: CALL empty stack (or invalid entry)."); else if (t.functionsUsed[l] = !0, l in t.functionsStackDeltas) {
                  let e = d.length + t.functionsStackDeltas[l];
                  if (e < 0) {
                    r.warn("TT: CALL invalid functions stack delta.");
                    t.hintsValid = !1;
                    return;
                  }
                  d.length = e;
                } else if (l in t.functionsDefined && !g.includes(l)) {
                  if (f.push({
                    data: a,
                    i,
                    stackTop: d.length - 1
                  }), g.push(l), !(c = t.functionsDefined[l])) {
                    r.warn("TT: CALL non-existent function");
                    t.hintsValid = !1;
                    return;
                  }
                  a = c.data;
                  i = c.i;
                }
              }
              if (!m && !y) {
                let t = 0;
                for (e <= 142 ? t = k[e] : e >= 192 && e <= 223 ? t = -1 : e >= 224 && (t = -2), e >= 113 && e <= 117 && !isNaN(s = d.pop()) && (t = -(2 * s)); t < 0 && d.length > 0;) {
                  d.pop();
                  t++;
                }
                for (; t > 0;) {
                  d.push(NaN);
                  t--;
                }
              }
            }
            t.tooComplexToFollowFunctions = p;
            let w = [a];
            i > a.length && w.push(new Uint8Array(i - a.length));
            u > h && (r.warn("TT: complementing a missing function tail"), w.push(new Uint8Array([34, 45])));
            (function (e, t) {
              if (t.length > 1) {
                let a;
                let r;
                let i = 0;
                for (a = 0, r = t.length; a < r; a++) i += t[a].length;
                let n = new Uint8Array(i = i + 3 & -4);
                let s = 0;
                for (a = 0, r = t.length; a < r; a++) {
                  n.set(t[a], s);
                  s += t[a].length;
                }
                e.data = n;
                e.length = i;
              }
            })(e, w);
          }
          if (M(t = new y.Stream(new Uint8Array(t.getBytes())))) {
            let e = function (e, t) {
              let a;
              let {
                numFonts,
                offsetTable
              } = function (e) {
                let t = e.getString(4);
                r.assert("ttcf" === t, "Must be a TrueType Collection font.");
                let a = e.getUint16();
                let i = e.getUint16();
                let n = e.getInt32() >>> 0;
                let s = [];
                for (let t = 0; t < n; t++) s.push(e.getInt32() >>> 0);
                let o = {
                  ttcTag: t,
                  majorVersion: a,
                  minorVersion: i,
                  numFonts: n,
                  offsetTable: s
                };
                switch (a) {
                  case 1:
                    return o;
                  case 2:
                    o.dsigTag = e.getInt32() >>> 0;
                    o.dsigLength = e.getInt32() >>> 0;
                    o.dsigOffset = e.getInt32() >>> 0;
                    return o;
                }
                throw new r.FormatError(`Invalid TrueType Collection majorVersion: ${a}.`);
              }(e);
              let s = t.split("+");
              for (let o = 0; o < numFonts; o++) {
                e.pos = (e.start || 0) + offsetTable[o];
                let i = x(e);
                let l = w(e, i.numTables);
                if (!l.name) throw new r.FormatError('TrueType Collection font must contain a "name" table.');
                let c = S(l.name);
                for (function () {
                  let e = 0;
                  let r = c.length;
                }(); e < r; e++) for (function () {
                  let r = 0;
                  let n = c[e].length;
                }(); r < n; r++) {
                    let n = c[e][r] && c[e][r].replace(/\s/g, "");
                    if (n) {
                      if (n === t) return {
                        header: i,
                        tables: l
                      };
                      if (!(s.length < 2)) for (let e of s) n === e && (a = {
                        name: e,
                        header: i,
                        tables: l
                      });
                    }
                  }
              }
              if (a) {
                r.warn(`TrueType Collection does not contain "${t}" font, falling back to "${a.name}" font instead.`);
                return {
                  header: a.header,
                  tables: a.tables
                };
              }
              throw new r.FormatError(`TrueType Collection does not contain "${t}" font.`);
            }(t, this.name);
            s = e.header;
            c = e.tables;
          } else {
            s = x(t);
            c = w(t, s.numTables);
          }
          let C = !c["CFF "];
          if (C) {
            if (!c.loca) throw new r.FormatError('Required "loca" table is not found');
            c.glyf || (r.warn('Required "glyf" table is not found -- trying to recover.'), c.glyf = {
              tag: "glyf",
              data: new Uint8Array(0)
            });
            this.isOpenType = !1;
          } else {
            let t = a.composite && ((a.cidToGidMap || []).length > 0 || !(a.cMap instanceof p.IdentityCMap));
            if ("OTTO" === s.version && !t || !c.head || !c.hhea || !c.maxp || !c.post) {
              f = new y.Stream(c["CFF "].data);
              d = new u.CFFFont(f, a);
              A(a);
              return this.convert(e, d, a);
            }
            delete c.glyf;
            delete c.loca;
            delete c.fpgm;
            delete c.prep;
            delete c["cvt "];
            this.isOpenType = !0;
          }
          if (!c.maxp) throw new r.FormatError('Required "maxp" table is not found');
          t.pos = (t.start || 0) + c.maxp.offset;
          let I = t.getInt32();
          let T = t.getUint16();
          if (a.scaleFactors && a.scaleFactors.length === T && C) {
            let {
              scaleFactors
            } = a;
            let t = (c.head.data[50] << 8) + c.head.data[51];
            let r = new g.GlyfTable({
              glyfTable: c.glyf.data,
              isGlyphLocationsLong: t,
              locaTable: c.loca.data,
              numGlyphs: T
            });
            r.scale(scaleFactors);
            let {
              glyf,
              loca,
              isLocationLong
            } = r.write();
            c.glyf.data = glyf;
            c.loca.data = loca;
            !!t !== isLocationLong && (c.head.data[50] = 0, c.head.data[51] = isLocationLong ? 1 : 0);
            let o = c.hmtx.data;
            for (let t = 0; t < T; t++) {
              let a = 4 * t;
              let r = Math.round(scaleFactors[t] * ((o[a] << 8) + o[a + 1]));
              o[a] = r >> 8 & 255;
              o[a + 1] = 255 & r;
              let i = Math.round(scaleFactors[t] * F(o[a + 2], o[a + 3]));
              O(o, a + 2, i);
            }
          }
          let P = T + 1;
          let E = !0;
          P > 65535 && (E = !1, P = T, r.warn("Not enough space in glyfs to duplicate first glyph."));
          let j = 0;
          let _ = 0;
          I >= 65536 && c.maxp.length >= 22 && (t.pos += 8, t.getUint16() > 2 && (c.maxp.data[14] = 0, c.maxp.data[15] = 2), t.pos += 4, j = t.getUint16(), t.pos += 4, _ = t.getUint16());
          c.maxp.data[4] = P >> 8;
          c.maxp.data[5] = 255 & P;
          let U = function (e, t, a, i) {
            let n = {
              functionsDefined: [],
              functionsUsed: [],
              functionsStackDeltas: [],
              tooComplexToFollowFunctions: !1,
              hintsValid: !0
            };
            if (e && v(e, n), t && v(t, n), e && function (e, t) {
              if (!e.tooComplexToFollowFunctions) {
                if (e.functionsDefined.length > t) {
                  r.warn("TT: more functions defined than expected");
                  e.hintsValid = !1;
                  return;
                }
                for (function () {
                  let a = 0;
                  let i = e.functionsUsed.length;
                }(); a < i; a++) {
                  if (a > t) {
                    r.warn("TT: invalid function id: " + a);
                    e.hintsValid = !1;
                    return;
                  }
                  if (e.functionsUsed[a] && !e.functionsDefined[a]) {
                    r.warn("TT: undefined function: " + a);
                    e.hintsValid = !1;
                    return;
                  }
                }
              }
            }(n, i), a && 1 & a.length) {
              let e = new Uint8Array(a.length + 1);
              e.set(a.data);
              a.data = e;
            }
            return n.hintsValid;
          }(c.fpgm, c.prep, c["cvt "], j);
          if (U || (delete c.fpgm, delete c.prep, delete c["cvt "]), function (e, t, a, i, n, s) {
            if (!t) {
              a && (a.data = null);
              return;
            }
            e.pos = (e.start ? e.start : 0) + t.offset;
            e.pos += 4;
            e.pos += 2;
            e.pos += 2;
            e.pos += 2;
            e.pos += 2;
            e.pos += 2;
            e.pos += 2;
            e.pos += 2;
            e.pos += 2;
            e.pos += 2;
            let o = e.getUint16();
            e.pos += 8;
            e.pos += 2;
            let l = e.getUint16();
            0 !== o && (2 & (i.data[44] << 8) + i.data[45] || (t.data[22] = 0, t.data[23] = 0));
            l > n && (r.info(`The numOfMetrics (${l}) should not be greater than the numGlyphs (${n}).`), l = n, t.data[34] = (65280 & l) >> 8, t.data[35] = 255 & l);
            let c = n - l - (a.length - 4 * l >> 1);
            if (c > 0) {
              let e = new Uint8Array(a.length + 2 * c);
              e.set(a.data);
              s && (e[a.length] = a.data[2], e[a.length + 1] = a.data[3]);
              a.data = e;
            }
          }(t, c.hhea, c.hmtx, c.head, P, E), !c.head) throw new r.FormatError('Required "head" table is not found');
          !function (e, t, a) {
            var i;
            let n = e.data;
            i = n[0];
            let s = (i << 24) + (n[1] << 16) + (n[2] << 8) + n[3];
            s >> 16 != 1 && (r.info("Attempting to fix invalid version in head table: " + s), n[0] = 0, n[1] = 1, n[2] = 0, n[3] = 0);
            let o = (n[50] << 8) + n[51];
            if (o < 0 || o > 1) {
              r.info("Attempting to fix invalid indexToLocFormat in head table: " + o);
              let e = t + 1;
              if (a === e << 1) {
                n[50] = 0;
                n[51] = 0;
              } else if (a === e << 2) {
                n[50] = 0;
                n[51] = 1;
              } else throw new r.FormatError("Could not fix indexToLocFormat: " + o);
            }
          }(c.head, T, C ? c.loca.length : 0);
          let X = Object.create(null);
          if (C) {
            let e = (c.head.data[50] << 8) + c.head.data[51];
            let t = function (e, t, a, r, i, n, s) {
              let o;
              let l;
              let c;
              let h;
              let u;
              r ? (o = 4, l = function (e, t) {
                return e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3];
              }, c = function (e, t, a) {
                e[t] = a >>> 24 & 255;
                e[t + 1] = a >> 16 & 255;
                e[t + 2] = a >> 8 & 255;
                e[t + 3] = 255 & a;
              }) : (o = 2, l = function (e, t) {
                return e[t] << 9 | e[t + 1] << 1;
              }, c = function (e, t, a) {
                e[t] = a >> 9 & 255;
                e[t + 1] = a >> 1 & 255;
              });
              let d = n ? a + 1 : a;
              let f = o * (1 + d);
              let g = new Uint8Array(f);
              g.set(e.data.subarray(0, f));
              e.data = g;
              let p = t.data;
              let m = p.length;
              let b = new Uint8Array(m);
              let y = [];
              for (h = 0, u = 0; h < a + 1; h++, u += o) {
                let e = l(g, u);
                e > m && (e = m);
                y.push({
                  index: h,
                  offset: e,
                  endOffset: 0
                });
              }
              for (y.sort((e, t) => e.offset - t.offset), h = 0; h < a; h++) y[h].endOffset = y[h + 1].offset;
              y.sort((e, t) => e.index - t.index);
              let w = Object.create(null);
              let x = 0;
              for (c(g, 0, 0), h = 0, u = o; h < a; h++, u += o) {
                let e = function (e, t, a, r, i, n) {
                  let s = {
                    length: 0,
                    sizeOfInstructions: 0
                  };
                  if (a - t <= 12) return s;
                  let o = e.subarray(t, a);
                  let l = F(o[0], o[1]);
                  if (l < 0) {
                    O(o, 0, l = -1);
                    r.set(o, i);
                    s.length = o.length;
                    return s;
                  }
                  let c;
                  let h = 10;
                  let u = 0;
                  for (c = 0; c < l; c++) {
                    u = (o[h] << 8 | o[h + 1]) + 1;
                    h += 2;
                  }
                  let d = h;
                  let f = o[h] << 8 | o[h + 1];
                  s.sizeOfInstructions = f;
                  let g = h += 2 + f;
                  let p = 0;
                  for (c = 0; c < u; c++) {
                    let e = o[h++];
                    192 & e && (o[h - 1] = 63 & e);
                    let t = 2;
                    2 & e ? t = 1 : 16 & e && (t = 0);
                    let a = 2;
                    4 & e ? a = 1 : 32 & e && (a = 0);
                    let r = t + a;
                    if (p += r, 8 & e) {
                      let e = o[h++];
                      c += e;
                      p += e * r;
                    }
                  }
                  if (0 === p) return s;
                  let m = h + p;
                  m > o.length || (!n && f > 0 ? (r.set(o.subarray(0, d), i), r.set([0, 0], i + d), r.set(o.subarray(g, m), i + d + 2), m -= f, o.length - m > 3 && (m = m + 3 & -4), s.length = m) : o.length - m > 3 ? (m = m + 3 & -4, r.set(o.subarray(0, m), i), s.length = m) : (r.set(o, i), s.length = o.length));
                  return s;
                }(p, y[h].offset, y[h].endOffset, b, x, i);
                let t = e.length;
                0 === t && (w[h] = !0);
                e.sizeOfInstructions > s && (s = e.sizeOfInstructions);
                c(g, u, x += t);
              }
              if (0 === x) {
                let e = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
                for (h = 0, u = o; h < d; h++, u += o) c(g, u, e.length);
                t.data = e;
              } else if (n) {
                let a = l(g, o);
                b.length > a + x ? t.data = b.subarray(0, a + x) : (t.data = new Uint8Array(a + x), t.data.set(b.subarray(0, x)));
                t.data.set(b.subarray(0, a), x);
                c(e.data, g.length - o, x + a);
              } else t.data = b.subarray(0, x);
              return {
                missingGlyphs: w,
                maxSizeOfInstructions: s
              };
            }(c.loca, c.glyf, T, e, U, E, _);
            X = t.missingGlyphs;
            I >= 65536 && c.maxp.length >= 22 && (c.maxp.data[26] = t.maxSizeOfInstructions >> 8, c.maxp.data[27] = 255 & t.maxSizeOfInstructions);
          }
          if (!c.hhea) throw new r.FormatError('Required "hhea" table is not found');
          0 === c.hhea.data[10] && 0 === c.hhea.data[11] && (c.hhea.data[10] = 255, c.hhea.data[11] = 255);
          let H = {
            unitsPerEm: (c.head.data[18] << 8) + c.head.data[19],
            yMax: (c.head.data[42] << 8) + c.head.data[43],
            yMin: F(c.head.data[38], c.head.data[39]),
            ascent: F(c.hhea.data[4], c.hhea.data[5]),
            descent: F(c.hhea.data[6], c.hhea.data[7]),
            lineGap: F(c.hhea.data[8], c.hhea.data[9])
          };
          this.ascent = H.ascent / H.unitsPerEm;
          this.descent = H.descent / H.unitsPerEm;
          this.lineGap = H.lineGap / H.unitsPerEm;
          this.cssFontInfo && this.cssFontInfo.lineHeight ? (this.lineHeight = this.cssFontInfo.metrics.lineHeight, this.lineGap = this.cssFontInfo.metrics.lineGap) : this.lineHeight = this.ascent - this.descent + this.lineGap;
          c.post && function (e, a, i) {
            let s;
            let o;
            let l = (t.start ? t.start : 0) + e.offset;
            t.pos = l;
            let c = l + e.length;
            let h = t.getInt32();
            t.skip(28);
            let u = !0;
            switch (h) {
              case 65536:
                s = n.MacStandardGlyphOrdering;
                break;
              case 131072:
                let d = t.getUint16();
                if (d !== i) {
                  u = !1;
                  break;
                }
                let f = [];
                for (o = 0; o < d; ++o) {
                  let e = t.getUint16();
                  if (e >= 32768) {
                    u = !1;
                    break;
                  }
                  f.push(e);
                }
                if (!u) break;
                let g = [];
                let p = [];
                for (; t.pos < c;) {
                  let e = t.getByte();
                  for (o = 0, p.length = e; o < e; ++o) p[o] = String.fromCharCode(t.getByte());
                  g.push(p.join(""));
                }
                for (o = 0, s = []; o < d; ++o) {
                  let e = f[o];
                  if (e < 258) {
                    s.push(n.MacStandardGlyphOrdering[e]);
                    continue;
                  }
                  s.push(g[e - 258]);
                }
                break;
              case 196608:
                break;
              default:
                r.warn("Unknown/unsupported post table version " + h);
                u = !1;
                a.defaultEncoding && (s = a.defaultEncoding);
            }
            a.glyphNames = s;
          }(c.post, a, T);
          c.post = {
            tag: "post",
            data: R(a)
          };
          let q = [];
          function z(e) {
            return !X[e];
          }
          if (a.composite) {
            let e = a.cidToGidMap || [];
            let t = 0 === e.length;
            a.cMap.forEach(function (a, i) {
              if ("string" == typeof i && (i = N(a, i, !0)), i > 65535) throw new r.FormatError("Max size of CID is 65,535");
              let n = -1;
              t ? n = i : void 0 !== e[i] && (n = e[i]);
              n >= 0 && n < T && z(n) && (q[a] = n);
            });
          } else {
            let e = function (e, t, a, i) {
              let n;
              let s;
              let o;
              let l;
              if (!e) {
                r.warn("No cmap table available.");
                return {
                  platformId: -1,
                  encodingId: -1,
                  mappings: [],
                  hasShortCmap: !1
                };
              }
              let c = (t.start ? t.start : 0) + e.offset;
              t.pos = c;
              t.skip(2);
              let h = t.getUint16();
              let u = !1;
              for (let e = 0; e < h; e++) {
                let r = t.getUint16();
                let n = t.getUint16();
                let o = t.getInt32() >>> 0;
                let l = !1;
                if (!s || s.platformId !== r || s.encodingId !== n) {
                  if (0 === r && (0 === n || 1 === n || 3 === n)) l = !0; else if (1 === r && 0 === n) l = !0; else if (3 === r && 1 === n && (i || !s)) {
                    l = !0;
                    a || (u = !0);
                  } else if (a && 3 === r && 0 === n) {
                    l = !0;
                    let a = !0;
                    if (e < h - 1) {
                      let e = t.peekBytes(2);
                      (e[0] << 8) + e[1] < r && (a = !1);
                    }
                    a && (u = !0);
                  }
                  if (l && (s = {
                    platformId: r,
                    encodingId: n,
                    offset: o
                  }), u) break;
                }
              }
              if (s && (t.pos = c + s.offset), !s || -1 === t.peekByte()) {
                r.warn("Could not find a preferred cmap table.");
                return {
                  platformId: -1,
                  encodingId: -1,
                  mappings: [],
                  hasShortCmap: !1
                };
              }
              let d = t.getUint16();
              t.skip(4);
              let f = !1;
              let g = [];
              if (0 === d) {
                for (o = 0; o < 256; o++) {
                  let e = t.getByte();
                  e && g.push({
                    charCode: o,
                    glyphId: e
                  });
                }
                f = !0;
              } else if (2 === d) {
                let e = [];
                let a = 0;
                for (let r = 0; r < 256; r++) {
                  let r = t.getUint16() >> 3;
                  e.push(r);
                  a = Math.max(r, a);
                }
                let r = [];
                for (let e = 0; e <= a; e++) r.push({
                  firstCode: t.getUint16(),
                  entryCount: t.getUint16(),
                  idDelta: F(t.getByte(), t.getByte()),
                  idRangePos: t.pos + t.getUint16()
                });
                for (let a = 0; a < 256; a++) if (0 === e[a]) {
                  t.pos = r[0].idRangePos + 2 * a;
                  l = t.getUint16();
                  g.push({
                    charCode: a,
                    glyphId: l
                  });
                } else {
                  let i = r[e[a]];
                  for (o = 0; o < i.entryCount; o++) {
                    let e = (a << 8) + o + i.firstCode;
                    t.pos = i.idRangePos + 2 * o;
                    0 !== (l = t.getUint16()) && (l = (l + i.idDelta) % 65536);
                    g.push({
                      charCode: e,
                      glyphId: l
                    });
                  }
                }
              } else if (4 === d) {
                let e;
                let a = t.getUint16() >> 1;
                t.skip(6);
                let r = [];
                for (e = 0; e < a; e++) r.push({
                  end: t.getUint16()
                });
                for (t.skip(2), e = 0; e < a; e++) r[e].start = t.getUint16();
                for (e = 0; e < a; e++) r[e].delta = t.getUint16();
                let i = 0;
                let s;
                for (e = 0; e < a; e++) {
                  n = r[e];
                  let o = t.getUint16();
                  if (!o) {
                    n.offsetIndex = -1;
                    continue;
                  }
                  s = (o >> 1) - (a - e);
                  n.offsetIndex = s;
                  i = Math.max(i, s + n.end - n.start + 1);
                }
                let h = [];
                for (o = 0; o < i; o++) h.push(t.getUint16());
                for (e = 0; e < a; e++) {
                  c = (n = r[e]).start;
                  let t = n.end;
                  let a = n.delta;
                  for (s = n.offsetIndex, o = c; o <= t; o++) 65535 !== o && (l = (l = s < 0 ? o : h[s + o - c]) + a & 65535, g.push({
                    charCode: o,
                    glyphId: l
                  }));
                }
              } else {
                if (6 !== d) {
                  r.warn("cmap table has unsupported format: " + d);
                  return {
                    platformId: -1,
                    encodingId: -1,
                    mappings: [],
                    hasShortCmap: !1
                  };
                }
                let e = t.getUint16();
                let a = t.getUint16();
                for (o = 0; o < a; o++) {
                  l = t.getUint16();
                  let a = e + o;
                  g.push({
                    charCode: a,
                    glyphId: l
                  });
                }
              }
              g.sort(function (e, t) {
                return e.charCode - t.charCode;
              });
              for (let e = 1; e < g.length; e++) g[e - 1].charCode === g[e].charCode && (g.splice(e, 1), e--);
              return {
                platformId: s.platformId,
                encodingId: s.encodingId,
                mappings: g,
                hasShortCmap: f
              };
            }(c.cmap, t, this.isSymbolicFont, a.hasEncoding);
            let i = e.platformId;
            let s = e.encodingId;
            let u = e.mappings;
            let d = u.length;
            let f = [];
            let g = !1;
            if (a.hasEncoding && ("MacRomanEncoding" === a.baseEncodingName || "WinAnsiEncoding" === a.baseEncodingName) && (f = l.getEncoding(a.baseEncodingName)), a.hasEncoding && !this.isSymbolicFont && (3 === i && 1 === s || 1 === i && 0 === s)) {
              let e = o.getGlyphsUnicode();
              for (let t = 0; t < 256; t++) {
                let r;
                let o;
                if (!(r = void 0 !== this.differences[t] ? this.differences[t] : f.length && "" !== f[t] ? f[t] : l.StandardEncoding[t])) continue;
                let c = n.recoverGlyphName(r, e);
                if (3 === i && 1 === s ? o = e[c] : 1 === i && 0 === s && (o = l.MacRomanEncoding.indexOf(c)), void 0 === o) {
                  if (!a.glyphNames && a.hasIncludedToUnicodeMap && !(this.toUnicode instanceof h.IdentityToUnicodeMap)) {
                    let e = this.toUnicode.get(t);
                    e && (o = e.codePointAt(0));
                  }
                  if (void 0 === o) continue;
                }
                for (let e = 0; e < d; ++e) if (u[e].charCode === o) {
                  q[t] = u[e].glyphId;
                  break;
                }
              }
            } else if (0 === i) {
              for (let e = 0; e < d; ++e) q[u[e].charCode] = u[e].glyphId;
              g = !0;
            } else for (let e = 0; e < d; ++e) {
              let t = u[e].charCode;
              3 === i && t >= 61440 && t <= 61695 && (t &= 255);
              q[t] = u[e].glyphId;
            }
            if (a.glyphNames && (f.length || this.differences.length)) for (let e = 0; e < 256; ++e) {
              if (!g && void 0 !== q[e]) continue;
              let t = this.differences[e] || f[e];
              if (!t) continue;
              let r = a.glyphNames.indexOf(t);
              r > 0 && z(r) && (q[e] = r);
            }
          }
          0 === q.length && (q[0] = 0);
          let G = P - 1;
          if (E || (G = 0), !a.cssFontInfo) {
            let e = B(q, z, G);
            this.toFontChar = e.toFontChar;
            c.cmap = {
              tag: "cmap",
              data: D(e.charCodeToGlyphId, P)
            };
            c["OS/2"] && function (e, t) {
              t.pos = (t.start || 0) + e.offset;
              let a = t.getUint16();
              t.skip(60);
              let r = t.getUint16();
              return (!(a < 4) || !(768 & r)) && !(t.getUint16() > t.getUint16()) && (t.skip(6), 0 !== t.getUint16() && (e.data[8] = e.data[9] = 0, !0));
            }(c["OS/2"], t) || (c["OS/2"] = {
              tag: "OS/2",
              data: L(a, e.charCodeToGlyphId, H)
            });
          }
          if (!C) try {
            f = new y.Stream(c["CFF "].data);
            (d = new i.CFFParser(f, a, n.SEAC_ANALYSIS_ENABLED).parse()).duplicateFirstGlyph();
            let e = new i.CFFCompiler(d);
            c["CFF "].data = e.compile();
          } catch (e) {
            r.warn("Failed to compile font " + a.loadedName);
          }
          if (c.name) {
            let t = S(c.name);
            c.name.data = $(e, t);
            this.psName = t[0][6] || null;
          } else c.name = {
            tag: "name",
            data: $(this.name)
          };
          let W = new m.OpenTypeFileBuilder(s.version);
          for (let e in c) W.addTable(e, c[e].data);
          return W.toArray();
        }
        convert(e, t, a) {
          a.fixedPitch = !1;
          a.builtInEncoding && function (e, t) {
            if (e.isInternalFont || t === e.defaultEncoding || e.toUnicode instanceof h.IdentityToUnicodeMap) return;
            let a = [];
            let r = o.getGlyphsUnicode();
            for (let i in t) {
              if (e.hasIncludedToUnicodeMap) {
                if (e.toUnicode.has(i)) continue;
              } else if (e.hasEncoding && (0 === e.differences.length || void 0 !== e.differences[i])) continue;
              let n = t[i];
              let o = s.getUnicodeForGlyph(n, r);
              -1 !== o && (a[i] = String.fromCharCode(o));
            }
            a.length > 0 && e.toUnicode.amend(a);
          }(a, a.builtInEncoding);
          let i = 1;
          t instanceof u.CFFFont && (i = t.numGlyphs - 1);
          let c = t.getGlyphMapping(a);
          let d = null;
          let f = c;
          a.cssFontInfo || (d = B(c, t.hasGlyphId.bind(t), i), this.toFontChar = d.toFontChar, f = d.charCodeToGlyphId);
          let g = t.numGlyphs;
          function p(e, t) {
            for (let a in e) if (t === e[a]) return 0 | a;
            d.charCodeToGlyphId[d.nextAvailableFontCharCode] = t;
            return d.nextAvailableFontCharCode++;
          }
          let b = t.seacs;
          if (d && n.SEAC_ANALYSIS_ENABLED && b && b.length) {
            let e = a.fontMatrix || r.FONT_IDENTITY_MATRIX;
            let i = t.getCharset();
            let n = Object.create(null);
            for (let t in b) {
              let a = b[t |= 0];
              let r = l.StandardEncoding[a[2]];
              let s = l.StandardEncoding[a[3]];
              let o = i.indexOf(r);
              let h = i.indexOf(s);
              if (o < 0 || h < 0) continue;
              let u = {
                x: a[0] * e[0] + a[1] * e[2] + e[4],
                y: a[0] * e[1] + a[1] * e[3] + e[5]
              };
              let f = function (e, t) {
                let a = null;
                for (let r in e) t === e[r] && (a || (a = []), a.push(0 | r));
                return a;
              }(c, t);
              if (f) for (function () {
                let e = 0;
                let t = f.length;
              }(); e < t; e++) {
                let t = f[e];
                let a = d.charCodeToGlyphId;
                let r = p(a, o);
                let i = p(a, h);
                n[t] = {
                  baseFontCharCode: r,
                  accentFontCharCode: i,
                  accentOffset: u
                };
              }
            }
            a.seacMap = n;
          }
          let y = 1 / (a.fontMatrix || r.FONT_IDENTITY_MATRIX)[0];
          let w = new m.OpenTypeFileBuilder("OTTO");
          w.addTable("CFF ", t.data);
          w.addTable("OS/2", L(a, f));
          w.addTable("cmap", D(f, g));
          w.addTable("head", "\0\x01\0\0\0\0\x10\0\0\0\0\0_\x0f<\xf5\0\0" + T(y) + "\0\0\0\0\x9e\v~'\0\0\0\0\x9e\v~'\0\0" + T(a.descent) + "\x0f\xff" + T(a.ascent) + I(a.italicAngle ? 2 : 0) + "\0\x11\0\0\0\0\0\0");
          w.addTable("hhea", "\0\x01\0\0" + T(a.ascent) + T(a.descent) + "\0\0\xff\xff\0\0\0\0\0\0" + T(a.capHeight) + T(Math.tan(a.italicAngle) * a.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + I(g));
          w.addTable("hmtx", function () {
            let e = t.charstrings;
            let a = t.cff ? t.cff.widths : null;
            let r = "\0\0\0\0";
            for (let t = 1; t < g; t++) {
              let i = 0;
              if (e) {
                let a = e[t - 1];
                i = "width" in a ? a.width : 0;
              } else a && (i = Math.ceil(a[t] || 0));
              r += I(i) + I(0);
            }
            return r;
          }());
          w.addTable("maxp", "\0\0P\0" + I(g));
          w.addTable("name", $(e));
          w.addTable("post", R(a));
          return w.toArray();
        }
        get spaceWidth() {
          let e;
          let t = ["space", "minus", "one", "i", "I"];
          for (function () {
            let a = 0;
            let r = t.length;
          }(); a < r; a++) {
            let r = t[a];
            if (r in this.widths) {
              e = this.widths[r];
              break;
            }
            let i = o.getGlyphsUnicode()[r];
            let n = 0;
            if (this.composite && this.cMap.contains(i) && "string" == typeof (n = this.cMap.lookup(i)) && (n = N(i, n)), !n && this.toUnicode && (n = this.toUnicode.charCodeOf(i)), n <= 0 && (n = i), e = this.widths[n]) break;
          }
          e = e || this.defaultWidth;
          return r.shadow(this, "spaceWidth", e);
        }
        _charToGlyph(e, t = !1) {
          let a;
          let i;
          let n;
          let o = e;
          this.cMap && this.cMap.contains(e) && "string" == typeof (o = this.cMap.lookup(e)) && (o = N(e, o));
          "number" != typeof (i = this.widths[o]) && (i = this.defaultWidth);
          let l = this.vmetrics && this.vmetrics[o];
          let c = this.toUnicode.get(e) || e;
          "number" == typeof c && (c = String.fromCharCode(c));
          let h = void 0 !== this.toFontChar[e];
          if (a = this.toFontChar[e] || e, this.missingFile) {
            let t = this.differences[e] || this.defaultEncoding[e];
            (".notdef" === t || "" === t) && "Type1" === this.type && (a = 32);
            a = s.mapSpecialUnicodeValues(a);
          }
          this.isType3Font && (n = a);
          let u = null;
          if (this.seacMap && this.seacMap[e]) {
            h = !0;
            let t = this.seacMap[e];
            a = t.baseFontCharCode;
            u = {
              fontChar: String.fromCodePoint(t.accentFontCharCode),
              offset: t.accentOffset
            };
          }
          let d = "";
          "number" == typeof a && (a <= 1114111 ? d = String.fromCodePoint(a) : r.warn(`charToGlyph - invalid fontCharCode: ${a}`));
          let f = this._glyphCache[e];
          f && f.matchesForCache(e, d, c, u, i, l, n, t, h) || (f = new C(e, d, c, u, i, l, n, t, h), this._glyphCache[e] = f);
          return f;
        }
        charsToGlyphs(e) {
          let t = this._charsCache[e];
          if (t) return t;
          if (t = [], this.cMap) {
            let a = Object.create(null);
            let r = e.length;
            let i = 0;
            for (; i < r;) {
              this.cMap.readCharCode(e, i, a);
              let {
                charcode,
                length
              } = a;
              i += length;
              let s = this._charToGlyph(charcode, 1 === length && 32 === e.charCodeAt(i - 1));
              t.push(s);
            }
          } else for (function () {
            let a = 0;
            let r = e.length;
          }(); a < r; ++a) {
            let r = e.charCodeAt(a);
            let i = this._charToGlyph(r, 32 === r);
            t.push(i);
          }
          return this._charsCache[e] = t;
        }
        getCharPositions(e) {
          let t = [];
          if (this.cMap) {
            let a = Object.create(null);
            let r = 0;
            for (; r < e.length;) {
              this.cMap.readCharCode(e, r, a);
              let i = a.length;
              t.push([r, r + i]);
              r += i;
            }
          } else for (function () {
            let a = 0;
            let r = e.length;
          }(); a < r; ++a) t.push([a, a + 1]);
          return t;
        }
        get glyphCacheValues() {
          return Object.values(this._glyphCache);
        }
        encodeString(e) {
          let t = [];
          let a = [];
          let r = () => t.length % 2 == 1;
          let i = this.toUnicode instanceof h.IdentityToUnicodeMap ? e => this.toUnicode.charCodeOf(e) : e => this.toUnicode.charCodeOf(String.fromCodePoint(e));
          for (function () {
            let n = 0;
            let s = e.length;
          }(); n < s; n++) {
            let s = e.codePointAt(n);
            if (s > 55295 && (s < 57344 || s > 65533) && n++, this.toUnicode) {
              let e = i(s);
              if (-1 !== e) {
                r() && (t.push(a.join("")), a.length = 0);
                let i = this.cMap ? this.cMap.getCharCodeLength(e) : 1;
                for (let t = i - 1; t >= 0; t--) a.push(String.fromCharCode(e >> 8 * t & 255));
                continue;
              }
            }
            r() || (t.push(a.join("")), a.length = 0);
            a.push(String.fromCodePoint(s));
          }
          t.push(a.join(""));
          return t;
        }
      };
      t.ErrorFont = class {
        constructor(e) {
          this.error = e;
          this.loadedName = "g_font_error";
          this.missingFile = !0;
        }
        charsToGlyphs() {
          return [];
        }
        encodeString(e) {
          return [e];
        }
        exportData(e = !1) {
          return {
            error: this.error
          };
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.CFFTopDict = t.CFFStrings = t.CFFStandardStrings = t.CFFPrivateDict = t.CFFParser = t.CFFIndex = t.CFFHeader = t.CFFFDSelect = t.CFFCompiler = t.CFFCharset = t.CFF = void 0;
      var r = a(2);
      var i = a(46);
      var n = a(19);
      let s = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
      t.CFFStandardStrings = s;
      let o = function () {
        let e = [null, {
          id: "hstem",
          min: 2,
          stackClearing: !0,
          stem: !0
        }, null, {
            id: "vstem",
            min: 2,
            stackClearing: !0,
            stem: !0
          }, {
            id: "vmoveto",
            min: 1,
            stackClearing: !0
          }, {
            id: "rlineto",
            min: 2,
            resetStack: !0
          }, {
            id: "hlineto",
            min: 1,
            resetStack: !0
          }, {
            id: "vlineto",
            min: 1,
            resetStack: !0
          }, {
            id: "rrcurveto",
            min: 6,
            resetStack: !0
          }, null, {
            id: "callsubr",
            min: 1,
            undefStack: !0
          }, {
            id: "return",
            min: 0,
            undefStack: !0
          }, null, null, {
            id: "endchar",
            min: 0,
            stackClearing: !0
          }, null, null, null, {
            id: "hstemhm",
            min: 2,
            stackClearing: !0,
            stem: !0
          }, {
            id: "hintmask",
            min: 0,
            stackClearing: !0
          }, {
            id: "cntrmask",
            min: 0,
            stackClearing: !0
          }, {
            id: "rmoveto",
            min: 2,
            stackClearing: !0
          }, {
            id: "hmoveto",
            min: 1,
            stackClearing: !0
          }, {
            id: "vstemhm",
            min: 2,
            stackClearing: !0,
            stem: !0
          }, {
            id: "rcurveline",
            min: 8,
            resetStack: !0
          }, {
            id: "rlinecurve",
            min: 8,
            resetStack: !0
          }, {
            id: "vvcurveto",
            min: 4,
            resetStack: !0
          }, {
            id: "hhcurveto",
            min: 4,
            resetStack: !0
          }, null, {
            id: "callgsubr",
            min: 1,
            undefStack: !0
          }, {
            id: "vhcurveto",
            min: 4,
            resetStack: !0
          }, {
            id: "hvcurveto",
            min: 4,
            resetStack: !0
          }];
        let t = [null, null, null, {
          id: "and",
          min: 2,
          stackDelta: -1
        }, {
            id: "or",
            min: 2,
            stackDelta: -1
          }, {
            id: "not",
            min: 1,
            stackDelta: 0
          }, null, null, null, {
            id: "abs",
            min: 1,
            stackDelta: 0
          }, {
            id: "add",
            min: 2,
            stackDelta: -1,
            stackFn: function (e, t) {
              e[t - 2] = e[t - 2] + e[t - 1];
            }
          }, {
            id: "sub",
            min: 2,
            stackDelta: -1,
            stackFn: function (e, t) {
              e[t - 2] = e[t - 2] - e[t - 1];
            }
          }, {
            id: "div",
            min: 2,
            stackDelta: -1,
            stackFn: function (e, t) {
              e[t - 2] = e[t - 2] / e[t - 1];
            }
          }, null, {
            id: "neg",
            min: 1,
            stackDelta: 0,
            stackFn: function (e, t) {
              e[t - 1] = -e[t - 1];
            }
          }, {
            id: "eq",
            min: 2,
            stackDelta: -1
          }, null, null, {
            id: "drop",
            min: 1,
            stackDelta: -1
          }, null, {
            id: "put",
            min: 2,
            stackDelta: -2
          }, {
            id: "get",
            min: 1,
            stackDelta: 0
          }, {
            id: "ifelse",
            min: 4,
            stackDelta: -3
          }, {
            id: "random",
            min: 0,
            stackDelta: 1
          }, {
            id: "mul",
            min: 2,
            stackDelta: -1,
            stackFn: function (e, t) {
              e[t - 2] = e[t - 2] * e[t - 1];
            }
          }, null, {
            id: "sqrt",
            min: 1,
            stackDelta: 0
          }, {
            id: "dup",
            min: 1,
            stackDelta: 1
          }, {
            id: "exch",
            min: 2,
            stackDelta: 0
          }, {
            id: "index",
            min: 2,
            stackDelta: 0
          }, {
            id: "roll",
            min: 3,
            stackDelta: -2
          }, null, null, null, {
            id: "hflex",
            min: 7,
            resetStack: !0
          }, {
            id: "flex",
            min: 13,
            resetStack: !0
          }, {
            id: "hflex1",
            min: 9,
            resetStack: !0
          }, {
            id: "flex1",
            min: 11,
            resetStack: !0
          }];
        return class {
          constructor(e, t, a) {
            this.bytes = e.getBytes();
            this.properties = t;
            this.seacAnalysisEnabled = !!a;
          }
          parse() {
            let e;
            let t;
            let a = this.properties;
            let r = new l();
            this.cff = r;
            let i = this.parseHeader();
            let n = this.parseIndex(i.endPos);
            let s = this.parseIndex(n.endPos);
            let o = this.parseIndex(s.endPos);
            let c = this.parseIndex(o.endPos);
            let h = this.parseDict(s.obj.get(0));
            let u = this.createDict(f, h, r.strings);
            r.header = i.obj;
            r.names = this.parseNameIndex(n.obj);
            r.strings = this.parseStringIndex(o.obj);
            r.topDict = u;
            r.globalSubrIndex = c.obj;
            this.parsePrivateDict(r.topDict);
            r.isCIDFont = u.hasName("ROS");
            let d = u.getByName("CharStrings");
            let g = this.parseIndex(d).obj;
            let p = u.getByName("FontMatrix");
            p && (a.fontMatrix = p);
            let m = u.getByName("FontBBox");
            if (m && (a.ascent = Math.max(m[3], m[1]), a.descent = Math.min(m[1], m[3]), a.ascentScaled = !0), r.isCIDFont) {
              let a = this.parseIndex(u.getByName("FDArray")).obj;
              for (function () {
                let e = 0;
                let t = a.count;
              }(); e < t; ++e) {
                let t = a.get(e);
                let i = this.createDict(f, this.parseDict(t), r.strings);
                this.parsePrivateDict(i);
                r.fdArray.push(i);
              }
              t = null;
              e = this.parseCharsets(u.getByName("charset"), g.count, r.strings, !0);
              r.fdSelect = this.parseFDSelect(u.getByName("FDSelect"), g.count);
            } else {
              e = this.parseCharsets(u.getByName("charset"), g.count, r.strings, !1);
              t = this.parseEncoding(u.getByName("Encoding"), a, r.strings, e.charset);
            }
            r.charset = e;
            r.encoding = t;
            let b = this.parseCharStrings({
              charStrings: g,
              localSubrIndex: u.privateDict.subrsIndex,
              globalSubrIndex: c.obj,
              fdSelect: r.fdSelect,
              fdArray: r.fdArray,
              privateDict: u.privateDict
            });
            r.charStrings = b.charStrings;
            r.seacs = b.seacs;
            r.widths = b.widths;
            return r;
          }
          parseHeader() {
            let e = this.bytes;
            let t = e.length;
            let a = 0;
            for (; a < t && 1 !== e[a];) ++a;
            if (a >= t) throw new r.FormatError("Invalid CFF header");
            0 !== a && (r.info("cff data is shifted"), e = e.subarray(a), this.bytes = e);
            let i = e[0];
            let n = e[1];
            let s = e[2];
            return {
              obj: new c(i, n, s, e[3]),
              endPos: s
            };
          }
          parseDict(e) {
            let t = 0;
            let a = [];
            let i = [];
            t = 0;
            let n = e.length;
            for (; t < n;) {
              let n = e[t];
              n <= 21 ? (12 === n && (n = n << 8 | e[++t]), i.push([n, a]), a = [], ++t) : a.push(function () {
                let a = e[t++];
                return 30 === a ? function () {
                  let a = "";
                  let r = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];
                  let i = e.length;
                  for (; t < i;) {
                    let i = e[t++];
                    let n = i >> 4;
                    let s = 15 & i;
                    if (15 === n || (a += r[n], 15 === s)) break;
                    a += r[s];
                  }
                  return parseFloat(a);
                }() : 28 === a ? ((a = e[t++]) << 24 | e[t++] << 16) >> 16 : 29 === a ? (a = (a = (a = e[t++]) << 8 | e[t++]) << 8 | e[t++]) << 8 | e[t++] : a >= 32 && a <= 246 ? a - 139 : a >= 247 && a <= 250 ? (a - 247) * 256 + e[t++] + 108 : a >= 251 && a <= 254 ? -((a - 251) * 256) - e[t++] - 108 : (r.warn('CFFParser_parseDict: "' + a + '" is a reserved command.'), NaN);
              }());
            }
            return i;
          }
          parseIndex(e) {
            let t;
            let a;
            let r = new u();
            let i = this.bytes;
            let n = i[e++] << 8 | i[e++];
            let s = [];
            let o = e;
            if (0 !== n) {
              let r = i[e++];
              let l = e + (n + 1) * r - 1;
              for (t = 0, a = n + 1; t < a; ++t) {
                let t = 0;
                for (let a = 0; a < r; ++a) {
                  t <<= 8;
                  t += i[e++];
                }
                s.push(l + t);
              }
              o = s[n];
            }
            for (t = 0, a = s.length - 1; t < a; ++t) {
              let e = s[t];
              let a = s[t + 1];
              r.add(i.subarray(e, a));
            }
            return {
              obj: r,
              endPos: o
            };
          }
          parseNameIndex(e) {
            let t = [];
            for (function () {
              let a = 0;
              let i = e.count;
            }(); a < i; ++a) {
              let i = e.get(a);
              t.push(r.bytesToString(i));
            }
            return t;
          }
          parseStringIndex(e) {
            let t = new h();
            for (function () {
              let a = 0;
              let i = e.count;
            }(); a < i; ++a) {
              let i = e.get(a);
              t.add(r.bytesToString(i));
            }
            return t;
          }
          createDict(e, t, a) {
            let r = new e(a);
            for (function () {
              let e = 0;
              let a = t.length;
            }(); e < a; ++e) {
              let a = t[e];
              let i = a[0];
              let n = a[1];
              r.setByKey(i, n);
            }
            return r;
          }
          parseCharString(a, i, n, s) {
            if (!i || a.callDepth > 10) return !1;
            let o = a.stackSize;
            let l = a.stack;
            let c = i.length;
            for (let h = 0; h < c;) {
              let c = i[h++];
              let u = null;
              if (12 === c) {
                let e = i[h++];
                0 === e ? (i[h - 2] = 139, i[h - 1] = 22, o = 0) : u = t[e];
              } else if (28 === c) {
                l[o] = (i[h] << 24 | i[h + 1] << 16) >> 16;
                h += 2;
                o++;
              } else if (14 === c) {
                if (o >= 4 && (o -= 4, this.seacAnalysisEnabled)) {
                  a.seac = l.slice(o, o + 4);
                  return !1;
                }
                u = e[c];
              } else if (c >= 32 && c <= 246) {
                l[o] = c - 139;
                o++;
              } else if (c >= 247 && c <= 254) {
                l[o] = c < 251 ? (c - 247 << 8) + i[h] + 108 : -(c - 251 << 8) - i[h] - 108;
                h++;
                o++;
              } else if (255 === c) {
                l[o] = (i[h] << 24 | i[h + 1] << 16 | i[h + 2] << 8 | i[h + 3]) / 65536;
                h += 4;
                o++;
              } else if (19 === c || 20 === c) {
                a.hints += o >> 1;
                h += a.hints + 7 >> 3;
                o %= 2;
                u = e[c];
              } else if (10 === c || 29 === c) {
                let t;
                if (!(t = 10 === c ? n : s)) {
                  u = e[c];
                  r.warn("Missing subrsIndex for " + u.id);
                  return !1;
                }
                let i = 32768;
                t.count < 1240 ? i = 107 : t.count < 33900 && (i = 1131);
                let h = l[--o] + i;
                if (h < 0 || h >= t.count || isNaN(h)) {
                  u = e[c];
                  r.warn("Out of bounds subrIndex for " + u.id);
                  return !1;
                }
                if (a.stackSize = o, a.callDepth++, !this.parseCharString(a, t.get(h), n, s)) return !1;
                a.callDepth--;
                o = a.stackSize;
                continue;
              } else {
                if (11 === c) {
                  a.stackSize = o;
                  return !0;
                }
                0 === c && h === i.length ? (i[h - 1] = 14, u = e[14]) : u = e[c];
              }
              if (u) {
                if (u.stem && (a.hints += o >> 1, 3 === c || 23 === c ? a.hasVStems = !0 : a.hasVStems && (1 === c || 18 === c) && (r.warn("CFF stem hints are in wrong order"), i[h - 1] = 1 === c ? 3 : 23)), "min" in u && !a.undefStack && o < u.min) {
                  if (r.warn("Not enough parameters for " + u.id + "; actual: " + o + ", expected: " + u.min), 0 === o) {
                    i[h - 1] = 14;
                    return !0;
                  }
                  return !1;
                }
                a.firstStackClearing && u.stackClearing && (a.firstStackClearing = !1, (o -= u.min) >= 2 && u.stem ? o %= 2 : o > 1 && r.warn("Found too many parameters for stack-clearing command"), o > 0 && (a.width = l[o - 1]));
                "stackDelta" in u ? ("stackFn" in u && u.stackFn(l, o), o += u.stackDelta) : u.stackClearing ? o = 0 : u.resetStack ? (o = 0, a.undefStack = !1) : u.undefStack && (o = 0, a.undefStack = !0, a.firstStackClearing = !1);
              }
            }
            a.stackSize = o;
            return !0;
          }
          parseCharStrings({
            charStrings: e,
            localSubrIndex: t,
            globalSubrIndex: a,
            fdSelect: i,
            fdArray: n,
            privateDict: s
          }) {
            let o = [];
            let l = [];
            let c = e.count;
            for (let h = 0; h < c; h++) {
              let c = e.get(h);
              let u = {
                callDepth: 0,
                stackSize: 0,
                stack: [],
                undefStack: !0,
                hints: 0,
                firstStackClearing: !0,
                seac: null,
                width: null,
                hasVStems: !1
              };
              let d = !0;
              let f = null;
              let g = s;
              if (i && n.length) {
                let e = i.getFDIndex(h);
                -1 === e && (r.warn("Glyph index is not in fd select."), d = !1);
                e >= n.length && (r.warn("Invalid fd index for glyph index."), d = !1);
                d && (f = (g = n[e].privateDict).subrsIndex);
              } else t && (f = t);
              if (d && (d = this.parseCharString(u, c, f, a)), null !== u.width) {
                let e = g.getByName("nominalWidthX");
                l[h] = e + u.width;
              } else {
                let e = g.getByName("defaultWidthX");
                l[h] = e;
              }
              null !== u.seac && (o[h] = u.seac);
              d || e.set(h, new Uint8Array([14]));
            }
            return {
              charStrings: e,
              seacs: o,
              widths: l
            };
          }
          emptyPrivateDictionary(e) {
            let t = this.createDict(g, [], e.strings);
            e.setByKey(18, [0, 0]);
            e.privateDict = t;
          }
          parsePrivateDict(e) {
            if (!e.hasName("Private")) {
              this.emptyPrivateDictionary(e);
              return;
            }
            let t = e.getByName("Private");
            if (!Array.isArray(t) || 2 !== t.length) {
              e.removeByName("Private");
              return;
            }
            let a = t[0];
            let r = t[1];
            if (0 === a || r >= this.bytes.length) {
              this.emptyPrivateDictionary(e);
              return;
            }
            let i = this.bytes.subarray(r, r + a);
            let n = this.parseDict(i);
            let s = this.createDict(g, n, e.strings);
            if (e.privateDict = s, !s.getByName("Subrs")) return;
            let o = s.getByName("Subrs");
            let l = r + o;
            if (0 === o || l >= this.bytes.length) {
              this.emptyPrivateDictionary(e);
              return;
            }
            let c = this.parseIndex(l);
            s.subrsIndex = c.obj;
          }
          parseCharsets(e, t, a, n) {
            let s;
            let o;
            let l;
            if (0 === e) return new m(!0, p.ISO_ADOBE, i.ISOAdobeCharset);
            if (1 === e) return new m(!0, p.EXPERT, i.ExpertCharset);
            if (2 === e) return new m(!0, p.EXPERT_SUBSET, i.ExpertSubsetCharset);
            let c = this.bytes;
            let h = e;
            let u = c[e++];
            let d = [n ? 0 : ".notdef"];
            switch (t -= 1, u) {
              case 0:
                for (l = 0; l < t; l++) {
                  s = c[e++] << 8 | c[e++];
                  d.push(n ? s : a.get(s));
                }
                break;
              case 1:
                for (; d.length <= t;) for (l = 0, s = c[e++] << 8 | c[e++], o = c[e++]; l <= o; l++) d.push(n ? s++ : a.get(s++));
                break;
              case 2:
                for (; d.length <= t;) for (l = 0, s = c[e++] << 8 | c[e++], o = c[e++] << 8 | c[e++]; l <= o; l++) d.push(n ? s++ : a.get(s++));
                break;
              default:
                throw new r.FormatError("Unknown charset format");
            }
            let f = e;
            return new m(!1, u, d, c.subarray(h, f));
          }
          parseEncoding(e, t, a, i) {
            let s;
            let o;
            let l;
            let c = Object.create(null);
            let h = this.bytes;
            let u = !1;
            let d = null;
            if (0 === e || 1 === e) {
              u = !0;
              s = e;
              let t = e ? n.ExpertEncoding : n.StandardEncoding;
              for (o = 0, l = i.length; o < l; o++) {
                let e = t.indexOf(i[o]);
                -1 !== e && (c[e] = o);
              }
            } else {
              let t = e;
              switch (127 & (s = h[e++])) {
                case 0:
                  let n = h[e++];
                  for (o = 1; o <= n; o++) c[h[e++]] = o;
                  break;
                case 1:
                  let l = h[e++];
                  let u = 1;
                  for (o = 0; o < l; o++) {
                    let t = h[e++];
                    let a = h[e++];
                    for (let e = t; e <= t + a; e++) c[e] = u++;
                  }
                  break;
                default:
                  throw new r.FormatError(`Unknown encoding format: ${s} in CFF`);
              }
              let f = e;
              128 & s && (h[t] &= 127, function () {
                let t = h[e++];
                for (o = 0; o < t; o++) {
                  let t = h[e++];
                  let r = (h[e++] << 8) + (255 & h[e++]);
                  c[t] = i.indexOf(a.get(r));
                }
              }());
              d = h.subarray(t, f);
            }
            return new b(u, s &= 127, c, d);
          }
          parseFDSelect(e, t) {
            let a;
            let i = this.bytes;
            let n = i[e++];
            let s = [];
            switch (n) {
              case 0:
                for (a = 0; a < t; ++a) {
                  let t = i[e++];
                  s.push(t);
                }
                break;
              case 3:
                let o = i[e++] << 8 | i[e++];
                for (a = 0; a < o; ++a) {
                  let t = i[e++] << 8 | i[e++];
                  0 === a && 0 !== t && (r.warn("parseFDSelect: The first range must have a first GID of 0 -- trying to recover."), t = 0);
                  let n = i[e++];
                  let o = i[e] << 8 | i[e + 1];
                  for (let e = t; e < o; ++e) s.push(n);
                }
                e += 2;
                break;
              default:
                throw new r.FormatError(`parseFDSelect: Unknown format "${n}".`);
            }
            if (s.length !== t) throw new r.FormatError("parseFDSelect: Invalid font data.");
            return new y(n, s);
          }
        };
      }();
      t.CFFParser = o;
      class l {
        constructor() {
          this.header = null;
          this.names = [];
          this.topDict = null;
          this.strings = new h();
          this.globalSubrIndex = null;
          this.encoding = null;
          this.charset = null;
          this.charStrings = null;
          this.fdArray = [];
          this.fdSelect = null;
          this.isCIDFont = !1;
        }
        duplicateFirstGlyph() {
          if (this.charStrings.count >= 65535) {
            r.warn("Not enough space in charstrings to duplicate first glyph.");
            return;
          }
          let e = this.charStrings.get(0);
          this.charStrings.add(e);
          this.isCIDFont && this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
        }
        hasGlyphId(e) {
          return !(e < 0) && !(e >= this.charStrings.count) && this.charStrings.get(e).length > 0;
        }
      }
      t.CFF = l;
      class c {
        constructor(e, t, a, r) {
          this.major = e;
          this.minor = t;
          this.hdrSize = a;
          this.offSize = r;
        }
      }
      t.CFFHeader = c;
      class h {
        constructor() {
          this.strings = [];
        }
        get(e) {
          return e >= 0 && e <= 390 ? s[e] : e - 391 <= this.strings.length ? this.strings[e - 391] : s[0];
        }
        getSID(e) {
          let t = s.indexOf(e);
          return -1 !== t ? t : -1 !== (t = this.strings.indexOf(e)) ? t + 391 : -1;
        }
        add(e) {
          this.strings.push(e);
        }
        get count() {
          return this.strings.length;
        }
      }
      t.CFFStrings = h;
      class u {
        constructor() {
          this.objects = [];
          this.length = 0;
        }
        add(e) {
          this.length += e.length;
          this.objects.push(e);
        }
        set(e, t) {
          this.length += t.length - this.objects[e].length;
          this.objects[e] = t;
        }
        get(e) {
          return this.objects[e];
        }
        get count() {
          return this.objects.length;
        }
      }
      t.CFFIndex = u;
      class d {
        constructor(e, t) {
          this.keyToNameMap = e.keyToNameMap;
          this.nameToKeyMap = e.nameToKeyMap;
          this.defaults = e.defaults;
          this.types = e.types;
          this.opcodes = e.opcodes;
          this.order = e.order;
          this.strings = t;
          this.values = Object.create(null);
        }
        setByKey(e, t) {
          if (!(e in this.keyToNameMap)) return !1;
          let a = t.length;
          if (0 === a) return !0;
          for (let i = 0; i < a; i++) if (isNaN(t[i])) {
            r.warn('Invalid CFFDict value: "' + t + '" for key "' + e + '".');
            return !0;
          }
          let i = this.types[e];
          ("num" === i || "sid" === i || "offset" === i) && (t = t[0]);
          this.values[e] = t;
          return !0;
        }
        setByName(e, t) {
          if (!(e in this.nameToKeyMap)) throw new r.FormatError(`Invalid dictionary name "${e}"`);
          this.values[this.nameToKeyMap[e]] = t;
        }
        hasName(e) {
          return this.nameToKeyMap[e] in this.values;
        }
        getByName(e) {
          if (!(e in this.nameToKeyMap)) throw new r.FormatError(`Invalid dictionary name ${e}"`);
          let t = this.nameToKeyMap[e];
          return t in this.values ? this.values[t] : this.defaults[t];
        }
        removeByName(e) {
          delete this.values[this.nameToKeyMap[e]];
        }
        static createTables(e) {
          let t = {
            keyToNameMap: {},
            nameToKeyMap: {},
            defaults: {},
            types: {},
            opcodes: {},
            order: []
          };
          for (function () {
            let a = 0;
            let r = e.length;
          }(); a < r; ++a) {
            let r = e[a];
            let i = Array.isArray(r[0]) ? (r[0][0] << 8) + r[0][1] : r[0];
            t.keyToNameMap[i] = r[1];
            t.nameToKeyMap[r[1]] = i;
            t.types[i] = r[2];
            t.defaults[i] = r[3];
            t.opcodes[i] = Array.isArray(r[0]) ? r[0] : [r[0]];
            t.order.push(i);
          }
          return t;
        }
      }
      let f = function () {
        let e = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [.001, 0, 0, .001, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
        let t = null;
        return class extends d {
          constructor(a) {
            null === t && (t = d.createTables(e));
            super(t, a);
            this.privateDict = null;
          }
        };
      }();
      t.CFFTopDict = f;
      let g = function () {
        let e = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", .039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", .06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
        let t = null;
        return class extends d {
          constructor(a) {
            null === t && (t = d.createTables(e));
            super(t, a);
            this.subrsIndex = null;
          }
        };
      }();
      t.CFFPrivateDict = g;
      let p = {
        ISO_ADOBE: 0,
        EXPERT: 1,
        EXPERT_SUBSET: 2
      };
      class m {
        constructor(e, t, a, r) {
          this.predefined = e;
          this.format = t;
          this.charset = a;
          this.raw = r;
        }
      }
      t.CFFCharset = m;
      class b {
        constructor(e, t, a, r) {
          this.predefined = e;
          this.format = t;
          this.encoding = a;
          this.raw = r;
        }
      }
      class y {
        constructor(e, t) {
          this.format = e;
          this.fdSelect = t;
        }
        getFDIndex(e) {
          return e < 0 || e >= this.fdSelect.length ? -1 : this.fdSelect[e];
        }
      }
      t.CFFFDSelect = y;
      class w {
        constructor() {
          this.offsets = Object.create(null);
        }
        isTracking(e) {
          return e in this.offsets;
        }
        track(e, t) {
          if (e in this.offsets) throw new r.FormatError(`Already tracking location of ${e}`);
          this.offsets[e] = t;
        }
        offset(e) {
          for (let t in this.offsets) this.offsets[t] += e;
        }
        setEntryLocation(e, t, a) {
          if (!(e in this.offsets)) throw new r.FormatError(`Not tracking location of ${e}`);
          let i = a.data;
          let n = this.offsets[e];
          for (function () {
            let e = 0;
            let a = t.length;
          }(); e < a; ++e) {
            let a = 5 * e + n;
            let s = a + 1;
            let o = a + 2;
            let l = a + 3;
            let c = a + 4;
            if (29 !== i[a] || 0 !== i[s] || 0 !== i[o] || 0 !== i[l] || 0 !== i[c]) throw new r.FormatError("writing to an offset that is not empty");
            let h = t[e];
            i[a] = 29;
            i[s] = h >> 24 & 255;
            i[o] = h >> 16 & 255;
            i[l] = h >> 8 & 255;
            i[c] = 255 & h;
          }
        }
      }
      class x {
        constructor(e) {
          this.cff = e;
        }
        compile() {
          let e = this.cff;
          let t = {
            data: [],
            length: 0,
            add: function (e) {
              this.data = this.data.concat(e);
              this.length = this.data.length;
            }
          };
          let a = this.compileHeader(e.header);
          t.add(a);
          let i = this.compileNameIndex(e.names);
          if (t.add(i), e.isCIDFont && e.topDict.hasName("FontMatrix")) {
            let t = e.topDict.getByName("FontMatrix");
            e.topDict.removeByName("FontMatrix");
            for (function () {
              let a = 0;
              let i = e.fdArray.length;
            }(); a < i; a++) {
              let i = e.fdArray[a];
              let n = t.slice(0);
              i.hasName("FontMatrix") && (n = r.Util.transform(n, i.getByName("FontMatrix")));
              i.setByName("FontMatrix", n);
            }
          }
          let n = e.topDict.getByName("XUID");
          n && n.length > 16 && e.topDict.removeByName("XUID");
          e.topDict.setByName("charset", 0);
          let s = this.compileTopDicts([e.topDict], t.length, e.isCIDFont);
          t.add(s.output);
          let o = s.trackers[0];
          let l = this.compileStringIndex(e.strings.strings);
          t.add(l);
          let c = this.compileIndex(e.globalSubrIndex);
          if (t.add(c), e.encoding && e.topDict.hasName("Encoding")) {
            if (e.encoding.predefined) o.setEntryLocation("Encoding", [e.encoding.format], t); else {
              let a = this.compileEncoding(e.encoding);
              o.setEntryLocation("Encoding", [t.length], t);
              t.add(a);
            }
          }
          let h = this.compileCharset(e.charset, e.charStrings.count, e.strings, e.isCIDFont);
          o.setEntryLocation("charset", [t.length], t);
          t.add(h);
          let u = this.compileCharStrings(e.charStrings);
          if (o.setEntryLocation("CharStrings", [t.length], t), t.add(u), e.isCIDFont) {
            o.setEntryLocation("FDSelect", [t.length], t);
            let a = this.compileFDSelect(e.fdSelect);
            t.add(a);
            s = this.compileTopDicts(e.fdArray, t.length, !0);
            o.setEntryLocation("FDArray", [t.length], t);
            t.add(s.output);
            let r = s.trackers;
            this.compilePrivateDicts(e.fdArray, r, t);
          }
          this.compilePrivateDicts([e.topDict], [o], t);
          t.add([0]);
          return t.data;
        }
        encodeNumber(e) {
          return Number.isInteger(e) ? this.encodeInteger(e) : this.encodeFloat(e);
        }
        static get EncodeFloatRegExp() {
          return r.shadow(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
        }
        encodeFloat(e) {
          let t;
          let a;
          let r = e.toString();
          let i = x.EncodeFloatRegExp.exec(r);
          if (i) {
            let t = parseFloat("1e" + ((i[2] ? +i[2] : 0) + i[1].length));
            r = (Math.round(e * t) / t).toString();
          }
          let n = "";
          for (t = 0, a = r.length; t < a; ++t) {
            let e = r[t];
            "e" === e ? n += "-" === r[++t] ? "c" : "b" : "." === e ? n += "a" : "-" === e ? n += "e" : n += e;
          }
          n += 1 & n.length ? "f" : "ff";
          let s = [30];
          for (t = 0, a = n.length; t < a; t += 2) s.push(parseInt(n.substring(t, t + 2), 16));
          return s;
        }
        encodeInteger(e) {
          let t;
          e >= -107 && e <= 107 ? t = [e + 139] : e >= 108 && e <= 1131 ? (e -= 108, t = [(e >> 8) + 247, 255 & e]) : t = e >= -1131 && e <= -108 ? [((e = -e - 108) >> 8) + 251, 255 & e] : e >= -32768 && e <= 32767 ? [28, e >> 8 & 255, 255 & e] : [29, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e];
          return t;
        }
        compileHeader(e) {
          return [e.major, e.minor, 4, e.offSize];
        }
        compileNameIndex(e) {
          let t = new u();
          for (function () {
            let a = 0;
            let i = e.length;
          }(); a < i; ++a) {
            let i = e[a];
            let n = Math.min(i.length, 127);
            let s = Array(n);
            for (let e = 0; e < n; e++) {
              let t = i[e];
              (t < "!" || t > "~" || "[" === t || "]" === t || "(" === t || ")" === t || "{" === t || "}" === t || "<" === t || ">" === t || "/" === t || "%" === t) && (t = "_");
              s[e] = t;
            }
            "" === (s = s.join("")) && (s = "Bad_Font_Name");
            t.add(r.stringToBytes(s));
          }
          return this.compileIndex(t);
        }
        compileTopDicts(e, t, a) {
          let r = [];
          let i = new u();
          for (function () {
            let n = 0;
            let s = e.length;
          }(); n < s; ++n) {
            let s = e[n];
            a && (s.removeByName("CIDFontVersion"), s.removeByName("CIDFontRevision"), s.removeByName("CIDFontType"), s.removeByName("CIDCount"), s.removeByName("UIDBase"));
            let o = new w();
            let l = this.compileDict(s, o);
            r.push(o);
            i.add(l);
            o.offset(t);
          }
          i = this.compileIndex(i, r);
          return {
            trackers: r,
            output: i
          };
        }
        compilePrivateDicts(e, t, a) {
          for (function () {
            let i = 0;
            let n = e.length;
          }(); i < n; ++i) {
            let n = e[i];
            let s = n.privateDict;
            if (!s || !n.hasName("Private")) throw new r.FormatError("There must be a  dictionary.");
            let o = new w();
            let l = this.compileDict(s, o);
            let c = a.length;
            if (o.offset(c), l.length || (c = 0), t[i].setEntryLocation("Private", [l.length, c], a), a.add(l), s.subrsIndex && s.hasName("Subrs")) {
              let e = this.compileIndex(s.subrsIndex);
              o.setEntryLocation("Subrs", [l.length], a);
              a.add(e);
            }
          }
        }
        compileDict(e, t) {
          let a = [];
          let i = e.order;
          for (let n = 0; n < i.length; ++n) {
            let s = i[n];
            if (!(s in e.values)) continue;
            let o = e.values[s];
            let l = e.types[s];
            if (Array.isArray(l) || (l = [l]), Array.isArray(o) || (o = [o]), 0 !== o.length) {
              for (function () {
                let i = 0;
                let n = l.length;
              }(); i < n; ++i) {
                let n = l[i];
                let c = o[i];
                switch (n) {
                  case "num":
                  case "sid":
                    a = a.concat(this.encodeNumber(c));
                    break;
                  case "offset":
                    let h = e.keyToNameMap[s];
                    t.isTracking(h) || t.track(h, a.length);
                    a = a.concat([29, 0, 0, 0, 0]);
                    break;
                  case "array":
                  case "delta":
                    a = a.concat(this.encodeNumber(c));
                    for (function () {
                      let e = 1;
                      let t = o.length;
                    }(); e < t; ++e) a = a.concat(this.encodeNumber(o[e]));
                    break;
                  default:
                    throw new r.FormatError(`Unknown data type of ${n}`);
                }
              }
              a = a.concat(e.opcodes[s]);
            }
          }
          return a;
        }
        compileStringIndex(e) {
          let t = new u();
          for (function () {
            let a = 0;
            let i = e.length;
          }(); a < i; ++a) t.add(r.stringToBytes(e[a]));
          return this.compileIndex(t);
        }
        compileGlobalSubrIndex() {
          let e = this.cff.globalSubrIndex;
          this.out.writeByteArray(this.compileIndex(e));
        }
        compileCharStrings(e) {
          let t = new u();
          for (let a = 0; a < e.count; a++) {
            let r = e.get(a);
            if (0 === r.length) {
              t.add(new Uint8Array([139, 14]));
              continue;
            }
            t.add(r);
          }
          return this.compileIndex(t);
        }
        compileCharset(e, t, a, i) {
          let n;
          let s = t - 1;
          if (i) n = new Uint8Array([2, 0, 0, s >> 8 & 255, 255 & s]); else {
            (n = new Uint8Array(1 + 2 * s))[0] = 0;
            let t = 0;
            let i = e.charset.length;
            let o = !1;
            for (let s = 1; s < n.length; s += 2) {
              let l = 0;
              if (t < i) {
                let i = e.charset[t++];
                -1 !== (l = a.getSID(i)) || (l = 0, o || (o = !0, r.warn(`Couldn't find ${i} in CFF strings`)));
              }
              n[s] = l >> 8 & 255;
              n[s + 1] = 255 & l;
            }
          }
          return this.compileTypedArray(n);
        }
        compileEncoding(e) {
          return this.compileTypedArray(e.raw);
        }
        compileFDSelect(e) {
          let t;
          let a;
          let r = e.format;
          switch (r) {
            case 0:
              for (a = 0, (t = new Uint8Array(1 + e.fdSelect.length))[0] = r; a < e.fdSelect.length; a++) t[a + 1] = e.fdSelect[a];
              break;
            case 3:
              let i = e.fdSelect[0];
              let n = [r, 0, 0, 0, 0, i];
              for (a = 1; a < e.fdSelect.length; a++) {
                let t = e.fdSelect[a];
                t !== i && (n.push(a >> 8 & 255, 255 & a, t), i = t);
              }
              let s = (n.length - 3) / 3;
              n[1] = s >> 8 & 255;
              n[2] = 255 & s;
              n.push(a >> 8 & 255, 255 & a);
              t = new Uint8Array(n);
          }
          return this.compileTypedArray(t);
        }
        compileTypedArray(e) {
          let t = [];
          for (function () {
            let a = 0;
            let r = e.length;
          }(); a < r; ++a) t[a] = e[a];
          return t;
        }
        compileIndex(e, t = []) {
          let a;
          let r = e.objects;
          let i = r.length;
          if (0 === i) return [0, 0, 0];
          let n = [i >> 8 & 255, 255 & i];
          let s = 1;
          let o;
          for (o = 0; o < i; ++o) s += r[o].length;
          a = s < 256 ? 1 : s < 65536 ? 2 : s < 0x1000000 ? 3 : 4;
          n.push(a);
          let l = 1;
          for (o = 0; o < i + 1; o++) {
            1 === a ? n.push(255 & l) : 2 === a ? n.push(l >> 8 & 255, 255 & l) : 3 === a ? n.push(l >> 16 & 255, l >> 8 & 255, 255 & l) : n.push(l >>> 24 & 255, l >> 16 & 255, l >> 8 & 255, 255 & l);
            r[o] && (l += r[o].length);
          }
          for (o = 0; o < i; o++) {
            t[o] && t[o].offset(n.length);
            for (function () {
              let e = 0;
              let t = r[o].length;
            }(); e < t; e++) n.push(r[o][e]);
          }
          return n;
        }
      }
      t.CFFCompiler = x;
    }, (e, t) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.ISOAdobeCharset = t.ExpertSubsetCharset = t.ExpertCharset = void 0;
      t.ISOAdobeCharset = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
      t.ExpertCharset = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
      t.ExpertSubsetCharset = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.getSerifFonts = t.getNonStdFontMap = t.getGlyphMapForStandardFonts = t.getFontNameToFileMap = void 0;
      t.getStandardFontName = function (e) {
        let t = i.normalizeFontName(e);
        return n()[t];
      };
      t.getSymbolsFonts = t.getSupplementalGlyphMapForCalibri = t.getSupplementalGlyphMapForArialBlack = t.getStdFontMap = void 0;
      var r = a(8);
      var i = a(18);
      let n = r.getLookupTableFactory(function (e) {
        e["Times-Roman"] = "Times-Roman";
        e.Helvetica = "Helvetica";
        e.Courier = "Courier";
        e.Symbol = "Symbol";
        e["Times-Bold"] = "Times-Bold";
        e["Helvetica-Bold"] = "Helvetica-Bold";
        e["Courier-Bold"] = "Courier-Bold";
        e.ZapfDingbats = "ZapfDingbats";
        e["Times-Italic"] = "Times-Italic";
        e["Helvetica-Oblique"] = "Helvetica-Oblique";
        e["Courier-Oblique"] = "Courier-Oblique";
        e["Times-BoldItalic"] = "Times-BoldItalic";
        e["Helvetica-BoldOblique"] = "Helvetica-BoldOblique";
        e["Courier-BoldOblique"] = "Courier-BoldOblique";
        e.ArialNarrow = "Helvetica";
        e["ArialNarrow-Bold"] = "Helvetica-Bold";
        e["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique";
        e["ArialNarrow-Italic"] = "Helvetica-Oblique";
        e.ArialBlack = "Helvetica";
        e["ArialBlack-Bold"] = "Helvetica-Bold";
        e["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique";
        e["ArialBlack-Italic"] = "Helvetica-Oblique";
        e["Arial-Black"] = "Helvetica";
        e["Arial-Black-Bold"] = "Helvetica-Bold";
        e["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique";
        e["Arial-Black-Italic"] = "Helvetica-Oblique";
        e.Arial = "Helvetica";
        e["Arial-Bold"] = "Helvetica-Bold";
        e["Arial-BoldItalic"] = "Helvetica-BoldOblique";
        e["Arial-Italic"] = "Helvetica-Oblique";
        e["Arial-BoldItalicMT"] = "Helvetica-BoldOblique";
        e["Arial-BoldMT"] = "Helvetica-Bold";
        e["Arial-ItalicMT"] = "Helvetica-Oblique";
        e.ArialMT = "Helvetica";
        e["Courier-BoldItalic"] = "Courier-BoldOblique";
        e["Courier-Italic"] = "Courier-Oblique";
        e.CourierNew = "Courier";
        e["CourierNew-Bold"] = "Courier-Bold";
        e["CourierNew-BoldItalic"] = "Courier-BoldOblique";
        e["CourierNew-Italic"] = "Courier-Oblique";
        e["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique";
        e["CourierNewPS-BoldMT"] = "Courier-Bold";
        e["CourierNewPS-ItalicMT"] = "Courier-Oblique";
        e.CourierNewPSMT = "Courier";
        e["Helvetica-BoldItalic"] = "Helvetica-BoldOblique";
        e["Helvetica-Italic"] = "Helvetica-Oblique";
        e["Symbol-Bold"] = "Symbol";
        e["Symbol-BoldItalic"] = "Symbol";
        e["Symbol-Italic"] = "Symbol";
        e.TimesNewRoman = "Times-Roman";
        e["TimesNewRoman-Bold"] = "Times-Bold";
        e["TimesNewRoman-BoldItalic"] = "Times-BoldItalic";
        e["TimesNewRoman-Italic"] = "Times-Italic";
        e.TimesNewRomanPS = "Times-Roman";
        e["TimesNewRomanPS-Bold"] = "Times-Bold";
        e["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic";
        e["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic";
        e["TimesNewRomanPS-BoldMT"] = "Times-Bold";
        e["TimesNewRomanPS-Italic"] = "Times-Italic";
        e["TimesNewRomanPS-ItalicMT"] = "Times-Italic";
        e.TimesNewRomanPSMT = "Times-Roman";
        e["TimesNewRomanPSMT-Bold"] = "Times-Bold";
        e["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic";
        e["TimesNewRomanPSMT-Italic"] = "Times-Italic";
      });
      t.getStdFontMap = n;
      let s = r.getLookupTableFactory(function (e) {
        e.Courier = "FoxitFixed.pfb";
        e["Courier-Bold"] = "FoxitFixedBold.pfb";
        e["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb";
        e["Courier-Oblique"] = "FoxitFixedItalic.pfb";
        e.Helvetica = "FoxitSans.pfb";
        e["Helvetica-Bold"] = "FoxitSansBold.pfb";
        e["Helvetica-BoldOblique"] = "FoxitSansBoldItalic.pfb";
        e["Helvetica-Oblique"] = "FoxitSansItalic.pfb";
        e["Times-Roman"] = "FoxitSerif.pfb";
        e["Times-Bold"] = "FoxitSerifBold.pfb";
        e["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb";
        e["Times-Italic"] = "FoxitSerifItalic.pfb";
        e.Symbol = "FoxitSymbol.pfb";
        e.ZapfDingbats = "FoxitDingbats.pfb";
        e["LiberationSans-Regular"] = "LiberationSans-Regular.ttf";
        e["LiberationSans-Bold"] = "LiberationSans-Bold.ttf";
        e["LiberationSans-Italic"] = "LiberationSans-Italic.ttf";
        e["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
      });
      t.getFontNameToFileMap = s;
      let o = r.getLookupTableFactory(function (e) {
        e.Calibri = "Helvetica";
        e["Calibri-Bold"] = "Helvetica-Bold";
        e["Calibri-BoldItalic"] = "Helvetica-BoldOblique";
        e["Calibri-Italic"] = "Helvetica-Oblique";
        e.CenturyGothic = "Helvetica";
        e["CenturyGothic-Bold"] = "Helvetica-Bold";
        e["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique";
        e["CenturyGothic-Italic"] = "Helvetica-Oblique";
        e.ComicSansMS = "Comic Sans MS";
        e["ComicSansMS-Bold"] = "Comic Sans MS-Bold";
        e["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic";
        e["ComicSansMS-Italic"] = "Comic Sans MS-Italic";
        e["ItcSymbol-Bold"] = "Helvetica-Bold";
        e["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique";
        e["ItcSymbol-Book"] = "Helvetica";
        e["ItcSymbol-BookItalic"] = "Helvetica-Oblique";
        e["ItcSymbol-Medium"] = "Helvetica";
        e["ItcSymbol-MediumItalic"] = "Helvetica-Oblique";
        e.LucidaConsole = "Courier";
        e["LucidaConsole-Bold"] = "Courier-Bold";
        e["LucidaConsole-BoldItalic"] = "Courier-BoldOblique";
        e["LucidaConsole-Italic"] = "Courier-Oblique";
        e["LucidaSans-Demi"] = "Helvetica-Bold";
        e["MS-Gothic"] = "MS Gothic";
        e["MS-Gothic-Bold"] = "MS Gothic-Bold";
        e["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic";
        e["MS-Gothic-Italic"] = "MS Gothic-Italic";
        e["MS-Mincho"] = "MS Mincho";
        e["MS-Mincho-Bold"] = "MS Mincho-Bold";
        e["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic";
        e["MS-Mincho-Italic"] = "MS Mincho-Italic";
        e["MS-PGothic"] = "MS PGothic";
        e["MS-PGothic-Bold"] = "MS PGothic-Bold";
        e["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic";
        e["MS-PGothic-Italic"] = "MS PGothic-Italic";
        e["MS-PMincho"] = "MS PMincho";
        e["MS-PMincho-Bold"] = "MS PMincho-Bold";
        e["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic";
        e["MS-PMincho-Italic"] = "MS PMincho-Italic";
        e.NuptialScript = "Times-Italic";
        e.SegoeUISymbol = "Helvetica";
        e.Wingdings = "ZapfDingbats";
        e["Wingdings-Regular"] = "ZapfDingbats";
      });
      t.getNonStdFontMap = o;
      let l = r.getLookupTableFactory(function (e) {
        e["Adobe Jenson"] = !0;
        e["Adobe Text"] = !0;
        e.Albertus = !0;
        e.Aldus = !0;
        e.Alexandria = !0;
        e.Algerian = !0;
        e["American Typewriter"] = !0;
        e.Antiqua = !0;
        e.Apex = !0;
        e.Arno = !0;
        e.Aster = !0;
        e.Aurora = !0;
        e.Baskerville = !0;
        e.Bell = !0;
        e.Bembo = !0;
        e["Bembo Schoolbook"] = !0;
        e.Benguiat = !0;
        e["Berkeley Old Style"] = !0;
        e["Bernhard Modern"] = !0;
        e["Berthold City"] = !0;
        e.Bodoni = !0;
        e["Bauer Bodoni"] = !0;
        e["Book Antiqua"] = !0;
        e.Bookman = !0;
        e["Bordeaux Roman"] = !0;
        e["Californian FB"] = !0;
        e.Calisto = !0;
        e.Calvert = !0;
        e.Capitals = !0;
        e.Cambria = !0;
        e.Cartier = !0;
        e.Caslon = !0;
        e.Catull = !0;
        e.Centaur = !0;
        e["Century Old Style"] = !0;
        e["Century Schoolbook"] = !0;
        e.Chaparral = !0;
        e["Charis SIL"] = !0;
        e.Cheltenham = !0;
        e["Cholla Slab"] = !0;
        e.Clarendon = !0;
        e.Clearface = !0;
        e.Cochin = !0;
        e.Colonna = !0;
        e["Computer Modern"] = !0;
        e["Concrete Roman"] = !0;
        e.Constantia = !0;
        e["Cooper Black"] = !0;
        e.Corona = !0;
        e.Ecotype = !0;
        e.Egyptienne = !0;
        e.Elephant = !0;
        e.Excelsior = !0;
        e.Fairfield = !0;
        e["FF Scala"] = !0;
        e.Folkard = !0;
        e.Footlight = !0;
        e.FreeSerif = !0;
        e["Friz Quadrata"] = !0;
        e.Garamond = !0;
        e.Gentium = !0;
        e.Georgia = !0;
        e.Gloucester = !0;
        e["Goudy Old Style"] = !0;
        e["Goudy Schoolbook"] = !0;
        e["Goudy Pro Font"] = !0;
        e.Granjon = !0;
        e["Guardian Egyptian"] = !0;
        e.Heather = !0;
        e.Hercules = !0;
        e["High Tower Text"] = !0;
        e.Hiroshige = !0;
        e["Hoefler Text"] = !0;
        e["Humana Serif"] = !0;
        e.Imprint = !0;
        e["Ionic No. 5"] = !0;
        e.Janson = !0;
        e.Joanna = !0;
        e.Korinna = !0;
        e.Lexicon = !0;
        e.LiberationSerif = !0;
        e["Liberation Serif"] = !0;
        e["Linux Libertine"] = !0;
        e.Literaturnaya = !0;
        e.Lucida = !0;
        e["Lucida Bright"] = !0;
        e.Melior = !0;
        e.Memphis = !0;
        e.Miller = !0;
        e.Minion = !0;
        e.Modern = !0;
        e["Mona Lisa"] = !0;
        e["Mrs Eaves"] = !0;
        e["MS Serif"] = !0;
        e["Museo Slab"] = !0;
        e["New York"] = !0;
        e["Nimbus Roman"] = !0;
        e["NPS Rawlinson Roadway"] = !0;
        e.NuptialScript = !0;
        e.Palatino = !0;
        e.Perpetua = !0;
        e.Plantin = !0;
        e["Plantin Schoolbook"] = !0;
        e.Playbill = !0;
        e["Poor Richard"] = !0;
        e["Rawlinson Roadway"] = !0;
        e.Renault = !0;
        e.Requiem = !0;
        e.Rockwell = !0;
        e.Roman = !0;
        e["Rotis Serif"] = !0;
        e.Sabon = !0;
        e.Scala = !0;
        e.Seagull = !0;
        e.Sistina = !0;
        e.Souvenir = !0;
        e.STIX = !0;
        e["Stone Informal"] = !0;
        e["Stone Serif"] = !0;
        e.Sylfaen = !0;
        e.Times = !0;
        e.Trajan = !0;
        e["Trinit\xe9"] = !0;
        e["Trump Mediaeval"] = !0;
        e.Utopia = !0;
        e["Vale Type"] = !0;
        e["Bitstream Vera"] = !0;
        e["Vera Serif"] = !0;
        e.Versailles = !0;
        e.Wanted = !0;
        e.Weiss = !0;
        e["Wide Latin"] = !0;
        e.Windsor = !0;
        e.XITS = !0;
      });
      t.getSerifFonts = l;
      let c = r.getLookupTableFactory(function (e) {
        e.Dingbats = !0;
        e.Symbol = !0;
        e.ZapfDingbats = !0;
      });
      t.getSymbolsFonts = c;
      let h = r.getLookupTableFactory(function (e) {
        e[2] = 10;
        e[3] = 32;
        e[4] = 33;
        e[5] = 34;
        e[6] = 35;
        e[7] = 36;
        e[8] = 37;
        e[9] = 38;
        e[10] = 39;
        e[11] = 40;
        e[12] = 41;
        e[13] = 42;
        e[14] = 43;
        e[15] = 44;
        e[16] = 45;
        e[17] = 46;
        e[18] = 47;
        e[19] = 48;
        e[20] = 49;
        e[21] = 50;
        e[22] = 51;
        e[23] = 52;
        e[24] = 53;
        e[25] = 54;
        e[26] = 55;
        e[27] = 56;
        e[28] = 57;
        e[29] = 58;
        e[30] = 894;
        e[31] = 60;
        e[32] = 61;
        e[33] = 62;
        e[34] = 63;
        e[35] = 64;
        e[36] = 65;
        e[37] = 66;
        e[38] = 67;
        e[39] = 68;
        e[40] = 69;
        e[41] = 70;
        e[42] = 71;
        e[43] = 72;
        e[44] = 73;
        e[45] = 74;
        e[46] = 75;
        e[47] = 76;
        e[48] = 77;
        e[49] = 78;
        e[50] = 79;
        e[51] = 80;
        e[52] = 81;
        e[53] = 82;
        e[54] = 83;
        e[55] = 84;
        e[56] = 85;
        e[57] = 86;
        e[58] = 87;
        e[59] = 88;
        e[60] = 89;
        e[61] = 90;
        e[62] = 91;
        e[63] = 92;
        e[64] = 93;
        e[65] = 94;
        e[66] = 95;
        e[67] = 96;
        e[68] = 97;
        e[69] = 98;
        e[70] = 99;
        e[71] = 100;
        e[72] = 101;
        e[73] = 102;
        e[74] = 103;
        e[75] = 104;
        e[76] = 105;
        e[77] = 106;
        e[78] = 107;
        e[79] = 108;
        e[80] = 109;
        e[81] = 110;
        e[82] = 111;
        e[83] = 112;
        e[84] = 113;
        e[85] = 114;
        e[86] = 115;
        e[87] = 116;
        e[88] = 117;
        e[89] = 118;
        e[90] = 119;
        e[91] = 120;
        e[92] = 121;
        e[93] = 122;
        e[94] = 123;
        e[95] = 124;
        e[96] = 125;
        e[97] = 126;
        e[98] = 196;
        e[99] = 197;
        e[100] = 199;
        e[101] = 201;
        e[102] = 209;
        e[103] = 214;
        e[104] = 220;
        e[105] = 225;
        e[106] = 224;
        e[107] = 226;
        e[108] = 228;
        e[109] = 227;
        e[110] = 229;
        e[111] = 231;
        e[112] = 233;
        e[113] = 232;
        e[114] = 234;
        e[115] = 235;
        e[116] = 237;
        e[117] = 236;
        e[118] = 238;
        e[119] = 239;
        e[120] = 241;
        e[121] = 243;
        e[122] = 242;
        e[123] = 244;
        e[124] = 246;
        e[125] = 245;
        e[126] = 250;
        e[127] = 249;
        e[128] = 251;
        e[129] = 252;
        e[130] = 8224;
        e[131] = 176;
        e[132] = 162;
        e[133] = 163;
        e[134] = 167;
        e[135] = 8226;
        e[136] = 182;
        e[137] = 223;
        e[138] = 174;
        e[139] = 169;
        e[140] = 8482;
        e[141] = 180;
        e[142] = 168;
        e[143] = 8800;
        e[144] = 198;
        e[145] = 216;
        e[146] = 8734;
        e[147] = 177;
        e[148] = 8804;
        e[149] = 8805;
        e[150] = 165;
        e[151] = 181;
        e[152] = 8706;
        e[153] = 8721;
        e[154] = 8719;
        e[156] = 8747;
        e[157] = 170;
        e[158] = 186;
        e[159] = 8486;
        e[160] = 230;
        e[161] = 248;
        e[162] = 191;
        e[163] = 161;
        e[164] = 172;
        e[165] = 8730;
        e[166] = 402;
        e[167] = 8776;
        e[168] = 8710;
        e[169] = 171;
        e[170] = 187;
        e[171] = 8230;
        e[200] = 193;
        e[203] = 205;
        e[210] = 218;
        e[223] = 711;
        e[224] = 321;
        e[225] = 322;
        e[226] = 352;
        e[227] = 353;
        e[228] = 381;
        e[229] = 382;
        e[233] = 221;
        e[234] = 253;
        e[252] = 263;
        e[253] = 268;
        e[254] = 269;
        e[258] = 258;
        e[260] = 260;
        e[261] = 261;
        e[265] = 280;
        e[266] = 281;
        e[267] = 282;
        e[268] = 283;
        e[269] = 313;
        e[275] = 323;
        e[276] = 324;
        e[278] = 328;
        e[283] = 344;
        e[284] = 345;
        e[285] = 346;
        e[286] = 347;
        e[292] = 367;
        e[295] = 377;
        e[296] = 378;
        e[298] = 380;
        e[305] = 963;
        e[306] = 964;
        e[307] = 966;
        e[308] = 8215;
        e[309] = 8252;
        e[310] = 8319;
        e[311] = 8359;
        e[312] = 8592;
        e[313] = 8593;
        e[337] = 9552;
        e[493] = 1039;
        e[494] = 1040;
        e[705] = 1524;
        e[706] = 8362;
        e[710] = 64288;
        e[711] = 64298;
        e[759] = 1617;
        e[761] = 1776;
        e[763] = 1778;
        e[775] = 1652;
        e[777] = 1764;
        e[778] = 1780;
        e[779] = 1781;
        e[780] = 1782;
        e[782] = 771;
        e[783] = 64726;
        e[786] = 8363;
        e[788] = 8532;
        e[790] = 768;
        e[791] = 769;
        e[792] = 768;
        e[795] = 803;
        e[797] = 64336;
        e[798] = 64337;
        e[799] = 64342;
        e[800] = 64343;
        e[801] = 64344;
        e[802] = 64345;
        e[803] = 64362;
        e[804] = 64363;
        e[805] = 64364;
        e[2424] = 7821;
        e[2425] = 7822;
        e[2426] = 7823;
        e[2427] = 7824;
        e[2428] = 7825;
        e[2429] = 7826;
        e[2430] = 7827;
        e[2433] = 7682;
        e[2678] = 8045;
        e[2679] = 8046;
        e[2830] = 1552;
        e[2838] = 686;
        e[2840] = 751;
        e[2842] = 753;
        e[2843] = 754;
        e[2844] = 755;
        e[2846] = 757;
        e[2856] = 767;
        e[2857] = 848;
        e[2858] = 849;
        e[2862] = 853;
        e[2863] = 854;
        e[2864] = 855;
        e[2865] = 861;
        e[2866] = 862;
        e[2906] = 7460;
        e[2908] = 7462;
        e[2909] = 7463;
        e[2910] = 7464;
        e[2912] = 7466;
        e[2913] = 7467;
        e[2914] = 7468;
        e[2916] = 7470;
        e[2917] = 7471;
        e[2918] = 7472;
        e[2920] = 7474;
        e[2921] = 7475;
        e[2922] = 7476;
        e[2924] = 7478;
        e[2925] = 7479;
        e[2926] = 7480;
        e[2928] = 7482;
        e[2929] = 7483;
        e[2930] = 7484;
        e[2932] = 7486;
        e[2933] = 7487;
        e[2934] = 7488;
        e[2936] = 7490;
        e[2937] = 7491;
        e[2938] = 7492;
        e[2940] = 7494;
        e[2941] = 7495;
        e[2942] = 7496;
        e[2944] = 7498;
        e[2946] = 7500;
        e[2948] = 7502;
        e[2950] = 7504;
        e[2951] = 7505;
        e[2952] = 7506;
        e[2954] = 7508;
        e[2955] = 7509;
        e[2956] = 7510;
        e[2958] = 7512;
        e[2959] = 7513;
        e[2960] = 7514;
        e[2962] = 7516;
        e[2963] = 7517;
        e[2964] = 7518;
        e[2966] = 7520;
        e[2967] = 7521;
        e[2968] = 7522;
        e[2970] = 7524;
        e[2971] = 7525;
        e[2972] = 7526;
        e[2974] = 7528;
        e[2975] = 7529;
        e[2976] = 7530;
        e[2978] = 1537;
        e[2979] = 1538;
        e[2980] = 1539;
        e[2982] = 1549;
        e[2983] = 1551;
        e[2984] = 1552;
        e[2986] = 1554;
        e[2987] = 1555;
        e[2988] = 1556;
        e[2990] = 1623;
        e[2991] = 1624;
        e[2995] = 1775;
        e[2999] = 1791;
        e[3002] = 64290;
        e[3003] = 64291;
        e[3004] = 64292;
        e[3006] = 64294;
        e[3007] = 64295;
        e[3008] = 64296;
        e[3011] = 1900;
        e[3014] = 8223;
        e[3015] = 8244;
        e[3017] = 7532;
        e[3018] = 7533;
        e[3019] = 7534;
        e[3075] = 7590;
        e[3076] = 7591;
        e[3079] = 7594;
        e[3080] = 7595;
        e[3083] = 7598;
        e[3084] = 7599;
        e[3087] = 7602;
        e[3088] = 7603;
        e[3091] = 7606;
        e[3092] = 7607;
        e[3095] = 7610;
        e[3096] = 7611;
        e[3099] = 7614;
        e[3100] = 7615;
        e[3103] = 7618;
        e[3104] = 7619;
        e[3107] = 8337;
        e[3108] = 8338;
        e[3116] = 1884;
        e[3119] = 1885;
        e[3120] = 1885;
        e[3123] = 1886;
        e[3124] = 1886;
        e[3127] = 1887;
        e[3128] = 1887;
        e[3131] = 1888;
        e[3132] = 1888;
        e[3135] = 1889;
        e[3136] = 1889;
        e[3139] = 1890;
        e[3140] = 1890;
        e[3143] = 1891;
        e[3144] = 1891;
        e[3147] = 1892;
        e[3148] = 1892;
        e[3153] = 580;
        e[3154] = 581;
        e[3157] = 584;
        e[3158] = 585;
        e[3161] = 588;
        e[3162] = 589;
        e[3165] = 891;
        e[3166] = 892;
        e[3169] = 1274;
        e[3170] = 1275;
        e[3173] = 1278;
        e[3174] = 1279;
        e[3181] = 7622;
        e[3182] = 7623;
        e[3282] = 11799;
        e[3316] = 578;
        e[3379] = 42785;
        e[3393] = 1159;
        e[3416] = 8377;
      });
      t.getGlyphMapForStandardFonts = h;
      let u = r.getLookupTableFactory(function (e) {
        e[227] = 322;
        e[264] = 261;
        e[291] = 346;
      });
      t.getSupplementalGlyphMapForArialBlack = u;
      let d = r.getLookupTableFactory(function (e) {
        e[1] = 32;
        e[4] = 65;
        e[6] = 193;
        e[17] = 66;
        e[18] = 67;
        e[21] = 268;
        e[24] = 68;
        e[28] = 69;
        e[30] = 201;
        e[32] = 282;
        e[38] = 70;
        e[39] = 71;
        e[44] = 72;
        e[47] = 73;
        e[49] = 205;
        e[58] = 74;
        e[60] = 75;
        e[62] = 76;
        e[68] = 77;
        e[69] = 78;
        e[75] = 79;
        e[87] = 80;
        e[89] = 81;
        e[90] = 82;
        e[92] = 344;
        e[94] = 83;
        e[97] = 352;
        e[100] = 84;
        e[104] = 85;
        e[115] = 86;
        e[116] = 87;
        e[121] = 88;
        e[122] = 89;
        e[124] = 221;
        e[127] = 90;
        e[129] = 381;
        e[258] = 97;
        e[260] = 225;
        e[268] = 261;
        e[271] = 98;
        e[272] = 99;
        e[273] = 263;
        e[275] = 269;
        e[282] = 100;
        e[286] = 101;
        e[288] = 233;
        e[290] = 283;
        e[295] = 281;
        e[296] = 102;
        e[336] = 103;
        e[346] = 104;
        e[349] = 105;
        e[351] = 237;
        e[361] = 106;
        e[364] = 107;
        e[367] = 108;
        e[371] = 322;
        e[373] = 109;
        e[374] = 110;
        e[381] = 111;
        e[383] = 243;
        e[393] = 112;
        e[395] = 113;
        e[396] = 114;
        e[398] = 345;
        e[400] = 115;
        e[401] = 347;
        e[403] = 353;
        e[410] = 116;
        e[437] = 117;
        e[448] = 118;
        e[449] = 119;
        e[454] = 120;
        e[455] = 121;
        e[457] = 253;
        e[460] = 122;
        e[462] = 382;
        e[463] = 380;
        e[853] = 44;
        e[855] = 58;
        e[856] = 46;
        e[876] = 47;
        e[878] = 45;
        e[882] = 45;
        e[894] = 40;
        e[895] = 41;
        e[896] = 91;
        e[897] = 93;
        e[923] = 64;
        e[1004] = 48;
        e[1005] = 49;
        e[1006] = 50;
        e[1007] = 51;
        e[1008] = 52;
        e[1009] = 53;
        e[1010] = 54;
        e[1011] = 55;
        e[1012] = 56;
        e[1013] = 57;
        e[1081] = 37;
        e[1085] = 43;
        e[1086] = 45;
      });
      t.getSupplementalGlyphMapForCalibri = d;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.ToUnicodeMap = t.IdentityToUnicodeMap = void 0;
      var r = a(2);
      t.ToUnicodeMap = class {
        constructor(e = []) {
          this._map = e;
        }
        get length() {
          return this._map.length;
        }
        forEach(e) {
          for (let t in this._map) e(t, this._map[t].charCodeAt(0));
        }
        has(e) {
          return void 0 !== this._map[e];
        }
        get(e) {
          return this._map[e];
        }
        charCodeOf(e) {
          let t = this._map;
          if (t.length <= 65536) return t.indexOf(e);
          for (let a in t) if (t[a] === e) return 0 | a;
          return -1;
        }
        amend(e) {
          for (let t in e) this._map[t] = e[t];
        }
      };
      t.IdentityToUnicodeMap = class {
        constructor(e, t) {
          this.firstChar = e;
          this.lastChar = t;
        }
        get length() {
          return this.lastChar + 1 - this.firstChar;
        }
        forEach(e) {
          var _this2 = this;
          for (function () {
            let t = _this2.firstChar;
            let a = _this2.lastChar;
          }(); t <= a; t++) e(t, t);
        }
        has(e) {
          return this.firstChar <= e && e <= this.lastChar;
        }
        get(e) {
          if (this.firstChar <= e && e <= this.lastChar) return String.fromCharCode(e);
        }
        charCodeOf(e) {
          return Number.isInteger(e) && e >= this.firstChar && e <= this.lastChar ? e : -1;
        }
        amend(e) {
          r.unreachable("Should not call amend()");
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.CFFFont = void 0;
      var r = a(45);
      var i = a(18);
      var n = a(2);
      t.CFFFont = class {
        constructor(e, t) {
          this.properties = t;
          let a = new r.CFFParser(e, t, i.SEAC_ANALYSIS_ENABLED);
          this.cff = a.parse();
          this.cff.duplicateFirstGlyph();
          let s = new r.CFFCompiler(this.cff);
          this.seacs = this.cff.seacs;
          try {
            this.data = s.compile();
          } catch (a) {
            n.warn("Failed to compile font " + t.loadedName);
            this.data = e;
          }
          this._createBuiltInEncoding();
        }
        get numGlyphs() {
          return this.cff.charStrings.count;
        }
        getCharset() {
          return this.cff.charset.charset;
        }
        getGlyphMapping() {
          let e;
          let t;
          let a = this.cff;
          let r = this.properties;
          let n = a.charset.charset;
          if (r.composite) {
            if (e = Object.create(null), a.isCIDFont) for (t = 0; t < n.length; t++) {
              let a = n[t];
              e[r.cMap.charCodeOf(a)] = t;
            } else for (t = 0; t < a.charStrings.count; t++) e[r.cMap.charCodeOf(t)] = t;
            return e;
          }
          let s = a.encoding ? a.encoding.encoding : null;
          r.isInternalFont && (s = r.defaultEncoding);
          return e = i.type1FontGlyphMapping(r, s, n);
        }
        hasGlyphId(e) {
          return this.cff.hasGlyphId(e);
        }
        _createBuiltInEncoding() {
          let {
            charset,
            encoding
          } = this.cff;
          if (!charset || !encoding) return;
          let a = charset.charset;
          let r = encoding.encoding;
          let i = [];
          for (let e in r) {
            let t = r[e];
            if (t >= 0) {
              let r = a[t];
              r && (i[e] = r);
            }
          }
          i.length > 0 && (this.properties.builtInEncoding = i);
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.FontRendererFactory = void 0;
      var r = a(2);
      var i = a(45);
      var n = a(20);
      var s = a(19);
      var o = a(10);
      function l(e, t) {
        return (e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) >>> 0;
      }
      function c(e, t) {
        return e[t] << 8 | e[t + 1];
      }
      function h(e, t) {
        return (e[t] << 24 | e[t + 1] << 16) >> 16;
      }
      function u(e, t) {
        return e[t] << 24 >> 24;
      }
      function d(e, t) {
        return h(e, t) / 16384;
      }
      function f(e) {
        let t = e.length;
        let a = 32768;
        t < 1240 ? a = 107 : t < 33900 && (a = 1131);
        return a;
      }
      function g(e, t) {
        let a = t.codePointAt(0);
        let r = 0;
        let i = 0;
        let n = e.length - 1;
        for (; i < n;) {
          let t = i + n + 1 >> 1;
          a < e[t].start ? n = t - 1 : i = t;
        }
        e[i].start <= a && a <= e[i].end && (r = e[i].idDelta + (e[i].ids ? e[i].ids[a - e[i].start] : a) & 65535);
        return {
          charCode: a,
          glyphId: r
        };
      }
      let p = [];
      class m {
        constructor(e) {
          this.constructor === m && r.unreachable("Cannot initialize CompiledFont.");
          this.fontMatrix = e;
          this.compiledGlyphs = Object.create(null);
          this.compiledCharCodeToGlyphId = Object.create(null);
        }
        getPathJs(e) {
          let {
            charCode,
            glyphId
          } = g(this.cmap, e);
          let r = this.compiledGlyphs[glyphId];
          if (!r) try {
            r = this.compileGlyph(this.glyphs[glyphId], glyphId);
            this.compiledGlyphs[glyphId] = r;
          } catch (e) {
            this.compiledGlyphs[glyphId] = p;
            void 0 === this.compiledCharCodeToGlyphId[charCode] && (this.compiledCharCodeToGlyphId[charCode] = glyphId);
            return e;
          }
          void 0 === this.compiledCharCodeToGlyphId[charCode] && (this.compiledCharCodeToGlyphId[charCode] = glyphId);
          return r;
        }
        compileGlyph(e, t) {
          if (!e || 0 === e.length || 14 === e[0]) return p;
          let a = this.fontMatrix;
          if (this.isCFFCIDFont) {
            let e = this.fdSelect.getFDIndex(t);
            e >= 0 && e < this.fdArray.length ? a = this.fdArray[e].getByName("FontMatrix") || r.FONT_IDENTITY_MATRIX : r.warn("Invalid fd index for glyph index.");
          }
          let i = [{
            cmd: "save"
          }, {
            cmd: "transform",
            args: a.slice()
          }, {
            cmd: "scale",
            args: ["size", "-size"]
          }];
          this.compileGlyphImpl(e, i, t);
          i.push({
            cmd: "restore"
          });
          return i;
        }
        compileGlyphImpl() {
          r.unreachable("Children classes should implement this.");
        }
        hasBuiltPath(e) {
          let {
            charCode,
            glyphId
          } = g(this.cmap, e);
          return void 0 !== this.compiledGlyphs[glyphId] && void 0 !== this.compiledCharCodeToGlyphId[charCode];
        }
      }
      class b extends m {
        constructor(e, t, a) {
          super(a || [488e-6, 0, 0, 488e-6, 0, 0]);
          this.glyphs = e;
          this.cmap = t;
        }
        compileGlyphImpl(e, t) {
          !function e(t, a, r) {
            let i;
            function n(e, t, r, i) {
              a.push({
                cmd: "quadraticCurveTo",
                args: [e, t, r, i]
              });
            }
            let s = 0;
            let o = h(t, 0);
            let l = 0;
            let f = 0;
            if (s += 10, o < 0) do {
              let n;
              let o;
              i = c(t, s);
              let g = c(t, s + 2);
              s += 4;
              1 & i ? (2 & i ? (n = h(t, s), o = h(t, s + 2)) : (n = c(t, s), o = c(t, s + 2)), s += 4) : 2 & i ? (n = u(t, s++), o = u(t, s++)) : (n = t[s++], o = t[s++]);
              2 & i ? (l = n, f = o) : (l = 0, f = 0);
              let p = 1;
              let m = 1;
              let b = 0;
              let y = 0;
              8 & i ? (p = m = d(t, s), s += 2) : 64 & i ? (p = d(t, s), m = d(t, s + 2), s += 4) : 128 & i && (p = d(t, s), b = d(t, s + 2), y = d(t, s + 4), m = d(t, s + 6), s += 8);
              let w = r.glyphs[g];
              w && (a.push({
                cmd: "save"
              }, {
                cmd: "transform",
                args: [p, b, y, m, l, f]
              }), e(w, a, r), a.push({
                cmd: "restore"
              }));
            } while (32 & i); else {
              let e;
              let r;
              let u = [];
              for (e = 0; e < o; e++) {
                u.push(c(t, s));
                s += 2;
              }
              let d = c(t, s);
              s += 2 + d;
              let y = u[u.length - 1] + 1;
              let w = [];
              for (; w.length < y;) {
                i = t[s++];
                let e = 1;
                for (8 & i && (e += t[s++]); e-- > 0;) w.push({
                  flags: i
                });
              }
              for (e = 0; e < y; e++) {
                switch (18 & w[e].flags) {
                  case 0:
                    l += h(t, s);
                    s += 2;
                    break;
                  case 2:
                    l -= t[s++];
                    break;
                  case 18:
                    l += t[s++];
                }
                w[e].x = l;
              }
              for (e = 0; e < y; e++) {
                switch (36 & w[e].flags) {
                  case 0:
                    f += h(t, s);
                    s += 2;
                    break;
                  case 4:
                    f -= t[s++];
                    break;
                  case 36:
                    f += t[s++];
                }
                w[e].y = f;
              }
              let x = 0;
              for (s = 0; s < o; s++) {
                var g;
                var p;
                var m;
                var b;
                let t = u[s];
                let i = w.slice(x, t + 1);
                if (1 & i[0].flags) i.push(i[0]); else if (1 & i[i.length - 1].flags) i.unshift(i[i.length - 1]); else {
                  let e = {
                    flags: 1,
                    x: (i[0].x + i[i.length - 1].x) / 2,
                    y: (i[0].y + i[i.length - 1].y) / 2
                  };
                  i.unshift(e);
                  i.push(e);
                }
                for (g = i[0].x, p = i[0].y, a.push({
                  cmd: "moveTo",
                  args: [g, p]
                }), e = 1, r = i.length; e < r; e++) 1 & i[e].flags ? (m = i[e].x, b = i[e].y, a.push({
                  cmd: "lineTo",
                  args: [m, b]
                })) : 1 & i[e + 1].flags ? (n(i[e].x, i[e].y, i[e + 1].x, i[e + 1].y), e++) : n(i[e].x, i[e].y, (i[e].x + i[e + 1].x) / 2, (i[e].y + i[e + 1].y) / 2);
                x = t + 1;
              }
            }
          }(e, t, this);
        }
      }
      class y extends m {
        constructor(e, t, a, r) {
          super(a || [.001, 0, 0, .001, 0, 0]);
          this.glyphs = e.glyphs;
          this.gsubrs = e.gsubrs || [];
          this.subrs = e.subrs || [];
          this.cmap = t;
          this.glyphNameMap = r || n.getGlyphsUnicode();
          this.gsubrsBias = f(this.gsubrs);
          this.subrsBias = f(this.subrs);
          this.isCFFCIDFont = e.isCFFCIDFont;
          this.fdSelect = e.fdSelect;
          this.fdArray = e.fdArray;
        }
        compileGlyphImpl(e, t, a) {
          !function e(t, a, i, n) {
            function o(e, t) {
              a.push({
                cmd: "moveTo",
                args: [e, t]
              });
            }
            function l(e, t) {
              a.push({
                cmd: "lineTo",
                args: [e, t]
              });
            }
            function c(e, t, r, i, n, s) {
              a.push({
                cmd: "bezierCurveTo",
                args: [e, t, r, i, n, s]
              });
            }
            let h = [];
            let u = 0;
            let d = 0;
            let p = 0;
            !function t(m) {
              let b = 0;
              for (; b < m.length;) {
                let y;
                let w;
                let x;
                let S;
                let k;
                let A;
                let v;
                let C;
                let O;
                let F = !1;
                let I = m[b++];
                switch (I) {
                  case 1:
                  case 3:
                  case 18:
                  case 23:
                    p += h.length >> 1;
                    F = !0;
                    break;
                  case 4:
                    d += h.pop();
                    o(u, d);
                    F = !0;
                    break;
                  case 5:
                    for (; h.length > 0;) {
                      u += h.shift();
                      d += h.shift();
                      l(u, d);
                    }
                    break;
                  case 6:
                    for (; h.length > 0 && (l(u += h.shift(), d), 0 !== h.length);) {
                      d += h.shift();
                      l(u, d);
                    }
                    break;
                  case 7:
                    for (; h.length > 0 && (d += h.shift(), l(u, d), 0 !== h.length);) l(u += h.shift(), d);
                    break;
                  case 8:
                    for (; h.length > 0;) {
                      y = u + h.shift();
                      x = d + h.shift();
                      w = y + h.shift();
                      S = x + h.shift();
                      u = w + h.shift();
                      d = S + h.shift();
                      c(y, x, w, S, u, d);
                    }
                    break;
                  case 10:
                    if (C = h.pop(), O = null, i.isCFFCIDFont) {
                      let e = i.fdSelect.getFDIndex(n);
                      if (e >= 0 && e < i.fdArray.length) {
                        let t;
                        let a = i.fdArray[e];
                        a.privateDict && a.privateDict.subrsIndex && (t = a.privateDict.subrsIndex.objects);
                        t && (C += f(t), O = t[C]);
                      } else r.warn("Invalid fd index for glyph index.");
                    } else O = i.subrs[C + i.subrsBias];
                    O && t(O);
                    break;
                  case 11:
                    return;
                  case 12:
                    switch (I = m[b++]) {
                      case 34:
                        w = (y = u + h.shift()) + h.shift();
                        k = d + h.shift();
                        u = w + h.shift();
                        c(y, d, w, k, u, k);
                        u = (w = (y = u + h.shift()) + h.shift()) + h.shift();
                        c(y, k, w, d, u, d);
                        break;
                      case 35:
                        y = u + h.shift();
                        x = d + h.shift();
                        w = y + h.shift();
                        S = x + h.shift();
                        u = w + h.shift();
                        d = S + h.shift();
                        c(y, x, w, S, u, d);
                        y = u + h.shift();
                        x = d + h.shift();
                        w = y + h.shift();
                        S = x + h.shift();
                        u = w + h.shift();
                        d = S + h.shift();
                        c(y, x, w, S, u, d);
                        h.pop();
                        break;
                      case 36:
                        y = u + h.shift();
                        k = d + h.shift();
                        w = y + h.shift();
                        A = k + h.shift();
                        u = w + h.shift();
                        c(y, k, w, A, u, A);
                        w = (y = u + h.shift()) + h.shift();
                        v = A + h.shift();
                        u = w + h.shift();
                        c(y, A, w, v, u, d);
                        break;
                      case 37:
                        let T = u;
                        let M = d;
                        y = u + h.shift();
                        x = d + h.shift();
                        w = y + h.shift();
                        S = x + h.shift();
                        u = w + h.shift();
                        d = S + h.shift();
                        c(y, x, w, S, u, d);
                        y = u + h.shift();
                        x = d + h.shift();
                        w = y + h.shift();
                        S = x + h.shift();
                        Math.abs((u = w) - T) > Math.abs((d = S) - M) ? u += h.shift() : d += h.shift();
                        c(y, x, w, S, u, d);
                        break;
                      default:
                        throw new r.FormatError(`unknown operator: 12 ${I}`);
                    }
                    break;
                  case 14:
                    if (h.length >= 4) {
                      let t = h.pop();
                      let r = h.pop();
                      d = h.pop();
                      u = h.pop();
                      a.push({
                        cmd: "save"
                      }, {
                        cmd: "translate",
                        args: [u, d]
                      });
                      let n = g(i.cmap, String.fromCharCode(i.glyphNameMap[s.StandardEncoding[t]]));
                      e(i.glyphs[n.glyphId], a, i, n.glyphId);
                      a.push({
                        cmd: "restore"
                      });
                      n = g(i.cmap, String.fromCharCode(i.glyphNameMap[s.StandardEncoding[r]]));
                      e(i.glyphs[n.glyphId], a, i, n.glyphId);
                    }
                    return;
                  case 19:
                  case 20:
                    p += h.length >> 1;
                    b += p + 7 >> 3;
                    F = !0;
                    break;
                  case 21:
                    d += h.pop();
                    o(u += h.pop(), d);
                    F = !0;
                    break;
                  case 22:
                    o(u += h.pop(), d);
                    F = !0;
                    break;
                  case 24:
                    for (; h.length > 2;) {
                      y = u + h.shift();
                      x = d + h.shift();
                      w = y + h.shift();
                      S = x + h.shift();
                      u = w + h.shift();
                      d = S + h.shift();
                      c(y, x, w, S, u, d);
                    }
                    u += h.shift();
                    d += h.shift();
                    l(u, d);
                    break;
                  case 25:
                    for (; h.length > 6;) {
                      u += h.shift();
                      d += h.shift();
                      l(u, d);
                    }
                    y = u + h.shift();
                    x = d + h.shift();
                    w = y + h.shift();
                    S = x + h.shift();
                    u = w + h.shift();
                    d = S + h.shift();
                    c(y, x, w, S, u, d);
                    break;
                  case 26:
                    for (h.length % 2 && (u += h.shift()); h.length > 0;) {
                      y = u;
                      x = d + h.shift();
                      w = y + h.shift();
                      S = x + h.shift();
                      u = w;
                      d = S + h.shift();
                      c(y, x, w, S, u, d);
                    }
                    break;
                  case 27:
                    for (h.length % 2 && (d += h.shift()); h.length > 0;) {
                      y = u + h.shift();
                      x = d;
                      w = y + h.shift();
                      S = x + h.shift();
                      u = w + h.shift();
                      d = S;
                      c(y, x, w, S, u, d);
                    }
                    break;
                  case 28:
                    h.push((m[b] << 24 | m[b + 1] << 16) >> 16);
                    b += 2;
                    break;
                  case 29:
                    C = h.pop() + i.gsubrsBias;
                    (O = i.gsubrs[C]) && t(O);
                    break;
                  case 30:
                    for (; h.length > 0 && (y = u, x = d + h.shift(), w = y + h.shift(), S = x + h.shift(), u = w + h.shift(), d = S + (1 === h.length ? h.shift() : 0), c(y, x, w, S, u, d), 0 !== h.length);) {
                      y = u + h.shift();
                      x = d;
                      w = y + h.shift();
                      d = (S = x + h.shift()) + h.shift();
                      u = w + (1 === h.length ? h.shift() : 0);
                      c(y, x, w, S, u, d);
                    }
                    break;
                  case 31:
                    for (; h.length > 0 && (y = u + h.shift(), x = d, w = y + h.shift(), d = (S = x + h.shift()) + h.shift(), u = w + (1 === h.length ? h.shift() : 0), c(y, x, w, S, u, d), 0 !== h.length);) {
                      y = u;
                      x = d + h.shift();
                      w = y + h.shift();
                      S = x + h.shift();
                      u = w + h.shift();
                      d = S + (1 === h.length ? h.shift() : 0);
                      c(y, x, w, S, u, d);
                    }
                    break;
                  default:
                    if (I < 32) throw new r.FormatError(`unknown operator: ${I}`);
                    I < 247 ? h.push(I - 139) : I < 251 ? h.push((I - 247) * 256 + m[b++] + 108) : I < 255 ? h.push(-(256 * (I - 251)) - m[b++] - 108) : (h.push((m[b] << 24 | m[b + 1] << 16 | m[b + 2] << 8 | m[b + 3]) / 65536), b += 4);
                }
                F && (h.length = 0);
              }
            }(t);
          }(e, t, this, a);
        }
      }
      t.FontRendererFactory = class {
        static create(e, t) {
          let a;
          let n;
          let s;
          let h;
          let u;
          let d;
          let f = new Uint8Array(e.data);
          let g = c(f, 4);
          for (function () {
            let e = 0;
            let p = 12;
          }(); e < g; e++, p += 16) {
            let e = r.bytesToString(f.subarray(p, p + 4));
            let g = l(f, p + 8);
            let m = l(f, p + 12);
            switch (e) {
              case "cmap":
                a = function (e, t, a) {
                  let i;
                  let n;
                  let s;
                  let o = 1 === c(e, t + 2) ? l(e, t + 8) : l(e, t + 16);
                  let h = c(e, t + o);
                  if (4 === h) {
                    c(e, t + o + 2);
                    let a = c(e, t + o + 6) >> 1;
                    for (s = 0, n = t + o + 14, i = []; s < a; s++, n += 2) i[s] = {
                      end: c(e, n)
                    };
                    for (n += 2, s = 0; s < a; s++, n += 2) i[s].start = c(e, n);
                    for (s = 0; s < a; s++, n += 2) i[s].idDelta = c(e, n);
                    for (s = 0; s < a; s++, n += 2) {
                      let t = c(e, n);
                      if (0 !== t) {
                        i[s].ids = [];
                        for (function () {
                          let a = 0;
                          let r = i[s].end - i[s].start + 1;
                        }(); a < r; a++) {
                          i[s].ids[a] = c(e, n + t);
                          t += 2;
                        }
                      }
                    }
                    return i;
                  }
                  if (12 === h) {
                    let a = l(e, t + o + 12);
                    for (s = 0, n = t + o + 16, i = []; s < a; s++) {
                      t = l(e, n);
                      i.push({
                        start: t,
                        end: l(e, n + 4),
                        idDelta: l(e, n + 8) - t
                      });
                      n += 12;
                    }
                    return i;
                  }
                  throw new r.FormatError(`unsupported cmap: ${h}`);
                }(f, g, 0);
                break;
              case "glyf":
                n = f.subarray(g, g + m);
                break;
              case "loca":
                s = f.subarray(g, g + m);
                break;
              case "head":
                d = c(f, g + 18);
                u = c(f, g + 50);
                break;
              case "CFF ":
                h = function (e, t, a, r) {
                  let n = new i.CFFParser(new o.Stream(e, t, a - t), {}, r).parse();
                  return {
                    glyphs: n.charStrings.objects,
                    subrs: n.topDict.privateDict && n.topDict.privateDict.subrsIndex && n.topDict.privateDict.subrsIndex.objects,
                    gsubrs: n.globalSubrIndex && n.globalSubrIndex.objects,
                    isCFFCIDFont: n.isCIDFont,
                    fdSelect: n.fdSelect,
                    fdArray: n.fdArray
                  };
                }(f, g, g + m, t);
            }
          }
          if (n) {
            let t = d ? [1 / d, 0, 0, 1 / d, 0, 0] : e.fontMatrix;
            return new b(function (e, t, a) {
              let r;
              let i;
              a ? (r = 4, i = l) : (r = 2, i = (e, t) => 2 * c(e, t));
              let n = [];
              let s = i(t, 0);
              for (let a = r; a < t.length; a += r) {
                let r = i(t, a);
                n.push(e.subarray(s, r));
                s = r;
              }
              return n;
            }(n, s, u), a, t);
          }
          return new y(h, a, e.fontMatrix, e.glyphNameMap);
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.getMetrics = t.getFontBasicMetrics = void 0;
      var r = a(8);
      let i = r.getLookupTableFactory(function (e) {
        e.Courier = 600;
        e["Courier-Bold"] = 600;
        e["Courier-BoldOblique"] = 600;
        e["Courier-Oblique"] = 600;
        e.Helvetica = r.getLookupTableFactory(function (e) {
          e.space = 278;
          e.exclam = 278;
          e.quotedbl = 355;
          e.numbersign = 556;
          e.dollar = 556;
          e.percent = 889;
          e.ampersand = 667;
          e.quoteright = 222;
          e.parenleft = 333;
          e.parenright = 333;
          e.asterisk = 389;
          e.plus = 584;
          e.comma = 278;
          e.hyphen = 333;
          e.period = 278;
          e.slash = 278;
          e.zero = 556;
          e.one = 556;
          e.two = 556;
          e.three = 556;
          e.four = 556;
          e.five = 556;
          e.six = 556;
          e.seven = 556;
          e.eight = 556;
          e.nine = 556;
          e.colon = 278;
          e.semicolon = 278;
          e.less = 584;
          e.equal = 584;
          e.greater = 584;
          e.question = 556;
          e.at = 1015;
          e.A = 667;
          e.B = 667;
          e.C = 722;
          e.D = 722;
          e.E = 667;
          e.F = 611;
          e.G = 778;
          e.H = 722;
          e.I = 278;
          e.J = 500;
          e.K = 667;
          e.L = 556;
          e.M = 833;
          e.N = 722;
          e.O = 778;
          e.P = 667;
          e.Q = 778;
          e.R = 722;
          e.S = 667;
          e.T = 611;
          e.U = 722;
          e.V = 667;
          e.W = 944;
          e.X = 667;
          e.Y = 667;
          e.Z = 611;
          e.bracketleft = 278;
          e.backslash = 278;
          e.bracketright = 278;
          e.asciicircum = 469;
          e.underscore = 556;
          e.quoteleft = 222;
          e.a = 556;
          e.b = 556;
          e.c = 500;
          e.d = 556;
          e.e = 556;
          e.f = 278;
          e.g = 556;
          e.h = 556;
          e.i = 222;
          e.j = 222;
          e.k = 500;
          e.l = 222;
          e.m = 833;
          e.n = 556;
          e.o = 556;
          e.p = 556;
          e.q = 556;
          e.r = 333;
          e.s = 500;
          e.t = 278;
          e.u = 556;
          e.v = 500;
          e.w = 722;
          e.x = 500;
          e.y = 500;
          e.z = 500;
          e.braceleft = 334;
          e.bar = 260;
          e.braceright = 334;
          e.asciitilde = 584;
          e.exclamdown = 333;
          e.cent = 556;
          e.sterling = 556;
          e.fraction = 167;
          e.yen = 556;
          e.florin = 556;
          e.section = 556;
          e.currency = 556;
          e.quotesingle = 191;
          e.quotedblleft = 333;
          e.guillemotleft = 556;
          e.guilsinglleft = 333;
          e.guilsinglright = 333;
          e.fi = 500;
          e.fl = 500;
          e.endash = 556;
          e.dagger = 556;
          e.daggerdbl = 556;
          e.periodcentered = 278;
          e.paragraph = 537;
          e.bullet = 350;
          e.quotesinglbase = 222;
          e.quotedblbase = 333;
          e.quotedblright = 333;
          e.guillemotright = 556;
          e.ellipsis = 1e3;
          e.perthousand = 1e3;
          e.questiondown = 611;
          e.grave = 333;
          e.acute = 333;
          e.circumflex = 333;
          e.tilde = 333;
          e.macron = 333;
          e.breve = 333;
          e.dotaccent = 333;
          e.dieresis = 333;
          e.ring = 333;
          e.cedilla = 333;
          e.hungarumlaut = 333;
          e.ogonek = 333;
          e.caron = 333;
          e.emdash = 1e3;
          e.AE = 1e3;
          e.ordfeminine = 370;
          e.Lslash = 556;
          e.Oslash = 778;
          e.OE = 1e3;
          e.ordmasculine = 365;
          e.ae = 889;
          e.dotlessi = 278;
          e.lslash = 222;
          e.oslash = 611;
          e.oe = 944;
          e.germandbls = 611;
          e.Idieresis = 278;
          e.eacute = 556;
          e.abreve = 556;
          e.uhungarumlaut = 556;
          e.ecaron = 556;
          e.Ydieresis = 667;
          e.divide = 584;
          e.Yacute = 667;
          e.Acircumflex = 667;
          e.aacute = 556;
          e.Ucircumflex = 722;
          e.yacute = 500;
          e.scommaaccent = 500;
          e.ecircumflex = 556;
          e.Uring = 722;
          e.Udieresis = 722;
          e.aogonek = 556;
          e.Uacute = 722;
          e.uogonek = 556;
          e.Edieresis = 667;
          e.Dcroat = 722;
          e.commaaccent = 250;
          e.copyright = 737;
          e.Emacron = 667;
          e.ccaron = 500;
          e.aring = 556;
          e.Ncommaaccent = 722;
          e.lacute = 222;
          e.agrave = 556;
          e.Tcommaaccent = 611;
          e.Cacute = 722;
          e.atilde = 556;
          e.Edotaccent = 667;
          e.scaron = 500;
          e.scedilla = 500;
          e.iacute = 278;
          e.lozenge = 471;
          e.Rcaron = 722;
          e.Gcommaaccent = 778;
          e.ucircumflex = 556;
          e.acircumflex = 556;
          e.Amacron = 667;
          e.rcaron = 333;
          e.ccedilla = 500;
          e.Zdotaccent = 611;
          e.Thorn = 667;
          e.Omacron = 778;
          e.Racute = 722;
          e.Sacute = 667;
          e.dcaron = 643;
          e.Umacron = 722;
          e.uring = 556;
          e.threesuperior = 333;
          e.Ograve = 778;
          e.Agrave = 667;
          e.Abreve = 667;
          e.multiply = 584;
          e.uacute = 556;
          e.Tcaron = 611;
          e.partialdiff = 476;
          e.ydieresis = 500;
          e.Nacute = 722;
          e.icircumflex = 278;
          e.Ecircumflex = 667;
          e.adieresis = 556;
          e.edieresis = 556;
          e.cacute = 500;
          e.nacute = 556;
          e.umacron = 556;
          e.Ncaron = 722;
          e.Iacute = 278;
          e.plusminus = 584;
          e.brokenbar = 260;
          e.registered = 737;
          e.Gbreve = 778;
          e.Idotaccent = 278;
          e.summation = 600;
          e.Egrave = 667;
          e.racute = 333;
          e.omacron = 556;
          e.Zacute = 611;
          e.Zcaron = 611;
          e.greaterequal = 549;
          e.Eth = 722;
          e.Ccedilla = 722;
          e.lcommaaccent = 222;
          e.tcaron = 317;
          e.eogonek = 556;
          e.Uogonek = 722;
          e.Aacute = 667;
          e.Adieresis = 667;
          e.egrave = 556;
          e.zacute = 500;
          e.iogonek = 222;
          e.Oacute = 778;
          e.oacute = 556;
          e.amacron = 556;
          e.sacute = 500;
          e.idieresis = 278;
          e.Ocircumflex = 778;
          e.Ugrave = 722;
          e.Delta = 612;
          e.thorn = 556;
          e.twosuperior = 333;
          e.Odieresis = 778;
          e.mu = 556;
          e.igrave = 278;
          e.ohungarumlaut = 556;
          e.Eogonek = 667;
          e.dcroat = 556;
          e.threequarters = 834;
          e.Scedilla = 667;
          e.lcaron = 299;
          e.Kcommaaccent = 667;
          e.Lacute = 556;
          e.trademark = 1e3;
          e.edotaccent = 556;
          e.Igrave = 278;
          e.Imacron = 278;
          e.Lcaron = 556;
          e.onehalf = 834;
          e.lessequal = 549;
          e.ocircumflex = 556;
          e.ntilde = 556;
          e.Uhungarumlaut = 722;
          e.Eacute = 667;
          e.emacron = 556;
          e.gbreve = 556;
          e.onequarter = 834;
          e.Scaron = 667;
          e.Scommaaccent = 667;
          e.Ohungarumlaut = 778;
          e.degree = 400;
          e.ograve = 556;
          e.Ccaron = 722;
          e.ugrave = 556;
          e.radical = 453;
          e.Dcaron = 722;
          e.rcommaaccent = 333;
          e.Ntilde = 722;
          e.otilde = 556;
          e.Rcommaaccent = 722;
          e.Lcommaaccent = 556;
          e.Atilde = 667;
          e.Aogonek = 667;
          e.Aring = 667;
          e.Otilde = 778;
          e.zdotaccent = 500;
          e.Ecaron = 667;
          e.Iogonek = 278;
          e.kcommaaccent = 500;
          e.minus = 584;
          e.Icircumflex = 278;
          e.ncaron = 556;
          e.tcommaaccent = 278;
          e.logicalnot = 584;
          e.odieresis = 556;
          e.udieresis = 556;
          e.notequal = 549;
          e.gcommaaccent = 556;
          e.eth = 556;
          e.zcaron = 500;
          e.ncommaaccent = 556;
          e.onesuperior = 333;
          e.imacron = 278;
          e.Euro = 556;
        });
        e["Helvetica-Bold"] = r.getLookupTableFactory(function (e) {
          e.space = 278;
          e.exclam = 333;
          e.quotedbl = 474;
          e.numbersign = 556;
          e.dollar = 556;
          e.percent = 889;
          e.ampersand = 722;
          e.quoteright = 278;
          e.parenleft = 333;
          e.parenright = 333;
          e.asterisk = 389;
          e.plus = 584;
          e.comma = 278;
          e.hyphen = 333;
          e.period = 278;
          e.slash = 278;
          e.zero = 556;
          e.one = 556;
          e.two = 556;
          e.three = 556;
          e.four = 556;
          e.five = 556;
          e.six = 556;
          e.seven = 556;
          e.eight = 556;
          e.nine = 556;
          e.colon = 333;
          e.semicolon = 333;
          e.less = 584;
          e.equal = 584;
          e.greater = 584;
          e.question = 611;
          e.at = 975;
          e.A = 722;
          e.B = 722;
          e.C = 722;
          e.D = 722;
          e.E = 667;
          e.F = 611;
          e.G = 778;
          e.H = 722;
          e.I = 278;
          e.J = 556;
          e.K = 722;
          e.L = 611;
          e.M = 833;
          e.N = 722;
          e.O = 778;
          e.P = 667;
          e.Q = 778;
          e.R = 722;
          e.S = 667;
          e.T = 611;
          e.U = 722;
          e.V = 667;
          e.W = 944;
          e.X = 667;
          e.Y = 667;
          e.Z = 611;
          e.bracketleft = 333;
          e.backslash = 278;
          e.bracketright = 333;
          e.asciicircum = 584;
          e.underscore = 556;
          e.quoteleft = 278;
          e.a = 556;
          e.b = 611;
          e.c = 556;
          e.d = 611;
          e.e = 556;
          e.f = 333;
          e.g = 611;
          e.h = 611;
          e.i = 278;
          e.j = 278;
          e.k = 556;
          e.l = 278;
          e.m = 889;
          e.n = 611;
          e.o = 611;
          e.p = 611;
          e.q = 611;
          e.r = 389;
          e.s = 556;
          e.t = 333;
          e.u = 611;
          e.v = 556;
          e.w = 778;
          e.x = 556;
          e.y = 556;
          e.z = 500;
          e.braceleft = 389;
          e.bar = 280;
          e.braceright = 389;
          e.asciitilde = 584;
          e.exclamdown = 333;
          e.cent = 556;
          e.sterling = 556;
          e.fraction = 167;
          e.yen = 556;
          e.florin = 556;
          e.section = 556;
          e.currency = 556;
          e.quotesingle = 238;
          e.quotedblleft = 500;
          e.guillemotleft = 556;
          e.guilsinglleft = 333;
          e.guilsinglright = 333;
          e.fi = 611;
          e.fl = 611;
          e.endash = 556;
          e.dagger = 556;
          e.daggerdbl = 556;
          e.periodcentered = 278;
          e.paragraph = 556;
          e.bullet = 350;
          e.quotesinglbase = 278;
          e.quotedblbase = 500;
          e.quotedblright = 500;
          e.guillemotright = 556;
          e.ellipsis = 1e3;
          e.perthousand = 1e3;
          e.questiondown = 611;
          e.grave = 333;
          e.acute = 333;
          e.circumflex = 333;
          e.tilde = 333;
          e.macron = 333;
          e.breve = 333;
          e.dotaccent = 333;
          e.dieresis = 333;
          e.ring = 333;
          e.cedilla = 333;
          e.hungarumlaut = 333;
          e.ogonek = 333;
          e.caron = 333;
          e.emdash = 1e3;
          e.AE = 1e3;
          e.ordfeminine = 370;
          e.Lslash = 611;
          e.Oslash = 778;
          e.OE = 1e3;
          e.ordmasculine = 365;
          e.ae = 889;
          e.dotlessi = 278;
          e.lslash = 278;
          e.oslash = 611;
          e.oe = 944;
          e.germandbls = 611;
          e.Idieresis = 278;
          e.eacute = 556;
          e.abreve = 556;
          e.uhungarumlaut = 611;
          e.ecaron = 556;
          e.Ydieresis = 667;
          e.divide = 584;
          e.Yacute = 667;
          e.Acircumflex = 722;
          e.aacute = 556;
          e.Ucircumflex = 722;
          e.yacute = 556;
          e.scommaaccent = 556;
          e.ecircumflex = 556;
          e.Uring = 722;
          e.Udieresis = 722;
          e.aogonek = 556;
          e.Uacute = 722;
          e.uogonek = 611;
          e.Edieresis = 667;
          e.Dcroat = 722;
          e.commaaccent = 250;
          e.copyright = 737;
          e.Emacron = 667;
          e.ccaron = 556;
          e.aring = 556;
          e.Ncommaaccent = 722;
          e.lacute = 278;
          e.agrave = 556;
          e.Tcommaaccent = 611;
          e.Cacute = 722;
          e.atilde = 556;
          e.Edotaccent = 667;
          e.scaron = 556;
          e.scedilla = 556;
          e.iacute = 278;
          e.lozenge = 494;
          e.Rcaron = 722;
          e.Gcommaaccent = 778;
          e.ucircumflex = 611;
          e.acircumflex = 556;
          e.Amacron = 722;
          e.rcaron = 389;
          e.ccedilla = 556;
          e.Zdotaccent = 611;
          e.Thorn = 667;
          e.Omacron = 778;
          e.Racute = 722;
          e.Sacute = 667;
          e.dcaron = 743;
          e.Umacron = 722;
          e.uring = 611;
          e.threesuperior = 333;
          e.Ograve = 778;
          e.Agrave = 722;
          e.Abreve = 722;
          e.multiply = 584;
          e.uacute = 611;
          e.Tcaron = 611;
          e.partialdiff = 494;
          e.ydieresis = 556;
          e.Nacute = 722;
          e.icircumflex = 278;
          e.Ecircumflex = 667;
          e.adieresis = 556;
          e.edieresis = 556;
          e.cacute = 556;
          e.nacute = 611;
          e.umacron = 611;
          e.Ncaron = 722;
          e.Iacute = 278;
          e.plusminus = 584;
          e.brokenbar = 280;
          e.registered = 737;
          e.Gbreve = 778;
          e.Idotaccent = 278;
          e.summation = 600;
          e.Egrave = 667;
          e.racute = 389;
          e.omacron = 611;
          e.Zacute = 611;
          e.Zcaron = 611;
          e.greaterequal = 549;
          e.Eth = 722;
          e.Ccedilla = 722;
          e.lcommaaccent = 278;
          e.tcaron = 389;
          e.eogonek = 556;
          e.Uogonek = 722;
          e.Aacute = 722;
          e.Adieresis = 722;
          e.egrave = 556;
          e.zacute = 500;
          e.iogonek = 278;
          e.Oacute = 778;
          e.oacute = 611;
          e.amacron = 556;
          e.sacute = 556;
          e.idieresis = 278;
          e.Ocircumflex = 778;
          e.Ugrave = 722;
          e.Delta = 612;
          e.thorn = 611;
          e.twosuperior = 333;
          e.Odieresis = 778;
          e.mu = 611;
          e.igrave = 278;
          e.ohungarumlaut = 611;
          e.Eogonek = 667;
          e.dcroat = 611;
          e.threequarters = 834;
          e.Scedilla = 667;
          e.lcaron = 400;
          e.Kcommaaccent = 722;
          e.Lacute = 611;
          e.trademark = 1e3;
          e.edotaccent = 556;
          e.Igrave = 278;
          e.Imacron = 278;
          e.Lcaron = 611;
          e.onehalf = 834;
          e.lessequal = 549;
          e.ocircumflex = 611;
          e.ntilde = 611;
          e.Uhungarumlaut = 722;
          e.Eacute = 667;
          e.emacron = 556;
          e.gbreve = 611;
          e.onequarter = 834;
          e.Scaron = 667;
          e.Scommaaccent = 667;
          e.Ohungarumlaut = 778;
          e.degree = 400;
          e.ograve = 611;
          e.Ccaron = 722;
          e.ugrave = 611;
          e.radical = 549;
          e.Dcaron = 722;
          e.rcommaaccent = 389;
          e.Ntilde = 722;
          e.otilde = 611;
          e.Rcommaaccent = 722;
          e.Lcommaaccent = 611;
          e.Atilde = 722;
          e.Aogonek = 722;
          e.Aring = 722;
          e.Otilde = 778;
          e.zdotaccent = 500;
          e.Ecaron = 667;
          e.Iogonek = 278;
          e.kcommaaccent = 556;
          e.minus = 584;
          e.Icircumflex = 278;
          e.ncaron = 611;
          e.tcommaaccent = 333;
          e.logicalnot = 584;
          e.odieresis = 611;
          e.udieresis = 611;
          e.notequal = 549;
          e.gcommaaccent = 611;
          e.eth = 611;
          e.zcaron = 500;
          e.ncommaaccent = 611;
          e.onesuperior = 333;
          e.imacron = 278;
          e.Euro = 556;
        });
        e["Helvetica-BoldOblique"] = r.getLookupTableFactory(function (e) {
          e.space = 278;
          e.exclam = 333;
          e.quotedbl = 474;
          e.numbersign = 556;
          e.dollar = 556;
          e.percent = 889;
          e.ampersand = 722;
          e.quoteright = 278;
          e.parenleft = 333;
          e.parenright = 333;
          e.asterisk = 389;
          e.plus = 584;
          e.comma = 278;
          e.hyphen = 333;
          e.period = 278;
          e.slash = 278;
          e.zero = 556;
          e.one = 556;
          e.two = 556;
          e.three = 556;
          e.four = 556;
          e.five = 556;
          e.six = 556;
          e.seven = 556;
          e.eight = 556;
          e.nine = 556;
          e.colon = 333;
          e.semicolon = 333;
          e.less = 584;
          e.equal = 584;
          e.greater = 584;
          e.question = 611;
          e.at = 975;
          e.A = 722;
          e.B = 722;
          e.C = 722;
          e.D = 722;
          e.E = 667;
          e.F = 611;
          e.G = 778;
          e.H = 722;
          e.I = 278;
          e.J = 556;
          e.K = 722;
          e.L = 611;
          e.M = 833;
          e.N = 722;
          e.O = 778;
          e.P = 667;
          e.Q = 778;
          e.R = 722;
          e.S = 667;
          e.T = 611;
          e.U = 722;
          e.V = 667;
          e.W = 944;
          e.X = 667;
          e.Y = 667;
          e.Z = 611;
          e.bracketleft = 333;
          e.backslash = 278;
          e.bracketright = 333;
          e.asciicircum = 584;
          e.underscore = 556;
          e.quoteleft = 278;
          e.a = 556;
          e.b = 611;
          e.c = 556;
          e.d = 611;
          e.e = 556;
          e.f = 333;
          e.g = 611;
          e.h = 611;
          e.i = 278;
          e.j = 278;
          e.k = 556;
          e.l = 278;
          e.m = 889;
          e.n = 611;
          e.o = 611;
          e.p = 611;
          e.q = 611;
          e.r = 389;
          e.s = 556;
          e.t = 333;
          e.u = 611;
          e.v = 556;
          e.w = 778;
          e.x = 556;
          e.y = 556;
          e.z = 500;
          e.braceleft = 389;
          e.bar = 280;
          e.braceright = 389;
          e.asciitilde = 584;
          e.exclamdown = 333;
          e.cent = 556;
          e.sterling = 556;
          e.fraction = 167;
          e.yen = 556;
          e.florin = 556;
          e.section = 556;
          e.currency = 556;
          e.quotesingle = 238;
          e.quotedblleft = 500;
          e.guillemotleft = 556;
          e.guilsinglleft = 333;
          e.guilsinglright = 333;
          e.fi = 611;
          e.fl = 611;
          e.endash = 556;
          e.dagger = 556;
          e.daggerdbl = 556;
          e.periodcentered = 278;
          e.paragraph = 556;
          e.bullet = 350;
          e.quotesinglbase = 278;
          e.quotedblbase = 500;
          e.quotedblright = 500;
          e.guillemotright = 556;
          e.ellipsis = 1e3;
          e.perthousand = 1e3;
          e.questiondown = 611;
          e.grave = 333;
          e.acute = 333;
          e.circumflex = 333;
          e.tilde = 333;
          e.macron = 333;
          e.breve = 333;
          e.dotaccent = 333;
          e.dieresis = 333;
          e.ring = 333;
          e.cedilla = 333;
          e.hungarumlaut = 333;
          e.ogonek = 333;
          e.caron = 333;
          e.emdash = 1e3;
          e.AE = 1e3;
          e.ordfeminine = 370;
          e.Lslash = 611;
          e.Oslash = 778;
          e.OE = 1e3;
          e.ordmasculine = 365;
          e.ae = 889;
          e.dotlessi = 278;
          e.lslash = 278;
          e.oslash = 611;
          e.oe = 944;
          e.germandbls = 611;
          e.Idieresis = 278;
          e.eacute = 556;
          e.abreve = 556;
          e.uhungarumlaut = 611;
          e.ecaron = 556;
          e.Ydieresis = 667;
          e.divide = 584;
          e.Yacute = 667;
          e.Acircumflex = 722;
          e.aacute = 556;
          e.Ucircumflex = 722;
          e.yacute = 556;
          e.scommaaccent = 556;
          e.ecircumflex = 556;
          e.Uring = 722;
          e.Udieresis = 722;
          e.aogonek = 556;
          e.Uacute = 722;
          e.uogonek = 611;
          e.Edieresis = 667;
          e.Dcroat = 722;
          e.commaaccent = 250;
          e.copyright = 737;
          e.Emacron = 667;
          e.ccaron = 556;
          e.aring = 556;
          e.Ncommaaccent = 722;
          e.lacute = 278;
          e.agrave = 556;
          e.Tcommaaccent = 611;
          e.Cacute = 722;
          e.atilde = 556;
          e.Edotaccent = 667;
          e.scaron = 556;
          e.scedilla = 556;
          e.iacute = 278;
          e.lozenge = 494;
          e.Rcaron = 722;
          e.Gcommaaccent = 778;
          e.ucircumflex = 611;
          e.acircumflex = 556;
          e.Amacron = 722;
          e.rcaron = 389;
          e.ccedilla = 556;
          e.Zdotaccent = 611;
          e.Thorn = 667;
          e.Omacron = 778;
          e.Racute = 722;
          e.Sacute = 667;
          e.dcaron = 743;
          e.Umacron = 722;
          e.uring = 611;
          e.threesuperior = 333;
          e.Ograve = 778;
          e.Agrave = 722;
          e.Abreve = 722;
          e.multiply = 584;
          e.uacute = 611;
          e.Tcaron = 611;
          e.partialdiff = 494;
          e.ydieresis = 556;
          e.Nacute = 722;
          e.icircumflex = 278;
          e.Ecircumflex = 667;
          e.adieresis = 556;
          e.edieresis = 556;
          e.cacute = 556;
          e.nacute = 611;
          e.umacron = 611;
          e.Ncaron = 722;
          e.Iacute = 278;
          e.plusminus = 584;
          e.brokenbar = 280;
          e.registered = 737;
          e.Gbreve = 778;
          e.Idotaccent = 278;
          e.summation = 600;
          e.Egrave = 667;
          e.racute = 389;
          e.omacron = 611;
          e.Zacute = 611;
          e.Zcaron = 611;
          e.greaterequal = 549;
          e.Eth = 722;
          e.Ccedilla = 722;
          e.lcommaaccent = 278;
          e.tcaron = 389;
          e.eogonek = 556;
          e.Uogonek = 722;
          e.Aacute = 722;
          e.Adieresis = 722;
          e.egrave = 556;
          e.zacute = 500;
          e.iogonek = 278;
          e.Oacute = 778;
          e.oacute = 611;
          e.amacron = 556;
          e.sacute = 556;
          e.idieresis = 278;
          e.Ocircumflex = 778;
          e.Ugrave = 722;
          e.Delta = 612;
          e.thorn = 611;
          e.twosuperior = 333;
          e.Odieresis = 778;
          e.mu = 611;
          e.igrave = 278;
          e.ohungarumlaut = 611;
          e.Eogonek = 667;
          e.dcroat = 611;
          e.threequarters = 834;
          e.Scedilla = 667;
          e.lcaron = 400;
          e.Kcommaaccent = 722;
          e.Lacute = 611;
          e.trademark = 1e3;
          e.edotaccent = 556;
          e.Igrave = 278;
          e.Imacron = 278;
          e.Lcaron = 611;
          e.onehalf = 834;
          e.lessequal = 549;
          e.ocircumflex = 611;
          e.ntilde = 611;
          e.Uhungarumlaut = 722;
          e.Eacute = 667;
          e.emacron = 556;
          e.gbreve = 611;
          e.onequarter = 834;
          e.Scaron = 667;
          e.Scommaaccent = 667;
          e.Ohungarumlaut = 778;
          e.degree = 400;
          e.ograve = 611;
          e.Ccaron = 722;
          e.ugrave = 611;
          e.radical = 549;
          e.Dcaron = 722;
          e.rcommaaccent = 389;
          e.Ntilde = 722;
          e.otilde = 611;
          e.Rcommaaccent = 722;
          e.Lcommaaccent = 611;
          e.Atilde = 722;
          e.Aogonek = 722;
          e.Aring = 722;
          e.Otilde = 778;
          e.zdotaccent = 500;
          e.Ecaron = 667;
          e.Iogonek = 278;
          e.kcommaaccent = 556;
          e.minus = 584;
          e.Icircumflex = 278;
          e.ncaron = 611;
          e.tcommaaccent = 333;
          e.logicalnot = 584;
          e.odieresis = 611;
          e.udieresis = 611;
          e.notequal = 549;
          e.gcommaaccent = 611;
          e.eth = 611;
          e.zcaron = 500;
          e.ncommaaccent = 611;
          e.onesuperior = 333;
          e.imacron = 278;
          e.Euro = 556;
        });
        e["Helvetica-Oblique"] = r.getLookupTableFactory(function (e) {
          e.space = 278;
          e.exclam = 278;
          e.quotedbl = 355;
          e.numbersign = 556;
          e.dollar = 556;
          e.percent = 889;
          e.ampersand = 667;
          e.quoteright = 222;
          e.parenleft = 333;
          e.parenright = 333;
          e.asterisk = 389;
          e.plus = 584;
          e.comma = 278;
          e.hyphen = 333;
          e.period = 278;
          e.slash = 278;
          e.zero = 556;
          e.one = 556;
          e.two = 556;
          e.three = 556;
          e.four = 556;
          e.five = 556;
          e.six = 556;
          e.seven = 556;
          e.eight = 556;
          e.nine = 556;
          e.colon = 278;
          e.semicolon = 278;
          e.less = 584;
          e.equal = 584;
          e.greater = 584;
          e.question = 556;
          e.at = 1015;
          e.A = 667;
          e.B = 667;
          e.C = 722;
          e.D = 722;
          e.E = 667;
          e.F = 611;
          e.G = 778;
          e.H = 722;
          e.I = 278;
          e.J = 500;
          e.K = 667;
          e.L = 556;
          e.M = 833;
          e.N = 722;
          e.O = 778;
          e.P = 667;
          e.Q = 778;
          e.R = 722;
          e.S = 667;
          e.T = 611;
          e.U = 722;
          e.V = 667;
          e.W = 944;
          e.X = 667;
          e.Y = 667;
          e.Z = 611;
          e.bracketleft = 278;
          e.backslash = 278;
          e.bracketright = 278;
          e.asciicircum = 469;
          e.underscore = 556;
          e.quoteleft = 222;
          e.a = 556;
          e.b = 556;
          e.c = 500;
          e.d = 556;
          e.e = 556;
          e.f = 278;
          e.g = 556;
          e.h = 556;
          e.i = 222;
          e.j = 222;
          e.k = 500;
          e.l = 222;
          e.m = 833;
          e.n = 556;
          e.o = 556;
          e.p = 556;
          e.q = 556;
          e.r = 333;
          e.s = 500;
          e.t = 278;
          e.u = 556;
          e.v = 500;
          e.w = 722;
          e.x = 500;
          e.y = 500;
          e.z = 500;
          e.braceleft = 334;
          e.bar = 260;
          e.braceright = 334;
          e.asciitilde = 584;
          e.exclamdown = 333;
          e.cent = 556;
          e.sterling = 556;
          e.fraction = 167;
          e.yen = 556;
          e.florin = 556;
          e.section = 556;
          e.currency = 556;
          e.quotesingle = 191;
          e.quotedblleft = 333;
          e.guillemotleft = 556;
          e.guilsinglleft = 333;
          e.guilsinglright = 333;
          e.fi = 500;
          e.fl = 500;
          e.endash = 556;
          e.dagger = 556;
          e.daggerdbl = 556;
          e.periodcentered = 278;
          e.paragraph = 537;
          e.bullet = 350;
          e.quotesinglbase = 222;
          e.quotedblbase = 333;
          e.quotedblright = 333;
          e.guillemotright = 556;
          e.ellipsis = 1e3;
          e.perthousand = 1e3;
          e.questiondown = 611;
          e.grave = 333;
          e.acute = 333;
          e.circumflex = 333;
          e.tilde = 333;
          e.macron = 333;
          e.breve = 333;
          e.dotaccent = 333;
          e.dieresis = 333;
          e.ring = 333;
          e.cedilla = 333;
          e.hungarumlaut = 333;
          e.ogonek = 333;
          e.caron = 333;
          e.emdash = 1e3;
          e.AE = 1e3;
          e.ordfeminine = 370;
          e.Lslash = 556;
          e.Oslash = 778;
          e.OE = 1e3;
          e.ordmasculine = 365;
          e.ae = 889;
          e.dotlessi = 278;
          e.lslash = 222;
          e.oslash = 611;
          e.oe = 944;
          e.germandbls = 611;
          e.Idieresis = 278;
          e.eacute = 556;
          e.abreve = 556;
          e.uhungarumlaut = 556;
          e.ecaron = 556;
          e.Ydieresis = 667;
          e.divide = 584;
          e.Yacute = 667;
          e.Acircumflex = 667;
          e.aacute = 556;
          e.Ucircumflex = 722;
          e.yacute = 500;
          e.scommaaccent = 500;
          e.ecircumflex = 556;
          e.Uring = 722;
          e.Udieresis = 722;
          e.aogonek = 556;
          e.Uacute = 722;
          e.uogonek = 556;
          e.Edieresis = 667;
          e.Dcroat = 722;
          e.commaaccent = 250;
          e.copyright = 737;
          e.Emacron = 667;
          e.ccaron = 500;
          e.aring = 556;
          e.Ncommaaccent = 722;
          e.lacute = 222;
          e.agrave = 556;
          e.Tcommaaccent = 611;
          e.Cacute = 722;
          e.atilde = 556;
          e.Edotaccent = 667;
          e.scaron = 500;
          e.scedilla = 500;
          e.iacute = 278;
          e.lozenge = 471;
          e.Rcaron = 722;
          e.Gcommaaccent = 778;
          e.ucircumflex = 556;
          e.acircumflex = 556;
          e.Amacron = 667;
          e.rcaron = 333;
          e.ccedilla = 500;
          e.Zdotaccent = 611;
          e.Thorn = 667;
          e.Omacron = 778;
          e.Racute = 722;
          e.Sacute = 667;
          e.dcaron = 643;
          e.Umacron = 722;
          e.uring = 556;
          e.threesuperior = 333;
          e.Ograve = 778;
          e.Agrave = 667;
          e.Abreve = 667;
          e.multiply = 584;
          e.uacute = 556;
          e.Tcaron = 611;
          e.partialdiff = 476;
          e.ydieresis = 500;
          e.Nacute = 722;
          e.icircumflex = 278;
          e.Ecircumflex = 667;
          e.adieresis = 556;
          e.edieresis = 556;
          e.cacute = 500;
          e.nacute = 556;
          e.umacron = 556;
          e.Ncaron = 722;
          e.Iacute = 278;
          e.plusminus = 584;
          e.brokenbar = 260;
          e.registered = 737;
          e.Gbreve = 778;
          e.Idotaccent = 278;
          e.summation = 600;
          e.Egrave = 667;
          e.racute = 333;
          e.omacron = 556;
          e.Zacute = 611;
          e.Zcaron = 611;
          e.greaterequal = 549;
          e.Eth = 722;
          e.Ccedilla = 722;
          e.lcommaaccent = 222;
          e.tcaron = 317;
          e.eogonek = 556;
          e.Uogonek = 722;
          e.Aacute = 667;
          e.Adieresis = 667;
          e.egrave = 556;
          e.zacute = 500;
          e.iogonek = 222;
          e.Oacute = 778;
          e.oacute = 556;
          e.amacron = 556;
          e.sacute = 500;
          e.idieresis = 278;
          e.Ocircumflex = 778;
          e.Ugrave = 722;
          e.Delta = 612;
          e.thorn = 556;
          e.twosuperior = 333;
          e.Odieresis = 778;
          e.mu = 556;
          e.igrave = 278;
          e.ohungarumlaut = 556;
          e.Eogonek = 667;
          e.dcroat = 556;
          e.threequarters = 834;
          e.Scedilla = 667;
          e.lcaron = 299;
          e.Kcommaaccent = 667;
          e.Lacute = 556;
          e.trademark = 1e3;
          e.edotaccent = 556;
          e.Igrave = 278;
          e.Imacron = 278;
          e.Lcaron = 556;
          e.onehalf = 834;
          e.lessequal = 549;
          e.ocircumflex = 556;
          e.ntilde = 556;
          e.Uhungarumlaut = 722;
          e.Eacute = 667;
          e.emacron = 556;
          e.gbreve = 556;
          e.onequarter = 834;
          e.Scaron = 667;
          e.Scommaaccent = 667;
          e.Ohungarumlaut = 778;
          e.degree = 400;
          e.ograve = 556;
          e.Ccaron = 722;
          e.ugrave = 556;
          e.radical = 453;
          e.Dcaron = 722;
          e.rcommaaccent = 333;
          e.Ntilde = 722;
          e.otilde = 556;
          e.Rcommaaccent = 722;
          e.Lcommaaccent = 556;
          e.Atilde = 667;
          e.Aogonek = 667;
          e.Aring = 667;
          e.Otilde = 778;
          e.zdotaccent = 500;
          e.Ecaron = 667;
          e.Iogonek = 278;
          e.kcommaaccent = 500;
          e.minus = 584;
          e.Icircumflex = 278;
          e.ncaron = 556;
          e.tcommaaccent = 278;
          e.logicalnot = 584;
          e.odieresis = 556;
          e.udieresis = 556;
          e.notequal = 549;
          e.gcommaaccent = 556;
          e.eth = 556;
          e.zcaron = 500;
          e.ncommaaccent = 556;
          e.onesuperior = 333;
          e.imacron = 278;
          e.Euro = 556;
        });
        e.Symbol = r.getLookupTableFactory(function (e) {
          e.space = 250;
          e.exclam = 333;
          e.universal = 713;
          e.numbersign = 500;
          e.existential = 549;
          e.percent = 833;
          e.ampersand = 778;
          e.suchthat = 439;
          e.parenleft = 333;
          e.parenright = 333;
          e.asteriskmath = 500;
          e.plus = 549;
          e.comma = 250;
          e.minus = 549;
          e.period = 250;
          e.slash = 278;
          e.zero = 500;
          e.one = 500;
          e.two = 500;
          e.three = 500;
          e.four = 500;
          e.five = 500;
          e.six = 500;
          e.seven = 500;
          e.eight = 500;
          e.nine = 500;
          e.colon = 278;
          e.semicolon = 278;
          e.less = 549;
          e.equal = 549;
          e.greater = 549;
          e.question = 444;
          e.congruent = 549;
          e.Alpha = 722;
          e.Beta = 667;
          e.Chi = 722;
          e.Delta = 612;
          e.Epsilon = 611;
          e.Phi = 763;
          e.Gamma = 603;
          e.Eta = 722;
          e.Iota = 333;
          e.theta1 = 631;
          e.Kappa = 722;
          e.Lambda = 686;
          e.Mu = 889;
          e.Nu = 722;
          e.Omicron = 722;
          e.Pi = 768;
          e.Theta = 741;
          e.Rho = 556;
          e.Sigma = 592;
          e.Tau = 611;
          e.Upsilon = 690;
          e.sigma1 = 439;
          e.Omega = 768;
          e.Xi = 645;
          e.Psi = 795;
          e.Zeta = 611;
          e.bracketleft = 333;
          e.therefore = 863;
          e.bracketright = 333;
          e.perpendicular = 658;
          e.underscore = 500;
          e.radicalex = 500;
          e.alpha = 631;
          e.beta = 549;
          e.chi = 549;
          e.delta = 494;
          e.epsilon = 439;
          e.phi = 521;
          e.gamma = 411;
          e.eta = 603;
          e.iota = 329;
          e.phi1 = 603;
          e.kappa = 549;
          e.lambda = 549;
          e.mu = 576;
          e.nu = 521;
          e.omicron = 549;
          e.pi = 549;
          e.theta = 521;
          e.rho = 549;
          e.sigma = 603;
          e.tau = 439;
          e.upsilon = 576;
          e.omega1 = 713;
          e.omega = 686;
          e.xi = 493;
          e.psi = 686;
          e.zeta = 494;
          e.braceleft = 480;
          e.bar = 200;
          e.braceright = 480;
          e.similar = 549;
          e.Euro = 750;
          e.Upsilon1 = 620;
          e.minute = 247;
          e.lessequal = 549;
          e.fraction = 167;
          e.infinity = 713;
          e.florin = 500;
          e.club = 753;
          e.diamond = 753;
          e.heart = 753;
          e.spade = 753;
          e.arrowboth = 1042;
          e.arrowleft = 987;
          e.arrowup = 603;
          e.arrowright = 987;
          e.arrowdown = 603;
          e.degree = 400;
          e.plusminus = 549;
          e.second = 411;
          e.greaterequal = 549;
          e.multiply = 549;
          e.proportional = 713;
          e.partialdiff = 494;
          e.bullet = 460;
          e.divide = 549;
          e.notequal = 549;
          e.equivalence = 549;
          e.approxequal = 549;
          e.ellipsis = 1e3;
          e.arrowvertex = 603;
          e.arrowhorizex = 1e3;
          e.carriagereturn = 658;
          e.aleph = 823;
          e.Ifraktur = 686;
          e.Rfraktur = 795;
          e.weierstrass = 987;
          e.circlemultiply = 768;
          e.circleplus = 768;
          e.emptyset = 823;
          e.intersection = 768;
          e.union = 768;
          e.propersuperset = 713;
          e.reflexsuperset = 713;
          e.notsubset = 713;
          e.propersubset = 713;
          e.reflexsubset = 713;
          e.element = 713;
          e.notelement = 713;
          e.angle = 768;
          e.gradient = 713;
          e.registerserif = 790;
          e.copyrightserif = 790;
          e.trademarkserif = 890;
          e.product = 823;
          e.radical = 549;
          e.dotmath = 250;
          e.logicalnot = 713;
          e.logicaland = 603;
          e.logicalor = 603;
          e.arrowdblboth = 1042;
          e.arrowdblleft = 987;
          e.arrowdblup = 603;
          e.arrowdblright = 987;
          e.arrowdbldown = 603;
          e.lozenge = 494;
          e.angleleft = 329;
          e.registersans = 790;
          e.copyrightsans = 790;
          e.trademarksans = 786;
          e.summation = 713;
          e.parenlefttp = 384;
          e.parenleftex = 384;
          e.parenleftbt = 384;
          e.bracketlefttp = 384;
          e.bracketleftex = 384;
          e.bracketleftbt = 384;
          e.bracelefttp = 494;
          e.braceleftmid = 494;
          e.braceleftbt = 494;
          e.braceex = 494;
          e.angleright = 329;
          e.integral = 274;
          e.integraltp = 686;
          e.integralex = 686;
          e.integralbt = 686;
          e.parenrighttp = 384;
          e.parenrightex = 384;
          e.parenrightbt = 384;
          e.bracketrighttp = 384;
          e.bracketrightex = 384;
          e.bracketrightbt = 384;
          e.bracerighttp = 494;
          e.bracerightmid = 494;
          e.bracerightbt = 494;
          e.apple = 790;
        });
        e["Times-Roman"] = r.getLookupTableFactory(function (e) {
          e.space = 250;
          e.exclam = 333;
          e.quotedbl = 408;
          e.numbersign = 500;
          e.dollar = 500;
          e.percent = 833;
          e.ampersand = 778;
          e.quoteright = 333;
          e.parenleft = 333;
          e.parenright = 333;
          e.asterisk = 500;
          e.plus = 564;
          e.comma = 250;
          e.hyphen = 333;
          e.period = 250;
          e.slash = 278;
          e.zero = 500;
          e.one = 500;
          e.two = 500;
          e.three = 500;
          e.four = 500;
          e.five = 500;
          e.six = 500;
          e.seven = 500;
          e.eight = 500;
          e.nine = 500;
          e.colon = 278;
          e.semicolon = 278;
          e.less = 564;
          e.equal = 564;
          e.greater = 564;
          e.question = 444;
          e.at = 921;
          e.A = 722;
          e.B = 667;
          e.C = 667;
          e.D = 722;
          e.E = 611;
          e.F = 556;
          e.G = 722;
          e.H = 722;
          e.I = 333;
          e.J = 389;
          e.K = 722;
          e.L = 611;
          e.M = 889;
          e.N = 722;
          e.O = 722;
          e.P = 556;
          e.Q = 722;
          e.R = 667;
          e.S = 556;
          e.T = 611;
          e.U = 722;
          e.V = 722;
          e.W = 944;
          e.X = 722;
          e.Y = 722;
          e.Z = 611;
          e.bracketleft = 333;
          e.backslash = 278;
          e.bracketright = 333;
          e.asciicircum = 469;
          e.underscore = 500;
          e.quoteleft = 333;
          e.a = 444;
          e.b = 500;
          e.c = 444;
          e.d = 500;
          e.e = 444;
          e.f = 333;
          e.g = 500;
          e.h = 500;
          e.i = 278;
          e.j = 278;
          e.k = 500;
          e.l = 278;
          e.m = 778;
          e.n = 500;
          e.o = 500;
          e.p = 500;
          e.q = 500;
          e.r = 333;
          e.s = 389;
          e.t = 278;
          e.u = 500;
          e.v = 500;
          e.w = 722;
          e.x = 500;
          e.y = 500;
          e.z = 444;
          e.braceleft = 480;
          e.bar = 200;
          e.braceright = 480;
          e.asciitilde = 541;
          e.exclamdown = 333;
          e.cent = 500;
          e.sterling = 500;
          e.fraction = 167;
          e.yen = 500;
          e.florin = 500;
          e.section = 500;
          e.currency = 500;
          e.quotesingle = 180;
          e.quotedblleft = 444;
          e.guillemotleft = 500;
          e.guilsinglleft = 333;
          e.guilsinglright = 333;
          e.fi = 556;
          e.fl = 556;
          e.endash = 500;
          e.dagger = 500;
          e.daggerdbl = 500;
          e.periodcentered = 250;
          e.paragraph = 453;
          e.bullet = 350;
          e.quotesinglbase = 333;
          e.quotedblbase = 444;
          e.quotedblright = 444;
          e.guillemotright = 500;
          e.ellipsis = 1e3;
          e.perthousand = 1e3;
          e.questiondown = 444;
          e.grave = 333;
          e.acute = 333;
          e.circumflex = 333;
          e.tilde = 333;
          e.macron = 333;
          e.breve = 333;
          e.dotaccent = 333;
          e.dieresis = 333;
          e.ring = 333;
          e.cedilla = 333;
          e.hungarumlaut = 333;
          e.ogonek = 333;
          e.caron = 333;
          e.emdash = 1e3;
          e.AE = 889;
          e.ordfeminine = 276;
          e.Lslash = 611;
          e.Oslash = 722;
          e.OE = 889;
          e.ordmasculine = 310;
          e.ae = 667;
          e.dotlessi = 278;
          e.lslash = 278;
          e.oslash = 500;
          e.oe = 722;
          e.germandbls = 500;
          e.Idieresis = 333;
          e.eacute = 444;
          e.abreve = 444;
          e.uhungarumlaut = 500;
          e.ecaron = 444;
          e.Ydieresis = 722;
          e.divide = 564;
          e.Yacute = 722;
          e.Acircumflex = 722;
          e.aacute = 444;
          e.Ucircumflex = 722;
          e.yacute = 500;
          e.scommaaccent = 389;
          e.ecircumflex = 444;
          e.Uring = 722;
          e.Udieresis = 722;
          e.aogonek = 444;
          e.Uacute = 722;
          e.uogonek = 500;
          e.Edieresis = 611;
          e.Dcroat = 722;
          e.commaaccent = 250;
          e.copyright = 760;
          e.Emacron = 611;
          e.ccaron = 444;
          e.aring = 444;
          e.Ncommaaccent = 722;
          e.lacute = 278;
          e.agrave = 444;
          e.Tcommaaccent = 611;
          e.Cacute = 667;
          e.atilde = 444;
          e.Edotaccent = 611;
          e.scaron = 389;
          e.scedilla = 389;
          e.iacute = 278;
          e.lozenge = 471;
          e.Rcaron = 667;
          e.Gcommaaccent = 722;
          e.ucircumflex = 500;
          e.acircumflex = 444;
          e.Amacron = 722;
          e.rcaron = 333;
          e.ccedilla = 444;
          e.Zdotaccent = 611;
          e.Thorn = 556;
          e.Omacron = 722;
          e.Racute = 667;
          e.Sacute = 556;
          e.dcaron = 588;
          e.Umacron = 722;
          e.uring = 500;
          e.threesuperior = 300;
          e.Ograve = 722;
          e.Agrave = 722;
          e.Abreve = 722;
          e.multiply = 564;
          e.uacute = 500;
          e.Tcaron = 611;
          e.partialdiff = 476;
          e.ydieresis = 500;
          e.Nacute = 722;
          e.icircumflex = 278;
          e.Ecircumflex = 611;
          e.adieresis = 444;
          e.edieresis = 444;
          e.cacute = 444;
          e.nacute = 500;
          e.umacron = 500;
          e.Ncaron = 722;
          e.Iacute = 333;
          e.plusminus = 564;
          e.brokenbar = 200;
          e.registered = 760;
          e.Gbreve = 722;
          e.Idotaccent = 333;
          e.summation = 600;
          e.Egrave = 611;
          e.racute = 333;
          e.omacron = 500;
          e.Zacute = 611;
          e.Zcaron = 611;
          e.greaterequal = 549;
          e.Eth = 722;
          e.Ccedilla = 667;
          e.lcommaaccent = 278;
          e.tcaron = 326;
          e.eogonek = 444;
          e.Uogonek = 722;
          e.Aacute = 722;
          e.Adieresis = 722;
          e.egrave = 444;
          e.zacute = 444;
          e.iogonek = 278;
          e.Oacute = 722;
          e.oacute = 500;
          e.amacron = 444;
          e.sacute = 389;
          e.idieresis = 278;
          e.Ocircumflex = 722;
          e.Ugrave = 722;
          e.Delta = 612;
          e.thorn = 500;
          e.twosuperior = 300;
          e.Odieresis = 722;
          e.mu = 500;
          e.igrave = 278;
          e.ohungarumlaut = 500;
          e.Eogonek = 611;
          e.dcroat = 500;
          e.threequarters = 750;
          e.Scedilla = 556;
          e.lcaron = 344;
          e.Kcommaaccent = 722;
          e.Lacute = 611;
          e.trademark = 980;
          e.edotaccent = 444;
          e.Igrave = 333;
          e.Imacron = 333;
          e.Lcaron = 611;
          e.onehalf = 750;
          e.lessequal = 549;
          e.ocircumflex = 500;
          e.ntilde = 500;
          e.Uhungarumlaut = 722;
          e.Eacute = 611;
          e.emacron = 444;
          e.gbreve = 500;
          e.onequarter = 750;
          e.Scaron = 556;
          e.Scommaaccent = 556;
          e.Ohungarumlaut = 722;
          e.degree = 400;
          e.ograve = 500;
          e.Ccaron = 667;
          e.ugrave = 500;
          e.radical = 453;
          e.Dcaron = 722;
          e.rcommaaccent = 333;
          e.Ntilde = 722;
          e.otilde = 500;
          e.Rcommaaccent = 667;
          e.Lcommaaccent = 611;
          e.Atilde = 722;
          e.Aogonek = 722;
          e.Aring = 722;
          e.Otilde = 722;
          e.zdotaccent = 444;
          e.Ecaron = 611;
          e.Iogonek = 333;
          e.kcommaaccent = 500;
          e.minus = 564;
          e.Icircumflex = 333;
          e.ncaron = 500;
          e.tcommaaccent = 278;
          e.logicalnot = 564;
          e.odieresis = 500;
          e.udieresis = 500;
          e.notequal = 549;
          e.gcommaaccent = 500;
          e.eth = 500;
          e.zcaron = 444;
          e.ncommaaccent = 500;
          e.onesuperior = 300;
          e.imacron = 278;
          e.Euro = 500;
        });
        e["Times-Bold"] = r.getLookupTableFactory(function (e) {
          e.space = 250;
          e.exclam = 333;
          e.quotedbl = 555;
          e.numbersign = 500;
          e.dollar = 500;
          e.percent = 1e3;
          e.ampersand = 833;
          e.quoteright = 333;
          e.parenleft = 333;
          e.parenright = 333;
          e.asterisk = 500;
          e.plus = 570;
          e.comma = 250;
          e.hyphen = 333;
          e.period = 250;
          e.slash = 278;
          e.zero = 500;
          e.one = 500;
          e.two = 500;
          e.three = 500;
          e.four = 500;
          e.five = 500;
          e.six = 500;
          e.seven = 500;
          e.eight = 500;
          e.nine = 500;
          e.colon = 333;
          e.semicolon = 333;
          e.less = 570;
          e.equal = 570;
          e.greater = 570;
          e.question = 500;
          e.at = 930;
          e.A = 722;
          e.B = 667;
          e.C = 722;
          e.D = 722;
          e.E = 667;
          e.F = 611;
          e.G = 778;
          e.H = 778;
          e.I = 389;
          e.J = 500;
          e.K = 778;
          e.L = 667;
          e.M = 944;
          e.N = 722;
          e.O = 778;
          e.P = 611;
          e.Q = 778;
          e.R = 722;
          e.S = 556;
          e.T = 667;
          e.U = 722;
          e.V = 722;
          e.W = 1e3;
          e.X = 722;
          e.Y = 722;
          e.Z = 667;
          e.bracketleft = 333;
          e.backslash = 278;
          e.bracketright = 333;
          e.asciicircum = 581;
          e.underscore = 500;
          e.quoteleft = 333;
          e.a = 500;
          e.b = 556;
          e.c = 444;
          e.d = 556;
          e.e = 444;
          e.f = 333;
          e.g = 500;
          e.h = 556;
          e.i = 278;
          e.j = 333;
          e.k = 556;
          e.l = 278;
          e.m = 833;
          e.n = 556;
          e.o = 500;
          e.p = 556;
          e.q = 556;
          e.r = 444;
          e.s = 389;
          e.t = 333;
          e.u = 556;
          e.v = 500;
          e.w = 722;
          e.x = 500;
          e.y = 500;
          e.z = 444;
          e.braceleft = 394;
          e.bar = 220;
          e.braceright = 394;
          e.asciitilde = 520;
          e.exclamdown = 333;
          e.cent = 500;
          e.sterling = 500;
          e.fraction = 167;
          e.yen = 500;
          e.florin = 500;
          e.section = 500;
          e.currency = 500;
          e.quotesingle = 278;
          e.quotedblleft = 500;
          e.guillemotleft = 500;
          e.guilsinglleft = 333;
          e.guilsinglright = 333;
          e.fi = 556;
          e.fl = 556;
          e.endash = 500;
          e.dagger = 500;
          e.daggerdbl = 500;
          e.periodcentered = 250;
          e.paragraph = 540;
          e.bullet = 350;
          e.quotesinglbase = 333;
          e.quotedblbase = 500;
          e.quotedblright = 500;
          e.guillemotright = 500;
          e.ellipsis = 1e3;
          e.perthousand = 1e3;
          e.questiondown = 500;
          e.grave = 333;
          e.acute = 333;
          e.circumflex = 333;
          e.tilde = 333;
          e.macron = 333;
          e.breve = 333;
          e.dotaccent = 333;
          e.dieresis = 333;
          e.ring = 333;
          e.cedilla = 333;
          e.hungarumlaut = 333;
          e.ogonek = 333;
          e.caron = 333;
          e.emdash = 1e3;
          e.AE = 1e3;
          e.ordfeminine = 300;
          e.Lslash = 667;
          e.Oslash = 778;
          e.OE = 1e3;
          e.ordmasculine = 330;
          e.ae = 722;
          e.dotlessi = 278;
          e.lslash = 278;
          e.oslash = 500;
          e.oe = 722;
          e.germandbls = 556;
          e.Idieresis = 389;
          e.eacute = 444;
          e.abreve = 500;
          e.uhungarumlaut = 556;
          e.ecaron = 444;
          e.Ydieresis = 722;
          e.divide = 570;
          e.Yacute = 722;
          e.Acircumflex = 722;
          e.aacute = 500;
          e.Ucircumflex = 722;
          e.yacute = 500;
          e.scommaaccent = 389;
          e.ecircumflex = 444;
          e.Uring = 722;
          e.Udieresis = 722;
          e.aogonek = 500;
          e.Uacute = 722;
          e.uogonek = 556;
          e.Edieresis = 667;
          e.Dcroat = 722;
          e.commaaccent = 250;
          e.copyright = 747;
          e.Emacron = 667;
          e.ccaron = 444;
          e.aring = 500;
          e.Ncommaaccent = 722;
          e.lacute = 278;
          e.agrave = 500;
          e.Tcommaaccent = 667;
          e.Cacute = 722;
          e.atilde = 500;
          e.Edotaccent = 667;
          e.scaron = 389;
          e.scedilla = 389;
          e.iacute = 278;
          e.lozenge = 494;
          e.Rcaron = 722;
          e.Gcommaaccent = 778;
          e.ucircumflex = 556;
          e.acircumflex = 500;
          e.Amacron = 722;
          e.rcaron = 444;
          e.ccedilla = 444;
          e.Zdotaccent = 667;
          e.Thorn = 611;
          e.Omacron = 778;
          e.Racute = 722;
          e.Sacute = 556;
          e.dcaron = 672;
          e.Umacron = 722;
          e.uring = 556;
          e.threesuperior = 300;
          e.Ograve = 778;
          e.Agrave = 722;
          e.Abreve = 722;
          e.multiply = 570;
          e.uacute = 556;
          e.Tcaron = 667;
          e.partialdiff = 494;
          e.ydieresis = 500;
          e.Nacute = 722;
          e.icircumflex = 278;
          e.Ecircumflex = 667;
          e.adieresis = 500;
          e.edieresis = 444;
          e.cacute = 444;
          e.nacute = 556;
          e.umacron = 556;
          e.Ncaron = 722;
          e.Iacute = 389;
          e.plusminus = 570;
          e.brokenbar = 220;
          e.registered = 747;
          e.Gbreve = 778;
          e.Idotaccent = 389;
          e.summation = 600;
          e.Egrave = 667;
          e.racute = 444;
          e.omacron = 500;
          e.Zacute = 667;
          e.Zcaron = 667;
          e.greaterequal = 549;
          e.Eth = 722;
          e.Ccedilla = 722;
          e.lcommaaccent = 278;
          e.tcaron = 416;
          e.eogonek = 444;
          e.Uogonek = 722;
          e.Aacute = 722;
          e.Adieresis = 722;
          e.egrave = 444;
          e.zacute = 444;
          e.iogonek = 278;
          e.Oacute = 778;
          e.oacute = 500;
          e.amacron = 500;
          e.sacute = 389;
          e.idieresis = 278;
          e.Ocircumflex = 778;
          e.Ugrave = 722;
          e.Delta = 612;
          e.thorn = 556;
          e.twosuperior = 300;
          e.Odieresis = 778;
          e.mu = 556;
          e.igrave = 278;
          e.ohungarumlaut = 500;
          e.Eogonek = 667;
          e.dcroat = 556;
          e.threequarters = 750;
          e.Scedilla = 556;
          e.lcaron = 394;
          e.Kcommaaccent = 778;
          e.Lacute = 667;
          e.trademark = 1e3;
          e.edotaccent = 444;
          e.Igrave = 389;
          e.Imacron = 389;
          e.Lcaron = 667;
          e.onehalf = 750;
          e.lessequal = 549;
          e.ocircumflex = 500;
          e.ntilde = 556;
          e.Uhungarumlaut = 722;
          e.Eacute = 667;
          e.emacron = 444;
          e.gbreve = 500;
          e.onequarter = 750;
          e.Scaron = 556;
          e.Scommaaccent = 556;
          e.Ohungarumlaut = 778;
          e.degree = 400;
          e.ograve = 500;
          e.Ccaron = 722;
          e.ugrave = 556;
          e.radical = 549;
          e.Dcaron = 722;
          e.rcommaaccent = 444;
          e.Ntilde = 722;
          e.otilde = 500;
          e.Rcommaaccent = 722;
          e.Lcommaaccent = 667;
          e.Atilde = 722;
          e.Aogonek = 722;
          e.Aring = 722;
          e.Otilde = 778;
          e.zdotaccent = 444;
          e.Ecaron = 667;
          e.Iogonek = 389;
          e.kcommaaccent = 556;
          e.minus = 570;
          e.Icircumflex = 389;
          e.ncaron = 556;
          e.tcommaaccent = 333;
          e.logicalnot = 570;
          e.odieresis = 500;
          e.udieresis = 556;
          e.notequal = 549;
          e.gcommaaccent = 500;
          e.eth = 500;
          e.zcaron = 444;
          e.ncommaaccent = 556;
          e.onesuperior = 300;
          e.imacron = 278;
          e.Euro = 500;
        });
        e["Times-BoldItalic"] = r.getLookupTableFactory(function (e) {
          e.space = 250;
          e.exclam = 389;
          e.quotedbl = 555;
          e.numbersign = 500;
          e.dollar = 500;
          e.percent = 833;
          e.ampersand = 778;
          e.quoteright = 333;
          e.parenleft = 333;
          e.parenright = 333;
          e.asterisk = 500;
          e.plus = 570;
          e.comma = 250;
          e.hyphen = 333;
          e.period = 250;
          e.slash = 278;
          e.zero = 500;
          e.one = 500;
          e.two = 500;
          e.three = 500;
          e.four = 500;
          e.five = 500;
          e.six = 500;
          e.seven = 500;
          e.eight = 500;
          e.nine = 500;
          e.colon = 333;
          e.semicolon = 333;
          e.less = 570;
          e.equal = 570;
          e.greater = 570;
          e.question = 500;
          e.at = 832;
          e.A = 667;
          e.B = 667;
          e.C = 667;
          e.D = 722;
          e.E = 667;
          e.F = 667;
          e.G = 722;
          e.H = 778;
          e.I = 389;
          e.J = 500;
          e.K = 667;
          e.L = 611;
          e.M = 889;
          e.N = 722;
          e.O = 722;
          e.P = 611;
          e.Q = 722;
          e.R = 667;
          e.S = 556;
          e.T = 611;
          e.U = 722;
          e.V = 667;
          e.W = 889;
          e.X = 667;
          e.Y = 611;
          e.Z = 611;
          e.bracketleft = 333;
          e.backslash = 278;
          e.bracketright = 333;
          e.asciicircum = 570;
          e.underscore = 500;
          e.quoteleft = 333;
          e.a = 500;
          e.b = 500;
          e.c = 444;
          e.d = 500;
          e.e = 444;
          e.f = 333;
          e.g = 500;
          e.h = 556;
          e.i = 278;
          e.j = 278;
          e.k = 500;
          e.l = 278;
          e.m = 778;
          e.n = 556;
          e.o = 500;
          e.p = 500;
          e.q = 500;
          e.r = 389;
          e.s = 389;
          e.t = 278;
          e.u = 556;
          e.v = 444;
          e.w = 667;
          e.x = 500;
          e.y = 444;
          e.z = 389;
          e.braceleft = 348;
          e.bar = 220;
          e.braceright = 348;
          e.asciitilde = 570;
          e.exclamdown = 389;
          e.cent = 500;
          e.sterling = 500;
          e.fraction = 167;
          e.yen = 500;
          e.florin = 500;
          e.section = 500;
          e.currency = 500;
          e.quotesingle = 278;
          e.quotedblleft = 500;
          e.guillemotleft = 500;
          e.guilsinglleft = 333;
          e.guilsinglright = 333;
          e.fi = 556;
          e.fl = 556;
          e.endash = 500;
          e.dagger = 500;
          e.daggerdbl = 500;
          e.periodcentered = 250;
          e.paragraph = 500;
          e.bullet = 350;
          e.quotesinglbase = 333;
          e.quotedblbase = 500;
          e.quotedblright = 500;
          e.guillemotright = 500;
          e.ellipsis = 1e3;
          e.perthousand = 1e3;
          e.questiondown = 500;
          e.grave = 333;
          e.acute = 333;
          e.circumflex = 333;
          e.tilde = 333;
          e.macron = 333;
          e.breve = 333;
          e.dotaccent = 333;
          e.dieresis = 333;
          e.ring = 333;
          e.cedilla = 333;
          e.hungarumlaut = 333;
          e.ogonek = 333;
          e.caron = 333;
          e.emdash = 1e3;
          e.AE = 944;
          e.ordfeminine = 266;
          e.Lslash = 611;
          e.Oslash = 722;
          e.OE = 944;
          e.ordmasculine = 300;
          e.ae = 722;
          e.dotlessi = 278;
          e.lslash = 278;
          e.oslash = 500;
          e.oe = 722;
          e.germandbls = 500;
          e.Idieresis = 389;
          e.eacute = 444;
          e.abreve = 500;
          e.uhungarumlaut = 556;
          e.ecaron = 444;
          e.Ydieresis = 611;
          e.divide = 570;
          e.Yacute = 611;
          e.Acircumflex = 667;
          e.aacute = 500;
          e.Ucircumflex = 722;
          e.yacute = 444;
          e.scommaaccent = 389;
          e.ecircumflex = 444;
          e.Uring = 722;
          e.Udieresis = 722;
          e.aogonek = 500;
          e.Uacute = 722;
          e.uogonek = 556;
          e.Edieresis = 667;
          e.Dcroat = 722;
          e.commaaccent = 250;
          e.copyright = 747;
          e.Emacron = 667;
          e.ccaron = 444;
          e.aring = 500;
          e.Ncommaaccent = 722;
          e.lacute = 278;
          e.agrave = 500;
          e.Tcommaaccent = 611;
          e.Cacute = 667;
          e.atilde = 500;
          e.Edotaccent = 667;
          e.scaron = 389;
          e.scedilla = 389;
          e.iacute = 278;
          e.lozenge = 494;
          e.Rcaron = 667;
          e.Gcommaaccent = 722;
          e.ucircumflex = 556;
          e.acircumflex = 500;
          e.Amacron = 667;
          e.rcaron = 389;
          e.ccedilla = 444;
          e.Zdotaccent = 611;
          e.Thorn = 611;
          e.Omacron = 722;
          e.Racute = 667;
          e.Sacute = 556;
          e.dcaron = 608;
          e.Umacron = 722;
          e.uring = 556;
          e.threesuperior = 300;
          e.Ograve = 722;
          e.Agrave = 667;
          e.Abreve = 667;
          e.multiply = 570;
          e.uacute = 556;
          e.Tcaron = 611;
          e.partialdiff = 494;
          e.ydieresis = 444;
          e.Nacute = 722;
          e.icircumflex = 278;
          e.Ecircumflex = 667;
          e.adieresis = 500;
          e.edieresis = 444;
          e.cacute = 444;
          e.nacute = 556;
          e.umacron = 556;
          e.Ncaron = 722;
          e.Iacute = 389;
          e.plusminus = 570;
          e.brokenbar = 220;
          e.registered = 747;
          e.Gbreve = 722;
          e.Idotaccent = 389;
          e.summation = 600;
          e.Egrave = 667;
          e.racute = 389;
          e.omacron = 500;
          e.Zacute = 611;
          e.Zcaron = 611;
          e.greaterequal = 549;
          e.Eth = 722;
          e.Ccedilla = 667;
          e.lcommaaccent = 278;
          e.tcaron = 366;
          e.eogonek = 444;
          e.Uogonek = 722;
          e.Aacute = 667;
          e.Adieresis = 667;
          e.egrave = 444;
          e.zacute = 389;
          e.iogonek = 278;
          e.Oacute = 722;
          e.oacute = 500;
          e.amacron = 500;
          e.sacute = 389;
          e.idieresis = 278;
          e.Ocircumflex = 722;
          e.Ugrave = 722;
          e.Delta = 612;
          e.thorn = 500;
          e.twosuperior = 300;
          e.Odieresis = 722;
          e.mu = 576;
          e.igrave = 278;
          e.ohungarumlaut = 500;
          e.Eogonek = 667;
          e.dcroat = 500;
          e.threequarters = 750;
          e.Scedilla = 556;
          e.lcaron = 382;
          e.Kcommaaccent = 667;
          e.Lacute = 611;
          e.trademark = 1e3;
          e.edotaccent = 444;
          e.Igrave = 389;
          e.Imacron = 389;
          e.Lcaron = 611;
          e.onehalf = 750;
          e.lessequal = 549;
          e.ocircumflex = 500;
          e.ntilde = 556;
          e.Uhungarumlaut = 722;
          e.Eacute = 667;
          e.emacron = 444;
          e.gbreve = 500;
          e.onequarter = 750;
          e.Scaron = 556;
          e.Scommaaccent = 556;
          e.Ohungarumlaut = 722;
          e.degree = 400;
          e.ograve = 500;
          e.Ccaron = 667;
          e.ugrave = 556;
          e.radical = 549;
          e.Dcaron = 722;
          e.rcommaaccent = 389;
          e.Ntilde = 722;
          e.otilde = 500;
          e.Rcommaaccent = 667;
          e.Lcommaaccent = 611;
          e.Atilde = 667;
          e.Aogonek = 667;
          e.Aring = 667;
          e.Otilde = 722;
          e.zdotaccent = 389;
          e.Ecaron = 667;
          e.Iogonek = 389;
          e.kcommaaccent = 500;
          e.minus = 606;
          e.Icircumflex = 389;
          e.ncaron = 556;
          e.tcommaaccent = 278;
          e.logicalnot = 606;
          e.odieresis = 500;
          e.udieresis = 556;
          e.notequal = 549;
          e.gcommaaccent = 500;
          e.eth = 500;
          e.zcaron = 389;
          e.ncommaaccent = 556;
          e.onesuperior = 300;
          e.imacron = 278;
          e.Euro = 500;
        });
        e["Times-Italic"] = r.getLookupTableFactory(function (e) {
          e.space = 250;
          e.exclam = 333;
          e.quotedbl = 420;
          e.numbersign = 500;
          e.dollar = 500;
          e.percent = 833;
          e.ampersand = 778;
          e.quoteright = 333;
          e.parenleft = 333;
          e.parenright = 333;
          e.asterisk = 500;
          e.plus = 675;
          e.comma = 250;
          e.hyphen = 333;
          e.period = 250;
          e.slash = 278;
          e.zero = 500;
          e.one = 500;
          e.two = 500;
          e.three = 500;
          e.four = 500;
          e.five = 500;
          e.six = 500;
          e.seven = 500;
          e.eight = 500;
          e.nine = 500;
          e.colon = 333;
          e.semicolon = 333;
          e.less = 675;
          e.equal = 675;
          e.greater = 675;
          e.question = 500;
          e.at = 920;
          e.A = 611;
          e.B = 611;
          e.C = 667;
          e.D = 722;
          e.E = 611;
          e.F = 611;
          e.G = 722;
          e.H = 722;
          e.I = 333;
          e.J = 444;
          e.K = 667;
          e.L = 556;
          e.M = 833;
          e.N = 667;
          e.O = 722;
          e.P = 611;
          e.Q = 722;
          e.R = 611;
          e.S = 500;
          e.T = 556;
          e.U = 722;
          e.V = 611;
          e.W = 833;
          e.X = 611;
          e.Y = 556;
          e.Z = 556;
          e.bracketleft = 389;
          e.backslash = 278;
          e.bracketright = 389;
          e.asciicircum = 422;
          e.underscore = 500;
          e.quoteleft = 333;
          e.a = 500;
          e.b = 500;
          e.c = 444;
          e.d = 500;
          e.e = 444;
          e.f = 278;
          e.g = 500;
          e.h = 500;
          e.i = 278;
          e.j = 278;
          e.k = 444;
          e.l = 278;
          e.m = 722;
          e.n = 500;
          e.o = 500;
          e.p = 500;
          e.q = 500;
          e.r = 389;
          e.s = 389;
          e.t = 278;
          e.u = 500;
          e.v = 444;
          e.w = 667;
          e.x = 444;
          e.y = 444;
          e.z = 389;
          e.braceleft = 400;
          e.bar = 275;
          e.braceright = 400;
          e.asciitilde = 541;
          e.exclamdown = 389;
          e.cent = 500;
          e.sterling = 500;
          e.fraction = 167;
          e.yen = 500;
          e.florin = 500;
          e.section = 500;
          e.currency = 500;
          e.quotesingle = 214;
          e.quotedblleft = 556;
          e.guillemotleft = 500;
          e.guilsinglleft = 333;
          e.guilsinglright = 333;
          e.fi = 500;
          e.fl = 500;
          e.endash = 500;
          e.dagger = 500;
          e.daggerdbl = 500;
          e.periodcentered = 250;
          e.paragraph = 523;
          e.bullet = 350;
          e.quotesinglbase = 333;
          e.quotedblbase = 556;
          e.quotedblright = 556;
          e.guillemotright = 500;
          e.ellipsis = 889;
          e.perthousand = 1e3;
          e.questiondown = 500;
          e.grave = 333;
          e.acute = 333;
          e.circumflex = 333;
          e.tilde = 333;
          e.macron = 333;
          e.breve = 333;
          e.dotaccent = 333;
          e.dieresis = 333;
          e.ring = 333;
          e.cedilla = 333;
          e.hungarumlaut = 333;
          e.ogonek = 333;
          e.caron = 333;
          e.emdash = 889;
          e.AE = 889;
          e.ordfeminine = 276;
          e.Lslash = 556;
          e.Oslash = 722;
          e.OE = 944;
          e.ordmasculine = 310;
          e.ae = 667;
          e.dotlessi = 278;
          e.lslash = 278;
          e.oslash = 500;
          e.oe = 667;
          e.germandbls = 500;
          e.Idieresis = 333;
          e.eacute = 444;
          e.abreve = 500;
          e.uhungarumlaut = 500;
          e.ecaron = 444;
          e.Ydieresis = 556;
          e.divide = 675;
          e.Yacute = 556;
          e.Acircumflex = 611;
          e.aacute = 500;
          e.Ucircumflex = 722;
          e.yacute = 444;
          e.scommaaccent = 389;
          e.ecircumflex = 444;
          e.Uring = 722;
          e.Udieresis = 722;
          e.aogonek = 500;
          e.Uacute = 722;
          e.uogonek = 500;
          e.Edieresis = 611;
          e.Dcroat = 722;
          e.commaaccent = 250;
          e.copyright = 760;
          e.Emacron = 611;
          e.ccaron = 444;
          e.aring = 500;
          e.Ncommaaccent = 667;
          e.lacute = 278;
          e.agrave = 500;
          e.Tcommaaccent = 556;
          e.Cacute = 667;
          e.atilde = 500;
          e.Edotaccent = 611;
          e.scaron = 389;
          e.scedilla = 389;
          e.iacute = 278;
          e.lozenge = 471;
          e.Rcaron = 611;
          e.Gcommaaccent = 722;
          e.ucircumflex = 500;
          e.acircumflex = 500;
          e.Amacron = 611;
          e.rcaron = 389;
          e.ccedilla = 444;
          e.Zdotaccent = 556;
          e.Thorn = 611;
          e.Omacron = 722;
          e.Racute = 611;
          e.Sacute = 500;
          e.dcaron = 544;
          e.Umacron = 722;
          e.uring = 500;
          e.threesuperior = 300;
          e.Ograve = 722;
          e.Agrave = 611;
          e.Abreve = 611;
          e.multiply = 675;
          e.uacute = 500;
          e.Tcaron = 556;
          e.partialdiff = 476;
          e.ydieresis = 444;
          e.Nacute = 667;
          e.icircumflex = 278;
          e.Ecircumflex = 611;
          e.adieresis = 500;
          e.edieresis = 444;
          e.cacute = 444;
          e.nacute = 500;
          e.umacron = 500;
          e.Ncaron = 667;
          e.Iacute = 333;
          e.plusminus = 675;
          e.brokenbar = 275;
          e.registered = 760;
          e.Gbreve = 722;
          e.Idotaccent = 333;
          e.summation = 600;
          e.Egrave = 611;
          e.racute = 389;
          e.omacron = 500;
          e.Zacute = 556;
          e.Zcaron = 556;
          e.greaterequal = 549;
          e.Eth = 722;
          e.Ccedilla = 667;
          e.lcommaaccent = 278;
          e.tcaron = 300;
          e.eogonek = 444;
          e.Uogonek = 722;
          e.Aacute = 611;
          e.Adieresis = 611;
          e.egrave = 444;
          e.zacute = 389;
          e.iogonek = 278;
          e.Oacute = 722;
          e.oacute = 500;
          e.amacron = 500;
          e.sacute = 389;
          e.idieresis = 278;
          e.Ocircumflex = 722;
          e.Ugrave = 722;
          e.Delta = 612;
          e.thorn = 500;
          e.twosuperior = 300;
          e.Odieresis = 722;
          e.mu = 500;
          e.igrave = 278;
          e.ohungarumlaut = 500;
          e.Eogonek = 611;
          e.dcroat = 500;
          e.threequarters = 750;
          e.Scedilla = 500;
          e.lcaron = 300;
          e.Kcommaaccent = 667;
          e.Lacute = 556;
          e.trademark = 980;
          e.edotaccent = 444;
          e.Igrave = 333;
          e.Imacron = 333;
          e.Lcaron = 611;
          e.onehalf = 750;
          e.lessequal = 549;
          e.ocircumflex = 500;
          e.ntilde = 500;
          e.Uhungarumlaut = 722;
          e.Eacute = 611;
          e.emacron = 444;
          e.gbreve = 500;
          e.onequarter = 750;
          e.Scaron = 500;
          e.Scommaaccent = 500;
          e.Ohungarumlaut = 722;
          e.degree = 400;
          e.ograve = 500;
          e.Ccaron = 667;
          e.ugrave = 500;
          e.radical = 453;
          e.Dcaron = 722;
          e.rcommaaccent = 389;
          e.Ntilde = 667;
          e.otilde = 500;
          e.Rcommaaccent = 611;
          e.Lcommaaccent = 556;
          e.Atilde = 611;
          e.Aogonek = 611;
          e.Aring = 611;
          e.Otilde = 722;
          e.zdotaccent = 389;
          e.Ecaron = 611;
          e.Iogonek = 333;
          e.kcommaaccent = 444;
          e.minus = 675;
          e.Icircumflex = 333;
          e.ncaron = 500;
          e.tcommaaccent = 278;
          e.logicalnot = 675;
          e.odieresis = 500;
          e.udieresis = 500;
          e.notequal = 549;
          e.gcommaaccent = 500;
          e.eth = 500;
          e.zcaron = 389;
          e.ncommaaccent = 500;
          e.onesuperior = 300;
          e.imacron = 278;
          e.Euro = 500;
        });
        e.ZapfDingbats = r.getLookupTableFactory(function (e) {
          e.space = 278;
          e.a1 = 974;
          e.a2 = 961;
          e.a202 = 974;
          e.a3 = 980;
          e.a4 = 719;
          e.a5 = 789;
          e.a119 = 790;
          e.a118 = 791;
          e.a117 = 690;
          e.a11 = 960;
          e.a12 = 939;
          e.a13 = 549;
          e.a14 = 855;
          e.a15 = 911;
          e.a16 = 933;
          e.a105 = 911;
          e.a17 = 945;
          e.a18 = 974;
          e.a19 = 755;
          e.a20 = 846;
          e.a21 = 762;
          e.a22 = 761;
          e.a23 = 571;
          e.a24 = 677;
          e.a25 = 763;
          e.a26 = 760;
          e.a27 = 759;
          e.a28 = 754;
          e.a6 = 494;
          e.a7 = 552;
          e.a8 = 537;
          e.a9 = 577;
          e.a10 = 692;
          e.a29 = 786;
          e.a30 = 788;
          e.a31 = 788;
          e.a32 = 790;
          e.a33 = 793;
          e.a34 = 794;
          e.a35 = 816;
          e.a36 = 823;
          e.a37 = 789;
          e.a38 = 841;
          e.a39 = 823;
          e.a40 = 833;
          e.a41 = 816;
          e.a42 = 831;
          e.a43 = 923;
          e.a44 = 744;
          e.a45 = 723;
          e.a46 = 749;
          e.a47 = 790;
          e.a48 = 792;
          e.a49 = 695;
          e.a50 = 776;
          e.a51 = 768;
          e.a52 = 792;
          e.a53 = 759;
          e.a54 = 707;
          e.a55 = 708;
          e.a56 = 682;
          e.a57 = 701;
          e.a58 = 826;
          e.a59 = 815;
          e.a60 = 789;
          e.a61 = 789;
          e.a62 = 707;
          e.a63 = 687;
          e.a64 = 696;
          e.a65 = 689;
          e.a66 = 786;
          e.a67 = 787;
          e.a68 = 713;
          e.a69 = 791;
          e.a70 = 785;
          e.a71 = 791;
          e.a72 = 873;
          e.a73 = 761;
          e.a74 = 762;
          e.a203 = 762;
          e.a75 = 759;
          e.a204 = 759;
          e.a76 = 892;
          e.a77 = 892;
          e.a78 = 788;
          e.a79 = 784;
          e.a81 = 438;
          e.a82 = 138;
          e.a83 = 277;
          e.a84 = 415;
          e.a97 = 392;
          e.a98 = 392;
          e.a99 = 668;
          e.a100 = 668;
          e.a89 = 390;
          e.a90 = 390;
          e.a93 = 317;
          e.a94 = 317;
          e.a91 = 276;
          e.a92 = 276;
          e.a205 = 509;
          e.a85 = 509;
          e.a206 = 410;
          e.a86 = 410;
          e.a87 = 234;
          e.a88 = 234;
          e.a95 = 334;
          e.a96 = 334;
          e.a101 = 732;
          e.a102 = 544;
          e.a103 = 544;
          e.a104 = 910;
          e.a106 = 667;
          e.a107 = 760;
          e.a108 = 760;
          e.a112 = 776;
          e.a111 = 595;
          e.a110 = 694;
          e.a109 = 626;
          e.a120 = 788;
          e.a121 = 788;
          e.a122 = 788;
          e.a123 = 788;
          e.a124 = 788;
          e.a125 = 788;
          e.a126 = 788;
          e.a127 = 788;
          e.a128 = 788;
          e.a129 = 788;
          e.a130 = 788;
          e.a131 = 788;
          e.a132 = 788;
          e.a133 = 788;
          e.a134 = 788;
          e.a135 = 788;
          e.a136 = 788;
          e.a137 = 788;
          e.a138 = 788;
          e.a139 = 788;
          e.a140 = 788;
          e.a141 = 788;
          e.a142 = 788;
          e.a143 = 788;
          e.a144 = 788;
          e.a145 = 788;
          e.a146 = 788;
          e.a147 = 788;
          e.a148 = 788;
          e.a149 = 788;
          e.a150 = 788;
          e.a151 = 788;
          e.a152 = 788;
          e.a153 = 788;
          e.a154 = 788;
          e.a155 = 788;
          e.a156 = 788;
          e.a157 = 788;
          e.a158 = 788;
          e.a159 = 788;
          e.a160 = 894;
          e.a161 = 838;
          e.a163 = 1016;
          e.a164 = 458;
          e.a196 = 748;
          e.a165 = 924;
          e.a192 = 748;
          e.a166 = 918;
          e.a167 = 927;
          e.a168 = 928;
          e.a169 = 928;
          e.a170 = 834;
          e.a171 = 873;
          e.a172 = 828;
          e.a173 = 924;
          e.a162 = 924;
          e.a174 = 917;
          e.a175 = 930;
          e.a176 = 931;
          e.a177 = 463;
          e.a178 = 883;
          e.a179 = 836;
          e.a193 = 836;
          e.a180 = 867;
          e.a199 = 867;
          e.a181 = 696;
          e.a200 = 696;
          e.a182 = 874;
          e.a201 = 874;
          e.a183 = 760;
          e.a184 = 946;
          e.a197 = 771;
          e.a185 = 865;
          e.a194 = 771;
          e.a198 = 888;
          e.a186 = 967;
          e.a195 = 888;
          e.a187 = 831;
          e.a188 = 873;
          e.a189 = 927;
          e.a190 = 970;
          e.a191 = 918;
        });
      });
      t.getMetrics = i;
      let n = r.getLookupTableFactory(function (e) {
        e.Courier = {
          ascent: 629,
          descent: -157,
          capHeight: 562,
          xHeight: -426
        };
        e["Courier-Bold"] = {
          ascent: 629,
          descent: -157,
          capHeight: 562,
          xHeight: 439
        };
        e["Courier-Oblique"] = {
          ascent: 629,
          descent: -157,
          capHeight: 562,
          xHeight: 426
        };
        e["Courier-BoldOblique"] = {
          ascent: 629,
          descent: -157,
          capHeight: 562,
          xHeight: 426
        };
        e.Helvetica = {
          ascent: 718,
          descent: -207,
          capHeight: 718,
          xHeight: 523
        };
        e["Helvetica-Bold"] = {
          ascent: 718,
          descent: -207,
          capHeight: 718,
          xHeight: 532
        };
        e["Helvetica-Oblique"] = {
          ascent: 718,
          descent: -207,
          capHeight: 718,
          xHeight: 523
        };
        e["Helvetica-BoldOblique"] = {
          ascent: 718,
          descent: -207,
          capHeight: 718,
          xHeight: 532
        };
        e["Times-Roman"] = {
          ascent: 683,
          descent: -217,
          capHeight: 662,
          xHeight: 450
        };
        e["Times-Bold"] = {
          ascent: 683,
          descent: -217,
          capHeight: 676,
          xHeight: 461
        };
        e["Times-Italic"] = {
          ascent: 683,
          descent: -217,
          capHeight: 653,
          xHeight: 441
        };
        e["Times-BoldItalic"] = {
          ascent: 683,
          descent: -217,
          capHeight: 669,
          xHeight: 462
        };
        e.Symbol = {
          ascent: Math.NaN,
          descent: Math.NaN,
          capHeight: Math.NaN,
          xHeight: Math.NaN
        };
        e.ZapfDingbats = {
          ascent: Math.NaN,
          descent: Math.NaN,
          capHeight: Math.NaN,
          xHeight: Math.NaN
        };
      });
      t.getFontBasicMetrics = n;
    }, (e, t) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.GlyfTable = void 0;
      t.GlyfTable = class {
        constructor({
          glyfTable: e,
          isGlyphLocationsLong: t,
          locaTable: r,
          numGlyphs: i
        }) {
          this.glyphs = [];
          let n = new DataView(r.buffer, r.byteOffset, r.byteLength);
          let s = new DataView(e.buffer, e.byteOffset, e.byteLength);
          let o = t ? 4 : 2;
          let l = t ? n.getUint32(0) : 2 * n.getUint16(0);
          let c = 0;
          for (let e = 0; e < i; e++) {
            c += o;
            let e = t ? n.getUint32(c) : 2 * n.getUint16(c);
            if (e === l) {
              this.glyphs.push(new a({}));
              continue;
            }
            let r = a.parse(l, s);
            this.glyphs.push(r);
            l = e;
          }
        }
        getSize() {
          return this.glyphs.reduce((e, t) => e + (t.getSize() + 3 & -4), 0);
        }
        write() {
          let e = this.getSize();
          let t = new DataView(new ArrayBuffer(e));
          let a = e > 131070;
          let r = a ? 4 : 2;
          let i = new DataView(new ArrayBuffer((this.glyphs.length + 1) * r));
          a ? i.setUint32(0, 0) : i.setUint16(0, 0);
          let n = 0;
          let s = 0;
          for (let e of this.glyphs) {
            n += e.write(n, t);
            n = n + 3 & -4;
            s += r;
            a ? i.setUint32(s, n) : i.setUint16(s, n >> 1);
          }
          return {
            isLocationLong: a,
            loca: new Uint8Array(i.buffer),
            glyf: new Uint8Array(t.buffer)
          };
        }
        scale(e) {
          var _this3 = this;
          for (function () {
            let t = 0;
            let a = _this3.glyphs.length;
          }(); t < a; t++) this.glyphs[t].scale(e[t]);
        }
      };
      class a {
        constructor({
          header: e = null,
          simple: t = null,
          composites: a = null
        }) {
          this.header = e;
          this.simple = t;
          this.composites = a;
        }
        static parse(e, t) {
          let [i, o] = r.parse(e, t);
          if (e += i, o.numberOfContours < 0) {
            let r = [];
            for (; ;) {
              let [a, i] = s.parse(e, t);
              if (e += a, r.push(i), !(32 & i.flags)) break;
            }
            return new a({
              header: o,
              composites: r
            });
          }
          let l = n.parse(e, t, o.numberOfContours);
          return new a({
            header: o,
            simple: l
          });
        }
        getSize() {
          if (!this.header) return 0;
          let e = this.simple ? this.simple.getSize() : this.composites.reduce((e, t) => e + t.getSize(), 0);
          return this.header.getSize() + e;
        }
        write(e, t) {
          if (!this.header) return 0;
          let a = e;
          if (e += this.header.write(e, t), this.simple) e += this.simple.write(e, t); else for (let a of this.composites) e += a.write(e, t);
          return e - a;
        }
        scale(e) {
          if (!this.header) return;
          let t = (this.header.xMin + this.header.xMax) / 2;
          if (this.header.scale(t, e), this.simple) this.simple.scale(t, e); else for (let a of this.composites) a.scale(t, e);
        }
      }
      class r {
        constructor({
          numberOfContours: e,
          xMin: t,
          yMin: a,
          xMax: r,
          yMax: i
        }) {
          this.numberOfContours = e;
          this.xMin = t;
          this.yMin = a;
          this.xMax = r;
          this.yMax = i;
        }
        static parse(e, t) {
          return [10, new r({
            numberOfContours: t.getInt16(e),
            xMin: t.getInt16(e + 2),
            yMin: t.getInt16(e + 4),
            xMax: t.getInt16(e + 6),
            yMax: t.getInt16(e + 8)
          })];
        }
        getSize() {
          return 10;
        }
        write(e, t) {
          t.setInt16(e, this.numberOfContours);
          t.setInt16(e + 2, this.xMin);
          t.setInt16(e + 4, this.yMin);
          t.setInt16(e + 6, this.xMax);
          t.setInt16(e + 8, this.yMax);
          return 10;
        }
        scale(e, t) {
          this.xMin = Math.round(e + (this.xMin - e) * t);
          this.xMax = Math.round(e + (this.xMax - e) * t);
        }
      }
      class i {
        constructor({
          flags: e,
          xCoordinates: t,
          yCoordinates: a
        }) {
          this.xCoordinates = t;
          this.yCoordinates = a;
          this.flags = e;
        }
      }
      class n {
        constructor({
          contours: e,
          instructions: t
        }) {
          this.contours = e;
          this.instructions = t;
        }
        static parse(e, t, a) {
          let r = [];
          for (let i = 0; i < a; i++) {
            let a = t.getUint16(e);
            e += 2;
            r.push(a);
          }
          let s = r[a - 1] + 1;
          let o = t.getUint16(e);
          e += 2;
          let l = new Uint8Array(t).slice(e, e + o);
          e += o;
          let c = [];
          for (let a = 0; a < s; e++, a++) {
            let r = t.getUint8(e);
            if (c.push(r), 8 & r) {
              let i = t.getUint8(++e);
              r ^= 8;
              for (let e = 0; e < i; e++) c.push(r);
              a += i;
            }
          }
          let h = [];
          let u = [];
          let d = [];
          let f = [];
          let g = [];
          let p = 0;
          let m = 0;
          for (let a = 0; a < s; a++) {
            let i = c[a];
            if (2 & i) {
              let a = t.getUint8(e++);
              m += 16 & i ? a : -a;
              u.push(m);
            } else {
              16 & i || (m += t.getInt16(e), e += 2);
              u.push(m);
            }
            r[p] === a && (p++, h.push(u), u = []);
          }
          m = 0;
          p = 0;
          for (let a = 0; a < s; a++) {
            let n = c[a];
            if (4 & n) {
              let a = t.getUint8(e++);
              m += 32 & n ? a : -a;
              d.push(m);
            } else {
              32 & n || (m += t.getInt16(e), e += 2);
              d.push(m);
            }
            f.push(1 & n | 64 & n);
            r[p] === a && (u = h[p], p++, g.push(new i({
              flags: f,
              xCoordinates: u,
              yCoordinates: d
            })), d = [], f = []);
          }
          return new n({
            contours: g,
            instructions: l
          });
        }
        getSize() {
          let e = 2 * this.contours.length + 2 + this.instructions.length;
          let t = 0;
          let a = 0;
          for (let r of this.contours) {
            e += r.flags.length;
            for (function () {
              let i = 0;
              let n = r.xCoordinates.length;
            }(); i < n; i++) {
              let n = r.xCoordinates[i];
              let s = r.yCoordinates[i];
              let o = Math.abs(n - t);
              o > 255 ? e += 2 : o > 0 && (e += 1);
              t = n;
              (o = Math.abs(s - a)) > 255 ? e += 2 : o > 0 && (e += 1);
              a = s;
            }
          }
          return e;
        }
        write(e, t) {
          let a = e;
          let r = [];
          let i = [];
          let n = [];
          let s = 0;
          let o = 0;
          for (let a of this.contours) {
            for (function () {
              let e = 0;
              let t = a.xCoordinates.length;
            }(); e < t; e++) {
              let t = a.flags[e];
              let l = a.xCoordinates[e];
              let c = l - s;
              if (0 === c) {
                t |= 16;
                r.push(0);
              } else {
                let e = Math.abs(c);
                e <= 255 ? (t |= c >= 0 ? 18 : 2, r.push(e)) : r.push(c);
              }
              s = l;
              let h = a.yCoordinates[e];
              if (0 == (c = h - o)) {
                t |= 32;
                i.push(0);
              } else {
                let e = Math.abs(c);
                e <= 255 ? (t |= c >= 0 ? 36 : 4, i.push(e)) : i.push(c);
              }
              o = h;
              n.push(t);
            }
            t.setUint16(e, r.length - 1);
            e += 2;
          }
          for (let a of (t.setUint16(e, this.instructions.length), e += 2, this.instructions.length && (new Uint8Array(t.buffer, 0, t.buffer.byteLength).set(this.instructions, e), e += this.instructions.length), n)) t.setUint8(e++, a);
          for (function () {
            let a = 0;
            let i = r.length;
          }(); a < i; a++) {
            let i = r[a];
            let s = n[a];
            2 & s ? t.setUint8(e++, i) : 16 & s || (t.setInt16(e, i), e += 2);
          }
          for (function () {
            let a = 0;
            let r = i.length;
          }(); a < r; a++) {
            let r = i[a];
            let s = n[a];
            4 & s ? t.setUint8(e++, r) : 32 & s || (t.setInt16(e, r), e += 2);
          }
          return e - a;
        }
        scale(e, t) {
          for (let a of this.contours) if (0 !== a.xCoordinates.length) for (function () {
            let r = 0;
            let i = a.xCoordinates.length;
          }(); r < i; r++) a.xCoordinates[r] = Math.round(e + (a.xCoordinates[r] - e) * t);
        }
      }
      class s {
        constructor({
          flags: e,
          glyphIndex: t,
          argument1: a,
          argument2: r,
          transf: i,
          instructions: n
        }) {
          this.flags = e;
          this.glyphIndex = t;
          this.argument1 = a;
          this.argument2 = r;
          this.transf = i;
          this.instructions = n;
        }
        static parse(e, t) {
          let a;
          let r;
          let i = e;
          let n = [];
          let o = t.getUint16(e);
          let l = t.getUint16(e + 2);
          e += 4;
          1 & o ? (2 & o ? (a = t.getInt16(e), r = t.getInt16(e + 2)) : (a = t.getUint16(e), r = t.getUint16(e + 2)), e += 4, o ^= 1) : (2 & o ? (a = t.getInt8(e), r = t.getInt8(e + 1)) : (a = t.getUint8(e), r = t.getUint8(e + 1)), e += 2);
          8 & o ? (n.push(t.getUint16(e)), e += 2) : 64 & o ? (n.push(t.getUint16(e), t.getUint16(e + 2)), e += 4) : 128 & o && (n.push(t.getUint16(e), t.getUint16(e + 2), t.getUint16(e + 4), t.getUint16(e + 6)), e += 8);
          let c = null;
          if (256 & o) {
            let a = t.getUint16(e);
            e += 2;
            c = new Uint8Array(t).slice(e, e + a);
            e += a;
          }
          return [e - i, new s({
            flags: o,
            glyphIndex: l,
            argument1: a,
            argument2: r,
            transf: n,
            instructions: c
          })];
        }
        getSize() {
          let e = 4 + 2 * this.transf.length;
          256 & this.flags && (e += 2 + this.instructions.length);
          e += 2;
          2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (e += 2) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (e += 2);
          return e;
        }
        write(e, t) {
          let a = e;
          2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (this.flags |= 1) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (this.flags |= 1);
          t.setUint16(e, this.flags);
          t.setUint16(e + 2, this.glyphIndex);
          e += 4;
          1 & this.flags ? (2 & this.flags ? (t.setInt16(e, this.argument1), t.setInt16(e + 2, this.argument2)) : (t.setUint16(e, this.argument1), t.setUint16(e + 2, this.argument2)), e += 4) : (t.setUint8(e, this.argument1), t.setUint8(e + 1, this.argument2), e += 2);
          256 & this.flags && (t.setUint16(e, this.instructions.length), e += 2, this.instructions.length && (new Uint8Array(t.buffer, 0, t.buffer.byteLength).set(this.instructions, e), e += this.instructions.length));
          return e - a;
        }
        scale(e, t) { }
      }
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.OpenTypeFileBuilder = void 0;
      var r = a(8);
      var i = a(2);
      function n(e, t, a) {
        e[t] = a >> 8 & 255;
        e[t + 1] = 255 & a;
      }
      function s(e, t, a) {
        e[t] = a >> 24 & 255;
        e[t + 1] = a >> 16 & 255;
        e[t + 2] = a >> 8 & 255;
        e[t + 3] = 255 & a;
      }
      class o {
        constructor(e) {
          this.sfnt = e;
          this.tables = Object.create(null);
        }
        static getSearchParams(e, t) {
          let a = 1;
          let r = 0;
          for (; (a ^ e) > a;) {
            a <<= 1;
            r++;
          }
          let i = a * t;
          return {
            range: i,
            entry: r,
            rangeShift: t * e - i
          };
        }
        toArray() {
          let e;
          let t;
          let a;
          let l;
          let c;
          let h = this.sfnt;
          let u = this.tables;
          let d = Object.keys(u);
          d.sort();
          let f = d.length;
          let g = 12 + 16 * f;
          let p = [g];
          for (e = 0; e < f; e++) {
            g += ((l = u[d[e]]).length + 3 & -4) >>> 0;
            p.push(g);
          }
          let m = new Uint8Array(g);
          for (e = 0; e < f; e++) {
            l = u[d[e]];
            (function (e, t, a) {
              if (a instanceof Uint8Array) e.set(a, t); else if ("string" == typeof a) for (function () {
                let r = 0;
                let i = a.length;
              }(); r < i; r++) e[t++] = 255 & a.charCodeAt(r); else for (function () {
                let r = 0;
                let i = a.length;
              }(); r < i; r++) e[t++] = 255 & a[r];
            })(m, p[e], l);
          }
          "true" === h && (h = i.string32(65536));
          m[0] = 255 & h.charCodeAt(0);
          m[1] = 255 & h.charCodeAt(1);
          m[2] = 255 & h.charCodeAt(2);
          m[3] = 255 & h.charCodeAt(3);
          n(m, 4, f);
          let b = o.getSearchParams(f, 16);
          for (n(m, 6, b.range), n(m, 8, b.entry), n(m, 10, b.rangeShift), g = 12, e = 0; e < f; e++) {
            c = d[e];
            m[g] = 255 & c.charCodeAt(0);
            m[g + 1] = 255 & c.charCodeAt(1);
            m[g + 2] = 255 & c.charCodeAt(2);
            m[g + 3] = 255 & c.charCodeAt(3);
            let i = 0;
            for (t = p[e], a = p[e + 1]; t < a; t += 4) i = i + r.readUint32(m, t) >>> 0;
            s(m, g + 4, i);
            s(m, g + 8, p[e]);
            s(m, g + 12, u[c].length);
            g += 16;
          }
          return m;
        }
        addTable(e, t) {
          if (e in this.tables) throw Error("Table " + e + " already exists");
          this.tables[e] = t;
        }
      }
      t.OpenTypeFileBuilder = o;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.Type1Font = void 0;
      var r = a(45);
      var i = a(18);
      var n = a(8);
      var s = a(10);
      var o = a(55);
      var l = a(2);
      function c(e, t, a) {
        let r = e.length;
        let i = t.length;
        let s = r - i;
        let o = a;
        let l = !1;
        for (; o < s;) {
          let a = 0;
          for (; a < i && e[o + a] === t[a];) a++;
          if (a >= i) {
            for (o += a; o < r && n.isWhiteSpace(e[o]);) o++;
            l = !0;
            break;
          }
          o++;
        }
        return {
          found: l,
          length: o
        };
      }
      t.Type1Font = class {
        constructor(e, t, a) {
          let r = a.length1;
          a.length2;
          let n = t.peekBytes(6);
          let h = 128 === n[0] && 1 === n[1];
          h && (t.skip(6), r = n[5] << 24 | n[4] << 16 | n[3] << 8 | n[2]);
          let u = function (e, t) {
            let a;
            let r;
            let i;
            let n;
            let o = [101, 101, 120, 101, 99];
            let h = e.pos;
            try {
              r = (a = e.getBytes(t)).length;
            } catch (e) { }
            if (r === t && (i = c(a, o, t - 2 * o.length)).found && i.length === t) return {
              stream: new s.Stream(a),
              length: t
            };
            for (l.warn('Invalid "Length1" property in Type1 font -- trying to recover.'), e.pos = h; 0 !== (i = c(e.peekBytes(2048), o, 0)).length;) if (e.pos += i.length, i.found) {
              n = e.pos - h;
              break;
            }
            return (e.pos = h, n) ? {
              stream: new s.Stream(e.getBytes(n)),
              length: n
            } : (l.warn('Unable to recover "Length1" property in Type1 font -- using as is.'), {
              stream: new s.Stream(e.getBytes(t)),
              length: t
            });
          }(t, r);
          new o.Type1Parser(u.stream, !1, i.SEAC_ANALYSIS_ENABLED).extractFontHeader(a);
          h && ((n = t.getBytes(6))[5], n[4], n[3], n[2]);
          let d = function (e, t) {
            let a = e.getBytes();
            return {
              stream: new s.Stream(a),
              length: a.length
            };
          }(t, 0);
          let f = new o.Type1Parser(d.stream, !0, i.SEAC_ANALYSIS_ENABLED).extractFontProgram(a);
          for (let e in f.properties) a[e] = f.properties[e];
          let g = f.charstrings;
          let p = this.getType2Charstrings(g);
          let m = this.getType2Subrs(f.subrs);
          this.charstrings = g;
          this.data = this.wrap(e, p, this.charstrings, m, a);
          this.seacs = this.getSeacs(f.charstrings);
        }
        get numGlyphs() {
          return this.charstrings.length + 1;
        }
        getCharset() {
          let e = [".notdef"];
          let t = this.charstrings;
          for (let a = 0; a < t.length; a++) e.push(t[a].glyphName);
          return e;
        }
        getGlyphMapping(e) {
          let t;
          let a;
          let r = this.charstrings;
          if (e.composite) {
            let t = Object.create(null);
            for (function () {
              let a = 0;
              let i = r.length;
            }(); a < i; a++) t[e.cMap.charCodeOf(a)] = a + 1;
            return t;
          }
          let n = [".notdef"];
          for (a = 0; a < r.length; a++) n.push(r[a].glyphName);
          let s = e.builtInEncoding;
          if (s) for (let e in t = Object.create(null), s) (a = n.indexOf(s[e])) >= 0 && (t[e] = a);
          return i.type1FontGlyphMapping(e, t, n);
        }
        hasGlyphId(e) {
          return !(e < 0) && !(e >= this.numGlyphs) && (0 === e || this.charstrings[e - 1].charstring.length > 0);
        }
        getSeacs(e) {
          let t = [];
          for (function () {
            let a = 0;
            let r = e.length;
          }(); a < r; a++) {
            let r = e[a];
            r.seac && (t[a + 1] = r.seac);
          }
          return t;
        }
        getType2Charstrings(e) {
          let t = [];
          for (function () {
            let a = 0;
            let r = e.length;
          }(); a < r; a++) t.push(e[a].charstring);
          return t;
        }
        getType2Subrs(e) {
          let t;
          let a = 0;
          let r = e.length;
          a = r < 1133 ? 107 : r < 33769 ? 1131 : 32768;
          let i = [];
          for (t = 0; t < a; t++) i.push([11]);
          for (t = 0; t < r; t++) i.push(e[t]);
          return i;
        }
        wrap(e, t, a, i, n) {
          let s;
          let o;
          let l = new r.CFF();
          l.header = new r.CFFHeader(1, 0, 4, 4);
          l.names = [e];
          let c = new r.CFFTopDict();
          c.setByName("version", 391);
          c.setByName("Notice", 392);
          c.setByName("FullName", 393);
          c.setByName("FamilyName", 394);
          c.setByName("Weight", 395);
          c.setByName("Encoding", null);
          c.setByName("FontMatrix", n.fontMatrix);
          c.setByName("FontBBox", n.bbox);
          c.setByName("charset", null);
          c.setByName("CharStrings", null);
          c.setByName("Private", null);
          l.topDict = c;
          let h = new r.CFFStrings();
          h.add("Version 0.11");
          h.add("See original notice");
          h.add(e);
          h.add(e);
          h.add("Medium");
          l.strings = h;
          l.globalSubrIndex = new r.CFFIndex();
          let u = t.length;
          let d = [".notdef"];
          for (s = 0; s < u; s++) {
            let e = a[s].glyphName;
            -1 === r.CFFStandardStrings.indexOf(e) && h.add(e);
            d.push(e);
          }
          l.charset = new r.CFFCharset(!1, 0, d);
          let f = new r.CFFIndex();
          for (f.add([139, 14]), s = 0; s < u; s++) f.add(t[s]);
          l.charStrings = f;
          let g = new r.CFFPrivateDict();
          g.setByName("Subrs", null);
          let p = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
          for (s = 0, o = p.length; s < o; s++) {
            let e = p[s];
            if (!(e in n.privateData)) continue;
            let t = n.privateData[e];
            if (Array.isArray(t)) for (let e = t.length - 1; e > 0; e--) t[e] -= t[e - 1];
            g.setByName(e, t);
          }
          l.topDict.privateDict = g;
          let m = new r.CFFIndex();
          for (s = 0, o = i.length; s < o; s++) m.add(i[s]);
          g.subrsIndex = m;
          return new r.CFFCompiler(l).compile();
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.Type1Parser = void 0;
      var r = a(19);
      var i = a(8);
      var n = a(10);
      var s = a(2);
      let o = function () {
        let e = {
          vmoveto: [4],
          rlineto: [5],
          hlineto: [6],
          vlineto: [7],
          rrcurveto: [8],
          flex: [12, 35],
          endchar: [14],
          rmoveto: [21],
          hmoveto: [22],
          vhcurveto: [30],
          hvcurveto: [31]
        };
        return class {
          constructor() {
            this.width = 0;
            this.lsb = 0;
            this.flexing = !1;
            this.output = [];
            this.stack = [];
          }
          convert(t, a, r) {
            let i;
            let n;
            let o;
            let l = t.length;
            let c = !1;
            for (let h = 0; h < l; h++) {
              let l = t[h];
              if (l < 32) {
                switch (12 === l && (l = (l << 8) + t[++h]), l) {
                  case 1:
                  case 3:
                  case 9:
                  case 3072:
                  case 3105:
                  case 3073:
                  case 3074:
                    this.stack = [];
                    break;
                  case 4:
                    if (this.flexing) {
                      if (this.stack.length < 1) {
                        c = !0;
                        break;
                      }
                      let e = this.stack.pop();
                      this.stack.push(0, e);
                      break;
                    }
                    c = this.executeCommand(1, e.vmoveto);
                    break;
                  case 5:
                    c = this.executeCommand(2, e.rlineto);
                    break;
                  case 6:
                    c = this.executeCommand(1, e.hlineto);
                    break;
                  case 7:
                    c = this.executeCommand(1, e.vlineto);
                    break;
                  case 8:
                    c = this.executeCommand(6, e.rrcurveto);
                    break;
                  case 10:
                    if (this.stack.length < 1 || !a[o = this.stack.pop()]) {
                      c = !0;
                      break;
                    }
                    c = this.convert(a[o], a, r);
                    break;
                  case 11:
                    return c;
                  case 13:
                    if (this.stack.length < 2) {
                      c = !0;
                      break;
                    }
                    i = this.stack.pop();
                    n = this.stack.pop();
                    this.lsb = n;
                    this.width = i;
                    this.stack.push(i, n);
                    c = this.executeCommand(2, e.hmoveto);
                    break;
                  case 14:
                    this.output.push(e.endchar[0]);
                    break;
                  case 21:
                    if (this.flexing) break;
                    c = this.executeCommand(2, e.rmoveto);
                    break;
                  case 22:
                    if (this.flexing) {
                      this.stack.push(0);
                      break;
                    }
                    c = this.executeCommand(1, e.hmoveto);
                    break;
                  case 30:
                    c = this.executeCommand(4, e.vhcurveto);
                    break;
                  case 31:
                    c = this.executeCommand(4, e.hvcurveto);
                    break;
                  case 3078:
                    if (r) {
                      let t = this.stack[this.stack.length - 5];
                      this.seac = this.stack.splice(-4, 4);
                      this.seac[0] += this.lsb - t;
                      c = this.executeCommand(0, e.endchar);
                    } else c = this.executeCommand(4, e.endchar);
                    break;
                  case 3079:
                    if (this.stack.length < 4) {
                      c = !0;
                      break;
                    }
                    this.stack.pop();
                    i = this.stack.pop();
                    let u = this.stack.pop();
                    n = this.stack.pop();
                    this.lsb = n;
                    this.width = i;
                    this.stack.push(i, n, u);
                    c = this.executeCommand(3, e.rmoveto);
                    break;
                  case 3084:
                    if (this.stack.length < 2) {
                      c = !0;
                      break;
                    }
                    let d = this.stack.pop();
                    let f = this.stack.pop();
                    this.stack.push(f / d);
                    break;
                  case 3088:
                    if (this.stack.length < 2) {
                      c = !0;
                      break;
                    }
                    o = this.stack.pop();
                    let g = this.stack.pop();
                    if (0 === o && 3 === g) {
                      let t = this.stack.splice(this.stack.length - 17, 17);
                      this.stack.push(t[2] + t[0], t[3] + t[1], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14]);
                      c = this.executeCommand(13, e.flex, !0);
                      this.flexing = !1;
                      this.stack.push(t[15], t[16]);
                    } else 1 === o && 0 === g && (this.flexing = !0);
                    break;
                  case 3089:
                    break;
                  default:
                    s.warn('Unknown type 1 charstring command of "' + l + '"');
                }
                if (c) break;
                continue;
              }
              l <= 246 ? l -= 139 : l = l <= 250 ? (l - 247) * 256 + t[++h] + 108 : l <= 254 ? -((l - 251) * 256) - t[++h] - 108 : (255 & t[++h]) << 24 | (255 & t[++h]) << 16 | (255 & t[++h]) << 8 | (255 & t[++h]) << 0;
              this.stack.push(l);
            }
            return c;
          }
          executeCommand(e, t, a) {
            let r = this.stack.length;
            if (e > r) return !0;
            let i = r - e;
            for (let e = i; e < r; e++) {
              let t = this.stack[e];
              Number.isInteger(t) ? this.output.push(28, t >> 8 & 255, 255 & t) : (t = 65536 * t | 0, this.output.push(255, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t));
            }
            this.output.push.apply(this.output, t);
            a ? this.stack.splice(i, e) : this.stack.length = 0;
            return !1;
          }
        };
      }();
      let l = function () {
        function e(e) {
          return e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102;
        }
        function t(e, t, a) {
          if (a >= e.length) return new Uint8Array(0);
          let r = 0 | t;
          let i;
          let n;
          for (i = 0; i < a; i++) r = (e[i] + r) * 52845 + 22719 & 65535;
          let s = e.length - a;
          let o = new Uint8Array(s);
          for (i = a, n = 0; n < s; i++, n++) {
            let t = e[i];
            o[n] = t ^ r >> 8;
            r = (t + r) * 52845 + 22719 & 65535;
          }
          return o;
        }
        function a(e) {
          return 47 === e || 91 === e || 93 === e || 123 === e || 125 === e || 40 === e || 41 === e;
        }
        return class {
          constructor(a, r, s) {
            if (r) {
              let r = a.getBytes();
              let s = !((e(r[0]) || i.isWhiteSpace(r[0])) && e(r[1]) && e(r[2]) && e(r[3]) && e(r[4]) && e(r[5]) && e(r[6]) && e(r[7]));
              a = new n.Stream(s ? t(r, 55665, 4) : function (t, a, r) {
                let i;
                let n;
                let s = 55665;
                let o = t.length;
                let l = new Uint8Array(o >>> 1);
                for (i = 0, n = 0; i < o; i++) {
                  let a;
                  let r = t[i];
                  if (e(r)) {
                    for (i++; i < o && !e(a = t[i]);) i++;
                    if (i < o) {
                      let e = parseInt(String.fromCharCode(r, a), 16);
                      l[n++] = e ^ s >> 8;
                      s = (e + s) * 52845 + 22719 & 65535;
                    }
                  }
                }
                return l.slice(4, n);
              }(r, 0, 0));
            }
            this.seacAnalysisEnabled = !!s;
            this.stream = a;
            this.nextChar();
          }
          readNumberArray() {
            this.getToken();
            let e = [];
            for (; ;) {
              let t = this.getToken();
              if (null === t || "]" === t || "}" === t) break;
              e.push(parseFloat(t || 0));
            }
            return e;
          }
          readNumber() {
            return parseFloat(this.getToken() || 0);
          }
          readInt() {
            return 0 | parseInt(this.getToken() || 0, 10);
          }
          readBoolean() {
            return "true" === this.getToken() ? 1 : 0;
          }
          nextChar() {
            return this.currentChar = this.stream.getByte();
          }
          prevChar() {
            this.stream.skip(-2);
            return this.currentChar = this.stream.getByte();
          }
          getToken() {
            let e = !1;
            let t = this.currentChar;
            for (; ;) {
              if (-1 === t) return null;
              if (e) (10 === t || 13 === t) && (e = !1); else if (37 === t) e = !0; else if (!i.isWhiteSpace(t)) break;
              t = this.nextChar();
            }
            if (a(t)) {
              this.nextChar();
              return String.fromCharCode(t);
            }
            let r = "";
            do {
              r += String.fromCharCode(t);
              t = this.nextChar();
            } while (t >= 0 && !i.isWhiteSpace(t) && !a(t));
            return r;
          }
          readCharStrings(e, a) {
            return -1 === a ? e : t(e, 4330, a);
          }
          extractFontProgram(e) {
            let t;
            let a;
            let r;
            let i;
            let n;
            let s = this.stream;
            let l = [];
            let c = [];
            let h = Object.create(null);
            h.lenIV = 4;
            let u = {
              subrs: [],
              charstrings: [],
              properties: {
                privateData: h
              }
            };
            for (; null !== (t = this.getToken());) if ("/" === t) switch (t = this.getToken()) {
              case "CharStrings":
                for (this.getToken(), this.getToken(), this.getToken(), this.getToken(); null !== (t = this.getToken()) && "end" !== t;) {
                  if ("/" !== t) continue;
                  let e = this.getToken();
                  a = this.readInt();
                  this.getToken();
                  r = a > 0 ? s.getBytes(a) : new Uint8Array(0);
                  i = u.properties.privateData.lenIV;
                  n = this.readCharStrings(r, i);
                  this.nextChar();
                  "noaccess" === (t = this.getToken()) ? this.getToken() : "/" === t && this.prevChar();
                  c.push({
                    glyph: e,
                    encoded: n
                  });
                }
                break;
              case "Subrs":
                for (this.readInt(), this.getToken(); "dup" === this.getToken();) {
                  let e = this.readInt();
                  a = this.readInt();
                  this.getToken();
                  r = a > 0 ? s.getBytes(a) : new Uint8Array(0);
                  i = u.properties.privateData.lenIV;
                  n = this.readCharStrings(r, i);
                  this.nextChar();
                  "noaccess" === (t = this.getToken()) && this.getToken();
                  l[e] = n;
                }
                break;
              case "BlueValues":
              case "OtherBlues":
              case "FamilyBlues":
              case "FamilyOtherBlues":
                let e = this.readNumberArray();
                e.length > 0 && e.length;
                break;
              case "StemSnapH":
              case "StemSnapV":
                u.properties.privateData[t] = this.readNumberArray();
                break;
              case "StdHW":
              case "StdVW":
                u.properties.privateData[t] = this.readNumberArray()[0];
                break;
              case "BlueShift":
              case "lenIV":
              case "BlueFuzz":
              case "BlueScale":
              case "LanguageGroup":
              case "ExpansionFactor":
                u.properties.privateData[t] = this.readNumber();
                break;
              case "ForceBold":
                u.properties.privateData[t] = this.readBoolean();
            }
            for (let t = 0; t < c.length; t++) {
              let a = c[t].glyph;
              n = c[t].encoded;
              let r = new o();
              let i = r.convert(n, l, this.seacAnalysisEnabled);
              let s = r.output;
              i && (s = [14]);
              let h = {
                glyphName: a,
                charstring: s,
                width: r.width,
                lsb: r.lsb,
                seac: r.seac
              };
              if (".notdef" === a ? u.charstrings.unshift(h) : u.charstrings.push(h), e.builtInEncoding) {
                let t = e.builtInEncoding.indexOf(a);
                t > -1 && void 0 === e.widths[t] && t >= e.firstChar && t <= e.lastChar && (e.widths[t] = r.width);
              }
            }
            return u;
          }
          extractFontHeader(e) {
            let t;
            for (; null !== (t = this.getToken());) if ("/" === t) switch (t = this.getToken()) {
              case "FontMatrix":
                let a = this.readNumberArray();
                e.fontMatrix = a;
                break;
              case "Encoding":
                let i;
                let n = this.getToken();
                if (/^\d+$/.test(n)) {
                  i = [];
                  let e = 0 | parseInt(n, 10);
                  this.getToken();
                  for (let a = 0; a < e; a++) {
                    for (t = this.getToken(); "dup" !== t && "def" !== t;) if (null === (t = this.getToken())) return;
                    if ("def" === t) break;
                    let e = this.readInt();
                    this.getToken();
                    let a = this.getToken();
                    i[e] = a;
                    this.getToken();
                  }
                } else i = r.getEncoding(n);
                e.builtInEncoding = i;
                break;
              case "FontBBox":
                let s = this.readNumberArray();
                e.ascent = Math.max(s[3], s[1]);
                e.descent = Math.min(s[1], s[3]);
                e.ascentScaled = !0;
            }
          }
        };
      }();
      t.Type1Parser = l;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.Pattern = void 0;
      t.getTilingPatternIR = function (e, t, a) {
        let i = t.getArray("Matrix");
        let n = r.Util.normalizeRect(t.getArray("BBox"));
        let s = t.get("XStep");
        let o = t.get("YStep");
        let l = t.get("PaintType");
        let c = t.get("TilingType");
        if (n[2] - n[0] == 0 || n[3] - n[1] == 0) throw new r.FormatError(`Invalid getTilingPatternIR /BBox array: [${n}].`);
        return ["TilingPattern", a, e, i, n, s, o, l, c];
      };
      var r = a(2);
      var i = a(9);
      var n = a(24);
      var s = a(8);
      let o = {
        AXIAL: 2,
        RADIAL: 3,
        FREE_FORM_MESH: 4,
        LATTICE_FORM_MESH: 5,
        COONS_PATCH_MESH: 6,
        TENSOR_PATCH_MESH: 7
      };
      t.Pattern = class {
        constructor() {
          r.unreachable("Cannot initialize Pattern.");
        }
        static parseShading(e, t, a, n, l, h) {
          let u = e instanceof i.BaseStream ? e.dict : e;
          let g = u.get("ShadingType");
          try {
            switch (g) {
              case o.AXIAL:
              case o.RADIAL:
                return new c(u, t, a, l, h);
              case o.FREE_FORM_MESH:
              case o.LATTICE_FORM_MESH:
              case o.COONS_PATCH_MESH:
              case o.TENSOR_PATCH_MESH:
                return new d(e, t, a, l, h);
              default:
                throw new r.FormatError("Unsupported ShadingType: " + g);
            }
          } catch (e) {
            if (e instanceof s.MissingDataException) throw e;
            n.send("UnsupportedFeature", {
              featureId: r.UNSUPPORTED_FEATURES.shadingPattern
            });
            r.warn(e);
            return new f();
          }
        }
      };
      class l {
        static get SMALL_NUMBER() {
          return r.shadow(this, "SMALL_NUMBER", 1e-6);
        }
        constructor() {
          this.constructor === l && r.unreachable("Cannot initialize BaseShading.");
        }
        getIR() {
          r.unreachable("Abstract method `getIR` called.");
        }
      }
      class c extends l {
        constructor(e, t, a, i, s) {
          let c;
          super();
          this.coordsArr = e.getArray("Coords");
          this.shadingType = e.get("ShadingType");
          let h = n.ColorSpace.parse({
            cs: e.getRaw("CS") || e.getRaw("ColorSpace"),
            xref: t,
            resources: a,
            pdfFunctionFactory: i,
            localColorSpaceCache: s
          });
          let u = e.getArray("BBox");
          Array.isArray(u) && 4 === u.length ? this.bbox = r.Util.normalizeRect(u) : this.bbox = null;
          let d = 0;
          let f = 1;
          if (e.has("Domain")) {
            let t = e.getArray("Domain");
            d = t[0];
            f = t[1];
          }
          let g = !1;
          let p = !1;
          if (e.has("Extend")) {
            let t = e.getArray("Extend");
            g = t[0];
            p = t[1];
          }
          if (this.shadingType === o.RADIAL && (!g || !p)) {
            let [e, t, a, i, n, s] = this.coordsArr;
            let o = Math.hypot(e - i, t - n);
            a <= s + o && s <= a + o && r.warn("Unsupported radial gradient.");
          }
          this.extendStart = g;
          this.extendEnd = p;
          let m = e.getRaw("Function");
          let b = i.createFromArray(m);
          let y = (f - d) / 10;
          let w = this.colorStops = [];
          if (d >= f || y <= 0) {
            r.info("Bad shading domain.");
            return;
          }
          let x = new Float32Array(h.numComps);
          let S = new Float32Array(1);
          for (let e = 0; e <= 10; e++) {
            S[0] = d + e * y;
            b(S, 0, x, 0);
            c = h.getRgb(x, 0);
            let t = r.Util.makeHexColor(c[0], c[1], c[2]);
            w.push([e / 10, t]);
          }
          let k = "transparent";
          e.has("Background") && (c = h.getRgb(e.get("Background"), 0), k = r.Util.makeHexColor(c[0], c[1], c[2]));
          g || (w.unshift([0, k]), w[1][0] += l.SMALL_NUMBER);
          p || (w[w.length - 1][0] -= l.SMALL_NUMBER, w.push([1, k]));
          this.colorStops = w;
        }
        getIR() {
          let e;
          let t;
          let a;
          let i;
          let n;
          let s = this.coordsArr;
          let l = this.shadingType;
          l === o.AXIAL ? (t = [s[0], s[1]], a = [s[2], s[3]], i = null, n = null, e = "axial") : l === o.RADIAL ? (t = [s[0], s[1]], a = [s[3], s[4]], i = s[2], n = s[5], e = "radial") : r.unreachable(`getPattern type unknown: ${l}`);
          return ["RadialAxial", e, this.bbox, this.colorStops, t, a, i, n];
        }
      }
      class h {
        constructor(e, t) {
          this.stream = e;
          this.context = t;
          this.buffer = 0;
          this.bufferLength = 0;
          let a = t.numComps;
          this.tmpCompsBuf = new Float32Array(a);
          let r = t.colorSpace.numComps;
          this.tmpCsCompsBuf = t.colorFn ? new Float32Array(r) : this.tmpCompsBuf;
        }
        get hasData() {
          if (this.stream.end) return this.stream.pos < this.stream.end;
          if (this.bufferLength > 0) return !0;
          let e = this.stream.getByte();
          return !(e < 0) && (this.buffer = e, this.bufferLength = 8, !0);
        }
        readBits(e) {
          let t = this.buffer;
          let a = this.bufferLength;
          if (32 === e) {
            if (0 === a) return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
            t = t << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
            let e = this.stream.getByte();
            this.buffer = e & (1 << a) - 1;
            return (t << 8 - a | (255 & e) >> a) >>> 0;
          }
          if (8 === e && 0 === a) return this.stream.getByte();
          for (; a < e;) {
            t = t << 8 | this.stream.getByte();
            a += 8;
          }
          a -= e;
          this.bufferLength = a;
          this.buffer = t & (1 << a) - 1;
          return t >> a;
        }
        align() {
          this.buffer = 0;
          this.bufferLength = 0;
        }
        readFlag() {
          return this.readBits(this.context.bitsPerFlag);
        }
        readCoordinate() {
          let e = this.context.bitsPerCoordinate;
          let t = this.readBits(e);
          let a = this.readBits(e);
          let r = this.context.decode;
          let i = e < 32 ? 1 / ((1 << e) - 1) : 23283064365386963e-26;
          return [t * i * (r[1] - r[0]) + r[0], a * i * (r[3] - r[2]) + r[2]];
        }
        readComponents() {
          let e = this.context.numComps;
          let t = this.context.bitsPerComponent;
          let a = t < 32 ? 1 / ((1 << t) - 1) : 23283064365386963e-26;
          let r = this.context.decode;
          let i = this.tmpCompsBuf;
          for (function () {
            let n = 0;
            let s = 4;
          }(); n < e; n++, s += 2) {
            let e = this.readBits(t);
            i[n] = e * a * (r[s + 1] - r[s]) + r[s];
          }
          let n = this.tmpCsCompsBuf;
          this.context.colorFn && this.context.colorFn(i, 0, n, 0);
          return this.context.colorSpace.getRgb(n, 0);
        }
      }
      let u = function () {
        let e = [];
        return function (t) {
          e[t] || (e[t] = function (e) {
            let t = [];
            for (let a = 0; a <= e; a++) {
              let r = a / e;
              let i = 1 - r;
              t.push(new Float32Array([i * i * i, 3 * r * i * i, 3 * r * r * i, r * r * r]));
            }
            return t;
          }(t));
          return e[t];
        };
      }();
      class d extends l {
        static get MIN_SPLIT_PATCH_CHUNKS_AMOUNT() {
          return r.shadow(this, "MIN_SPLIT_PATCH_CHUNKS_AMOUNT", 3);
        }
        static get MAX_SPLIT_PATCH_CHUNKS_AMOUNT() {
          return r.shadow(this, "MAX_SPLIT_PATCH_CHUNKS_AMOUNT", 20);
        }
        static get TRIANGLE_DENSITY() {
          return r.shadow(this, "TRIANGLE_DENSITY", 20);
        }
        constructor(e, t, a, s, l) {
          var _this4;
          if (super(), _this4 = this, !(e instanceof i.BaseStream)) throw new r.FormatError("Mesh data is not a stream");
          let c = e.dict;
          this.shadingType = c.get("ShadingType");
          let u = c.getArray("BBox");
          Array.isArray(u) && 4 === u.length ? this.bbox = r.Util.normalizeRect(u) : this.bbox = null;
          let d = n.ColorSpace.parse({
            cs: c.getRaw("CS") || c.getRaw("ColorSpace"),
            xref: t,
            resources: a,
            pdfFunctionFactory: s,
            localColorSpaceCache: l
          });
          this.background = c.has("Background") ? d.getRgb(c.get("Background"), 0) : null;
          let f = c.getRaw("Function");
          let g = f ? s.createFromArray(f) : null;
          this.coords = [];
          this.colors = [];
          this.figures = [];
          let p = new h(e, {
            bitsPerCoordinate: c.get("BitsPerCoordinate"),
            bitsPerComponent: c.get("BitsPerComponent"),
            bitsPerFlag: c.get("BitsPerFlag"),
            decode: c.getArray("Decode"),
            colorFn: g,
            colorSpace: d,
            numComps: g ? 1 : d.numComps
          });
          let m = !1;
          switch (this.shadingType) {
            case o.FREE_FORM_MESH:
              this._decodeType4Shading(p);
              break;
            case o.LATTICE_FORM_MESH:
              let b = 0 | c.get("VerticesPerRow");
              if (b < 2) throw new r.FormatError("Invalid VerticesPerRow");
              this._decodeType5Shading(p, b);
              break;
            case o.COONS_PATCH_MESH:
              this._decodeType6Shading(p);
              m = !0;
              break;
            case o.TENSOR_PATCH_MESH:
              this._decodeType7Shading(p);
              m = !0;
              break;
            default:
              r.unreachable("Unsupported mesh type.");
          }
          if (m) {
            this._updateBounds();
            for (function () {
              let e = 0;
              let t = _this4.figures.length;
            }(); e < t; e++) this._buildFigureFromPatch(e);
          }
          this._updateBounds();
          this._packData();
        }
        _decodeType4Shading(e) {
          let t = this.coords;
          let a = this.colors;
          let i = [];
          let n = [];
          let s = 0;
          for (; e.hasData;) {
            let o = e.readFlag();
            let l = e.readCoordinate();
            let c = e.readComponents();
            if (0 === s) {
              if (!(0 <= o && o <= 2)) throw new r.FormatError("Unknown type4 flag");
              switch (o) {
                case 0:
                  s = 3;
                  break;
                case 1:
                  n.push(n[n.length - 2], n[n.length - 1]);
                  s = 1;
                  break;
                case 2:
                  n.push(n[n.length - 3], n[n.length - 1]);
                  s = 1;
              }
              i.push(o);
            }
            n.push(t.length);
            t.push(l);
            a.push(c);
            s--;
            e.align();
          }
          this.figures.push({
            type: "triangles",
            coords: new Int32Array(n),
            colors: new Int32Array(n)
          });
        }
        _decodeType5Shading(e, t) {
          let a = this.coords;
          let r = this.colors;
          let i = [];
          for (; e.hasData;) {
            let t = e.readCoordinate();
            let n = e.readComponents();
            i.push(a.length);
            a.push(t);
            r.push(n);
          }
          this.figures.push({
            type: "lattice",
            coords: new Int32Array(i),
            colors: new Int32Array(i),
            verticesPerRow: t
          });
        }
        _decodeType6Shading(e) {
          let t = this.coords;
          let a = this.colors;
          let i = new Int32Array(16);
          let n = new Int32Array(4);
          for (; e.hasData;) {
            let s;
            let o;
            let l;
            let c;
            let h = e.readFlag();
            if (!(0 <= h && h <= 3)) throw new r.FormatError("Unknown type6 flag");
            let u = t.length;
            for (function () {
              let a = 0;
              let r = 0 !== h ? 8 : 12;
            }(); a < r; a++) t.push(e.readCoordinate());
            let d = a.length;
            for (function () {
              let t = 0;
              let r = 0 !== h ? 2 : 4;
            }(); t < r; t++) a.push(e.readComponents());
            switch (h) {
              case 0:
                i[12] = u + 3;
                i[13] = u + 4;
                i[14] = u + 5;
                i[15] = u + 6;
                i[8] = u + 2;
                i[11] = u + 7;
                i[4] = u + 1;
                i[7] = u + 8;
                i[0] = u;
                i[1] = u + 11;
                i[2] = u + 10;
                i[3] = u + 9;
                n[2] = d + 1;
                n[3] = d + 2;
                n[0] = d;
                n[1] = d + 3;
                break;
              case 1:
                s = i[12];
                o = i[13];
                l = i[14];
                c = i[15];
                i[12] = c;
                i[13] = u + 0;
                i[14] = u + 1;
                i[15] = u + 2;
                i[8] = l;
                i[11] = u + 3;
                i[4] = o;
                i[7] = u + 4;
                i[0] = s;
                i[1] = u + 7;
                i[2] = u + 6;
                i[3] = u + 5;
                s = n[2];
                o = n[3];
                n[2] = o;
                n[3] = d;
                n[0] = s;
                n[1] = d + 1;
                break;
              case 2:
                s = i[15];
                o = i[11];
                i[12] = i[3];
                i[13] = u + 0;
                i[14] = u + 1;
                i[15] = u + 2;
                i[8] = i[7];
                i[11] = u + 3;
                i[4] = o;
                i[7] = u + 4;
                i[0] = s;
                i[1] = u + 7;
                i[2] = u + 6;
                i[3] = u + 5;
                s = n[3];
                n[2] = n[1];
                n[3] = d;
                n[0] = s;
                n[1] = d + 1;
                break;
              case 3:
                i[12] = i[0];
                i[13] = u + 0;
                i[14] = u + 1;
                i[15] = u + 2;
                i[8] = i[1];
                i[11] = u + 3;
                i[4] = i[2];
                i[7] = u + 4;
                i[0] = i[3];
                i[1] = u + 7;
                i[2] = u + 6;
                i[3] = u + 5;
                n[2] = n[0];
                n[3] = d;
                n[0] = n[1];
                n[1] = d + 1;
            }
            i[5] = t.length;
            t.push([(-4 * t[i[0]][0] - t[i[15]][0] + 6 * (t[i[4]][0] + t[i[1]][0]) - 2 * (t[i[12]][0] + t[i[3]][0]) + 3 * (t[i[13]][0] + t[i[7]][0])) / 9, (-4 * t[i[0]][1] - t[i[15]][1] + 6 * (t[i[4]][1] + t[i[1]][1]) - 2 * (t[i[12]][1] + t[i[3]][1]) + 3 * (t[i[13]][1] + t[i[7]][1])) / 9]);
            i[6] = t.length;
            t.push([(-4 * t[i[3]][0] - t[i[12]][0] + 6 * (t[i[2]][0] + t[i[7]][0]) - 2 * (t[i[0]][0] + t[i[15]][0]) + 3 * (t[i[4]][0] + t[i[14]][0])) / 9, (-4 * t[i[3]][1] - t[i[12]][1] + 6 * (t[i[2]][1] + t[i[7]][1]) - 2 * (t[i[0]][1] + t[i[15]][1]) + 3 * (t[i[4]][1] + t[i[14]][1])) / 9]);
            i[9] = t.length;
            t.push([(-4 * t[i[12]][0] - t[i[3]][0] + 6 * (t[i[8]][0] + t[i[13]][0]) - 2 * (t[i[0]][0] + t[i[15]][0]) + 3 * (t[i[11]][0] + t[i[1]][0])) / 9, (-4 * t[i[12]][1] - t[i[3]][1] + 6 * (t[i[8]][1] + t[i[13]][1]) - 2 * (t[i[0]][1] + t[i[15]][1]) + 3 * (t[i[11]][1] + t[i[1]][1])) / 9]);
            i[10] = t.length;
            t.push([(-4 * t[i[15]][0] - t[i[0]][0] + 6 * (t[i[11]][0] + t[i[14]][0]) - 2 * (t[i[12]][0] + t[i[3]][0]) + 3 * (t[i[2]][0] + t[i[8]][0])) / 9, (-4 * t[i[15]][1] - t[i[0]][1] + 6 * (t[i[11]][1] + t[i[14]][1]) - 2 * (t[i[12]][1] + t[i[3]][1]) + 3 * (t[i[2]][1] + t[i[8]][1])) / 9]);
            this.figures.push({
              type: "patch",
              coords: new Int32Array(i),
              colors: new Int32Array(n)
            });
          }
        }
        _decodeType7Shading(e) {
          let t = this.coords;
          let a = this.colors;
          let i = new Int32Array(16);
          let n = new Int32Array(4);
          for (; e.hasData;) {
            let s;
            let o;
            let l;
            let c;
            let h = e.readFlag();
            if (!(0 <= h && h <= 3)) throw new r.FormatError("Unknown type7 flag");
            let u = t.length;
            for (function () {
              let a = 0;
              let r = 0 !== h ? 12 : 16;
            }(); a < r; a++) t.push(e.readCoordinate());
            let d = a.length;
            for (function () {
              let t = 0;
              let r = 0 !== h ? 2 : 4;
            }(); t < r; t++) a.push(e.readComponents());
            switch (h) {
              case 0:
                i[12] = u + 3;
                i[13] = u + 4;
                i[14] = u + 5;
                i[15] = u + 6;
                i[8] = u + 2;
                i[9] = u + 13;
                i[10] = u + 14;
                i[11] = u + 7;
                i[4] = u + 1;
                i[5] = u + 12;
                i[6] = u + 15;
                i[7] = u + 8;
                i[0] = u;
                i[1] = u + 11;
                i[2] = u + 10;
                i[3] = u + 9;
                n[2] = d + 1;
                n[3] = d + 2;
                n[0] = d;
                n[1] = d + 3;
                break;
              case 1:
                s = i[12];
                o = i[13];
                l = i[14];
                c = i[15];
                i[12] = c;
                i[13] = u + 0;
                i[14] = u + 1;
                i[15] = u + 2;
                i[8] = l;
                i[9] = u + 9;
                i[10] = u + 10;
                i[11] = u + 3;
                i[4] = o;
                i[5] = u + 8;
                i[6] = u + 11;
                i[7] = u + 4;
                i[0] = s;
                i[1] = u + 7;
                i[2] = u + 6;
                i[3] = u + 5;
                s = n[2];
                o = n[3];
                n[2] = o;
                n[3] = d;
                n[0] = s;
                n[1] = d + 1;
                break;
              case 2:
                s = i[15];
                o = i[11];
                i[12] = i[3];
                i[13] = u + 0;
                i[14] = u + 1;
                i[15] = u + 2;
                i[8] = i[7];
                i[9] = u + 9;
                i[10] = u + 10;
                i[11] = u + 3;
                i[4] = o;
                i[5] = u + 8;
                i[6] = u + 11;
                i[7] = u + 4;
                i[0] = s;
                i[1] = u + 7;
                i[2] = u + 6;
                i[3] = u + 5;
                s = n[3];
                n[2] = n[1];
                n[3] = d;
                n[0] = s;
                n[1] = d + 1;
                break;
              case 3:
                i[12] = i[0];
                i[13] = u + 0;
                i[14] = u + 1;
                i[15] = u + 2;
                i[8] = i[1];
                i[9] = u + 9;
                i[10] = u + 10;
                i[11] = u + 3;
                i[4] = i[2];
                i[5] = u + 8;
                i[6] = u + 11;
                i[7] = u + 4;
                i[0] = i[3];
                i[1] = u + 7;
                i[2] = u + 6;
                i[3] = u + 5;
                n[2] = n[0];
                n[3] = d;
                n[0] = n[1];
                n[1] = d + 1;
            }
            this.figures.push({
              type: "patch",
              coords: new Int32Array(i),
              colors: new Int32Array(n)
            });
          }
        }
        _buildFigureFromPatch(e) {
          let t = this.figures[e];
          r.assert("patch" === t.type, "Unexpected patch mesh figure");
          let a = this.coords;
          let i = this.colors;
          let n = t.coords;
          let s = t.colors;
          let o = Math.min(a[n[0]][0], a[n[3]][0], a[n[12]][0], a[n[15]][0]);
          let l = Math.min(a[n[0]][1], a[n[3]][1], a[n[12]][1], a[n[15]][1]);
          let c = Math.max(a[n[0]][0], a[n[3]][0], a[n[12]][0], a[n[15]][0]);
          let h = Math.max(a[n[0]][1], a[n[3]][1], a[n[12]][1], a[n[15]][1]);
          let f = Math.ceil((c - o) * d.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
          f = Math.max(d.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(d.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, f));
          let g = Math.ceil((h - l) * d.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
          g = Math.max(d.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(d.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, g));
          let p = f + 1;
          let m = new Int32Array((g + 1) * p);
          let b = new Int32Array((g + 1) * p);
          let y = 0;
          let w = new Uint8Array(3);
          let x = new Uint8Array(3);
          let S = i[s[0]];
          let k = i[s[1]];
          let A = i[s[2]];
          let v = i[s[3]];
          let C = u(g);
          let O = u(f);
          for (let e = 0; e <= g; e++) {
            w[0] = (S[0] * (g - e) + A[0] * e) / g | 0;
            w[1] = (S[1] * (g - e) + A[1] * e) / g | 0;
            w[2] = (S[2] * (g - e) + A[2] * e) / g | 0;
            x[0] = (k[0] * (g - e) + v[0] * e) / g | 0;
            x[1] = (k[1] * (g - e) + v[1] * e) / g | 0;
            x[2] = (k[2] * (g - e) + v[2] * e) / g | 0;
            for (let t = 0; t <= f; t++, y++) {
              if ((0 === e || e === g) && (0 === t || t === f)) continue;
              let r = 0;
              let s = 0;
              let o = 0;
              for (let i = 0; i <= 3; i++) for (let l = 0; l <= 3; l++, o++) {
                let c = C[e][i] * O[t][l];
                r += a[n[o]][0] * c;
                s += a[n[o]][1] * c;
              }
              m[y] = a.length;
              a.push([r, s]);
              b[y] = i.length;
              let l = new Uint8Array(3);
              l[0] = (w[0] * (f - t) + x[0] * t) / f | 0;
              l[1] = (w[1] * (f - t) + x[1] * t) / f | 0;
              l[2] = (w[2] * (f - t) + x[2] * t) / f | 0;
              i.push(l);
            }
          }
          m[0] = n[0];
          b[0] = s[0];
          m[f] = n[3];
          b[f] = s[1];
          m[p * g] = n[12];
          b[p * g] = s[2];
          m[p * g + f] = n[15];
          b[p * g + f] = s[3];
          this.figures[e] = {
            type: "lattice",
            coords: m,
            colors: b,
            verticesPerRow: p
          };
        }
        _updateBounds() {
          var _this5 = this;
          let e = this.coords[0][0];
          let t = this.coords[0][1];
          let a = e;
          let r = t;
          for (function () {
            let i = 1;
            let n = _this5.coords.length;
          }(); i < n; i++) {
            let n = this.coords[i][0];
            let s = this.coords[i][1];
            e = e > n ? n : e;
            t = t > s ? s : t;
            a = a < n ? n : a;
            r = r < s ? s : r;
          }
          this.bounds = [e, t, a, r];
        }
        _packData() {
          let e;
          let t;
          let a;
          let r;
          let i = this.coords;
          let n = new Float32Array(2 * i.length);
          for (e = 0, a = 0, t = i.length; e < t; e++) {
            let t = i[e];
            n[a++] = t[0];
            n[a++] = t[1];
          }
          this.coords = n;
          let s = this.colors;
          let o = new Uint8Array(3 * s.length);
          for (e = 0, a = 0, t = s.length; e < t; e++) {
            let t = s[e];
            o[a++] = t[0];
            o[a++] = t[1];
            o[a++] = t[2];
          }
          this.colors = o;
          let l = this.figures;
          for (e = 0, t = l.length; e < t; e++) {
            let t = l[e];
            let i = t.coords;
            let n = t.colors;
            for (a = 0, r = i.length; a < r; a++) {
              i[a] *= 2;
              n[a] *= 3;
            }
          }
        }
        getIR() {
          return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, this.bounds, this.bbox, this.background];
        }
      }
      class f extends l {
        getIR() {
          return ["Dummy"];
        }
      }
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.PostScriptEvaluator = t.PostScriptCompiler = t.PDFFunctionFactory = void 0;
      t.isPDFFunction = function (e) {
        let t;
        if ("object" != typeof e) return !1;
        if (e instanceof r.Dict) t = e; else {
          if (!(e instanceof s.BaseStream)) return !1;
          t = e.dict;
        }
        return t.has("FunctionType");
      };
      var r = a(5);
      var i = a(2);
      var n = a(58);
      var s = a(9);
      var o = a(59);
      function l(e) {
        if (!Array.isArray(e)) return null;
        let t = e.length;
        for (let a = 0; a < t; a++) if ("number" != typeof e[a]) {
          let a = Array(t);
          for (let r = 0; r < t; r++) a[r] = +e[r];
          return a;
        }
        return e;
      }
      t.PDFFunctionFactory = class {
        constructor({
          xref: e,
          isEvalSupported: t = !0
        }) {
          this.xref = e;
          this.isEvalSupported = !1 !== t;
        }
        create(e) {
          let t = this.getCached(e);
          if (t) return t;
          let a = c.parse({
            xref: this.xref,
            isEvalSupported: this.isEvalSupported,
            fn: e instanceof r.Ref ? this.xref.fetch(e) : e
          });
          this._cache(e, a);
          return a;
        }
        createFromArray(e) {
          let t = this.getCached(e);
          if (t) return t;
          let a = c.parseArray({
            xref: this.xref,
            isEvalSupported: this.isEvalSupported,
            fnObj: e instanceof r.Ref ? this.xref.fetch(e) : e
          });
          this._cache(e, a);
          return a;
        }
        getCached(e) {
          let t;
          if (e instanceof r.Ref ? t = e : e instanceof r.Dict ? t = e.objId : e instanceof s.BaseStream && (t = e.dict && e.dict.objId), t) {
            let e = this._localFunctionCache.getByRef(t);
            if (e) return e;
          }
          return null;
        }
        _cache(e, t) {
          let a;
          if (!t) throw Error('PDFFunctionFactory._cache - expected "parsedFunction" argument.');
          e instanceof r.Ref ? a = e : e instanceof r.Dict ? a = e.objId : e instanceof s.BaseStream && (a = e.dict && e.dict.objId);
          a && this._localFunctionCache.set(null, a, t);
        }
        get _localFunctionCache() {
          return i.shadow(this, "_localFunctionCache", new o.LocalFunctionCache());
        }
      };
      class c {
        static getSampleArray(e, t, a, r) {
          let i;
          let n;
          let s = 1;
          for (i = 0, n = e.length; i < n; i++) s *= e[i];
          let o = Array(s *= t);
          let l = 0;
          let c = 0;
          let h = 1 / (2 ** a - 1);
          let u = r.getBytes((s * a + 7) / 8);
          let d = 0;
          for (i = 0; i < s; i++) {
            for (; l < a;) {
              c <<= 8;
              c |= u[d++];
              l += 8;
            }
            l -= a;
            o[i] = (c >> l) * h;
            c &= (1 << l) - 1;
          }
          return o;
        }
        static parse({
          xref: e,
          isEvalSupported: t,
          fn: a
        }) {
          let r = a.dict || a;
          switch (r.get("FunctionType")) {
            case 0:
              return this.constructSampled({
                xref: e,
                isEvalSupported: t,
                fn: a,
                dict: r
              });
            case 1:
              break;
            case 2:
              return this.constructInterpolated({
                xref: e,
                isEvalSupported: t,
                dict: r
              });
            case 3:
              return this.constructStiched({
                xref: e,
                isEvalSupported: t,
                dict: r
              });
            case 4:
              return this.constructPostScript({
                xref: e,
                isEvalSupported: t,
                fn: a,
                dict: r
              });
          }
          throw new i.FormatError("Unknown type of function");
        }
        static parseArray({
          xref: e,
          isEvalSupported: t,
          fnObj: a
        }) {
          if (!Array.isArray(a)) return this.parse({
            xref: e,
            isEvalSupported: t,
            fn: a
          });
          let r = [];
          for (function () {
            let i = 0;
            let n = a.length;
          }(); i < n; i++) r.push(this.parse({
            xref: e,
            isEvalSupported: t,
            fn: e.fetchIfRef(a[i])
          }));
          return function (e, t, a, i) {
            for (function () {
              let n = 0;
              let s = r.length;
            }(); n < s; n++) r[n](e, t, a, i + n);
          };
        }
        static constructSampled({
          xref: e,
          isEvalSupported: t,
          fn: a,
          dict: r
        }) {
          function n(e) {
            let t = e.length;
            let a = [];
            let r = 0;
            for (let i = 0; i < t; i += 2) a[r++] = [e[i], e[i + 1]];
            return a;
          }
          let s = l(r.getArray("Domain"));
          let o = l(r.getArray("Range"));
          if (!s || !o) throw new i.FormatError("No domain or range");
          let c = s.length / 2;
          let h = o.length / 2;
          s = n(s);
          o = n(o);
          let u = l(r.getArray("Size"));
          let d = r.get("BitsPerSample");
          let f = r.get("Order") || 1;
          1 !== f && i.info("No support for cubic spline interpolation: " + f);
          let g = l(r.getArray("Encode"));
          if (g) g = n(g); else {
            g = [];
            for (let e = 0; e < c; ++e) g.push([0, u[e] - 1]);
          }
          let p = l(r.getArray("Decode"));
          p = p ? n(p) : o;
          let m = this.getSampleArray(u, h, d, a);
          return function (e, t, a, r) {
            var i;
            var n;
            var l;
            var d;
            let f;
            let b;
            let y = 1 << c;
            let w = new Float64Array(y);
            let x = new Uint32Array(y);
            for (b = 0; b < y; b++) w[b] = 1;
            let S = h;
            let k = 1;
            for (f = 0; f < c; ++f) {
              let a = s[f][0];
              let r = s[f][1];
              i = Math.min(Math.max(e[t + f], a), r);
              let o = (n = g[f][0]) + (g[f][1] - n) / (r - a) * (i - a);
              let l = u[f];
              let c = (o = Math.min(Math.max(o, 0), l - 1)) < l - 1 ? Math.floor(o) : o - 1;
              let h = c + 1 - o;
              let d = o - c;
              let p = c * S;
              let m = p + S;
              for (b = 0; b < y; b++) b & k ? (w[b] *= d, x[b] += m) : (w[b] *= h, x[b] += p);
              S *= l;
              k <<= 1;
            }
            for (b = 0; b < h; ++b) {
              let e = 0;
              for (f = 0; f < y; f++) e += m[x[f] + b] * w[f];
              l = e;
              e = (d = p[b][0]) + (p[b][1] - d) / 1 * (l - 0);
              a[r + b] = Math.min(Math.max(e, o[b][0]), o[b][1]);
            }
          };
        }
        static constructInterpolated({
          xref: e,
          isEvalSupported: t,
          dict: a
        }) {
          let r = l(a.getArray("C0")) || [0];
          let i = l(a.getArray("C1")) || [1];
          let n = a.get("N");
          let s = [];
          for (function () {
            let e = 0;
            let t = r.length;
          }(); e < t; ++e) s.push(i[e] - r[e]);
          let o = s.length;
          return function (e, t, a, i) {
            let l = 1 === n ? e[t] : e[t] ** n;
            for (let e = 0; e < o; ++e) a[i + e] = r[e] + l * s[e];
          };
        }
        static constructStiched({
          xref: e,
          isEvalSupported: t,
          dict: a
        }) {
          let r = l(a.getArray("Domain"));
          if (!r) throw new i.FormatError("No domain");
          if (1 != r.length / 2) throw new i.FormatError("Bad domain for stiched function");
          let n = a.get("Functions");
          let s = [];
          for (function () {
            let a = 0;
            let r = n.length;
          }(); a < r; ++a) s.push(this.parse({
            xref: e,
            isEvalSupported: t,
            fn: e.fetchIfRef(n[a])
          }));
          let o = l(a.getArray("Bounds"));
          let c = l(a.getArray("Encode"));
          let h = new Float32Array(1);
          return function (e, t, a, i) {
            var n;
            var l;
            var u;
            let d;
            n = e[t];
            l = r[0];
            n > (u = r[1]) ? n = u : n < l && (n = l);
            let f = n;
            let g = o.length;
            for (d = 0; d < g && !(f < o[d]); ++d);
            let p = r[0];
            d > 0 && (p = o[d - 1]);
            let m = r[1];
            d < o.length && (m = o[d]);
            let b = c[2 * d];
            let y = c[2 * d + 1];
            h[0] = p === m ? b : b + (f - p) * (y - b) / (m - p);
            s[d](h, 0, a, i);
          };
        }
        static constructPostScript({
          xref: e,
          isEvalSupported: t,
          fn: a,
          dict: r
        }) {
          let s = l(r.getArray("Domain"));
          let o = l(r.getArray("Range"));
          if (!s) throw new i.FormatError("No domain.");
          if (!o) throw new i.FormatError("No range.");
          let c = new n.PostScriptLexer(a);
          let h = new n.PostScriptParser(c).parse();
          if (t && i.IsEvalSupportedCached.value) {
            let e = new d().compile(h, s, o);
            if (e) return Function("src", "srcOffset", "dest", "destOffset", e);
          }
          i.info("Unable to compile PS function");
          let f = o.length >> 1;
          let g = s.length >> 1;
          let p = new u(h);
          let m = Object.create(null);
          let b = 8192;
          let y = new Float32Array(g);
          return function (e, t, a, r) {
            let i;
            let n;
            let s = "";
            for (i = 0; i < g; i++) {
              n = e[t + i];
              y[i] = n;
              s += n + "_";
            }
            let l = m[s];
            if (void 0 !== l) {
              a.set(l, r);
              return;
            }
            let c = new Float32Array(f);
            let h = p.execute(y);
            let u = h.length - f;
            for (i = 0; i < f; i++) {
              n = h[u + i];
              let e = o[2 * i];
              n < e ? n = e : n > (e = o[2 * i + 1]) && (n = e);
              c[i] = n;
            }
            b > 0 && (b--, m[s] = c);
            a.set(c, r);
          };
        }
      }
      class h {
        static get MAX_STACK_SIZE() {
          return i.shadow(this, "MAX_STACK_SIZE", 100);
        }
        constructor(e) {
          this.stack = e ? Array.prototype.slice.call(e, 0) : [];
        }
        push(e) {
          if (this.stack.length >= h.MAX_STACK_SIZE) throw Error("PostScript function stack overflow.");
          this.stack.push(e);
        }
        pop() {
          if (this.stack.length <= 0) throw Error("PostScript function stack underflow.");
          return this.stack.pop();
        }
        copy(e) {
          if (this.stack.length + e >= h.MAX_STACK_SIZE) throw Error("PostScript function stack overflow.");
          let t = this.stack;
          for (function () {
            let a = t.length - e;
            let r = e - 1;
          }(); r >= 0; r--, a++) t.push(t[a]);
        }
        index(e) {
          this.push(this.stack[this.stack.length - e - 1]);
        }
        roll(e, t) {
          let a = this.stack;
          let r = a.length - e;
          let i = a.length - 1;
          let n = r + (t - Math.floor(t / e) * e);
          for (function () {
            let e = r;
            let t = i;
          }(); e < t; e++, t--) {
            let r = a[e];
            a[e] = a[t];
            a[t] = r;
          }
          for (function () {
            let e = r;
            let t = n - 1;
          }(); e < t; e++, t--) {
            let r = a[e];
            a[e] = a[t];
            a[t] = r;
          }
          for (function () {
            let e = n;
            let t = i;
          }(); e < t; e++, t--) {
            let r = a[e];
            a[e] = a[t];
            a[t] = r;
          }
        }
      }
      class u {
        constructor(e) {
          this.operators = e;
        }
        execute(e) {
          let t;
          let a;
          let r;
          let n = new h(e);
          let s = 0;
          let o = this.operators;
          let l = o.length;
          for (; s < l;) {
            if ("number" == typeof (t = o[s++])) {
              n.push(t);
              continue;
            }
            switch (t) {
              case "jz":
                r = n.pop();
                (a = n.pop()) || (s = r);
                break;
              case "j":
                s = a = n.pop();
                break;
              case "abs":
                a = n.pop();
                n.push(Math.abs(a));
                break;
              case "add":
                r = n.pop();
                a = n.pop();
                n.push(a + r);
                break;
              case "and":
                r = n.pop();
                "boolean" == typeof (a = n.pop()) && "boolean" == typeof r ? n.push(a && r) : n.push(a & r);
                break;
              case "atan":
                a = n.pop();
                n.push(Math.atan(a));
                break;
              case "bitshift":
                r = n.pop();
                (a = n.pop()) > 0 ? n.push(a << r) : n.push(a >> r);
                break;
              case "ceiling":
                a = n.pop();
                n.push(Math.ceil(a));
                break;
              case "copy":
                a = n.pop();
                n.copy(a);
                break;
              case "cos":
                a = n.pop();
                n.push(Math.cos(a));
                break;
              case "cvi":
                a = 0 | n.pop();
                n.push(a);
                break;
              case "cvr":
                break;
              case "div":
                r = n.pop();
                a = n.pop();
                n.push(a / r);
                break;
              case "dup":
                n.copy(1);
                break;
              case "eq":
                r = n.pop();
                a = n.pop();
                n.push(a === r);
                break;
              case "exch":
                n.roll(2, 1);
                break;
              case "exp":
                r = n.pop();
                a = n.pop();
                n.push(a ** r);
                break;
              case "false":
                n.push(!1);
                break;
              case "floor":
                a = n.pop();
                n.push(Math.floor(a));
                break;
              case "ge":
                r = n.pop();
                a = n.pop();
                n.push(a >= r);
                break;
              case "gt":
                r = n.pop();
                a = n.pop();
                n.push(a > r);
                break;
              case "idiv":
                r = n.pop();
                a = n.pop();
                n.push(a / r | 0);
                break;
              case "index":
                a = n.pop();
                n.index(a);
                break;
              case "le":
                r = n.pop();
                a = n.pop();
                n.push(a <= r);
                break;
              case "ln":
                a = n.pop();
                n.push(Math.log(a));
                break;
              case "log":
                a = n.pop();
                n.push(Math.log(a) / Math.LN10);
                break;
              case "lt":
                r = n.pop();
                a = n.pop();
                n.push(a < r);
                break;
              case "mod":
                r = n.pop();
                a = n.pop();
                n.push(a % r);
                break;
              case "mul":
                r = n.pop();
                a = n.pop();
                n.push(a * r);
                break;
              case "ne":
                r = n.pop();
                a = n.pop();
                n.push(a !== r);
                break;
              case "neg":
                a = n.pop();
                n.push(-a);
                break;
              case "not":
                "boolean" == typeof (a = n.pop()) ? n.push(!a) : n.push(~a);
                break;
              case "or":
                r = n.pop();
                "boolean" == typeof (a = n.pop()) && "boolean" == typeof r ? n.push(a || r) : n.push(a | r);
                break;
              case "pop":
                n.pop();
                break;
              case "roll":
                r = n.pop();
                a = n.pop();
                n.roll(a, r);
                break;
              case "round":
                a = n.pop();
                n.push(Math.round(a));
                break;
              case "sin":
                a = n.pop();
                n.push(Math.sin(a));
                break;
              case "sqrt":
                a = n.pop();
                n.push(Math.sqrt(a));
                break;
              case "sub":
                r = n.pop();
                a = n.pop();
                n.push(a - r);
                break;
              case "true":
                n.push(!0);
                break;
              case "truncate":
                a = (a = n.pop()) < 0 ? Math.ceil(a) : Math.floor(a);
                n.push(a);
                break;
              case "xor":
                r = n.pop();
                "boolean" == typeof (a = n.pop()) && "boolean" == typeof r ? n.push(a !== r) : n.push(a ^ r);
                break;
              default:
                throw new i.FormatError(`Unknown operator ${t}`);
            }
          }
          return n.stack;
        }
      }
      t.PostScriptEvaluator = u;
      let d = function () {
        class e {
          constructor(e) {
            this.type = e;
          }
          visit(e) {
            i.unreachable("abstract method");
          }
        }
        class t extends e {
          constructor(e, t, a) {
            super("args");
            this.index = e;
            this.min = t;
            this.max = a;
          }
          visit(e) {
            e.visitArgument(this);
          }
        }
        class a extends e {
          constructor(e) {
            super("literal");
            this.number = e;
            this.min = e;
            this.max = e;
          }
          visit(e) {
            e.visitLiteral(this);
          }
        }
        class r extends e {
          constructor(e, t, a, r, i) {
            super("binary");
            this.op = e;
            this.arg1 = t;
            this.arg2 = a;
            this.min = r;
            this.max = i;
          }
          visit(e) {
            e.visitBinaryOperation(this);
          }
        }
        class n extends e {
          constructor(e, t) {
            super("max");
            this.arg = e;
            this.min = e.min;
            this.max = t;
          }
          visit(e) {
            e.visitMin(this);
          }
        }
        class s extends e {
          constructor(e, t, a) {
            super("var");
            this.index = e;
            this.min = t;
            this.max = a;
          }
          visit(e) {
            e.visitVariable(this);
          }
        }
        class o extends e {
          constructor(e, t) {
            super("definition");
            this.variable = e;
            this.arg = t;
          }
          visit(e) {
            e.visitVariableDefinition(this);
          }
        }
        class l {
          constructor() {
            this.parts = [];
          }
          visitArgument(e) {
            this.parts.push("Math.max(", e.min, ", Math.min(", e.max, ", src[srcOffset + ", e.index, "]))");
          }
          visitVariable(e) {
            this.parts.push("v", e.index);
          }
          visitLiteral(e) {
            this.parts.push(e.number);
          }
          visitBinaryOperation(e) {
            this.parts.push("(");
            e.arg1.visit(this);
            this.parts.push(" ", e.op, " ");
            e.arg2.visit(this);
            this.parts.push(")");
          }
          visitVariableDefinition(e) {
            this.parts.push("var ");
            e.variable.visit(this);
            this.parts.push(" = ");
            e.arg.visit(this);
            this.parts.push(";");
          }
          visitMin(e) {
            this.parts.push("Math.min(");
            e.arg.visit(this);
            this.parts.push(", ", e.max, ")");
          }
          toString() {
            return this.parts.join("");
          }
        }
        return class {
          compile(e, i, c) {
            let h;
            let u;
            let d;
            let f;
            let g;
            let p;
            let m;
            let b;
            let y = [];
            let w = [];
            let x = i.length >> 1;
            let S = c.length >> 1;
            let k = 0;
            for (let e = 0; e < x; e++) y.push(new t(e, i[2 * e], i[2 * e + 1]));
            for (function () {
              let t = 0;
              let i = e.length;
            }(); t < i; t++) {
              var A;
              var v;
              var C;
              var O;
              if ("number" == typeof (b = e[t])) {
                y.push(new a(b));
                continue;
              }
              switch (b) {
                case "add":
                  if (y.length < 2) return null;
                  f = y.pop();
                  d = y.pop();
                  y.push((A = d, "literal" === (v = f).type && 0 === v.number ? A : "literal" === A.type && 0 === A.number ? v : "literal" === v.type && "literal" === A.type ? new a(A.number + v.number) : new r("+", A, v, A.min + v.min, A.max + v.max)));
                  break;
                case "cvr":
                  if (y.length < 1) return null;
                  break;
                case "mul":
                  if (y.length < 2) return null;
                  f = y.pop();
                  d = y.pop();
                  y.push(function (e, t) {
                    if ("literal" === t.type) {
                      if (0 === t.number) return new a(0);
                      if (1 === t.number) return e;
                      if ("literal" === e.type) return new a(e.number * t.number);
                    }
                    if ("literal" === e.type) {
                      if (0 === e.number) return new a(0);
                      if (1 === e.number) return t;
                    }
                    let i = Math.min(e.min * t.min, e.min * t.max, e.max * t.min, e.max * t.max);
                    let n = Math.max(e.min * t.min, e.min * t.max, e.max * t.min, e.max * t.max);
                    return new r("*", e, t, i, n);
                  }(d, f));
                  break;
                case "sub":
                  if (y.length < 2) return null;
                  f = y.pop();
                  d = y.pop();
                  y.push(function (e, t) {
                    if ("literal" === t.type) {
                      if (0 === t.number) return e;
                      if ("literal" === e.type) return new a(e.number - t.number);
                    }
                    return "binary" === t.type && "-" === t.op && "literal" === e.type && 1 === e.number && "literal" === t.arg1.type && 1 === t.arg1.number ? t.arg2 : new r("-", e, t, e.min - t.max, e.max - t.min);
                  }(d, f));
                  break;
                case "exch":
                  if (y.length < 2) return null;
                  g = y.pop();
                  p = y.pop();
                  y.push(g, p);
                  break;
                case "pop":
                  if (y.length < 1) return null;
                  y.pop();
                  break;
                case "index":
                  if (y.length < 1 || "literal" !== (d = y.pop()).type || (h = d.number) < 0 || !Number.isInteger(h) || y.length < h) return null;
                  if ("literal" === (g = y[y.length - h - 1]).type || "var" === g.type) {
                    y.push(g);
                    break;
                  }
                  m = new s(k++, g.min, g.max);
                  y[y.length - h - 1] = m;
                  y.push(m);
                  w.push(new o(m, g));
                  break;
                case "dup":
                  if (y.length < 1) return null;
                  if ("number" == typeof e[t + 1] && "gt" === e[t + 2] && e[t + 3] === t + 7 && "jz" === e[t + 4] && "pop" === e[t + 5] && e[t + 6] === e[t + 1]) {
                    d = y.pop();
                    y.push((C = d, O = e[t + 1], C.min >= O ? new a(O) : C.max <= O ? C : new n(C, O)));
                    t += 6;
                    break;
                  }
                  if ("literal" === (g = y[y.length - 1]).type || "var" === g.type) {
                    y.push(g);
                    break;
                  }
                  m = new s(k++, g.min, g.max);
                  y[y.length - 1] = m;
                  y.push(m);
                  w.push(new o(m, g));
                  break;
                case "roll":
                  if (y.length < 2 || (f = y.pop(), d = y.pop(), "literal" !== f.type || "literal" !== d.type) || (u = f.number, (h = d.number) <= 0 || !Number.isInteger(h) || !Number.isInteger(u) || y.length < h)) return null;
                  if (0 == (u = (u % h + h) % h)) break;
                  Array.prototype.push.apply(y, y.splice(y.length - h, h - u));
                  break;
                default:
                  return null;
              }
            }
            if (y.length !== S) return null;
            let F = [];
            for (let e of w) {
              let t = new l();
              e.visit(t);
              F.push(t.toString());
            }
            for (function () {
              let e = 0;
              let t = y.length;
            }(); e < t; e++) {
              let t = y[e];
              let a = new l();
              t.visit(a);
              let r = c[2 * e];
              let i = c[2 * e + 1];
              let n = [a.toString()];
              r > t.min && (n.unshift("Math.max(", r, ", "), n.push(")"));
              i < t.max && (n.unshift("Math.min(", i, ", "), n.push(")"));
              n.unshift("dest[destOffset + ", e, "] = ");
              n.push(";");
              F.push(n.join(""));
            }
            return F.join("\n");
          }
        };
      }();
      t.PostScriptCompiler = d;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.PostScriptParser = t.PostScriptLexer = void 0;
      var r = a(2);
      var i = a(5);
      var n = a(8);
      t.PostScriptParser = class {
        constructor(e) {
          this.lexer = e;
          this.operators = [];
          this.token = null;
          this.prev = null;
        }
        nextToken() {
          this.prev = this.token;
          this.token = this.lexer.getToken();
        }
        accept(e) {
          return this.token.type === e && (this.nextToken(), !0);
        }
        expect(e) {
          if (this.accept(e)) return !0;
          throw new r.FormatError(`Unexpected symbol: found ${this.token.type} expected ${e}.`);
        }
        parse() {
          this.nextToken();
          this.expect(s.LBRACE);
          this.parseBlock();
          this.expect(s.RBRACE);
          return this.operators;
        }
        parseBlock() {
          for (; ;) if (this.accept(s.NUMBER)) this.operators.push(this.prev.value); else if (this.accept(s.OPERATOR)) this.operators.push(this.prev.value); else {
            if (!this.accept(s.LBRACE)) return;
            this.parseCondition();
          }
        }
        parseCondition() {
          let e = this.operators.length;
          if (this.operators.push(null, null), this.parseBlock(), this.expect(s.RBRACE), this.accept(s.IF)) {
            this.operators[e] = this.operators.length;
            this.operators[e + 1] = "jz";
          } else if (this.accept(s.LBRACE)) {
            let t = this.operators.length;
            this.operators.push(null, null);
            let a = this.operators.length;
            this.parseBlock();
            this.expect(s.RBRACE);
            this.expect(s.IFELSE);
            this.operators[t] = this.operators.length;
            this.operators[t + 1] = "j";
            this.operators[e] = a;
            this.operators[e + 1] = "jz";
          } else throw new r.FormatError("PS Function: error parsing conditional.");
        }
      };
      let s = {
        LBRACE: 0,
        RBRACE: 1,
        NUMBER: 2,
        OPERATOR: 3,
        IF: 4,
        IFELSE: 5
      };
      class o {
        static get opCache() {
          return r.shadow(this, "opCache", Object.create(null));
        }
        constructor(e, t) {
          this.type = e;
          this.value = t;
        }
        static getOperator(e) {
          return o.opCache[e] || (o.opCache[e] = new o(s.OPERATOR, e));
        }
        static get LBRACE() {
          return r.shadow(this, "LBRACE", new o(s.LBRACE, "{"));
        }
        static get RBRACE() {
          return r.shadow(this, "RBRACE", new o(s.RBRACE, "}"));
        }
        static get IF() {
          return r.shadow(this, "IF", new o(s.IF, "IF"));
        }
        static get IFELSE() {
          return r.shadow(this, "IFELSE", new o(s.IFELSE, "IFELSE"));
        }
      }
      t.PostScriptLexer = class {
        constructor(e) {
          this.stream = e;
          this.nextChar();
          this.strBuf = [];
        }
        nextChar() {
          return this.currentChar = this.stream.getByte();
        }
        getToken() {
          let e = !1;
          let t = this.currentChar;
          for (; ;) {
            if (t < 0) return i.EOF;
            if (e) (10 === t || 13 === t) && (e = !1); else if (37 === t) e = !0; else if (!n.isWhiteSpace(t)) break;
            t = this.nextChar();
          }
          switch (0 | t) {
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 43:
            case 45:
            case 46:
              return new o(s.NUMBER, this.getNumber());
            case 123:
              this.nextChar();
              return o.LBRACE;
            case 125:
              this.nextChar();
              return o.RBRACE;
          }
          let a = this.strBuf;
          for (a.length = 0, a[0] = String.fromCharCode(t); (t = this.nextChar()) >= 0 && (t >= 65 && t <= 90 || t >= 97 && t <= 122);) a.push(String.fromCharCode(t));
          let r = a.join("");
          switch (r.toLowerCase()) {
            case "if":
              return o.IF;
            case "ifelse":
              return o.IFELSE;
            default:
              return o.getOperator(r);
          }
        }
        getNumber() {
          let e = this.currentChar;
          let t = this.strBuf;
          for (t.length = 0, t[0] = String.fromCharCode(e); (e = this.nextChar()) >= 0;) if (e >= 48 && e <= 57 || 45 === e || 46 === e) t.push(String.fromCharCode(e)); else break;
          let a = parseFloat(t.join(""));
          if (isNaN(a)) throw new r.FormatError(`Invalid floating point number: ${a}`);
          return a;
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.LocalTilingPatternCache = t.LocalImageCache = t.LocalGStateCache = t.LocalFunctionCache = t.LocalColorSpaceCache = t.GlobalImageCache = void 0;
      var r = a(2);
      var i = a(5);
      class n {
        constructor(e) {
          this.constructor === n && r.unreachable("Cannot initialize BaseLocalCache.");
          this._onlyRefs = !0 === (e && e.onlyRefs);
          this._onlyRefs || (this._nameRefMap = new Map(), this._imageMap = new Map());
          this._imageCache = new i.RefSetCache();
        }
        getByName(e) {
          this._onlyRefs && r.unreachable("Should not call `getByName` method.");
          let t = this._nameRefMap.get(e);
          return t ? this.getByRef(t) : this._imageMap.get(e) || null;
        }
        getByRef(e) {
          return this._imageCache.get(e) || null;
        }
        set(e, t, a) {
          r.unreachable("Abstract method `set` called.");
        }
      }
      t.LocalImageCache = class extends n {
        set(e, t = null, a) {
          if ("string" != typeof e) throw Error('LocalImageCache.set - expected "name" argument.');
          if (t) {
            if (this._imageCache.has(t)) return;
            this._nameRefMap.set(e, t);
            this._imageCache.put(t, a);
            return;
          }
          this._imageMap.has(e) || this._imageMap.set(e, a);
        }
      };
      t.LocalColorSpaceCache = class extends n {
        set(e = null, t = null, a) {
          if ("string" != typeof e && !t) throw Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
          if (t) {
            if (this._imageCache.has(t)) return;
            null !== e && this._nameRefMap.set(e, t);
            this._imageCache.put(t, a);
            return;
          }
          this._imageMap.has(e) || this._imageMap.set(e, a);
        }
      };
      t.LocalFunctionCache = class extends n {
        constructor(e) {
          super({
            onlyRefs: !0
          });
        }
        set(e = null, t, a) {
          if (!t) throw Error('LocalFunctionCache.set - expected "ref" argument.');
          this._imageCache.has(t) || this._imageCache.put(t, a);
        }
      };
      t.LocalGStateCache = class extends n {
        set(e, t = null, a) {
          if ("string" != typeof e) throw Error('LocalGStateCache.set - expected "name" argument.');
          if (t) {
            if (this._imageCache.has(t)) return;
            this._nameRefMap.set(e, t);
            this._imageCache.put(t, a);
            return;
          }
          this._imageMap.has(e) || this._imageMap.set(e, a);
        }
      };
      t.LocalTilingPatternCache = class extends n {
        constructor(e) {
          super({
            onlyRefs: !0
          });
        }
        set(e = null, t, a) {
          if (!t) throw Error('LocalTilingPatternCache.set - expected "ref" argument.');
          this._imageCache.has(t) || this._imageCache.put(t, a);
        }
      };
      class s {
        static get NUM_PAGES_THRESHOLD() {
          return r.shadow(this, "NUM_PAGES_THRESHOLD", 2);
        }
        static get MIN_IMAGES_TO_CACHE() {
          return r.shadow(this, "MIN_IMAGES_TO_CACHE", 10);
        }
        static get MAX_BYTE_SIZE() {
          return r.shadow(this, "MAX_BYTE_SIZE", 4e7);
        }
        constructor() {
          this._refCache = new i.RefSetCache();
          this._imageCache = new i.RefSetCache();
        }
        get _byteSize() {
          let e = 0;
          this._imageCache.forEach(t => {
            e += t.byteSize;
          });
          return e;
        }
        get _cacheLimitReached() {
          return !(this._imageCache.size < s.MIN_IMAGES_TO_CACHE) && !(this._byteSize < s.MAX_BYTE_SIZE);
        }
        shouldCache(e, t) {
          let a = this._refCache.get(e);
          return !((a ? a.size + (a.has(t) ? 0 : 1) : 1) < s.NUM_PAGES_THRESHOLD) && (!!this._imageCache.has(e) || !this._cacheLimitReached);
        }
        addPageIndex(e, t) {
          let a = this._refCache.get(e);
          a || (a = new Set(), this._refCache.put(e, a));
          a.add(t);
        }
        addByteSize(e, t) {
          let a = this._imageCache.get(e);
          a && !a.byteSize && (a.byteSize = t);
        }
        getData(e, t) {
          let a = this._refCache.get(e);
          if (!a || a.size < s.NUM_PAGES_THRESHOLD) return null;
          let r = this._imageCache.get(e);
          return r ? (a.add(t), r) : null;
        }
        setData(e, t) {
          if (!this._refCache.has(e)) throw Error('GlobalImageCache.setData - expected "addPageIndex" to have been called.');
          if (!this._imageCache.has(e)) {
            if (this._cacheLimitReached) {
              r.warn("GlobalImageCache.setData - cache limit reached.");
              return;
            }
            this._imageCache.put(e, t);
          }
        }
        clear(e = !1) {
          e || this._refCache.clear();
          this._imageCache.clear();
        }
      }
      t.GlobalImageCache = s;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.bidi = function (e, t = -1, a = !1) {
        let h;
        let u;
        let d;
        let f;
        let g = !0;
        let p = e.length;
        if (0 === p || a) return o(e, g, a);
        l.length = p;
        c.length = p;
        let m = 0;
        for (h = 0; h < p; ++h) {
          l[h] = e.charAt(h);
          let t = e.charCodeAt(h);
          let a = "L";
          t <= 255 ? a = i[t] : 1424 <= t && t <= 1524 ? a = "R" : 1536 <= t && t <= 1791 ? (a = n[255 & t]) || r.warn("Bidi: invalid Unicode character " + t.toString(16)) : 1792 <= t && t <= 2220 && (a = "AL");
          ("R" === a || "AL" === a || "AN" === a) && m++;
          c[h] = a;
        }
        if (0 === m) return o(e, g = !0);
        -1 === t && (m / p < .3 && p > 4 ? (g = !0, t = 0) : (g = !1, t = 1));
        let b = [];
        for (h = 0; h < p; ++h) b[h] = t;
        let y = (1 & t) != 0 ? "R" : "L";
        let w = y;
        for (h = 0; h < p; ++h) "NSM" === c[h] ? c[h] = w : w = c[h];
        for (h = 0, w = y; h < p; ++h) "EN" === (d = c[h]) ? c[h] = "AL" === w ? "AN" : "EN" : ("R" === d || "L" === d || "AL" === d) && (w = d);
        for (h = 0; h < p; ++h) "AL" === (d = c[h]) && (c[h] = "R");
        for (h = 1; h < p - 1; ++h) {
          "ES" === c[h] && "EN" === c[h - 1] && "EN" === c[h + 1] && (c[h] = "EN");
          "CS" === c[h] && ("EN" === c[h - 1] || "AN" === c[h - 1]) && c[h + 1] === c[h - 1] && (c[h] = c[h - 1]);
        }
        for (h = 0; h < p; ++h) if ("EN" === c[h]) {
          for (let e = h - 1; e >= 0 && "ET" === c[e]; --e) c[e] = "EN";
          for (let e = h + 1; e < p && "ET" === c[e]; ++e) c[e] = "EN";
        }
        for (h = 0; h < p; ++h) ("WS" === (d = c[h]) || "ES" === d || "ET" === d || "CS" === d) && (c[h] = "ON");
        for (h = 0, w = y; h < p; ++h) "EN" === (d = c[h]) ? c[h] = "L" === w ? "L" : "EN" : ("R" === d || "L" === d) && (w = d);
        for (h = 0; h < p; ++h) if ("ON" === c[h]) {
          let e = function (e, t, a) {
            let r;
            let i;
            for (r = t, i = e.length; r < i && "ON" === e[r]; ++r);
            return r;
          }(c, h + 1, 0);
          let t = y;
          h > 0 && (t = c[h - 1]);
          let a = y;
          e + 1 < p && (a = c[e + 1]);
          "L" !== t && (t = "R");
          "L" !== a && (a = "R");
          t === a && function (e, t, a, r) {
            for (let i = t; i < a; ++i) e[i] = r;
          }(c, h, e, t);
          h = e - 1;
        }
        for (h = 0; h < p; ++h) "ON" === c[h] && (c[h] = y);
        for (h = 0; h < p; ++h) (d = c[h], (1 & b[h]) == 0) ? "R" === d ? b[h] += 1 : ("AN" === d || "EN" === d) && (b[h] += 2) : ("L" === d || "AN" === d || "EN" === d) && (b[h] += 1);
        let x = -1;
        let S = 99;
        for (h = 0, u = b.length; h < u; ++h) {
          x < (f = b[h]) && (x = f);
          S > f && (1 & f) != 0 && (S = f);
        }
        for (f = x; f >= S; --f) {
          let e = -1;
          for (h = 0, u = b.length; h < u; ++h) b[h] < f ? e >= 0 && (s(l, e, h), e = -1) : e < 0 && (e = h);
          e >= 0 && s(l, e, b.length);
        }
        for (h = 0, u = l.length; h < u; ++h) {
          let e = l[h];
          ("<" === e || ">" === e) && (l[h] = "");
        }
        return o(l.join(""), g);
      };
      var r = a(2);
      let i = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"];
      let n = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
      function s(e, t, a) {
        for (function () {
          let r = t;
          let i = a - 1;
        }(); r < i; ++r, --i) {
          let t = e[r];
          e[r] = e[i];
          e[i] = t;
        }
      }
      function o(e, t, a = !1) {
        let r = "ltr";
        a ? r = "ttb" : t || (r = "rtl");
        return {
          str: e,
          dir: r
        };
      }
      let l = [];
      let c = [];
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.MurmurHash3_64 = void 0;
      var r = a(2);
      t.MurmurHash3_64 = class {
        constructor(e) {
          this.h1 = e ? 0xffffffff & e : 0xc3d2e1f0;
          this.h2 = e ? 0xffffffff & e : 0xc3d2e1f0;
        }
        update(e) {
          let t;
          let a;
          if ("string" == typeof e) {
            t = new Uint8Array(2 * e.length);
            a = 0;
            for (function () {
              let r = 0;
              let i = e.length;
            }(); r < i; r++) {
              let i = e.charCodeAt(r);
              i <= 255 ? t[a++] = i : (t[a++] = i >>> 8, t[a++] = 255 & i);
            }
          } else if (r.isArrayBuffer(e)) a = (t = e.slice()).byteLength; else throw Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
          let i = a >> 2;
          let n = a - 4 * i;
          let s = new Uint32Array(t.buffer, 0, i);
          let o = 0;
          let l = 0;
          let c = this.h1;
          let h = this.h2;
          for (let e = 0; e < i; e++) 1 & e ? (c ^= o = 0x1b873593 * (o = (o = 0xcc9e2d51 * (o = s[e]) & 0xffff0000 | 11601 * o & 65535) << 15 | o >>> 17) & 0xffff0000 | 13715 * o & 65535, c = 5 * (c = c << 13 | c >>> 19) + 0xe6546b64) : (h ^= l = 0x1b873593 * (l = (l = 0xcc9e2d51 * (l = s[e]) & 0xffff0000 | 11601 * l & 65535) << 15 | l >>> 17) & 0xffff0000 | 13715 * l & 65535, h = 5 * (h = h << 13 | h >>> 19) + 0xe6546b64);
          switch (o = 0, n) {
            case 3:
              o ^= t[4 * i + 2] << 16;
            case 2:
              o ^= t[4 * i + 1] << 8;
            case 1:
              o ^= t[4 * i];
              o = 0x1b873593 * (o = (o = 0xcc9e2d51 * o & 0xffff0000 | 11601 * o & 65535) << 15 | o >>> 17) & 0xffff0000 | 13715 * o & 65535;
              1 & i ? c ^= o : h ^= o;
          }
          this.h1 = c;
          this.h2 = h;
        }
        hexdigest() {
          let e = this.h1;
          let t = this.h2;
          e ^= t >>> 1;
          t = 0xff51afd7 * t & 0xffff0000 | ((t << 16 | (e = 0xed558ccd * e & 0xffff0000 | 36045 * e & 65535) >>> 16) * 0xafd7ed55 & 0xffff0000) >>> 16;
          e ^= t >>> 1;
          t = 0xc4ceb9fe * t & 0xffff0000 | ((t << 16 | (e = 0x1a85ec53 * e & 0xffff0000 | 60499 * e & 65535) >>> 16) * 0xb9fe1a85 & 0xffff0000) >>> 16;
          let a = ((e ^= t >>> 1) >>> 0).toString(16);
          let r = (t >>> 0).toString(16);
          return a.padStart(8, "0") + r.padStart(8, "0");
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.OperatorList = void 0;
      var r = a(2);
      function i(e, t, a, r, i) {
        let n = e;
        for (function () {
          let e = 0;
          let a = t.length - 1;
        }(); e < a; e++) {
          let a = t[e];
          n = n[a] || (n[a] = []);
        }
        n[t[t.length - 1]] = {
          checkFn: a,
          iterateFn: r,
          processFn: i
        };
      }
      let n = [];
      i(n, [r.OPS.save, r.OPS.transform, r.OPS.paintInlineImageXObject, r.OPS.restore], null, function (e, t) {
        let a = e.fnArray;
        let i = (t - (e.iCurr - 3)) % 4;
        switch (i) {
          case 0:
            return a[t] === r.OPS.save;
          case 1:
            return a[t] === r.OPS.transform;
          case 2:
            return a[t] === r.OPS.paintInlineImageXObject;
          case 3:
            return a[t] === r.OPS.restore;
        }
        throw Error(`iterateInlineImageGroup - invalid pos: ${i}`);
      }, function (e, t) {
        let a = e.fnArray;
        let i = e.argsArray;
        let n = e.iCurr;
        let s = n - 3;
        let o = n - 2;
        let l = n - 1;
        let c = Math.min(Math.floor((t - s) / 4), 200);
        if (c < 10) return t - (t - s) % 4;
        let h = 0;
        let u = [];
        let d = 0;
        let f = 1;
        let g = 1;
        for (let e = 0; e < c; e++) {
          let t = i[o + (e << 2)];
          let a = i[l + (e << 2)][0];
          f + a.width > 1e3 && (h = Math.max(h, f), g += d + 2, f = 0, d = 0);
          u.push({
            transform: t,
            x: f,
            y: g,
            w: a.width,
            h: a.height
          });
          f += a.width + 2;
          d = Math.max(d, a.height);
        }
        let p = Math.max(h, f) + 1;
        let m = g + d + 1;
        let b = new Uint8ClampedArray(p * m * 4);
        let y = p << 2;
        for (let e = 0; e < c; e++) {
          let t = i[l + (e << 2)][0].data;
          let a = u[e].w << 2;
          let r = 0;
          let n = u[e].x + u[e].y * p << 2;
          b.set(t.subarray(0, a), n - y);
          for (function () {
            let i = 0;
            let s = u[e].h;
          }(); i < s; i++) {
            b.set(t.subarray(r, r + a), n);
            r += a;
            n += y;
          }
          for (b.set(t.subarray(r - a, r), n); n >= 0;) {
            t[n - 4] = t[n];
            t[n - 3] = t[n + 1];
            t[n - 2] = t[n + 2];
            t[n - 1] = t[n + 3];
            t[n + a] = t[n + a - 4];
            t[n + a + 1] = t[n + a - 3];
            t[n + a + 2] = t[n + a - 2];
            t[n + a + 3] = t[n + a - 1];
            n -= y;
          }
        }
        a.splice(s, 4 * c, r.OPS.paintInlineImageXObjectGroup);
        i.splice(s, 4 * c, [{
          width: p,
          height: m,
          kind: r.ImageKind.RGBA_32BPP,
          data: b
        }, u]);
        return s + 1;
      });
      i(n, [r.OPS.save, r.OPS.transform, r.OPS.paintImageMaskXObject, r.OPS.restore], null, function (e, t) {
        let a = e.fnArray;
        let i = (t - (e.iCurr - 3)) % 4;
        switch (i) {
          case 0:
            return a[t] === r.OPS.save;
          case 1:
            return a[t] === r.OPS.transform;
          case 2:
            return a[t] === r.OPS.paintImageMaskXObject;
          case 3:
            return a[t] === r.OPS.restore;
        }
        throw Error(`iterateImageMaskGroup - invalid pos: ${i}`);
      }, function (e, t) {
        let a;
        let i;
        let n = e.fnArray;
        let s = e.argsArray;
        let o = e.iCurr;
        let l = o - 3;
        let c = o - 2;
        let h = o - 1;
        let u = Math.floor((t - l) / 4);
        if ((u = function (e, t, a, i) {
          let n;
          let s = e + 2;
          for (n = 0; n < t; n++) {
            let e = i[s + 4 * n];
            let t = 1 === e.length && e[0];
            if (t && 1 === t.width && 1 === t.height && (!t.data.length || 1 === t.data.length && 0 === t.data[0])) {
              a[s + 4 * n] = r.OPS.paintSolidColorImageMask;
              continue;
            }
            break;
          }
          return t - n;
        }(l, u, n, s)) < 10) return t - (t - l) % 4;
        let d = !1;
        let f = s[h][0];
        let g = s[c][0];
        let p = s[c][1];
        let m = s[c][2];
        let b = s[c][3];
        if (p === m) {
          d = !0;
          a = c + 4;
          let e = h + 4;
          for (let t = 1; t < u; t++, a += 4, e += 4) if (i = s[a], s[e][0] !== f || i[0] !== g || i[1] !== p || i[2] !== m || i[3] !== b) {
            t < 10 ? d = !1 : u = t;
            break;
          }
        }
        if (d) {
          let e = new Float32Array(2 * (u = Math.min(u, 1e3)));
          a = c;
          for (let t = 0; t < u; t++, a += 4) {
            i = s[a];
            e[t << 1] = i[4];
            e[(t << 1) + 1] = i[5];
          }
          n.splice(l, 4 * u, r.OPS.paintImageMaskXObjectRepeat);
          s.splice(l, 4 * u, [f, g, p, m, b, e]);
        } else {
          u = Math.min(u, 100);
          let e = [];
          for (let t = 0; t < u; t++) {
            i = s[c + (t << 2)];
            let a = s[h + (t << 2)][0];
            e.push({
              data: a.data,
              width: a.width,
              height: a.height,
              transform: i
            });
          }
          n.splice(l, 4 * u, r.OPS.paintImageMaskXObjectGroup);
          s.splice(l, 4 * u, [e]);
        }
        return l + 1;
      });
      i(n, [r.OPS.save, r.OPS.transform, r.OPS.paintImageXObject, r.OPS.restore], function (e) {
        let t = e.argsArray;
        let a = e.iCurr - 2;
        return 0 === t[a][1] && 0 === t[a][2];
      }, function (e, t) {
        let a = e.fnArray;
        let i = e.argsArray;
        let n = (t - (e.iCurr - 3)) % 4;
        switch (n) {
          case 0:
            return a[t] === r.OPS.save;
          case 1:
            if (a[t] !== r.OPS.transform) return !1;
            let s = e.iCurr - 2;
            let o = i[s][0];
            let l = i[s][3];
            if (i[t][0] !== o || 0 !== i[t][1] || 0 !== i[t][2] || i[t][3] !== l) return !1;
            return !0;
          case 2:
            if (a[t] !== r.OPS.paintImageXObject) return !1;
            let c = i[e.iCurr - 1][0];
            if (i[t][0] !== c) return !1;
            return !0;
          case 3:
            return a[t] === r.OPS.restore;
        }
        throw Error(`iterateImageGroup - invalid pos: ${n}`);
      }, function (e, t) {
        let a = e.fnArray;
        let i = e.argsArray;
        let n = e.iCurr;
        let s = n - 3;
        let o = n - 2;
        let l = i[n - 1][0];
        let c = i[o][0];
        let h = i[o][3];
        let u = Math.min(Math.floor((t - s) / 4), 1e3);
        if (u < 3) return t - (t - s) % 4;
        let d = new Float32Array(2 * u);
        let f = o;
        for (let e = 0; e < u; e++, f += 4) {
          let t = i[f];
          d[e << 1] = t[4];
          d[(e << 1) + 1] = t[5];
        }
        let g = [l, c, h, d];
        a.splice(s, 4 * u, r.OPS.paintImageXObjectRepeat);
        i.splice(s, 4 * u, g);
        return s + 1;
      });
      i(n, [r.OPS.beginText, r.OPS.setFont, r.OPS.setTextMatrix, r.OPS.showText, r.OPS.endText], null, function (e, t) {
        let a = e.fnArray;
        let i = e.argsArray;
        let n = (t - (e.iCurr - 4)) % 5;
        switch (n) {
          case 0:
            return a[t] === r.OPS.beginText;
          case 1:
            return a[t] === r.OPS.setFont;
          case 2:
            return a[t] === r.OPS.setTextMatrix;
          case 3:
            if (a[t] !== r.OPS.showText) return !1;
            let s = e.iCurr - 3;
            let o = i[s][0];
            let l = i[s][1];
            if (i[t][0] !== o || i[t][1] !== l) return !1;
            return !0;
          case 4:
            return a[t] === r.OPS.endText;
        }
        throw Error(`iterateShowTextGroup - invalid pos: ${n}`);
      }, function (e, t) {
        let a = e.fnArray;
        let r = e.argsArray;
        let i = e.iCurr;
        let n = i - 4;
        let s = i - 3;
        let o = r[s][0];
        let l = r[s][1];
        let c = Math.min(Math.floor((t - n) / 5), 1e3);
        if (c < 3) return t - (t - n) % 5;
        let h = n;
        n >= 4 && a[n - 4] === a[s] && a[n - 3] === a[i - 2] && a[n - 2] === a[i - 1] && a[n - 1] === a[i] && r[n - 4][0] === o && r[n - 4][1] === l && (c++, h -= 5);
        let u = h + 4;
        for (let e = 1; e < c; e++) {
          a.splice(u, 3);
          r.splice(u, 3);
          u += 2;
        }
        return u + 1;
      });
      class s {
        constructor(e) {
          this.queue = e;
        }
        _optimize() { }
        push(e, t) {
          this.queue.fnArray.push(e);
          this.queue.argsArray.push(t);
          this._optimize();
        }
        flush() { }
        reset() { }
      }
      class o extends s {
        constructor(e) {
          super(e);
          this.state = null;
          this.context = {
            iCurr: 0,
            fnArray: e.fnArray,
            argsArray: e.argsArray
          };
          this.match = null;
          this.lastProcessed = 0;
        }
        _optimize() {
          let e = this.queue.fnArray;
          let t = this.lastProcessed;
          let a = e.length;
          let r = this.state;
          let i = this.match;
          if (!r && !i && t + 1 === a && !n[e[t]]) {
            this.lastProcessed = a;
            return;
          }
          let s = this.context;
          for (; t < a;) {
            if (i) {
              if (i.iterateFn(s, t)) {
                t++;
                continue;
              }
              if (t = i.processFn(s, t + 1), a = e.length, i = null, r = null, t >= a) break;
            }
            if (!(r = (r || n)[e[t]]) || Array.isArray(r)) {
              t++;
              continue;
            }
            if (s.iCurr = t, t++, r.checkFn && !r.checkFn(s)) {
              r = null;
              continue;
            }
            i = r;
            r = null;
          }
          this.state = r;
          this.match = i;
          this.lastProcessed = t;
        }
        flush() {
          for (; this.match;) {
            let e = this.queue.fnArray.length;
            this.lastProcessed = this.match.processFn(this.context, e);
            this.match = null;
            this.state = null;
            this._optimize();
          }
        }
        reset() {
          this.state = null;
          this.match = null;
          this.lastProcessed = 0;
        }
      }
      class l {
        static get CHUNK_SIZE() {
          return r.shadow(this, "CHUNK_SIZE", 1e3);
        }
        static get CHUNK_SIZE_ABOUT() {
          return r.shadow(this, "CHUNK_SIZE_ABOUT", this.CHUNK_SIZE - 5);
        }
        constructor(e = 0, t) {
          this._streamSink = t;
          this.fnArray = [];
          this.argsArray = [];
          t && !(e & r.RenderingIntentFlag.OPLIST) ? this.optimizer = new o(this) : this.optimizer = new s(this);
          this.dependencies = new Set();
          this._totalLength = 0;
          this.weight = 0;
          this._resolved = t ? null : Promise.resolve();
        }
        get length() {
          return this.argsArray.length;
        }
        get ready() {
          return this._resolved || this._streamSink.ready;
        }
        get totalLength() {
          return this._totalLength + this.length;
        }
        addOp(e, t) {
          this.optimizer.push(e, t);
          this.weight++;
          this._streamSink && (this.weight >= l.CHUNK_SIZE ? this.flush() : this.weight >= l.CHUNK_SIZE_ABOUT && (e === r.OPS.restore || e === r.OPS.endText) && this.flush());
        }
        addDependency(e) {
          this.dependencies.has(e) || (this.dependencies.add(e), this.addOp(r.OPS.dependency, [e]));
        }
        addDependencies(e) {
          for (let t of e) this.addDependency(t);
        }
        addOpList(e) {
          if (!(e instanceof l)) {
            r.warn('addOpList - ignoring invalid "opList" parameter.');
            return;
          }
          for (let t of e.dependencies) this.dependencies.add(t);
          for (function () {
            let t = 0;
            let a = e.length;
          }(); t < a; t++) this.addOp(e.fnArray[t], e.argsArray[t]);
        }
        getIR() {
          return {
            fnArray: this.fnArray,
            argsArray: this.argsArray,
            length: this.length
          };
        }
        get _transfers() {
          let e = [];
          let {
            fnArray,
            argsArray,
            length
          } = this;
          for (let n = 0; n < length; n++) switch (fnArray[n]) {
            case r.OPS.paintInlineImageXObject:
            case r.OPS.paintInlineImageXObjectGroup:
            case r.OPS.paintImageMaskXObject:
              let i = argsArray[n][0];
              i.cached || e.push(i.data.buffer);
          }
          return e;
        }
        flush(e = !1) {
          this.optimizer.flush();
          let t = this.length;
          this._totalLength += t;
          this._streamSink.enqueue({
            fnArray: this.fnArray,
            argsArray: this.argsArray,
            lastChunk: e,
            length: t
          }, 1, this._transfers);
          this.dependencies.clear();
          this.fnArray.length = 0;
          this.argsArray.length = 0;
          this.weight = 0;
          this.optimizer.reset();
        }
      }
      t.OperatorList = l;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.PDFImage = void 0;
      var r = a(2);
      var i = a(9);
      var n = a(24);
      var s = a(29);
      var o = a(37);
      var l = a(40);
      var c = a(5);
      function h(e, t, a, r, i, n) {
        let s;
        let o = i * n;
        s = t <= 8 ? new Uint8Array(o) : t <= 16 ? new Uint16Array(o) : new Uint32Array(o);
        let l = a / i;
        let c = r / n;
        let h;
        let u;
        let d;
        let f = 0;
        let g;
        let p = new Uint16Array(i);
        for (h = 0; h < i; h++) p[h] = Math.floor(h * l);
        for (h = 0; h < n; h++) for (u = 0, d = Math.floor(h * c) * a; u < i; u++) {
          g = d + p[u];
          s[f++] = e[g];
        }
        return s;
      }
      class u {
        constructor({
          xref: e,
          res: t,
          image: a,
          isInline: s = !1,
          smask: o = null,
          mask: h = null,
          isMask: d = !1,
          pdfFunctionFactory: f,
          localColorSpaceCache: g
        }) {
          this.decode = p.getArray("D", "Decode");
          this.needsDecode = !1;
          this.bpc = x;
          this.image = a;
          let p = a.dict;
          let m = p.get("F", "Filter");
          if (m instanceof c.Name) switch (m.name) {
            case "JPXDecode":
              let b = new l.JpxImage();
              b.parseImageProperties(a.stream);
              a.stream.reset();
              a.width = b.width;
              a.height = b.height;
              a.bitsPerComponent = b.bitsPerComponent;
              a.numComps = b.componentsCount;
              break;
            case "JBIG2Decode":
              a.bitsPerComponent = 1;
              a.numComps = 1;
          }
          let y = p.get("W", "Width");
          let w = p.get("H", "Height");
          if (Number.isInteger(a.width) && a.width > 0 && Number.isInteger(a.height) && a.height > 0 && (a.width !== y || a.height !== w) && (r.warn("PDFImage - using the Width/Height of the image data, rather than the image dictionary."), y = a.width, w = a.height), y < 1 || w < 1) throw new r.FormatError(`Invalid image width: ${y} or height: ${w}`);
          this.width = y;
          this.height = w;
          this.interpolate = p.get("I", "Interpolate");
          this.imageMask = p.get("IM", "ImageMask") || !1;
          this.matte = p.get("Matte") || !1;
          let x = a.bitsPerComponent;
          if (!x && !(x = p.get("BPC", "BitsPerComponent"))) {
            if (this.imageMask) x = 1; else throw new r.FormatError(`Bits per component missing in image: ${this.imageMask}`);
          }
          if (!this.imageMask) {
            let i = p.getRaw("CS") || p.getRaw("ColorSpace");
            if (!i) switch (r.info("JPX images (which do not require color spaces)"), a.numComps) {
              case 1:
                i = c.Name.get("DeviceGray");
                break;
              case 3:
                i = c.Name.get("DeviceRGB");
                break;
              case 4:
                i = c.Name.get("DeviceCMYK");
                break;
              default:
                throw Error(`JPX images with ${a.numComps} color components not supported.`);
            }
            this.colorSpace = n.ColorSpace.parse({
              cs: i,
              xref: e,
              resources: s ? t : null,
              pdfFunctionFactory: f,
              localColorSpaceCache: g
            });
            this.numComps = this.colorSpace.numComps;
          }
          if (this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, x) || d && !n.ColorSpace.isDefaultDecode(this.decode, 1))) {
            this.needsDecode = !0;
            let e = (1 << x) - 1;
            this.decodeCoefficients = [];
            this.decodeAddends = [];
            let t = this.colorSpace && "Indexed" === this.colorSpace.name;
            for (function () {
              let a = 0;
              let r = 0;
            }(); a < this.decode.length; a += 2, ++r) {
              let i = this.decode[a];
              let n = this.decode[a + 1];
              this.decodeCoefficients[r] = t ? (n - i) / e : n - i;
              this.decodeAddends[r] = t ? i : e * i;
            }
          }
          o ? this.smask = new u({
            xref: e,
            res: t,
            image: o,
            isInline: s,
            pdfFunctionFactory: f,
            localColorSpaceCache: g
          }) : h && (h instanceof i.BaseStream ? h.dict.get("IM", "ImageMask") ? this.mask = new u({
            xref: e,
            res: t,
            image: h,
            isInline: s,
            isMask: !0,
            pdfFunctionFactory: f,
            localColorSpaceCache: g
          }) : r.warn("Ignoring /Mask in image without /ImageMask.") : this.mask = h);
        }
        static async buildImage({
          xref: e,
          res: t,
          image: a,
          isInline: n = !1,
          pdfFunctionFactory: s,
          localColorSpaceCache: o
        }) {
          let l = null;
          let c = null;
          let h = a.dict.get("SMask");
          let d = a.dict.get("Mask");
          h ? l = h : d && (d instanceof i.BaseStream || Array.isArray(d) ? c = d : r.warn("Unsupported mask format."));
          return new u({
            xref: e,
            res: t,
            image: a,
            isInline: n,
            smask: l,
            mask: c,
            pdfFunctionFactory: s,
            localColorSpaceCache: o
          });
        }
        static createMask({
          imgArray: e,
          width: t,
          height: a,
          imageIsFromDecodeStream: r,
          inverseDecode: i,
          interpolate: n
        }) {
          let s;
          let o;
          let l = (t + 7 >> 3) * a;
          let c = e.byteLength;
          let h = l === c;
          if (r && (!i || h)) s = e; else if (i) for ((s = new Uint8ClampedArray(l)).set(e), o = c; o < l; o++) s[o] = 255; else (s = new Uint8ClampedArray(c)).set(e);
          if (i) for (o = 0; o < c; o++) s[o] ^= 255;
          return {
            data: s,
            width: t,
            height: a,
            interpolate: n
          };
        }
        get drawWidth() {
          return Math.max(this.width, this.smask && this.smask.width || 0, this.mask && this.mask.width || 0);
        }
        get drawHeight() {
          return Math.max(this.height, this.smask && this.smask.height || 0, this.mask && this.mask.height || 0);
        }
        decodeBuffer(e) {
          let t;
          let a;
          let r = this.bpc;
          let i = this.numComps;
          let n = this.decodeAddends;
          let s = this.decodeCoefficients;
          let o = (1 << r) - 1;
          if (1 === r) {
            for (t = 0, a = e.length; t < a; t++) e[t] = +!e[t];
            return;
          }
          let l = 0;
          for (t = 0, a = this.width * this.height; t < a; t++) for (let t = 0; t < i; t++) {
            var c;
            e[l] = (c = e[l], (c = n[t] + c * s[t]) < 0 ? c = 0 : c > o && (c = o), c);
            l++;
          }
        }
        getComponents(e) {
          let t;
          let a = this.bpc;
          if (8 === a) return e;
          let r = this.width;
          let i = this.height;
          let n = this.numComps;
          let s = r * i * n;
          let o = 0;
          t = a <= 8 ? new Uint8Array(s) : a <= 16 ? new Uint16Array(s) : new Uint32Array(s);
          let l = r * n;
          let c = (1 << a) - 1;
          let h = 0;
          let u;
          if (1 === a) {
            let a;
            let r;
            let n;
            for (let s = 0; s < i; s++) {
              for (r = h + (-8 & l), n = h + l; h < r;) {
                u = e[o++];
                t[h] = u >> 7 & 1;
                t[h + 1] = u >> 6 & 1;
                t[h + 2] = u >> 5 & 1;
                t[h + 3] = u >> 4 & 1;
                t[h + 4] = u >> 3 & 1;
                t[h + 5] = u >> 2 & 1;
                t[h + 6] = u >> 1 & 1;
                t[h + 7] = 1 & u;
                h += 8;
              }
              if (h < n) for (u = e[o++], a = 128; h < n;) {
                t[h++] = +!!(u & a);
                a >>= 1;
              }
            }
          } else {
            let r = 0;
            for (h = 0, u = 0; h < s; ++h) {
              for (h % l == 0 && (u = 0, r = 0); r < a;) {
                u = u << 8 | e[o++];
                r += 8;
              }
              let i = r - a;
              let n = u >> i;
              n < 0 ? n = 0 : n > c && (n = c);
              t[h] = n;
              u &= (1 << i) - 1;
              r = i;
            }
          }
          return t;
        }
        fillOpacity(e, t, a, i, n) {
          let s;
          let o;
          let l;
          let c;
          let d;
          let f;
          let g = this.smask;
          let p = this.mask;
          if (g) {
            s = new Uint8ClampedArray((o = g.width) * (l = g.height));
            g.fillGrayBuffer(s);
            (o !== t || l !== a) && (s = h(s, g.bpc, o, l, t, a));
          } else if (p) {
            if (p instanceof u) {
              for (s = new Uint8ClampedArray((o = p.width) * (l = p.height)), p.numComps = 1, p.fillGrayBuffer(s), c = 0, d = o * l; c < d; ++c) s[c] = 255 - s[c];
              (o !== t || l !== a) && (s = h(s, p.bpc, o, l, t, a));
            } else if (Array.isArray(p)) {
              s = new Uint8ClampedArray(t * a);
              let e = this.numComps;
              for (c = 0, d = t * a; c < d; ++c) {
                let t = 0;
                let a = c * e;
                for (f = 0; f < e; ++f) {
                  let e = n[a + f];
                  let r = 2 * f;
                  if (e < p[r] || e > p[r + 1]) {
                    t = 255;
                    break;
                  }
                }
                s[c] = t;
              }
            } else throw new r.FormatError("Unknown mask format.");
          }
          if (s) for (c = 0, f = 3, d = t * i; c < d; ++c, f += 4) e[f] = s[c]; else for (c = 0, f = 3, d = t * i; c < d; ++c, f += 4) e[f] = 255;
        }
        undoPreblend(e, t, a) {
          let r = this.smask && this.smask.matte;
          if (!r) return;
          let i = this.colorSpace.getRgb(r, 0);
          let n = i[0];
          let s = i[1];
          let o = i[2];
          let l = t * a * 4;
          for (let t = 0; t < l; t += 4) {
            let a = e[t + 3];
            if (0 === a) {
              e[t] = 255;
              e[t + 1] = 255;
              e[t + 2] = 255;
              continue;
            }
            let r = 255 / a;
            e[t] = (e[t] - n) * r + n;
            e[t + 1] = (e[t + 1] - s) * r + s;
            e[t + 2] = (e[t + 2] - o) * r + o;
          }
        }
        createImageData(e = !1) {
          let t;
          let a;
          let i;
          let n = this.drawWidth;
          let l = this.drawHeight;
          let c = {
            width: n,
            height: l,
            interpolate: this.interpolate,
            kind: 0,
            data: null
          };
          let h = this.numComps;
          let u = this.width;
          let d = this.height;
          let f = this.bpc;
          let g = u * h * f + 7 >> 3;
          if (!e) {
            let e;
            if ("DeviceGray" === this.colorSpace.name && 1 === f ? e = r.ImageKind.GRAYSCALE_1BPP : "DeviceRGB" !== this.colorSpace.name || 8 !== f || this.needsDecode || (e = r.ImageKind.RGB_24BPP), e && !this.smask && !this.mask && n === u && l === d) {
              if (c.kind = e, t = this.getImageBytes(d * g), this.image instanceof s.DecodeStream) c.data = t; else {
                let e = new Uint8ClampedArray(t.length);
                e.set(t);
                c.data = e;
              }
              if (this.needsDecode) {
                r.assert(e === r.ImageKind.GRAYSCALE_1BPP, "PDFImage.createImageData: The image must be grayscale.");
                let t = c.data;
                for (function () {
                  let e = 0;
                  let a = t.length;
                }(); e < a; e++) t[e] ^= 255;
              }
              return c;
            }
            if (this.image instanceof o.JpegStream && !this.smask && !this.mask) {
              let e = d * g;
              switch (this.colorSpace.name) {
                case "DeviceGray":
                  e *= 3;
                case "DeviceRGB":
                case "DeviceCMYK":
                  c.kind = r.ImageKind.RGB_24BPP;
                  c.data = this.getImageBytes(e, n, l, !0);
                  return c;
              }
            }
          }
          let p = 0 | (t = this.getImageBytes(d * g)).length / g * l / d;
          let m = this.getComponents(t);
          e || this.smask || this.mask ? (c.kind = r.ImageKind.RGBA_32BPP, c.data = new Uint8ClampedArray(n * l * 4), a = 1, i = !0, this.fillOpacity(c.data, n, l, p, m)) : (c.kind = r.ImageKind.RGB_24BPP, c.data = new Uint8ClampedArray(n * l * 3), a = 0, i = !1);
          this.needsDecode && this.decodeBuffer(m);
          this.colorSpace.fillRgb(c.data, u, d, n, l, p, f, m, a);
          i && this.undoPreblend(c.data, n, p);
          return c;
        }
        fillGrayBuffer(e) {
          let t;
          let a;
          let i = this.numComps;
          if (1 !== i) throw new r.FormatError(`Reading gray scale from a color image: ${i}`);
          let n = this.width;
          let s = this.height;
          let o = this.bpc;
          let l = this.getImageBytes(s * (n * i * o + 7 >> 3));
          let c = this.getComponents(l);
          if (1 === o) {
            if (a = n * s, this.needsDecode) for (t = 0; t < a; ++t) e[t] = c[t] - 1 & 255; else for (t = 0; t < a; ++t) e[t] = 255 & -c[t];
            return;
          }
          this.needsDecode && this.decodeBuffer(c);
          a = n * s;
          let h = 255 / ((1 << o) - 1);
          for (t = 0; t < a; ++t) e[t] = h * c[t];
        }
        getImageBytes(e, t, a, r = !1) {
          this.image.reset();
          this.image.drawWidth = t || this.width;
          this.image.drawHeight = a || this.height;
          this.image.forceRGB = !!r;
          return this.image.getBytes(e, !0);
        }
      }
      t.PDFImage = u;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.Catalog = void 0;
      var r = a(8);
      var i = a(2);
      var n = a(5);
      var s = a(65);
      var o = a(9);
      var l = a(66);
      var c = a(24);
      var h = a(67);
      var u = a(59);
      var d = a(68);
      var f = a(70);
      function g(e) {
        e instanceof n.Dict && (e = e.get("D"));
        return Array.isArray(e) ? e : null;
      }
      class p {
        constructor(e, t) {
          this.pdfManager = e;
          this.xref = t;
          this._catDict = t.getCatalogObj();
          if (!(this._catDict instanceof n.Dict)) throw new i.FormatError("Catalog object is not a dictionary.");
          this.toplevelPagesDict;
          this._actualNumPages = null;
          this.fontCache = new n.RefSetCache();
          this.builtInCMapCache = new Map();
          this.standardFontDataCache = new Map();
          this.globalImageCache = new u.GlobalImageCache();
          this.pageKidsCountCache = new n.RefSetCache();
          this.pageIndexCache = new n.RefSetCache();
          this.nonBlendModesSet = new n.RefSet();
        }
        get version() {
          let e = this._catDict.get("Version");
          return i.shadow(this, "version", e instanceof n.Name ? e.name : null);
        }
        get lang() {
          let e = this._catDict.get("Lang");
          return i.shadow(this, "lang", "string" == typeof e ? i.stringToPDFString(e) : null);
        }
        get needsRendering() {
          let e = this._catDict.get("NeedsRendering");
          return i.shadow(this, "needsRendering", "boolean" == typeof e && e);
        }
        get collection() {
          let e = null;
          try {
            let t = this._catDict.get("Collection");
            t instanceof n.Dict && t.size > 0 && (e = t);
          } catch (e) {
            if (e instanceof r.MissingDataException) throw e;
            i.info("Cannot fetch Collection entry; assuming no collection is present.");
          }
          return i.shadow(this, "collection", e);
        }
        get acroForm() {
          let e = null;
          try {
            let t = this._catDict.get("AcroForm");
            t instanceof n.Dict && t.size > 0 && (e = t);
          } catch (e) {
            if (e instanceof r.MissingDataException) throw e;
            i.info("Cannot fetch AcroForm entry; assuming no forms are present.");
          }
          return i.shadow(this, "acroForm", e);
        }
        get acroFormRef() {
          let e = this._catDict.getRaw("AcroForm");
          return i.shadow(this, "acroFormRef", e instanceof n.Ref ? e : null);
        }
        get metadata() {
          let e = this._catDict.getRaw("Metadata");
          if (!(e instanceof n.Ref)) return i.shadow(this, "metadata", null);
          let t = null;
          try {
            let a = !(this.xref.encrypt && this.xref.encrypt.encryptMetadata);
            let r = this.xref.fetch(e, a);
            if (r instanceof o.BaseStream && r.dict instanceof n.Dict) {
              let e = r.dict.get("Type");
              let a = r.dict.get("Subtype");
              if (n.isName(e, "Metadata") && n.isName(a, "XML")) {
                let e = i.stringToUTF8String(r.getString());
                e && (t = new d.MetadataParser(e).serializable);
              }
            }
          } catch (e) {
            if (e instanceof r.MissingDataException) throw e;
            i.info(`Skipping invalid Metadata: "${e}".`);
          }
          return i.shadow(this, "metadata", t);
        }
        get markInfo() {
          let e = null;
          try {
            e = this._readMarkInfo();
          } catch (e) {
            if (e instanceof r.MissingDataException) throw e;
            i.warn("Unable to read mark info.");
          }
          return i.shadow(this, "markInfo", e);
        }
        _readMarkInfo() {
          let e = this._catDict.get("MarkInfo");
          if (!(e instanceof n.Dict)) return null;
          let t = Object.assign(Object.create(null), {
            Marked: !1,
            UserProperties: !1,
            Suspects: !1
          });
          for (let a in t) {
            if (!e.has(a)) continue;
            let r = e.get(a);
            "boolean" == typeof r && (t[a] = r);
          }
          return t;
        }
        get structTreeRoot() {
          let e = null;
          try {
            e = this._readStructTreeRoot();
          } catch (e) {
            if (e instanceof r.MissingDataException) throw e;
            i.warn("Unable read to structTreeRoot info.");
          }
          return i.shadow(this, "structTreeRoot", e);
        }
        _readStructTreeRoot() {
          let e = this._catDict.get("StructTreeRoot");
          if (!(e instanceof n.Dict)) return null;
          let t = new f.StructTreeRoot(e);
          t.init();
          return t;
        }
        get toplevelPagesDict() {
          let e = this._catDict.get("Pages");
          if (!(e instanceof n.Dict)) throw new i.FormatError("Invalid top-level pages dictionary.");
          return i.shadow(this, "toplevelPagesDict", e);
        }
        get documentOutline() {
          let e = null;
          try {
            e = this._readDocumentOutline();
          } catch (e) {
            if (e instanceof r.MissingDataException) throw e;
            i.warn("Unable to read document outline.");
          }
          return i.shadow(this, "documentOutline", e);
        }
        _readDocumentOutline() {
          let e = this._catDict.get("Outlines");
          if (!(e instanceof n.Dict) || !((e = e.getRaw("First")) instanceof n.Ref)) return null;
          let t = {
            items: []
          };
          let a = [{
            obj: e,
            parent: t
          }];
          let r = new n.RefSet();
          r.put(e);
          let s = this.xref;
          let o = new Uint8ClampedArray(3);
          for (; a.length > 0;) {
            let t = a.shift();
            let l = s.fetchIfRef(t.obj);
            if (null === l) continue;
            if (!l.has("Title")) throw new i.FormatError("Invalid outline item encountered.");
            let h = {
              url: null,
              dest: null
            };
            p.parseDestDictionary({
              destDict: l,
              resultObj: h,
              docBaseUrl: this.pdfManager.docBaseUrl
            });
            let u = l.get("Title");
            let d = l.get("F") || 0;
            let f = l.getArray("C");
            let g = l.get("Count");
            let m = o;
            Array.isArray(f) && 3 === f.length && (0 !== f[0] || 0 !== f[1] || 0 !== f[2]) && (m = c.ColorSpace.singletons.rgb.getRgb(f, 0));
            let b = {
              dest: h.dest,
              url: h.url,
              unsafeUrl: h.unsafeUrl,
              newWindow: h.newWindow,
              title: i.stringToPDFString(u),
              color: m,
              count: Number.isInteger(g) ? g : void 0,
              bold: !!(2 & d),
              italic: !!(1 & d),
              items: []
            };
            t.parent.items.push(b);
            (e = l.getRaw("First")) instanceof n.Ref && !r.has(e) && (a.push({
              obj: e,
              parent: b
            }), r.put(e));
            (e = l.getRaw("Next")) instanceof n.Ref && !r.has(e) && (a.push({
              obj: e,
              parent: t.parent
            }), r.put(e));
          }
          return t.items.length > 0 ? t.items : null;
        }
        get permissions() {
          let e = null;
          try {
            e = this._readPermissions();
          } catch (e) {
            if (e instanceof r.MissingDataException) throw e;
            i.warn("Unable to read permissions.");
          }
          return i.shadow(this, "permissions", e);
        }
        _readPermissions() {
          let e = this.xref.trailer.get("Encrypt");
          if (!(e instanceof n.Dict)) return null;
          let t = e.get("P");
          if ("number" != typeof t) return null;
          t += 0x100000000;
          let a = [];
          for (let e in i.PermissionFlag) {
            let r = i.PermissionFlag[e];
            t & r && a.push(r);
          }
          return a;
        }
        get optionalContentConfig() {
          let e = null;
          try {
            let t = this._catDict.get("OCProperties");
            if (!t) return i.shadow(this, "optionalContentConfig", null);
            let a = t.get("D");
            if (!a) return i.shadow(this, "optionalContentConfig", null);
            let r = t.get("OCGs");
            if (!Array.isArray(r)) return i.shadow(this, "optionalContentConfig", null);
            let s = [];
            let o = [];
            for (let e of r) {
              if (!(e instanceof n.Ref)) continue;
              o.push(e);
              let t = this.xref.fetchIfRef(e);
              s.push({
                id: e.toString(),
                name: "string" == typeof t.get("Name") ? i.stringToPDFString(t.get("Name")) : null,
                intent: "string" == typeof t.get("Intent") ? i.stringToPDFString(t.get("Intent")) : null
              });
            }
            (e = this._readOptionalContentConfig(a, o)).groups = s;
          } catch (e) {
            if (e instanceof r.MissingDataException) throw e;
            i.warn(`Unable to read optional content config: ${e}`);
          }
          return i.shadow(this, "optionalContentConfig", e);
        }
        _readOptionalContentConfig(e, t) {
          function a(e) {
            let a = [];
            if (Array.isArray(e)) for (let r of e) r instanceof n.Ref && t.includes(r) && a.push(r.toString());
            return a;
          }
          let r = this.xref;
          let s = new n.RefSet();
          return {
            name: "string" == typeof e.get("Name") ? i.stringToPDFString(e.get("Name")) : null,
            creator: "string" == typeof e.get("Creator") ? i.stringToPDFString(e.get("Creator")) : null,
            baseState: e.get("BaseState") instanceof n.Name ? e.get("BaseState").name : null,
            on: a(e.get("ON")),
            off: a(e.get("OFF")),
            order: function e(a, o = 0) {
              if (!Array.isArray(a)) return null;
              let l = [];
              for (let c of a) {
                if (c instanceof n.Ref && t.includes(c)) {
                  s.put(c);
                  l.push(c.toString());
                  continue;
                }
                let a = function (t, a) {
                  if (++a > 10) {
                    i.warn("parseNestedOrder - reached MAX_NESTED_LEVELS.");
                    return null;
                  }
                  let n = r.fetchIfRef(t);
                  if (!Array.isArray(n)) return null;
                  let s = r.fetchIfRef(n[0]);
                  if ("string" != typeof s) return null;
                  let o = e(n.slice(1), a);
                  return o && o.length ? {
                    name: i.stringToPDFString(s),
                    order: o
                  } : null;
                }(c, o);
                a && l.push(a);
              }
              if (o > 0) return l;
              let c = [];
              for (let e of t) s.has(e) || c.push(e.toString());
              c.length && l.push({
                name: null,
                order: c
              });
              return l;
            }(e.get("Order")),
            groups: null
          };
        }
        setActualNumPages(e = null) {
          this._actualNumPages = e;
        }
        get hasActualNumPages() {
          return null !== this._actualNumPages;
        }
        get _pagesCount() {
          let e = this.toplevelPagesDict.get("Count");
          if (!Number.isInteger(e)) throw new i.FormatError("Page count in top-level pages dictionary is not an integer.");
          return i.shadow(this, "_pagesCount", e);
        }
        get numPages() {
          return this.hasActualNumPages ? this._actualNumPages : this._pagesCount;
        }
        get destinations() {
          let e = this._readDests();
          let t = Object.create(null);
          if (e instanceof s.NameTree) for (let [a, r] of e.getAll()) {
            let e = g(r);
            e && (t[a] = e);
          } else e instanceof n.Dict && e.forEach(function (e, a) {
            let r = g(a);
            r && (t[e] = r);
          });
          return i.shadow(this, "destinations", t);
        }
        getDestination(e) {
          let t = this._readDests();
          if (t instanceof s.NameTree) {
            let a = g(t.get(e));
            if (a) return a;
            let r = this.destinations[e];
            if (r) {
              i.warn(`Found "${e}" at an incorrect position in the NameTree.`);
              return r;
            }
          } else if (t instanceof n.Dict) {
            let a = g(t.get(e));
            if (a) return a;
          }
          return null;
        }
        _readDests() {
          let e = this._catDict.get("Names");
          return e && e.has("Dests") ? new s.NameTree(e.getRaw("Dests"), this.xref) : this._catDict.has("Dests") ? this._catDict.get("Dests") : void 0;
        }
        get pageLabels() {
          let e = null;
          try {
            e = this._readPageLabels();
          } catch (e) {
            if (e instanceof r.MissingDataException) throw e;
            i.warn("Unable to read page labels.");
          }
          return i.shadow(this, "pageLabels", e);
        }
        _readPageLabels() {
          var _this6 = this;
          let e = this._catDict.getRaw("PageLabels");
          if (!e) return null;
          let t = Array(this.numPages);
          let a = null;
          let o = "";
          let l = new s.NumberTree(e, this.xref).getAll();
          let c = "";
          let h = 1;
          for (function () {
            let e = 0;
            let s = _this6.numPages;
          }(); e < s; e++) {
            let s = l.get(e);
            if (void 0 !== s) {
              if (!(s instanceof n.Dict)) throw new i.FormatError("PageLabel is not a dictionary.");
              if (s.has("Type") && !n.isName(s.get("Type"), "PageLabel")) throw new i.FormatError("Invalid type in PageLabel dictionary.");
              if (s.has("S")) {
                let e = s.get("S");
                if (!(e instanceof n.Name)) throw new i.FormatError("Invalid style in PageLabel dictionary.");
                a = e.name;
              } else a = null;
              if (s.has("P")) {
                let e = s.get("P");
                if ("string" != typeof e) throw new i.FormatError("Invalid prefix in PageLabel dictionary.");
                o = i.stringToPDFString(e);
              } else o = "";
              if (s.has("St")) {
                let e = s.get("St");
                if (!(Number.isInteger(e) && e >= 1)) throw new i.FormatError("Invalid start in PageLabel dictionary.");
                h = e;
              } else h = 1;
            }
            switch (a) {
              case "D":
                c = h;
                break;
              case "R":
              case "r":
                c = r.toRomanNumerals(h, "r" === a);
                break;
              case "A":
              case "a":
                let u = h - 1;
                let d = String.fromCharCode(("a" === a ? 97 : 65) + u % 26);
                let f = [];
                for (function () {
                  let e = 0;
                  let t = u / 26 | 0;
                }(); e <= t; e++) f.push(d);
                c = f.join("");
                break;
              default:
                if (a) throw new i.FormatError(`Invalid style "${a}" in PageLabel dictionary.`);
                c = "";
            }
            t[e] = o + c;
            h++;
          }
          return t;
        }
        get pageLayout() {
          let e = this._catDict.get("PageLayout");
          let t = "";
          if (e instanceof n.Name) switch (e.name) {
            case "SinglePage":
            case "OneColumn":
            case "TwoColumnLeft":
            case "TwoColumnRight":
            case "TwoPageLeft":
            case "TwoPageRight":
              t = e.name;
          }
          return i.shadow(this, "pageLayout", t);
        }
        get pageMode() {
          let e = this._catDict.get("PageMode");
          let t = "UseNone";
          if (e instanceof n.Name) switch (e.name) {
            case "UseNone":
            case "UseOutlines":
            case "UseThumbs":
            case "FullScreen":
            case "UseOC":
            case "UseAttachments":
              t = e.name;
          }
          return i.shadow(this, "pageMode", t);
        }
        get viewerPreferences() {
          let e = this._catDict.get("ViewerPreferences");
          if (!(e instanceof n.Dict)) return i.shadow(this, "viewerPreferences", null);
          let t = null;
          for (let a of e.getKeys()) {
            let r;
            let s = e.get(a);
            switch (a) {
              case "HideToolbar":
              case "HideMenubar":
              case "HideWindowUI":
              case "FitWindow":
              case "CenterWindow":
              case "DisplayDocTitle":
              case "PickTrayByPDFSize":
                "boolean" == typeof s && (r = s);
                break;
              case "NonFullScreenPageMode":
                if (s instanceof n.Name) switch (s.name) {
                  case "UseNone":
                  case "UseOutlines":
                  case "UseThumbs":
                  case "UseOC":
                    r = s.name;
                    break;
                  default:
                    r = "UseNone";
                }
                break;
              case "Direction":
                if (s instanceof n.Name) switch (s.name) {
                  case "L2R":
                  case "R2L":
                    r = s.name;
                    break;
                  default:
                    r = "L2R";
                }
                break;
              case "ViewArea":
              case "ViewClip":
              case "PrintArea":
              case "PrintClip":
                if (s instanceof n.Name) switch (s.name) {
                  case "MediaBox":
                  case "CropBox":
                  case "BleedBox":
                  case "TrimBox":
                  case "ArtBox":
                    r = s.name;
                    break;
                  default:
                    r = "CropBox";
                }
                break;
              case "PrintScaling":
                if (s instanceof n.Name) switch (s.name) {
                  case "None":
                  case "AppDefault":
                    r = s.name;
                    break;
                  default:
                    r = "AppDefault";
                }
                break;
              case "Duplex":
                if (s instanceof n.Name) switch (s.name) {
                  case "Simplex":
                  case "DuplexFlipShortEdge":
                  case "DuplexFlipLongEdge":
                    r = s.name;
                    break;
                  default:
                    r = "None";
                }
                break;
              case "PrintPageRange":
                Array.isArray(s) && s.length % 2 == 0 && s.every((e, t, a) => Number.isInteger(e) && e > 0 && (0 === t || e >= a[t - 1]) && e <= this.numPages) && (r = s);
                break;
              case "NumCopies":
                Number.isInteger(s) && s > 0 && (r = s);
                break;
              default:
                i.warn(`Ignoring non-standard key in ViewerPreferences: ${a}.`);
                continue;
            }
            if (void 0 === r) {
              i.warn(`Bad value, for key "${a}", in ViewerPreferences: ${s}.`);
              continue;
            }
            t || (t = Object.create(null));
            t[a] = r;
          }
          return i.shadow(this, "viewerPreferences", t);
        }
        get openAction() {
          let e = this._catDict.get("OpenAction");
          let t = Object.create(null);
          if (e instanceof n.Dict) {
            let a = new n.Dict(this.xref);
            a.set("A", e);
            let r = {
              url: null,
              dest: null,
              action: null
            };
            p.parseDestDictionary({
              destDict: a,
              resultObj: r
            });
            Array.isArray(r.dest) ? t.dest = r.dest : r.action && (t.action = r.action);
          } else Array.isArray(e) && (t.dest = e);
          return i.shadow(this, "openAction", i.objectSize(t) > 0 ? t : null);
        }
        get attachments() {
          let e = this._catDict.get("Names");
          let t = null;
          if (e instanceof n.Dict && e.has("EmbeddedFiles")) for (let [a, r] of new s.NameTree(e.getRaw("EmbeddedFiles"), this.xref).getAll()) {
            let e = new h.FileSpec(r, this.xref);
            t || (t = Object.create(null));
            t[i.stringToPDFString(a)] = e.serializable;
          }
          return i.shadow(this, "attachments", t);
        }
        get xfaImages() {
          let e = this._catDict.get("Names");
          let t = null;
          if (e instanceof n.Dict && e.has("XFAImages")) for (let [a, r] of new s.NameTree(e.getRaw("XFAImages"), this.xref).getAll()) {
            t || (t = new n.Dict(this.xref));
            t.set(a, r);
          }
          return i.shadow(this, "xfaImages", t);
        }
        _collectJavaScript() {
          let e = this._catDict.get("Names");
          let t = null;
          function a(e, a) {
            if (!(a instanceof n.Dict) || !n.isName(a.get("S"), "JavaScript")) return;
            let r = a.get("JS");
            if (r instanceof o.BaseStream) r = r.getString(); else if ("string" != typeof r) return;
            null === t && (t = new Map());
            t.set(e, i.stringToPDFString(r));
          }
          if (e instanceof n.Dict && e.has("JavaScript")) for (let [t, r] of new s.NameTree(e.getRaw("JavaScript"), this.xref).getAll()) a(t, r);
          let r = this._catDict.get("OpenAction");
          r && a("OpenAction", r);
          return t;
        }
        get javaScript() {
          let e = this._collectJavaScript();
          return i.shadow(this, "javaScript", e ? [...e.values()] : null);
        }
        get jsActions() {
          let e = this._collectJavaScript();
          let t = r.collectActions(this.xref, this._catDict, i.DocumentActionEventType);
          if (e) for (let [a, r] of (t || (t = Object.create(null)), e)) a in t ? t[a].push(r) : t[a] = [r];
          return i.shadow(this, "jsActions", t);
        }
        fontFallback(e, t) {
          let a = [];
          this.fontCache.forEach(function (e) {
            a.push(e);
          });
          return Promise.all(a).then(a => {
            for (let r of a) if (r.loadedName === e) {
              r.fallback(t);
              return;
            }
          });
        }
        cleanup(e = !1) {
          l.clearGlobalCaches();
          this.globalImageCache.clear(e);
          this.pageKidsCountCache.clear();
          this.pageIndexCache.clear();
          this.nonBlendModesSet.clear();
          let t = [];
          this.fontCache.forEach(function (e) {
            t.push(e);
          });
          return Promise.all(t).then(e => {
            for (let {
              dict
            } of e) delete dict.cacheKey;
            this.fontCache.clear();
            this.builtInCMapCache.clear();
            this.standardFontDataCache.clear();
          });
        }
        async getPageDict(e) {
          let t = [this.toplevelPagesDict];
          let a = new n.RefSet();
          let r = this._catDict.getRaw("Pages");
          r instanceof n.Ref && a.put(r);
          let s = this.xref;
          let o = this.pageKidsCountCache;
          let l = this.pageIndexCache;
          let c = 0;
          for (; t.length;) {
            let r = t.pop();
            if (r instanceof n.Ref) {
              let h = o.get(r);
              if (h >= 0 && c + h <= e) {
                c += h;
                continue;
              }
              if (a.has(r)) throw new i.FormatError("Pages tree contains circular reference.");
              a.put(r);
              let u = await s.fetchAsync(r);
              if (u instanceof n.Dict) {
                let t = u.getRaw("Type");
                if (t instanceof n.Ref && (t = await s.fetchAsync(t)), n.isName(t, "Page") || !u.has("Kids")) {
                  if (o.has(r) || o.put(r, 1), l.has(r) || l.put(r, c), c === e) return [u, r];
                  c++;
                  continue;
                }
              }
              t.push(u);
              continue;
            }
            if (!(r instanceof n.Dict)) throw new i.FormatError("Page dictionary kid reference points to wrong type of object.");
            let {
              objId
            } = r;
            let u = r.getRaw("Count");
            if (u instanceof n.Ref && (u = await s.fetchAsync(u)), Number.isInteger(u) && u >= 0 && (objId && !o.has(objId) && o.put(objId, u), c + u <= e)) {
              c += u;
              continue;
            }
            let d = r.getRaw("Kids");
            if (d instanceof n.Ref && (d = await s.fetchAsync(d)), !Array.isArray(d)) {
              let t = r.getRaw("Type");
              if (t instanceof n.Ref && (t = await s.fetchAsync(t)), n.isName(t, "Page") || !r.has("Kids")) {
                if (c === e) return [r, null];
                c++;
                continue;
              }
              throw new i.FormatError("Page dictionary kids object is not an array.");
            }
            for (let e = d.length - 1; e >= 0; e--) t.push(d[e]);
          }
          throw Error(`Page index ${e} not found.`);
        }
        async getAllPageDicts(e = !1) {
          let t = [{
            currentNode: this.toplevelPagesDict,
            posInKids: 0
          }];
          let a = new n.RefSet();
          let s = this._catDict.getRaw("Pages");
          s instanceof n.Ref && a.put(s);
          let o = new Map();
          let l = this.xref;
          let c = this.pageIndexCache;
          let h = 0;
          function u(t) {
            if (t instanceof r.XRefEntryException && !e) throw t;
            o.set(h++, [t, null]);
          }
          for (; t.length > 0;) {
            let e;
            let r = t[t.length - 1];
            let {
              currentNode,
              posInKids
            } = r;
            let p = currentNode.getRaw("Kids");
            if (p instanceof n.Ref) try {
              p = await l.fetchAsync(p);
            } catch (e) {
              u(e);
              break;
            }
            if (!Array.isArray(p)) {
              u(new i.FormatError("Page dictionary kids object is not an array."));
              break;
            }
            if (posInKids >= p.length) {
              t.pop();
              continue;
            }
            let m = p[posInKids];
            if (m instanceof n.Ref) {
              if (a.has(m)) {
                u(new i.FormatError("Pages tree contains circular reference."));
                break;
              }
              a.put(m);
              try {
                e = await l.fetchAsync(m);
              } catch (e) {
                u(e);
                break;
              }
            } else e = m;
            if (!(e instanceof n.Dict)) {
              u(new i.FormatError("Page dictionary kid reference points to wrong type of object."));
              break;
            }
            let b = e.getRaw("Type");
            if (b instanceof n.Ref) try {
              b = await l.fetchAsync(b);
            } catch (e) {
              u(e);
              break;
            }
            if (n.isName(b, "Page") || !e.has("Kids")) {
              var d;
              var f;
              d = e;
              (f = m instanceof n.Ref ? m : null) && !c.has(f) && c.put(f, h);
              o.set(h++, [d, f]);
            } else t.push({
              currentNode: e,
              posInKids: 0
            });
            r.posInKids++;
          }
          return o;
        }
        getPageIndex(e) {
          let t = this.pageIndexCache.get(e);
          if (void 0 !== t) return Promise.resolve(t);
          let a = this.xref;
          let r = 0;
          let s = t => {
            let o;
            let l;
            return (o = 0, a.fetchAsync(t).then(function (a) {
              if (n.isRefsEqual(t, e) && !n.isDict(a, "Page") && !(a instanceof n.Dict && !a.has("Type") && a.has("Contents"))) throw new i.FormatError("The reference does not point to a /Page dictionary.");
              if (!a) return null;
              if (!(a instanceof n.Dict)) throw new i.FormatError("Node must be a dictionary.");
              l = a.getRaw("Parent");
              return a.getAsync("Parent");
            }).then(function (e) {
              if (!e) return null;
              if (!(e instanceof n.Dict)) throw new i.FormatError("Parent must be a dictionary.");
              return e.getAsync("Kids");
            }).then(function (e) {
              if (!e) return null;
              let r = [];
              let s = !1;
              for (function () {
                let l = 0;
                let c = e.length;
              }(); l < c; l++) {
                let c = e[l];
                if (!(c instanceof n.Ref)) throw new i.FormatError("Kid must be a reference.");
                if (n.isRefsEqual(c, t)) {
                  s = !0;
                  break;
                }
                r.push(a.fetchAsync(c).then(function (e) {
                  if (!(e instanceof n.Dict)) throw new i.FormatError("Kid node must be a dictionary.");
                  e.has("Count") ? o += e.get("Count") : o++;
                }));
              }
              if (!s) throw new i.FormatError("Kid reference not found in parent's kids.");
              return Promise.all(r).then(function () {
                return [o, l];
              });
            })).then(t => {
              if (!t) {
                this.pageIndexCache.put(e, r);
                return r;
              }
              let [a, i] = t;
              r += a;
              return s(i);
            });
          };
          return s(e);
        }
        static parseDestDictionary(e) {
          let t = e.destDict;
          if (!(t instanceof n.Dict)) {
            i.warn("parseDestDictionary: `destDict` must be a dictionary.");
            return;
          }
          let a = e.resultObj;
          if ("object" != typeof a) {
            i.warn("parseDestDictionary: `resultObj` must be an object.");
            return;
          }
          let s = e.docBaseUrl || null;
          let l = t.get("A");
          let c;
          let h;
          if (!(l instanceof n.Dict) && (t.has("Dest") ? l = t.get("Dest") : (l = t.get("AA")) instanceof n.Dict && (l.has("D") ? l = l.get("D") : l.has("U") && (l = l.get("U")))), l instanceof n.Dict) {
            let e = l.get("S");
            if (!(e instanceof n.Name)) {
              i.warn("parseDestDictionary: Invalid type in Action dictionary.");
              return;
            }
            let t = e.name;
            switch (t) {
              case "ResetForm":
                let s = l.get("Flags");
                let u = [];
                let d = [];
                for (let e of l.get("Fields") || []) e instanceof n.Ref ? d.push(e.toString()) : "string" == typeof e && u.push(i.stringToPDFString(e));
                a.resetForm = {
                  fields: u,
                  refs: d,
                  include: (("number" == typeof s ? s : 0) & 1) == 0
                };
                break;
              case "URI":
                (c = l.get("URI")) instanceof n.Name && (c = "/" + c.name);
                break;
              case "GoTo":
                h = l.get("D");
                break;
              case "Launch":
              case "GoToR":
                let f = l.get("F");
                f instanceof n.Dict ? c = f.get("F") || null : "string" == typeof f && (c = f);
                let g = l.get("D");
                if (g && (g instanceof n.Name && (g = g.name), "string" == typeof c)) {
                  let e = c.split("#")[0];
                  "string" == typeof g ? c = e + "#" + g : Array.isArray(g) && (c = e + "#" + JSON.stringify(g));
                }
                let p = l.get("NewWindow");
                "boolean" == typeof p && (a.newWindow = p);
                break;
              case "Named":
                let m = l.get("N");
                m instanceof n.Name && (a.action = m.name);
                break;
              case "JavaScript":
                let b;
                let y = l.get("JS");
                y instanceof o.BaseStream ? b = y.getString() : "string" == typeof y && (b = y);
                let w = b && r.recoverJsURL(i.stringToPDFString(b));
                if (w) {
                  c = w.url;
                  a.newWindow = w.newWindow;
                  break;
                }
              default:
                if ("JavaScript" === t || "SubmitForm" === t) break;
                i.warn(`parseDestDictionary - unsupported action: "${t}".`);
            }
          } else t.has("Dest") && (h = t.get("Dest"));
          if ("string" == typeof c) {
            let e = i.createValidAbsoluteUrl(c, s, {
              addDefaultProtocol: !0,
              tryConvertEncoding: !0
            });
            e && (a.url = e.href);
            a.unsafeUrl = c;
          }
          h && (h instanceof n.Name && (h = h.name), ("string" == typeof h || Array.isArray(h)) && (a.dest = h));
        }
      }
      t.Catalog = p;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.NumberTree = t.NameTree = void 0;
      var r = a(5);
      var i = a(2);
      class n {
        constructor(e, t, a) {
          this.constructor === n && i.unreachable("Cannot initialize NameOrNumberTree.");
          this.root = e;
          this.xref = t;
          this._type = a;
        }
        getAll() {
          let e = new Map();
          if (!this.root) return e;
          let t = this.xref;
          let a = new r.RefSet();
          a.put(this.root);
          let n = [this.root];
          for (; n.length > 0;) {
            let s = t.fetchIfRef(n.shift());
            if (!(s instanceof r.Dict)) continue;
            if (s.has("Kids")) {
              let e = s.get("Kids");
              for (function () {
                let t = 0;
                let r = e.length;
              }(); t < r; t++) {
                let r = e[t];
                if (a.has(r)) throw new i.FormatError(`Duplicate entry in "${this._type}" tree.`);
                n.push(r);
                a.put(r);
              }
              continue;
            }
            let o = s.get(this._type);
            if (Array.isArray(o)) for (function () {
              let a = 0;
              let r = o.length;
            }(); a < r; a += 2) e.set(t.fetchIfRef(o[a]), t.fetchIfRef(o[a + 1]));
          }
          return e;
        }
        get(e) {
          if (!this.root) return null;
          let t = this.xref;
          let a = t.fetchIfRef(this.root);
          let r = 0;
          for (; a.has("Kids");) {
            if (++r > 10) {
              i.warn(`Search depth limit reached for "${this._type}" tree.`);
              return null;
            }
            let n = a.get("Kids");
            if (!Array.isArray(n)) return null;
            let s = 0;
            let o = n.length - 1;
            for (; s <= o;) {
              let r = s + o >> 1;
              let i = t.fetchIfRef(n[r]).get("Limits");
              if (e < t.fetchIfRef(i[0])) o = r - 1; else if (e > t.fetchIfRef(i[1])) s = r + 1; else {
                a = t.fetchIfRef(n[r]);
                break;
              }
            }
            if (s > o) return null;
          }
          let n = a.get(this._type);
          if (Array.isArray(n)) {
            let a = 0;
            let r = n.length - 2;
            for (; a <= r;) {
              let i = a + r >> 1;
              let s = i + (1 & i);
              let o = t.fetchIfRef(n[s]);
              if (e < o) r = s - 2; else {
                if (!(e > o)) return t.fetchIfRef(n[s + 1]);
                a = s + 2;
              }
            }
          }
          return null;
        }
      }
      t.NameTree = class extends n {
        constructor(e, t) {
          super(e, t, "Names");
        }
      };
      t.NumberTree = class extends n {
        constructor(e, t) {
          super(e, t, "Nums");
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.clearGlobalCaches = function () {
        r.clearPrimitiveCaches();
        i.clearUnicodeCaches();
      };
      var r = a(5);
      var i = a(21);
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.FileSpec = void 0;
      var r = a(2);
      var i = a(9);
      var n = a(5);
      function s(e) {
        return e.has("UF") ? e.get("UF") : e.has("F") ? e.get("F") : e.has("Unix") ? e.get("Unix") : e.has("Mac") ? e.get("Mac") : e.has("DOS") ? e.get("DOS") : null;
      }
      t.FileSpec = class {
        constructor(e, t) {
          if (!(e instanceof n.Dict)) return;
          this.xref = t;
          this.root = e;
          e.has("FS") && (this.fs = e.get("FS"));
          this.description = e.has("Desc") ? r.stringToPDFString(e.get("Desc")) : "";
          e.has("RF") && r.warn("Related file specifications are not supported");
          this.contentAvailable = !0;
          e.has("EF") || (this.contentAvailable = !1, r.warn("Non-embedded file specifications are not supported"));
        }
        get filename() {
          if (!this._filename && this.root) {
            let e = s(this.root) || "unnamed";
            this._filename = r.stringToPDFString(e).replace(/\\\\/g, "\\").replace(/\\\//g, "/").replace(/\\/g, "/");
          }
          return this._filename;
        }
        get content() {
          if (!this.contentAvailable) return null;
          !this.contentRef && this.root && (this.contentRef = s(this.root.get("EF")));
          let e = null;
          if (this.contentRef) {
            let t = this.xref.fetchIfRef(this.contentRef);
            t instanceof i.BaseStream ? e = t.getBytes() : r.warn("Embedded file specification points to non-existing/invalid content");
          } else r.warn("Embedded file specification does not have a content");
          return e;
        }
        get serializable() {
          return {
            filename: this.filename,
            content: this.content
          };
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.MetadataParser = void 0;
      var r = a(69);
      t.MetadataParser = class {
        constructor(e) {
          e = this._repair(e);
          let t = new r.SimpleXMLParser({
            lowerCaseName: !0
          }).parseFromString(e);
          this._metadataMap = new Map();
          this._data = e;
          t && this._parse(t);
        }
        _repair(e) {
          return e.replace(/^[^<]+/, "").replace(/>\\376\\377([^<]+)/g, function (e, t) {
            let a = t.replace(/\\([0-3])([0-7])([0-7])/g, function (e, t, a, r) {
              return String.fromCharCode(64 * t + 8 * a + 1 * r);
            }).replace(/&(amp|apos|gt|lt|quot);/g, function (e, t) {
              switch (t) {
                case "amp":
                  return "&";
                case "apos":
                  return "'";
                case "gt":
                  return ">";
                case "lt":
                  return "<";
                case "quot":
                  return '"';
              }
              throw Error(`_repair: ${t} isn't defined.`);
            });
            let r = [];
            for (function () {
              let e = 0;
              let t = a.length;
            }(); e < t; e += 2) {
              let t = 256 * a.charCodeAt(e) + a.charCodeAt(e + 1);
              t >= 32 && t < 127 && 60 !== t && 62 !== t && 38 !== t ? r.push(String.fromCharCode(t)) : r.push("&#x" + (65536 + t).toString(16).substring(1) + ";");
            }
            return ">" + r.join("");
          });
        }
        _getSequence(e) {
          let t = e.nodeName;
          return "rdf:bag" !== t && "rdf:seq" !== t && "rdf:alt" !== t ? null : e.childNodes.filter(e => "rdf:li" === e.nodeName);
        }
        _parseArray(e) {
          if (!e.hasChildNodes()) return;
          let [t] = e.childNodes;
          let a = this._getSequence(t) || [];
          this._metadataMap.set(e.nodeName, a.map(e => e.textContent.trim()));
        }
        _parse(e) {
          let t = e.documentElement;
          if ("rdf:rdf" !== t.nodeName) for (t = t.firstChild; t && "rdf:rdf" !== t.nodeName;) t = t.nextSibling;
          if (t && "rdf:rdf" === t.nodeName && t.hasChildNodes()) {
            for (let e of t.childNodes) if ("rdf:description" === e.nodeName) for (let t of e.childNodes) {
              let e = t.nodeName;
              switch (e) {
                case "#text":
                  continue;
                case "dc:creator":
                case "dc:subject":
                  this._parseArray(t);
                  continue;
              }
              this._metadataMap.set(e, t.textContent.trim());
            }
          }
        }
        get serializable() {
          return {
            parsedData: this._metadataMap,
            rawData: this._data
          };
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.XMLParserErrorCode = t.XMLParserBase = t.SimpleXMLParser = t.SimpleDOMNode = void 0;
      var r = a(8);
      let i = {
        NoError: 0,
        EndOfDocument: -1,
        UnterminatedCdat: -2,
        UnterminatedXmlDeclaration: -3,
        UnterminatedDoctypeDeclaration: -4,
        UnterminatedComment: -5,
        MalformedElement: -6,
        OutOfMemory: -7,
        UnterminatedAttributeValue: -8,
        UnterminatedElement: -9,
        ElementNeverBegun: -10
      };
      function n(e, t) {
        let a = e[t];
        return " " === a || "\n" === a || "\r" === a || "	" === a;
      }
      t.XMLParserErrorCode = i;
      class s {
        _resolveEntities(e) {
          return e.replace(/&([^;]+);/g, (e, t) => {
            if ("#x" === t.substring(0, 2)) return String.fromCodePoint(parseInt(t.substring(2), 16));
            if ("#" === t.substring(0, 1)) return String.fromCodePoint(parseInt(t.substring(1), 10));
            switch (t) {
              case "lt":
                return "<";
              case "gt":
                return ">";
              case "amp":
                return "&";
              case "quot":
                return '"';
              case "apos":
                return "'";
            }
            return this.onResolveEntity(t);
          });
        }
        _parseContent(e, t) {
          let a = [];
          let r = t;
          function i() {
            for (; r < e.length && n(e, r);) ++r;
          }
          for (; r < e.length && !n(e, r) && ">" !== e[r] && "/" !== e[r];) ++r;
          let s = e.substring(t, r);
          for (i(); r < e.length && ">" !== e[r] && "/" !== e[r] && "?" !== e[r];) {
            i();
            let t = "";
            let s = "";
            for (; r < e.length && !n(e, r) && "=" !== e[r];) {
              t += e[r];
              ++r;
            }
            if (i(), "=" !== e[r]) return null;
            ++r;
            i();
            let o = e[r];
            if ('"' !== o && "'" !== o) return null;
            let l = e.indexOf(o, ++r);
            if (l < 0) return null;
            s = e.substring(r, l);
            a.push({
              name: t,
              value: this._resolveEntities(s)
            });
            r = l + 1;
            i();
          }
          return {
            name: s,
            attributes: a,
            parsed: r - t
          };
        }
        _parseProcessingInstruction(e, t) {
          let a = t;
          for (; a < e.length && !n(e, a) && ">" !== e[a] && "?" !== e[a] && "/" !== e[a];) ++a;
          let r = e.substring(t, a);
          !function () {
            for (; a < e.length && n(e, a);) ++a;
          }();
          let i = a;
          for (; a < e.length && ("?" !== e[a] || ">" !== e[a + 1]);) ++a;
          return {
            name: r,
            value: e.substring(i, a),
            parsed: a - t
          };
        }
        parseXml(e) {
          let t = 0;
          for (; t < e.length;) {
            let a = e[t];
            let r = t;
            if ("<" === a) {
              let t;
              switch (e[++r]) {
                case "/":
                  if (++r, (t = e.indexOf(">", r)) < 0) {
                    this.onError(i.UnterminatedElement);
                    return;
                  }
                  this.onEndElement(e.substring(r, t));
                  r = t + 1;
                  break;
                case "?":
                  ++r;
                  let a = this._parseProcessingInstruction(e, r);
                  if ("?>" !== e.substring(r + a.parsed, r + a.parsed + 2)) {
                    this.onError(i.UnterminatedXmlDeclaration);
                    return;
                  }
                  this.onPi(a.name, a.value);
                  r += a.parsed + 2;
                  break;
                case "!":
                  if ("--" === e.substring(r + 1, r + 3)) {
                    if ((t = e.indexOf("--\x3e", r + 3)) < 0) {
                      this.onError(i.UnterminatedComment);
                      return;
                    }
                    this.onComment(e.substring(r + 3, t));
                    r = t + 3;
                  } else if ("[CDATA[" === e.substring(r + 1, r + 8)) {
                    if ((t = e.indexOf("]]>", r + 8)) < 0) {
                      this.onError(i.UnterminatedCdat);
                      return;
                    }
                    this.onCdata(e.substring(r + 8, t));
                    r = t + 3;
                  } else if ("DOCTYPE" === e.substring(r + 1, r + 8)) {
                    let a = e.indexOf("[", r + 8);
                    let n = !1;
                    if ((t = e.indexOf(">", r + 8)) < 0) {
                      this.onError(i.UnterminatedDoctypeDeclaration);
                      return;
                    }
                    if (a > 0 && t > a) {
                      if ((t = e.indexOf("]>", r + 8)) < 0) {
                        this.onError(i.UnterminatedDoctypeDeclaration);
                        return;
                      }
                      n = !0;
                    }
                    let s = e.substring(r + 8, t + (n ? 1 : 0));
                    this.onDoctype(s);
                    r = t + (n ? 2 : 1);
                  } else {
                    this.onError(i.MalformedElement);
                    return;
                  }
                  break;
                default:
                  let n = this._parseContent(e, r);
                  if (null === n) {
                    this.onError(i.MalformedElement);
                    return;
                  }
                  let s = !1;
                  if ("/>" === e.substring(r + n.parsed, r + n.parsed + 2)) s = !0; else if (">" !== e.substring(r + n.parsed, r + n.parsed + 1)) {
                    this.onError(i.UnterminatedElement);
                    return;
                  }
                  this.onBeginElement(n.name, n.attributes, s);
                  r += n.parsed + (s ? 2 : 1);
              }
            } else {
              for (; r < e.length && "<" !== e[r];) r++;
              let a = e.substring(t, r);
              this.onText(this._resolveEntities(a));
            }
            t = r;
          }
        }
        onResolveEntity(e) {
          return `&${e};`;
        }
        onPi(e, t) { }
        onComment(e) { }
        onCdata(e) { }
        onDoctype(e) { }
        onText(e) { }
        onBeginElement(e, t, a) { }
        onEndElement(e) { }
        onError(e) { }
      }
      t.XMLParserBase = s;
      class o {
        constructor(e, t) {
          this.nodeName = e;
          this.nodeValue = t;
          Object.defineProperty(this, "parentNode", {
            value: null,
            writable: !0
          });
        }
        get firstChild() {
          return this.childNodes && this.childNodes[0];
        }
        get nextSibling() {
          let e = this.parentNode.childNodes;
          if (!e) return;
          let t = e.indexOf(this);
          if (-1 !== t) return e[t + 1];
        }
        get textContent() {
          return this.childNodes ? this.childNodes.map(function (e) {
            return e.textContent;
          }).join("") : this.nodeValue || "";
        }
        hasChildNodes() {
          return this.childNodes && this.childNodes.length > 0;
        }
        searchNode(e, t) {
          if (t >= e.length) return this;
          let a = e[t];
          let r = [];
          let i = this;
          for (; ;) {
            if (a.name === i.nodeName) {
              if (0 === a.pos) {
                let a = i.searchNode(e, t + 1);
                if (null !== a) return a;
              } else {
                if (0 === r.length) return null;
                let [n] = r.pop();
                let s = 0;
                for (let r of n.childNodes) if (a.name === r.nodeName) {
                  if (s === a.pos) return r.searchNode(e, t + 1);
                  s++;
                }
                return i.searchNode(e, t + 1);
              }
            }
            if (i.childNodes && 0 !== i.childNodes.length) {
              r.push([i, 0]);
              i = i.childNodes[0];
            } else {
              if (0 === r.length) return null;
              for (; 0 !== r.length;) {
                let [e, t] = r.pop();
                let a = t + 1;
                if (a < e.childNodes.length) {
                  r.push([e, a]);
                  i = e.childNodes[a];
                  break;
                }
              }
              if (0 === r.length) return null;
            }
          }
        }
        dump(e) {
          if ("#text" === this.nodeName) {
            e.push(r.encodeToXmlString(this.nodeValue));
            return;
          }
          if (e.push(`<${this.nodeName}`), this.attributes) for (let t of this.attributes) e.push(` ${t.name}="${r.encodeToXmlString(t.value)}"`);
          if (this.hasChildNodes()) {
            for (let t of (e.push(">"), this.childNodes)) t.dump(e);
            e.push(`</${this.nodeName}>`);
          } else this.nodeValue ? e.push(`>${r.encodeToXmlString(this.nodeValue)}</${this.nodeName}>`) : e.push("/>");
        }
      }
      t.SimpleDOMNode = o;
      t.SimpleXMLParser = class extends s {
        constructor({
          hasAttributes: e = !1,
          lowerCaseName: t = !1
        }) {
          super();
          this._currentFragment = null;
          this._stack = null;
          this._errorCode = i.NoError;
          this._hasAttributes = e;
          this._lowerCaseName = t;
        }
        parseFromString(e) {
          if (this._currentFragment = [], this._stack = [], this._errorCode = i.NoError, this.parseXml(e), this._errorCode !== i.NoError) return;
          let [t] = this._currentFragment;
          if (t) return {
            documentElement: t
          };
        }
        onText(e) {
          if (function (e) {
            for (function () {
              let t = 0;
              let a = e.length;
            }(); t < a; t++) if (!n(e, t)) return !1;
            return !0;
          }(e)) return;
          let t = new o("#text", e);
          this._currentFragment.push(t);
        }
        onCdata(e) {
          let t = new o("#text", e);
          this._currentFragment.push(t);
        }
        onBeginElement(e, t, a) {
          this._lowerCaseName && (e = e.toLowerCase());
          let r = new o(e);
          r.childNodes = [];
          this._hasAttributes && (r.attributes = t);
          this._currentFragment.push(r);
          a || (this._stack.push(this._currentFragment), this._currentFragment = r.childNodes);
        }
        onEndElement(e) {
          this._currentFragment = this._stack.pop() || [];
          let t = this._currentFragment[this._currentFragment.length - 1];
          if (t) for (function () {
            let e = 0;
            let a = t.childNodes.length;
          }(); e < a; e++) t.childNodes[e].parentNode = t;
        }
        onError(e) {
          this._errorCode = e;
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.StructTreeRoot = t.StructTreePage = void 0;
      var r = a(5);
      var i = a(2);
      var n = a(65);
      let s = {
        PAGE_CONTENT: "PAGE_CONTENT",
        STREAM_CONTENT: "STREAM_CONTENT",
        OBJECT: "OBJECT",
        ELEMENT: "ELEMENT"
      };
      t.StructTreeRoot = class {
        constructor(e) {
          this.dict = e;
          this.roleMap = new Map();
        }
        init() {
          this.readRoleMap();
        }
        readRoleMap() {
          let e = this.dict.get("RoleMap");
          e instanceof r.Dict && e.forEach((e, t) => {
            t instanceof r.Name && this.roleMap.set(e, t.name);
          });
        }
      };
      class o {
        constructor(e, t) {
          this.tree = e;
          this.dict = t;
          this.kids = [];
          this.parseKids();
        }
        get role() {
          let e = this.dict.get("S");
          let t = e instanceof r.Name ? e.name : "";
          let {
            root
          } = this.tree;
          return root.roleMap.has(t) ? root.roleMap.get(t) : t;
        }
        parseKids() {
          let e = null;
          let t = this.dict.getRaw("Pg");
          t instanceof r.Ref && (e = t.toString());
          let a = this.dict.get("K");
          if (Array.isArray(a)) for (let t of a) {
            let a = this.parseKid(e, t);
            a && this.kids.push(a);
          } else {
            let t = this.parseKid(e, a);
            t && this.kids.push(t);
          }
        }
        parseKid(e, t) {
          if (Number.isInteger(t)) return this.tree.pageDict.objId !== e ? null : new l({
            type: s.PAGE_CONTENT,
            mcid: t,
            pageObjId: e
          });
          let a = null;
          if (t instanceof r.Ref ? a = this.dict.xref.fetch(t) : t instanceof r.Dict && (a = t), !a) return null;
          let i = a.getRaw("Pg");
          i instanceof r.Ref && (e = i.toString());
          let n = a.get("Type") instanceof r.Name ? a.get("Type").name : null;
          return "MCR" === n ? this.tree.pageDict.objId !== e ? null : new l({
            type: s.STREAM_CONTENT,
            refObjId: a.getRaw("Stm") instanceof r.Ref ? a.getRaw("Stm").toString() : null,
            pageObjId: e,
            mcid: a.get("MCID")
          }) : "OBJR" === n ? this.tree.pageDict.objId !== e ? null : new l({
            type: s.OBJECT,
            refObjId: a.getRaw("Obj") instanceof r.Ref ? a.getRaw("Obj").toString() : null,
            pageObjId: e
          }) : new l({
            type: s.ELEMENT,
            dict: a
          });
        }
      }
      class l {
        constructor({
          type: e,
          dict: t = null,
          mcid: a = null,
          pageObjId: r = null,
          refObjId: i = null
        }) {
          this.type = e;
          this.dict = t;
          this.mcid = a;
          this.pageObjId = r;
          this.refObjId = i;
          this.parentNode = null;
        }
      }
      t.StructTreePage = class {
        constructor(e, t) {
          this.root = e;
          this.rootDict = e ? e.dict : null;
          this.pageDict = t;
          this.nodes = [];
        }
        parse() {
          if (!this.root || !this.rootDict) return;
          let e = this.rootDict.get("ParentTree");
          if (!e) return;
          let t = this.pageDict.get("StructParents");
          if (!Number.isInteger(t)) return;
          let a = new n.NumberTree(e, this.rootDict.xref).get(t);
          if (!Array.isArray(a)) return;
          let i = new Map();
          for (let e of a) e instanceof r.Ref && this.addNode(this.rootDict.xref.fetch(e), i);
        }
        addNode(e, t, a = 0) {
          if (a > 40) {
            i.warn("StructTree MAX_DEPTH reached.");
            return null;
          }
          if (t.has(e)) return t.get(e);
          let n = new o(this, e);
          t.set(e, n);
          let l = e.get("P");
          if (!l || r.isName(l.get("Type"), "StructTreeRoot")) {
            this.addTopLevelNode(e, n) || t.$$delete(e);
            return n;
          }
          let c = this.addNode(l, t, a + 1);
          if (!c) return n;
          let h = !1;
          for (let t of c.kids) t.type === s.ELEMENT && t.dict === e && (t.parentNode = n, h = !0);
          h || t.$$delete(e);
          return n;
        }
        addTopLevelNode(e, t) {
          let a = this.rootDict.get("K");
          if (!a) return !1;
          if (a instanceof r.Dict) return a.objId === e.objId && (this.nodes[0] = t, !0);
          if (!Array.isArray(a)) return !0;
          let i = !1;
          for (let r = 0; r < a.length; r++) {
            let n = a[r];
            n && n.toString() === e.objId && (this.nodes[r] = t, i = !0);
          }
          return i;
        }
        get serializable() {
          let e = Object.create(null);
          for (let t of (e.children = [], e.role = "Root", this.nodes)) t && function e(t, a, r = 0) {
            if (r > 40) {
              i.warn("StructTree too deep to be fully serialized.");
              return;
            }
            let n = Object.create(null);
            n.role = t.role;
            n.children = [];
            a.children.push(n);
            let o = t.dict.get("Alt");
            "string" == typeof o && (n.alt = i.stringToPDFString(o));
            let l = t.dict.get("Lang");
            for (let a of ("string" == typeof l && (n.lang = i.stringToPDFString(l)), t.kids)) {
              let t = a.type === s.ELEMENT ? a.parentNode : null;
              if (t) {
                e(t, n, r + 1);
                continue;
              }
              a.type === s.PAGE_CONTENT || a.type === s.STREAM_CONTENT ? n.children.push({
                type: "content",
                id: `page${a.pageObjId}_mcid${a.mcid}`
              }) : a.type === s.OBJECT && n.children.push({
                type: "object",
                id: a.refObjId
              });
            }
          }(t, e);
          return e;
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.ObjectLoader = void 0;
      var r = a(5);
      var i = a(9);
      var n = a(8);
      var s = a(2);
      t.ObjectLoader = class {
        constructor(e, t, a) {
          this.dict = e;
          this.keys = t;
          this.xref = a;
          this.refSet = null;
        }
        async load() {
          if (this.xref.stream.isDataLoaded) return;
          let {
            keys,
            dict
          } = this;
          this.refSet = new r.RefSet();
          let a = [];
          for (function () {
            let r = 0;
            let i = keys.length;
          }(); r < i; r++) {
            let i = dict.getRaw(keys[r]);
            void 0 !== i && a.push(i);
          }
          return this._walk(a);
        }
        async _walk(e) {
          let t = [];
          let a = [];
          for (; e.length;) {
            let o = e.pop();
            if (o instanceof r.Ref) {
              if (this.refSet.has(o)) continue;
              try {
                this.refSet.put(o);
                o = this.xref.fetch(o);
              } catch (e) {
                if (!(e instanceof n.MissingDataException)) {
                  s.warn(`ObjectLoader._walk - requesting all data: "${e}".`);
                  this.refSet = null;
                  let {
                    manager
                  } = this.xref.stream;
                  return manager.requestAllChunks();
                }
                t.push(o);
                a.push({
                  begin: e.begin,
                  end: e.end
                });
              }
            }
            if (o instanceof i.BaseStream) {
              let e = o.getBaseStreams();
              if (e) {
                let r = !1;
                for (let t of e) t.isDataLoaded || (r = !0, a.push({
                  begin: t.start,
                  end: t.end
                }));
                r && t.push(o);
              }
            }
            !function (e, t) {
              if (e instanceof r.Dict) e = e.getRawValues(); else if (e instanceof i.BaseStream) e = e.dict.getRawValues(); else if (!Array.isArray(e)) return;
              for (let a of e) (a instanceof r.Ref || a instanceof r.Dict || a instanceof i.BaseStream || Array.isArray(a)) && t.push(a);
            }(o, e);
          }
          if (a.length) {
            for (let e of (await this.xref.stream.manager.requestRanges(a), t)) e instanceof r.Ref && this.refSet.remove(e);
            return this._walk(t);
          }
          this.refSet = null;
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.incrementalUpdate = function ({
        originalData: e,
        xrefInfo: t,
        newRefs: a,
        xref: o = null,
        hasXfa: d = !1,
        xfaDatasetsRef: f = null,
        hasXfaDatasetsEntry: g = !1,
        acroFormRef: p = null,
        acroForm: m = null,
        xfaData: b = null
      }) {
        let y;
        let w;
        d && function ({
          xfaData: e,
          xfaDatasetsRef: t,
          hasXfaDatasetsEntry: a,
          acroFormRef: i,
          acroForm: o,
          newRefs: l,
          xref: h,
          xrefInfo: u
        }) {
          if (null === h) return;
          if (!a) {
            if (!i) {
              r.warn("XFA - Cannot save it");
              return;
            }
            let e = o.get("XFA");
            let a = e.slice();
            a.splice(2, 0, "datasets");
            a.splice(3, 0, t);
            o.set("XFA", a);
            let n = h.encrypt;
            let s = null;
            n && (s = n.createCipherTransform(i.num, i.gen));
            let u = [`${i.num} ${i.gen} obj
`];
            c(o, u, s);
            u.push("\n");
            o.set("XFA", e);
            l.push({
              ref: i,
              data: u.join("")
            });
          }
          null === e && (e = function (e, t) {
            let a = new s.SimpleXMLParser({
              hasAttributes: !0
            }).parseFromString(e);
            for (let {
              xfa
            } of t) {
              if (!xfa) continue;
              let {
                path,
                value
              } = xfa;
              if (!path) continue;
              let o = a.documentElement.searchNode(n.parseXFAPath(path), 0);
              o ? o.childNodes = [new s.SimpleDOMNode("#text", value)] : r.warn(`Node not found for path: ${path}`);
            }
            let i = [];
            a.documentElement.dump(i);
            return i.join("");
          }(h.fetchIfRef(t).getString(), l));
          let d = h.encrypt;
          d && (e = d.createCipherTransform(t.num, t.gen).encryptString(e));
          let f = `${t.num} ${t.gen} obj
<< /Type /EmbeddedFile /Length ${e.length}>>
stream
` + e + "\nendstream\nendobj\n";
          l.push({
            ref: t,
            data: f
          });
        }({
          xfaData: b,
          xfaDatasetsRef: f,
          hasXfaDatasetsEntry: g,
          acroFormRef: p,
          acroForm: m,
          newRefs: a,
          xref: o,
          xrefInfo: t
        });
        let x = new i.Dict(null);
        let S = t.newRef;
        let k = e[e.length - 1];
        10 === k || 13 === k ? (y = [], w = e.length) : (y = ["\n"], w = e.length + 1);
        x.set("Size", S.num + 1);
        x.set("Prev", t.startXRef);
        x.set("Type", i.Name.get("XRef"));
        null !== t.rootRef && x.set("Root", t.rootRef);
        null !== t.infoRef && x.set("Info", t.infoRef);
        null !== t.encryptRef && x.set("Encrypt", t.encryptRef);
        a.push({
          ref: S,
          data: ""
        });
        let A = [[0, 1, 65535]];
        let v = [0, 1];
        let C = 0;
        for (let {
          ref,
          data
        } of a = a.sort((e, t) => e.ref.num - t.ref.num)) {
          C = Math.max(C, w);
          A.push([1, w, Math.min(ref.gen, 65535)]);
          w += data.length;
          v.push(ref.num, 1);
          y.push(data);
        }
        if (x.set("Index", v), Array.isArray(t.fileIds) && t.fileIds.length > 0) {
          let e = function (e, t) {
            let a = Math.floor(Date.now() / 1e3);
            let i = t.filename || "";
            let n = [a.toString(), i, e.toString()];
            let s = n.reduce((e, t) => e + t.length, 0);
            for (let e of Object.values(t.info)) {
              n.push(e);
              s += e.length;
            }
            let o = new Uint8Array(s);
            let c = 0;
            for (let e of n) {
              u(e, c, o);
              c += e.length;
            }
            return r.bytesToString(l.calculateMD5(o));
          }(w, t);
          x.set("ID", [t.fileIds[0], e]);
        }
        let O = [1, Math.ceil(Math.log2(C) / 8), 2];
        let F = (O[0] + O[1] + O[2]) * A.length;
        x.set("W", O);
        x.set("Length", F);
        y.push(`${S.num} ${S.gen} obj
`);
        c(x, y, null);
        y.push(" stream\n");
        let I = y.reduce((e, t) => e + t.length, 0);
        let T = `
endstream
endobj
startxref
${w}
%%EOF
`;
        let M = new Uint8Array(e.length + I + F + T.length);
        M.set(e);
        let P = e.length;
        for (let e of y) {
          u(e, P, M);
          P += e.length;
        }
        for (let [e, t, a] of A) {
          P = h(e, O[0], P, M);
          P = h(t, O[1], P, M);
          P = h(a, O[2], P, M);
        }
        u(T, P, M);
        return M;
      };
      t.writeDict = c;
      var r = a(2);
      var i = a(5);
      var n = a(8);
      var s = a(69);
      var o = a(9);
      var l = a(73);
      function c(e, t, a) {
        for (let s of (t.push("<<"), e.getKeys())) {
          t.push(` /${n.escapePDFName(s)} `);
          (function e(t, a, s) {
            if (t instanceof i.Name) a.push(`/${n.escapePDFName(t.name)}`); else if (t instanceof i.Ref) a.push(`${t.num} ${t.gen} R`); else if (Array.isArray(t)) !function (t, a, r) {
              a.push("[");
              let i = !0;
              for (let n of t) {
                i ? i = !1 : a.push(" ");
                e(n, a, r);
              }
              a.push("]");
            }(t, a, s); else if ("string" == typeof t) {
              null !== s && (t = s.encryptString(t));
              a.push(`(${r.escapeString(t)})`);
            } else if ("number" == typeof t) a.push(function (e) {
              if (Number.isInteger(e)) return e.toString();
              let t = Math.round(100 * e);
              return t % 100 == 0 ? (t / 100).toString() : t % 10 == 0 ? e.toFixed(1) : e.toFixed(2);
            }(t)); else if ("boolean" == typeof t) a.push(t.toString()); else if (t instanceof i.Dict) c(t, a, s); else if (t instanceof o.BaseStream) {
              var l;
              let e;
              c((l = t).dict, a, s);
              a.push(" stream\n");
              e = l.getString();
              null !== s && (e = s.encryptString(e));
              a.push(e, "\nendstream\n");
            } else null === t ? a.push("null") : r.warn(`Unhandled value in writer: ${typeof t}, please file a bug.`);
          })(e.getRaw(s), t, a);
        }
        t.push(">>");
      }
      function h(e, t, a, r) {
        for (let i = t + a - 1; i > a - 1; i--) {
          r[i] = 255 & e;
          e >>= 8;
        }
        return a + t;
      }
      function u(e, t, a) {
        for (function () {
          let r = 0;
          let i = e.length;
        }(); r < i; r++) a[t + r] = 255 & e.charCodeAt(r);
      }
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.calculateSHA256 = t.calculateMD5 = t.PDF20 = t.PDF17 = t.CipherTransformFactory = t.ARCFourCipher = t.AES256Cipher = t.AES128Cipher = void 0;
      t.calculateSHA384 = u;
      t.calculateSHA512 = void 0;
      var r = a(2);
      var i = a(5);
      var n = a(74);
      class s {
        constructor(e) {
          this.a = 0;
          this.b = 0;
          let t = new Uint8Array(256);
          let a = e.length;
          for (let e = 0; e < 256; ++e) t[e] = e;
          for (function () {
            let r = 0;
            let i = 0;
          }(); r < 256; ++r) {
            let n = t[r];
            i = i + n + e[r % a] & 255;
            t[r] = t[i];
            t[i] = n;
          }
          this.s = t;
        }
        encryptBlock(e) {
          let t = this.a;
          let a = this.b;
          let r = this.s;
          let i = e.length;
          let n = new Uint8Array(i);
          for (let s = 0; s < i; ++s) {
            let i = r[t = t + 1 & 255];
            let o = r[a = a + i & 255];
            r[t] = o;
            r[a] = i;
            n[s] = e[s] ^ r[i + o & 255];
          }
          this.a = t;
          this.b = a;
          return n;
        }
        decryptBlock(e) {
          return this.encryptBlock(e);
        }
        encrypt(e) {
          return this.encryptBlock(e);
        }
      }
      t.ARCFourCipher = s;
      let o = function () {
        let e = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]);
        let t = new Int32Array([-0x28955b88, -0x173848aa, 0x242070db, -0x3e423112, -0xa83f051, 0x4787c62a, -0x57cfb9ed, -0x2b96aff, 0x698098d8, -0x74bb0851, -42063, -0x76a32842, 0x6b901122, -0x2678e6d, -0x5986bc72, 0x49b40821, -0x9e1da9e, -0x3fbf4cc0, 0x265e5a51, -0x16493856, -0x29d0efa3, 0x2441453, -0x275e197f, -0x182c0438, 0x21e1cde6, -0x3cc8f82a, -0xb2af279, 0x455a14ed, -0x561c16fb, -0x3105c08, 0x676f02d9, -0x72d5b376, -378558, -0x788e097f, 0x6d9d6122, -0x21ac7f4, -0x5b4115bc, 0x4bdecfa9, -0x944b4a0, -0x41404390, 0x289b7ec6, -0x155ed806, -0x2b10cf7b, 0x4881d05, -0x262b2fc7, -0x1924661b, 0x1fa27cf8, -0x3b53a99b, -0xbd6ddbc, 0x432aff97, -0x546bdc59, -0x36c5fc7, 0x655b59c3, -0x70f3336e, -1051523, -0x7a7ba22f, 0x6fa87e4f, -0x1d31920, -0x5cfebcec, 0x4e0811a1, -0x8ac817e, -0x42c50dcb, 0x2ad7d2bb, -0x14792c6f]);
        return function (a, r, i) {
          let n;
          let s;
          let o = 0x67452301;
          let l = -0x10325477;
          let c = -0x67452302;
          let h = 0x10325476;
          let u = i + 72 & -64;
          let d = new Uint8Array(u);
          for (n = 0; n < i; ++n) d[n] = a[r++];
          d[n++] = 128;
          let f = u - 8;
          for (; n < f;) d[n++] = 0;
          d[n++] = i << 3 & 255;
          d[n++] = i >> 5 & 255;
          d[n++] = i >> 13 & 255;
          d[n++] = i >> 21 & 255;
          d[n++] = i >>> 29 & 255;
          d[n++] = 0;
          d[n++] = 0;
          d[n++] = 0;
          let g = new Int32Array(16);
          for (n = 0; n < u;) {
            for (s = 0; s < 16; ++s, n += 4) g[s] = d[n] | d[n + 1] << 8 | d[n + 2] << 16 | d[n + 3] << 24;
            let a = o;
            let r = l;
            let i = c;
            let u = h;
            let f;
            let p;
            for (s = 0; s < 64; ++s) {
              s < 16 ? (f = r & i | ~r & u, p = s) : s < 32 ? (f = u & r | ~u & i, p = 5 * s + 1 & 15) : s < 48 ? (f = r ^ i ^ u, p = 3 * s + 5 & 15) : (f = i ^ (r | ~u), p = 7 * s & 15);
              let n = u;
              let o = a + f + t[s] + g[p] | 0;
              let l = e[s];
              u = i;
              i = r;
              r = r + (o << l | o >>> 32 - l) | 0;
              a = n;
            }
            o = o + a | 0;
            l = l + r | 0;
            c = c + i | 0;
            h = h + u | 0;
          }
          return new Uint8Array([255 & o, o >> 8 & 255, o >> 16 & 255, o >>> 24 & 255, 255 & l, l >> 8 & 255, l >> 16 & 255, l >>> 24 & 255, 255 & c, c >> 8 & 255, c >> 16 & 255, c >>> 24 & 255, 255 & h, h >> 8 & 255, h >> 16 & 255, h >>> 24 & 255]);
        };
      }();
      t.calculateMD5 = o;
      class l {
        constructor(e, t) {
          this.high = 0 | e;
          this.low = 0 | t;
        }
        and(e) {
          this.high &= e.high;
          this.low &= e.low;
        }
        xor(e) {
          this.high ^= e.high;
          this.low ^= e.low;
        }
        or(e) {
          this.high |= e.high;
          this.low |= e.low;
        }
        shiftRight(e) {
          e >= 32 ? (this.low = this.high >>> e - 32 | 0, this.high = 0) : (this.low = this.low >>> e | this.high << 32 - e, this.high = this.high >>> e | 0);
        }
        shiftLeft(e) {
          e >= 32 ? (this.high = this.low << e - 32, this.low = 0) : (this.high = this.high << e | this.low >>> 32 - e, this.low <<= e);
        }
        rotateRight(e) {
          let t;
          let a;
          32 & e ? (a = this.low, t = this.high) : (t = this.low, a = this.high);
          e &= 31;
          this.low = t >>> e | a << 32 - e;
          this.high = a >>> e | t << 32 - e;
        }
        not() {
          this.high = ~this.high;
          this.low = ~this.low;
        }
        add(e) {
          let t = (this.low >>> 0) + (e.low >>> 0);
          let a = (this.high >>> 0) + (e.high >>> 0);
          t > 0xffffffff && (a += 1);
          this.low = 0 | t;
          this.high = 0 | a;
        }
        copyTo(e, t) {
          e[t] = this.high >>> 24 & 255;
          e[t + 1] = this.high >> 16 & 255;
          e[t + 2] = this.high >> 8 & 255;
          e[t + 3] = 255 & this.high;
          e[t + 4] = this.low >>> 24 & 255;
          e[t + 5] = this.low >> 16 & 255;
          e[t + 6] = this.low >> 8 & 255;
          e[t + 7] = 255 & this.low;
        }
        assign(e) {
          this.high = e.high;
          this.low = e.low;
        }
      }
      let c = function () {
        function e(e, t) {
          return e >>> t | e << 32 - t;
        }
        let t = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0xfc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x6ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
        return function (a, r, i) {
          let n;
          let s;
          let o = 0x6a09e667;
          let l = 0xbb67ae85;
          let c = 0x3c6ef372;
          let h = 0xa54ff53a;
          let u = 0x510e527f;
          let d = 0x9b05688c;
          let f = 0x1f83d9ab;
          let g = 0x5be0cd19;
          let p = 64 * Math.ceil((i + 9) / 64);
          let m = new Uint8Array(p);
          for (n = 0; n < i; ++n) m[n] = a[r++];
          m[n++] = 128;
          let b = p - 8;
          for (; n < b;) m[n++] = 0;
          m[n++] = 0;
          m[n++] = 0;
          m[n++] = 0;
          m[n++] = i >>> 29 & 255;
          m[n++] = i >> 21 & 255;
          m[n++] = i >> 13 & 255;
          m[n++] = i >> 5 & 255;
          m[n++] = i << 3 & 255;
          let y = new Uint32Array(64);
          for (n = 0; n < p;) {
            var w;
            var x;
            var S;
            var k;
            var A;
            var v;
            var C;
            var O;
            for (s = 0; s < 16; ++s) {
              y[s] = m[n] << 24 | m[n + 1] << 16 | m[n + 2] << 8 | m[n + 3];
              n += 4;
            }
            for (s = 16; s < 64; ++s) y[s] = (e(w = y[s - 2], 17) ^ e(w, 19) ^ w >>> 10) + y[s - 7] + (e(x = y[s - 15], 7) ^ e(x, 18) ^ x >>> 3) + y[s - 16] | 0;
            let a = o;
            let r = l;
            let i = c;
            let p = h;
            let b = u;
            let F = d;
            let I = f;
            let T = g;
            let M;
            let P;
            for (s = 0; s < 64; ++s) {
              M = T + (e(S = b, 6) ^ e(S, 11) ^ e(S, 25)) + ((k = b) & F ^ ~k & I) + t[s] + y[s];
              P = (e(A = a, 2) ^ e(A, 13) ^ e(A, 22)) + ((v = a) & (C = r) ^ v & (O = i) ^ C & O);
              T = I;
              I = F;
              F = b;
              b = p + M | 0;
              p = i;
              i = r;
              r = a;
              a = M + P | 0;
            }
            o = o + a | 0;
            l = l + r | 0;
            c = c + i | 0;
            h = h + p | 0;
            u = u + b | 0;
            d = d + F | 0;
            f = f + I | 0;
            g = g + T | 0;
          }
          return new Uint8Array([o >> 24 & 255, o >> 16 & 255, o >> 8 & 255, 255 & o, l >> 24 & 255, l >> 16 & 255, l >> 8 & 255, 255 & l, c >> 24 & 255, c >> 16 & 255, c >> 8 & 255, 255 & c, h >> 24 & 255, h >> 16 & 255, h >> 8 & 255, 255 & h, u >> 24 & 255, u >> 16 & 255, u >> 8 & 255, 255 & u, d >> 24 & 255, d >> 16 & 255, d >> 8 & 255, 255 & d, f >> 24 & 255, f >> 16 & 255, f >> 8 & 255, 255 & f, g >> 24 & 255, g >> 16 & 255, g >> 8 & 255, 255 & g]);
        };
      }();
      t.calculateSHA256 = c;
      let h = function () {
        let e = [new l(0x428a2f98, 0xd728ae22), new l(0x71374491, 0x23ef65cd), new l(0xb5c0fbcf, 0xec4d3b2f), new l(0xe9b5dba5, 0x8189dbbc), new l(0x3956c25b, 0xf348b538), new l(0x59f111f1, 0xb605d019), new l(0x923f82a4, 0xaf194f9b), new l(0xab1c5ed5, 0xda6d8118), new l(0xd807aa98, 0xa3030242), new l(0x12835b01, 0x45706fbe), new l(0x243185be, 0x4ee4b28c), new l(0x550c7dc3, 0xd5ffb4e2), new l(0x72be5d74, 0xf27b896f), new l(0x80deb1fe, 0x3b1696b1), new l(0x9bdc06a7, 0x25c71235), new l(0xc19bf174, 0xcf692694), new l(0xe49b69c1, 0x9ef14ad2), new l(0xefbe4786, 0x384f25e3), new l(0xfc19dc6, 0x8b8cd5b5), new l(0x240ca1cc, 0x77ac9c65), new l(0x2de92c6f, 0x592b0275), new l(0x4a7484aa, 0x6ea6e483), new l(0x5cb0a9dc, 0xbd41fbd4), new l(0x76f988da, 0x831153b5), new l(0x983e5152, 0xee66dfab), new l(0xa831c66d, 0x2db43210), new l(0xb00327c8, 0x98fb213f), new l(0xbf597fc7, 0xbeef0ee4), new l(0xc6e00bf3, 0x3da88fc2), new l(0xd5a79147, 0x930aa725), new l(0x6ca6351, 0xe003826f), new l(0x14292967, 0xa0e6e70), new l(0x27b70a85, 0x46d22ffc), new l(0x2e1b2138, 0x5c26c926), new l(0x4d2c6dfc, 0x5ac42aed), new l(0x53380d13, 0x9d95b3df), new l(0x650a7354, 0x8baf63de), new l(0x766a0abb, 0x3c77b2a8), new l(0x81c2c92e, 0x47edaee6), new l(0x92722c85, 0x1482353b), new l(0xa2bfe8a1, 0x4cf10364), new l(0xa81a664b, 0xbc423001), new l(0xc24b8b70, 0xd0f89791), new l(0xc76c51a3, 0x654be30), new l(0xd192e819, 0xd6ef5218), new l(0xd6990624, 0x5565a910), new l(0xf40e3585, 0x5771202a), new l(0x106aa070, 0x32bbd1b8), new l(0x19a4c116, 0xb8d2d0c8), new l(0x1e376c08, 0x5141ab53), new l(0x2748774c, 0xdf8eeb99), new l(0x34b0bcb5, 0xe19b48a8), new l(0x391c0cb3, 0xc5c95a63), new l(0x4ed8aa4a, 0xe3418acb), new l(0x5b9cca4f, 0x7763e373), new l(0x682e6ff3, 0xd6b2b8a3), new l(0x748f82ee, 0x5defb2fc), new l(0x78a5636f, 0x43172f60), new l(0x84c87814, 0xa1f0ab72), new l(0x8cc70208, 0x1a6439ec), new l(0x90befffa, 0x23631e28), new l(0xa4506ceb, 0xde82bde9), new l(0xbef9a3f7, 0xb2c67915), new l(0xc67178f2, 0xe372532b), new l(0xca273ece, 0xea26619c), new l(0xd186b8c7, 0x21c0c207), new l(0xeada7dd6, 0xcde0eb1e), new l(0xf57d4f7f, 0xee6ed178), new l(0x6f067aa, 0x72176fba), new l(0xa637dc5, 0xa2c898a6), new l(0x113f9804, 0xbef90dae), new l(0x1b710b35, 0x131c471b), new l(0x28db77f5, 0x23047d84), new l(0x32caab7b, 0x40c72493), new l(0x3c9ebe0a, 0x15c9bebc), new l(0x431d67c4, 0x9c100d4c), new l(0x4cc5d4be, 0xcb3e42b6), new l(0x597f299c, 0xfc657e2a), new l(0x5fcb6fab, 0x3ad6faec), new l(0x6c44198c, 0x4a475817)];
        return function (t, a, r, i = !1) {
          let n;
          let s;
          let o;
          let c;
          let h;
          let u;
          let d;
          let f;
          let g;
          let p;
          let m;
          let b;
          i ? (n = new l(0xcbbb9d5d, 0xc1059ed8), s = new l(0x629a292a, 0x367cd507), o = new l(0x9159015a, 0x3070dd17), c = new l(0x152fecd8, 0xf70e5939), h = new l(0x67332667, 0xffc00b31), u = new l(0x8eb44a87, 0x68581511), d = new l(0xdb0c2e0d, 0x64f98fa7), f = new l(0x47b5481d, 0xbefa4fa4)) : (n = new l(0x6a09e667, 0xf3bcc908), s = new l(0xbb67ae85, 0x84caa73b), o = new l(0x3c6ef372, 0xfe94f82b), c = new l(0xa54ff53a, 0x5f1d36f1), h = new l(0x510e527f, 0xade682d1), u = new l(0x9b05688c, 0x2b3e6c1f), d = new l(0x1f83d9ab, 0xfb41bd6b), f = new l(0x5be0cd19, 0x137e2179));
          let y = 128 * Math.ceil((r + 17) / 128);
          let w = new Uint8Array(y);
          for (g = 0; g < r; ++g) w[g] = t[a++];
          w[g++] = 128;
          let x = y - 16;
          for (; g < x;) w[g++] = 0;
          w[g++] = 0;
          w[g++] = 0;
          w[g++] = 0;
          w[g++] = 0;
          w[g++] = 0;
          w[g++] = 0;
          w[g++] = 0;
          w[g++] = 0;
          w[g++] = 0;
          w[g++] = 0;
          w[g++] = 0;
          w[g++] = r >>> 29 & 255;
          w[g++] = r >> 21 & 255;
          w[g++] = r >> 13 & 255;
          w[g++] = r >> 5 & 255;
          w[g++] = r << 3 & 255;
          let S = Array(80);
          for (g = 0; g < 80; g++) S[g] = new l(0, 0);
          let k = new l(0, 0);
          let A = new l(0, 0);
          let v = new l(0, 0);
          let C = new l(0, 0);
          let O = new l(0, 0);
          let F = new l(0, 0);
          let I = new l(0, 0);
          let T = new l(0, 0);
          let M = new l(0, 0);
          let P = new l(0, 0);
          let E = new l(0, 0);
          let N = new l(0, 0);
          for (g = 0; g < y;) {
            var B;
            var D;
            var L;
            var R;
            var $;
            var j;
            var _;
            var U;
            var X;
            var H;
            var q;
            for (p = 0; p < 16; ++p) {
              S[p].high = w[g] << 24 | w[g + 1] << 16 | w[g + 2] << 8 | w[g + 3];
              S[p].low = w[g + 4] << 24 | w[g + 5] << 16 | w[g + 6] << 8 | w[g + 7];
              g += 8;
            }
            for (p = 16; p < 80; ++p) {
              B = m = S[p];
              D = S[p - 2];
              B.assign(D);
              B.rotateRight(19);
              N.assign(D);
              N.rotateRight(61);
              B.xor(N);
              N.assign(D);
              N.shiftRight(6);
              B.xor(N);
              m.add(S[p - 7]);
              L = S[p - 15];
              E.assign(L);
              E.rotateRight(1);
              N.assign(L);
              N.rotateRight(8);
              E.xor(N);
              N.assign(L);
              N.shiftRight(7);
              E.xor(N);
              m.add(E);
              m.add(S[p - 16]);
            }
            for (k.assign(n), A.assign(s), v.assign(o), C.assign(c), O.assign(h), F.assign(u), I.assign(d), T.assign(f), p = 0; p < 80; ++p) {
              M.assign(T);
              R = O;
              E.assign(R);
              E.rotateRight(14);
              N.assign(R);
              N.rotateRight(18);
              E.xor(N);
              N.assign(R);
              N.rotateRight(41);
              E.xor(N);
              M.add(E);
              $ = O;
              j = F;
              _ = I;
              E.assign($);
              E.and(j);
              N.assign($);
              N.not();
              N.and(_);
              E.xor(N);
              M.add(E);
              M.add(e[p]);
              M.add(S[p]);
              U = k;
              P.assign(U);
              P.rotateRight(28);
              N.assign(U);
              N.rotateRight(34);
              P.xor(N);
              N.assign(U);
              N.rotateRight(39);
              P.xor(N);
              X = k;
              H = A;
              q = v;
              E.assign(X);
              E.and(H);
              N.assign(X);
              N.and(q);
              E.xor(N);
              N.assign(H);
              N.and(q);
              E.xor(N);
              P.add(E);
              m = T;
              T = I;
              I = F;
              F = O;
              C.add(M);
              O = C;
              C = v;
              v = A;
              A = k;
              m.assign(M);
              m.add(P);
              k = m;
            }
            n.add(k);
            s.add(A);
            o.add(v);
            c.add(C);
            h.add(O);
            u.add(F);
            d.add(I);
            f.add(T);
          }
          i ? (b = new Uint8Array(48), n.copyTo(b, 0), s.copyTo(b, 8), o.copyTo(b, 16), c.copyTo(b, 24), h.copyTo(b, 32), u.copyTo(b, 40)) : (b = new Uint8Array(64), n.copyTo(b, 0), s.copyTo(b, 8), o.copyTo(b, 16), c.copyTo(b, 24), h.copyTo(b, 32), u.copyTo(b, 40), d.copyTo(b, 48), f.copyTo(b, 56));
          return b;
        };
      }();
      function u(e, t, a) {
        return h(e, t, a, !0);
      }
      t.calculateSHA512 = h;
      class d {
        decryptBlock(e) {
          return e;
        }
        encrypt(e) {
          return e;
        }
      }
      class f {
        constructor() {
          this.constructor === f && r.unreachable("Cannot initialize AESBaseCipher.");
          this._s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]);
          this._inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]);
          this._mix = new Uint32Array([0, 0xe090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x38f5fe7, 0xd8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x58ae132, 0xb83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x605bed5, 0x80cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x9808683, 0x7898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0xa0fd964, 0x406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0xc0a67b1, 0x2036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0xf853856, 0x18c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3]);
          this._mixCol = new Uint8Array(256);
          for (let e = 0; e < 256; e++) e < 128 ? this._mixCol[e] = e << 1 : this._mixCol[e] = e << 1 ^ 27;
          this.buffer = new Uint8Array(16);
          this.bufferPosition = 0;
        }
        _expandKey(e) {
          r.unreachable("Cannot call `_expandKey` on the base class");
        }
        _decrypt(e, t) {
          var _this7 = this;
          let a;
          let r;
          let i;
          let n = new Uint8Array(16);
          n.set(e);
          for (function () {
            let e = 0;
            let a = _this7._keySize;
          }(); e < 16; ++e, ++a) n[e] ^= t[a];
          for (let e = this._cyclesOfRepetition - 1; e >= 1; --e) {
            a = n[13];
            n[13] = n[9];
            n[9] = n[5];
            n[5] = n[1];
            n[1] = a;
            a = n[14];
            r = n[10];
            n[14] = n[6];
            n[10] = n[2];
            n[6] = a;
            n[2] = r;
            a = n[15];
            r = n[11];
            i = n[7];
            n[15] = n[3];
            n[11] = a;
            n[7] = r;
            n[3] = i;
            for (let e = 0; e < 16; ++e) n[e] = this._inv_s[n[e]];
            for (function () {
              let a = 0;
              let r = 16 * e;
            }(); a < 16; ++a, ++r) n[a] ^= t[r];
            for (let e = 0; e < 16; e += 4) {
              let t = this._mix[n[e]];
              let r = this._mix[n[e + 1]];
              let i = this._mix[n[e + 2]];
              let s = this._mix[n[e + 3]];
              a = t ^ r >>> 8 ^ r << 24 ^ i >>> 16 ^ i << 16 ^ s >>> 24 ^ s << 8;
              n[e] = a >>> 24 & 255;
              n[e + 1] = a >> 16 & 255;
              n[e + 2] = a >> 8 & 255;
              n[e + 3] = 255 & a;
            }
          }
          a = n[13];
          n[13] = n[9];
          n[9] = n[5];
          n[5] = n[1];
          n[1] = a;
          a = n[14];
          r = n[10];
          n[14] = n[6];
          n[10] = n[2];
          n[6] = a;
          n[2] = r;
          a = n[15];
          r = n[11];
          i = n[7];
          n[15] = n[3];
          n[11] = a;
          n[7] = r;
          n[3] = i;
          for (let e = 0; e < 16; ++e) {
            n[e] = this._inv_s[n[e]];
            n[e] ^= t[e];
          }
          return n;
        }
        _encrypt(e, t) {
          var _this8 = this;
          let a;
          let r;
          let i;
          let n = this._s;
          let s = new Uint8Array(16);
          s.set(e);
          for (let e = 0; e < 16; ++e) s[e] ^= t[e];
          for (let e = 1; e < this._cyclesOfRepetition; e++) {
            for (let e = 0; e < 16; ++e) s[e] = n[s[e]];
            i = s[1];
            s[1] = s[5];
            s[5] = s[9];
            s[9] = s[13];
            s[13] = i;
            i = s[2];
            r = s[6];
            s[2] = s[10];
            s[6] = s[14];
            s[10] = i;
            s[14] = r;
            i = s[3];
            r = s[7];
            a = s[11];
            s[3] = s[15];
            s[7] = i;
            s[11] = r;
            s[15] = a;
            for (let e = 0; e < 16; e += 4) {
              let t = s[e + 0];
              let r = s[e + 1];
              let i = s[e + 2];
              let n = s[e + 3];
              a = t ^ r ^ i ^ n;
              s[e + 0] ^= a ^ this._mixCol[t ^ r];
              s[e + 1] ^= a ^ this._mixCol[r ^ i];
              s[e + 2] ^= a ^ this._mixCol[i ^ n];
              s[e + 3] ^= a ^ this._mixCol[n ^ t];
            }
            for (function () {
              let a = 0;
              let r = 16 * e;
            }(); a < 16; ++a, ++r) s[a] ^= t[r];
          }
          for (let e = 0; e < 16; ++e) s[e] = n[s[e]];
          i = s[1];
          s[1] = s[5];
          s[5] = s[9];
          s[9] = s[13];
          s[13] = i;
          i = s[2];
          r = s[6];
          s[2] = s[10];
          s[6] = s[14];
          s[10] = i;
          s[14] = r;
          i = s[3];
          r = s[7];
          a = s[11];
          s[3] = s[15];
          s[7] = i;
          s[11] = r;
          s[15] = a;
          for (function () {
            let e = 0;
            let a = _this8._keySize;
          }(); e < 16; ++e, ++a) s[e] ^= t[a];
          return s;
        }
        _decryptBlock2(e, t) {
          let a = e.length;
          let r = this.buffer;
          let i = this.bufferPosition;
          let n = [];
          let s = this.iv;
          for (let t = 0; t < a; ++t) {
            if (r[i] = e[t], ++i < 16) continue;
            let a = this._decrypt(r, this._key);
            for (let e = 0; e < 16; ++e) a[e] ^= s[e];
            s = r;
            n.push(a);
            r = new Uint8Array(16);
            i = 0;
          }
          if (this.buffer = r, this.bufferLength = i, this.iv = s, 0 === n.length) return new Uint8Array(0);
          let o = 16 * n.length;
          if (t) {
            let e = n[n.length - 1];
            let t = e[15];
            if (t <= 16) {
              for (function () {
                let a = 15;
                let r = 16 - t;
              }(); a >= r; --a) if (e[a] !== t) {
                t = 0;
                break;
              }
              o -= t;
              n[n.length - 1] = e.subarray(0, 16 - t);
            }
          }
          let l = new Uint8Array(o);
          for (function () {
            let e = 0;
            let t = 0;
            let a = n.length;
          }(); e < a; ++e, t += 16) l.set(n[e], t);
          return l;
        }
        decryptBlock(e, t, a = null) {
          let r = e.length;
          let i = this.buffer;
          let n = this.bufferPosition;
          if (a) this.iv = a; else {
            for (let t = 0; n < 16 && t < r; ++t, ++n) i[n] = e[t];
            if (n < 16) {
              this.bufferLength = n;
              return new Uint8Array(0);
            }
            this.iv = i;
            e = e.subarray(16);
          }
          this.buffer = new Uint8Array(16);
          this.bufferLength = 0;
          this.decryptBlock = this._decryptBlock2;
          return this.decryptBlock(e, t);
        }
        encrypt(e, t) {
          let a = e.length;
          let r = this.buffer;
          let i = this.bufferPosition;
          let n = [];
          t || (t = new Uint8Array(16));
          for (let s = 0; s < a; ++s) {
            if (r[i] = e[s], ++i < 16) continue;
            for (let e = 0; e < 16; ++e) r[e] ^= t[e];
            let a = this._encrypt(r, this._key);
            t = a;
            n.push(a);
            r = new Uint8Array(16);
            i = 0;
          }
          if (this.buffer = r, this.bufferLength = i, this.iv = t, 0 === n.length) return new Uint8Array(0);
          let s = new Uint8Array(16 * n.length);
          for (function () {
            let e = 0;
            let t = 0;
            let a = n.length;
          }(); e < a; ++e, t += 16) s.set(n[e], t);
          return s;
        }
      }
      class g extends f {
        constructor(e) {
          super();
          this._cyclesOfRepetition = 10;
          this._keySize = 160;
          this._rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]);
          this._key = this._expandKey(e);
        }
        _expandKey(e) {
          let t = this._s;
          let a = this._rcon;
          let r = new Uint8Array(176);
          r.set(e);
          for (function () {
            let e = 16;
            let i = 1;
          }(); e < 176; ++i) {
            let n = r[e - 3];
            let s = r[e - 2];
            let o = r[e - 1];
            let l = r[e - 4];
            n = t[n];
            s = t[s];
            o = t[o];
            l = t[l];
            n ^= a[i];
            for (let t = 0; t < 4; ++t) {
              r[e] = n ^= r[e - 16];
              r[++e] = s ^= r[e - 16];
              r[++e] = o ^= r[e - 16];
              r[++e] = l ^= r[e - 16];
              e++;
            }
          }
          return r;
        }
      }
      t.AES128Cipher = g;
      class p extends f {
        constructor(e) {
          super();
          this._cyclesOfRepetition = 14;
          this._keySize = 224;
          this._key = this._expandKey(e);
        }
        _expandKey(e) {
          let t;
          let a;
          let r;
          let i;
          let n = this._s;
          let s = new Uint8Array(240);
          s.set(e);
          let o = 1;
          for (function () {
            let e = 32;
            let l = 1;
          }(); e < 240; ++l) {
            e % 32 == 16 ? (t = n[t], a = n[a], r = n[r], i = n[i]) : e % 32 == 0 && (t = s[e - 3], a = s[e - 2], r = s[e - 1], i = s[e - 4], t = n[t], a = n[a], r = n[r], i = n[i], t ^= o, (o <<= 1) >= 256 && (o = (27 ^ o) & 255));
            for (let n = 0; n < 4; ++n) {
              s[e] = t ^= s[e - 32];
              s[++e] = a ^= s[e - 32];
              s[++e] = r ^= s[e - 32];
              s[++e] = i ^= s[e - 32];
              e++;
            }
          }
          return s;
        }
      }
      t.AES256Cipher = p;
      class m {
        checkOwnerPassword(e, t, a, i) {
          let n = new Uint8Array(e.length + 56);
          n.set(e, 0);
          n.set(t, e.length);
          n.set(a, e.length + t.length);
          let s = c(n, 0, n.length);
          return r.isArrayEqual(s, i);
        }
        checkUserPassword(e, t, a) {
          let i = new Uint8Array(e.length + 8);
          i.set(e, 0);
          i.set(t, e.length);
          let n = c(i, 0, i.length);
          return r.isArrayEqual(n, a);
        }
        getOwnerKey(e, t, a, r) {
          let i = new Uint8Array(e.length + 56);
          i.set(e, 0);
          i.set(t, e.length);
          i.set(a, e.length + t.length);
          return new p(c(i, 0, i.length)).decryptBlock(r, !1, new Uint8Array(16));
        }
        getUserKey(e, t, a) {
          let r = new Uint8Array(e.length + 8);
          r.set(e, 0);
          r.set(t, e.length);
          return new p(c(r, 0, r.length)).decryptBlock(a, !1, new Uint8Array(16));
        }
      }
      t.PDF17 = m;
      let b = function () {
        function e(e, t, a) {
          let r = c(t, 0, t.length).subarray(0, 32);
          let i = [0];
          let n = 0;
          for (; n < 64 || i[i.length - 1] > n - 32;) {
            let t = e.length + r.length + a.length;
            let s = new Uint8Array(t);
            let o = 0;
            s.set(e, o);
            o += e.length;
            s.set(r, o);
            o += r.length;
            s.set(a, o);
            let l = new Uint8Array(64 * t);
            for (function () {
              let e = 0;
              let a = 0;
            }(); e < 64; e++, a += t) l.set(s, a);
            i = new g(r.subarray(0, 16)).encrypt(l, r.subarray(16, 32));
            let d = 0;
            for (let e = 0; e < 16; e++) {
              d *= 1;
              d %= 3;
              d += (i[e] >>> 0) % 3;
              d %= 3;
            }
            0 === d ? r = c(i, 0, i.length) : 1 === d ? r = u(i, 0, i.length) : 2 === d && (r = h(i, 0, i.length));
            n++;
          }
          return r.subarray(0, 32);
        }
        return class {
          hash(t, a, r) {
            return e(t, a, r);
          }
          checkOwnerPassword(t, a, i, n) {
            let s = new Uint8Array(t.length + 56);
            s.set(t, 0);
            s.set(a, t.length);
            s.set(i, t.length + a.length);
            let o = e(t, s, i);
            return r.isArrayEqual(o, n);
          }
          checkUserPassword(t, a, i) {
            let n = new Uint8Array(t.length + 8);
            n.set(t, 0);
            n.set(a, t.length);
            let s = e(t, n, []);
            return r.isArrayEqual(s, i);
          }
          getOwnerKey(t, a, r, i) {
            let n = new Uint8Array(t.length + 56);
            n.set(t, 0);
            n.set(a, t.length);
            n.set(r, t.length + a.length);
            return new p(e(t, n, r)).decryptBlock(i, !1, new Uint8Array(16));
          }
          getUserKey(t, a, r) {
            let i = new Uint8Array(t.length + 8);
            i.set(t, 0);
            i.set(a, t.length);
            return new p(e(t, i, [])).decryptBlock(r, !1, new Uint8Array(16));
          }
        };
      }();
      t.PDF20 = b;
      class y {
        constructor(e, t) {
          this.StringCipherConstructor = e;
          this.StreamCipherConstructor = t;
        }
        createStream(e, t) {
          let a = new this.StreamCipherConstructor();
          return new n.DecryptStream(e, t, function (e, t) {
            return a.decryptBlock(e, t);
          });
        }
        decryptString(e) {
          let t = new this.StringCipherConstructor();
          let a = r.stringToBytes(e);
          a = t.decryptBlock(a, !0);
          return r.bytesToString(a);
        }
        encryptString(e) {
          let t = new this.StringCipherConstructor();
          if (t instanceof f) {
            let a = 16 - e.length % 16;
            e += String.fromCharCode(a).repeat(a);
            let i = new Uint8Array(16);
            if ("undefined" != typeof crypto) crypto.getRandomValues(i); else for (let e = 0; e < 16; e++) i[e] = Math.floor(256 * Math.random());
            let n = r.stringToBytes(e);
            let s = new Uint8Array(16 + (n = t.encrypt(n, i)).length);
            s.set(i);
            s.set(n, 16);
            return r.bytesToString(s);
          }
          let a = r.stringToBytes(e);
          a = t.encrypt(a);
          return r.bytesToString(a);
        }
      }
      let w = function () {
        let e = new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]);
        function t(t, a, r, i, n, l, c, h) {
          let u;
          let d = new Uint8Array(40 + r.length + t.length);
          let f = 0;
          let g;
          let p;
          if (a) for (p = Math.min(32, a.length); f < p; ++f) d[f] = a[f];
          for (g = 0; f < 32;) d[f++] = e[g++];
          for (g = 0, p = r.length; g < p; ++g) d[f++] = r[g];
          for (g = 0, d[f++] = 255 & n, d[f++] = n >> 8 & 255, d[f++] = n >> 16 & 255, d[f++] = n >>> 24 & 255, p = t.length; g < p; ++g) d[f++] = t[g];
          l >= 4 && !h && (d[f++] = 255, d[f++] = 255, d[f++] = 255, d[f++] = 255);
          let m = o(d, 0, f);
          let b = c >> 3;
          if (l >= 3) for (g = 0; g < 50; ++g) m = o(m, 0, b);
          let y = m.subarray(0, b);
          if (l >= 3) {
            for (f = 0; f < 32; ++f) d[f] = e[f];
            for (g = 0, p = t.length; g < p; ++g) d[f++] = t[g];
            u = new s(y).encryptBlock(o(d, 0, f));
            let a = new Uint8Array(p = y.length);
            for (g = 1; g <= 19; ++g) {
              for (let e = 0; e < p; ++e) a[e] = y[e] ^ g;
              u = new s(a).encryptBlock(u);
            }
            for (g = 0, p = u.length; g < p; ++g) if (i[g] !== u[g]) return null;
          } else for (g = 0, p = (u = new s(y).encryptBlock(e)).length; g < p; ++g) if (i[g] !== u[g]) return null;
          return y;
        }
        let a = i.Name.get("Identity");
        function n(e, t, a, r = !1) {
          let i;
          let s = new Uint8Array(a.length + 9);
          let l = a.length;
          for (i = 0; i < l; ++i) s[i] = a[i];
          s[i++] = 255 & e;
          s[i++] = e >> 8 & 255;
          s[i++] = e >> 16 & 255;
          s[i++] = 255 & t;
          s[i++] = t >> 8 & 255;
          r && (s[i++] = 115, s[i++] = 65, s[i++] = 108, s[i++] = 84);
          return o(s, 0, i).subarray(0, Math.min(a.length + 5, 16));
        }
        function l(e, t, a, o, l) {
          let c;
          if (!(t instanceof i.Name)) throw new r.FormatError("Invalid crypt filter name.");
          let h = e.get(t.name);
          if (null != h && (c = h.get("CFM")), !c || "None" === c.name) return function () {
            return new d();
          };
          if ("V2" === c.name) return function () {
            return new s(n(a, o, l, !1));
          };
          if ("AESV2" === c.name) return function () {
            return new g(n(a, o, l, !0));
          };
          if ("AESV3" === c.name) return function () {
            return new p(l);
          };
          throw new r.FormatError("Unknown crypto method");
        }
        return class {
          constructor(n, l, c) {
            let h;
            let u;
            let d = n.get("Filter");
            if (!i.isName(d, "Standard")) throw new r.FormatError("unknown encryption method");
            this.filterName = d.name;
            this.dict = n;
            let f = n.get("V");
            if (!Number.isInteger(f) || 1 !== f && 2 !== f && 4 !== f && 5 !== f) throw new r.FormatError("unsupported encryption algorithm");
            this.algorithm = f;
            let g = n.get("Length");
            if (!g) {
              if (f <= 3) g = 40; else {
                let e = n.get("CF");
                let t = n.get("StmF");
                if (e instanceof i.Dict && t instanceof i.Name) {
                  e.suppressEncryption = !0;
                  let a = e.get(t.name);
                  (g = a && a.get("Length") || 128) < 40 && (g <<= 3);
                }
              }
            }
            if (!Number.isInteger(g) || g < 40 || g % 8 != 0) throw new r.FormatError("invalid key length");
            let p = r.stringToBytes(n.get("O")).subarray(0, 32);
            let y = r.stringToBytes(n.get("U")).subarray(0, 32);
            let w = n.get("P");
            let x = n.get("R");
            let S = (4 === f || 5 === f) && !1 !== n.get("EncryptMetadata");
            this.encryptMetadata = S;
            let k = r.stringToBytes(l);
            if (c) {
              if (6 === x) try {
                c = r.utf8StringToString(c);
              } catch (e) {
                r.warn("CipherTransformFactory: Unable to convert UTF8 encoded password.");
              }
              h = r.stringToBytes(c);
            }
            if (5 !== f) u = t(k, h, p, y, w, x, g, S); else {
              let e = r.stringToBytes(n.get("O")).subarray(32, 40);
              let t = r.stringToBytes(n.get("O")).subarray(40, 48);
              let a = r.stringToBytes(n.get("U")).subarray(0, 48);
              let i = r.stringToBytes(n.get("U")).subarray(32, 40);
              let s = r.stringToBytes(n.get("U")).subarray(40, 48);
              let o = r.stringToBytes(n.get("OE"));
              let l = r.stringToBytes(n.get("UE"));
              r.stringToBytes(n.get("Perms"));
              u = function (e, t, a, r, i, n, s, o, l, c, h, u) {
                let d;
                if (t) {
                  let e = Math.min(127, t.length);
                  t = t.subarray(0, e);
                } else t = [];
                return (d = 6 === e ? new b() : new m()).checkUserPassword(t, o, s) ? d.getUserKey(t, l, h) : t.length && d.checkOwnerPassword(t, r, n, a) ? d.getOwnerKey(t, i, n, c) : null;
              }(x, h, p, e, t, a, y, i, s, o, l, 0);
            }
            if (u || c) !u && c && (u = t(k, function (t, a, r, i) {
              let n;
              let l = new Uint8Array(32);
              let c = 0;
              let h = Math.min(32, t.length);
              for (; c < h; ++c) l[c] = t[c];
              let u = 0;
              for (; c < 32;) l[c++] = e[u++];
              let d = o(l, 0, c);
              let f = i >> 3;
              if (r >= 3) for (u = 0; u < 50; ++u) d = o(d, 0, d.length);
              if (r >= 3) {
                n = a;
                let e = new Uint8Array(f);
                for (u = 19; u >= 0; u--) {
                  for (let t = 0; t < f; ++t) e[t] = d[t] ^ u;
                  n = new s(e).encryptBlock(n);
                }
              } else n = new s(d.subarray(0, f)).encryptBlock(a);
              return n;
            }(h, p, x, g), p, y, w, x, g, S)); else throw new r.PasswordException("No password given", r.PasswordResponses.NEED_PASSWORD);
            if (!u) throw new r.PasswordException("Incorrect Password", r.PasswordResponses.INCORRECT_PASSWORD);
            if (this.encryptionKey = u, f >= 4) {
              let e = n.get("CF");
              e instanceof i.Dict && (e.suppressEncryption = !0);
              this.cf = e;
              this.stmf = n.get("StmF") || a;
              this.strf = n.get("StrF") || a;
              this.eff = n.get("EFF") || this.stmf;
            }
          }
          createCipherTransform(e, t) {
            if (4 === this.algorithm || 5 === this.algorithm) return new y(l(this.cf, this.stmf, e, t, this.encryptionKey), l(this.cf, this.strf, e, t, this.encryptionKey));
            let a = n(e, t, this.encryptionKey, !1);
            let r = function () {
              return new s(a);
            };
            return new y(r, r);
          }
        };
      }();
      t.CipherTransformFactory = w;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.DecryptStream = void 0;
      var r = a(29);
      class i extends r.DecodeStream {
        constructor(e, t, a) {
          super(t);
          this.str = e;
          this.dict = e.dict;
          this.decrypt = a;
          this.nextChunk = null;
          this.initialized = !1;
        }
        readBlock() {
          let e;
          if (this.initialized ? e = this.nextChunk : (e = this.str.getBytes(512), this.initialized = !0), !e || 0 === e.length) {
            this.eof = !0;
            return;
          }
          this.nextChunk = this.str.getBytes(512);
          let t = this.nextChunk && this.nextChunk.length > 0;
          e = this.decrypt(e, !t);
          let a = this.bufferLength;
          let r = e.length;
          let i = this.ensureBuffer(a + r);
          for (let t = 0; t < r; t++) i[a++] = e[t];
          this.bufferLength = a;
        }
      }
      t.DecryptStream = i;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.XFAFactory = void 0;
      var r = a(76);
      var i = a(80);
      var n = a(86);
      var s = a(84);
      var o = a(77);
      var l = a(2);
      var c = a(87);
      var h = a(97);
      class u {
        constructor(e) {
          try {
            this.root = new c.XFAParser().parse(u._createDocument(e));
            let t = new i.Binder(this.root);
            this.form = t.bind();
            this.dataHandler = new n.DataHandler(this.root, t.getData());
            this.form[r.$globalData].template = this.form;
          } catch (e) {
            l.warn(`XFA - an error occurred during parsing and binding: ${e}`);
          }
        }
        isValid() {
          return this.root && this.form;
        }
        _createPagesHelper() {
          let e = this.form[r.$toPages]();
          return new Promise((t, a) => {
            let r = () => {
              try {
                let a = e.next();
                a.done ? t(a.value) : setTimeout(r, 0);
              } catch (e) {
                a(e);
              }
            };
            setTimeout(r, 0);
          });
        }
        async _createPages() {
          try {
            this.pages = await this._createPagesHelper();
            this.dims = this.pages.children.map(e => {
              let {
                width,
                height
              } = e.attributes.style;
              return [0, 0, parseInt(width), parseInt(height)];
            });
          } catch (e) {
            l.warn(`XFA - an error occurred during layout: ${e}`);
          }
        }
        getBoundingBox(e) {
          return this.dims[e];
        }
        async getNumPages() {
          this.pages || (await this._createPages());
          return this.dims.length;
        }
        setImages(e) {
          this.form[r.$globalData].images = e;
        }
        setFonts(e) {
          this.form[r.$globalData].fontFinder = new s.FontFinder(e);
          let t = [];
          for (let e of this.form[r.$globalData].usedTypefaces) {
            e = o.stripQuotes(e);
            this.form[r.$globalData].fontFinder.find(e) || t.push(e);
          }
          return t.length > 0 ? t : null;
        }
        appendFonts(e, t) {
          this.form[r.$globalData].fontFinder.add(e, t);
        }
        async getPages() {
          this.pages || (await this._createPages());
          let e = this.pages;
          this.pages = null;
          return e;
        }
        serializeData(e) {
          return this.dataHandler.serialize(e);
        }
        static _createDocument(e) {
          return e["/xdp:xdp"] ? Object.values(e).join("") : e["xdp:xdp"];
        }
        static getRichTextAsHtml(e) {
          if (!e || "string" != typeof e) return null;
          try {
            let t = new c.XFAParser(h.XhtmlNamespace, !0).parse(e);
            if (!["body", "xhtml"].includes(t[r.$nodeName])) {
              let e = h.XhtmlNamespace.body({});
              e[r.$appendChild](t);
              t = e;
            }
            let a = t[r.$toHTML]();
            if (!a.success) return null;
            let {
              html
            } = a;
            let {
              attributes
            } = i;
            attributes && (attributes.$$class && (attributes.$$class = attributes.$$class.filter(e => !e.startsWith("xfa"))), attributes.dir = "auto");
            return {
              html,
              str: t[r.$text]()
            };
          } catch (e) {
            l.warn(`XFA - an error occurred during parsing of rich text: ${e}`);
          }
          return null;
        }
      }
      t.XFAFactory = u;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.XmlObject = t.XFAObjectArray = t.XFAObject = t.XFAAttribute = t.StringObject = t.OptionObject = t.Option10 = t.Option01 = t.IntegerObject = t.ContentObject = t.$uid = t.$toStyle = t.$toString = t.$toPages = t.$toHTML = t.$text = t.$tabIndex = t.$setValue = t.$setSetAttributes = t.$setId = t.$searchNode = t.$root = t.$resolvePrototypes = t.$removeChild = t.$pushPara = t.$pushGlyphs = t.$popPara = t.$onText = t.$onChildCheck = t.$onChild = t.$nsAttributes = t.$nodeName = t.$namespaceId = t.$isUsable = t.$isTransparent = t.$isThereMoreWidth = t.$isSplittable = t.$isNsAgnostic = t.$isDescendent = t.$isDataValue = t.$isCDATAXml = t.$isBindable = t.$insertAt = t.$indexOf = t.$ids = t.$hasSettableValue = t.$globalData = t.$getTemplateRoot = t.$getSubformParent = t.$getRealChildrenByNameIt = t.$getParent = t.$getNextPage = t.$getExtra = t.$getDataValue = t.$getContainedChildren = t.$getChildrenByNameIt = t.$getChildrenByName = t.$getChildrenByClass = t.$getChildren = t.$getAvailableSpace = t.$getAttributes = t.$getAttributeIt = t.$flushHTML = t.$finalize = t.$extra = t.$dump = t.$data = t.$content = t.$consumed = t.$clone = t.$cleanup = t.$cleanPage = t.$clean = t.$childrenToHTML = t.$appendChild = t.$addHTML = t.$acceptWhitespace = void 0;
      var r = a(77);
      var i = a(2);
      var n = a(8);
      var s = a(78);
      var o = a(79);
      let l = Symbol();
      t.$acceptWhitespace = l;
      let c = Symbol();
      t.$addHTML = c;
      let h = Symbol();
      t.$appendChild = h;
      let u = Symbol();
      t.$childrenToHTML = u;
      let d = Symbol();
      t.$clean = d;
      let f = Symbol();
      t.$cleanPage = f;
      let g = Symbol();
      t.$cleanup = g;
      let p = Symbol();
      t.$clone = p;
      let m = Symbol();
      t.$consumed = m;
      let b = Symbol("content");
      t.$content = b;
      let y = Symbol("data");
      t.$data = y;
      let w = Symbol();
      t.$dump = w;
      let x = Symbol("extra");
      t.$extra = x;
      let S = Symbol();
      t.$finalize = S;
      let k = Symbol();
      t.$flushHTML = k;
      let A = Symbol();
      t.$getAttributeIt = A;
      let v = Symbol();
      t.$getAttributes = v;
      let C = Symbol();
      t.$getAvailableSpace = C;
      let O = Symbol();
      t.$getChildrenByClass = O;
      let F = Symbol();
      t.$getChildrenByName = F;
      let I = Symbol();
      t.$getChildrenByNameIt = I;
      let T = Symbol();
      t.$getDataValue = T;
      let M = Symbol();
      t.$getExtra = M;
      let P = Symbol();
      t.$getRealChildrenByNameIt = P;
      let E = Symbol();
      t.$getChildren = E;
      let N = Symbol();
      t.$getContainedChildren = N;
      let B = Symbol();
      t.$getNextPage = B;
      let D = Symbol();
      t.$getSubformParent = D;
      let L = Symbol();
      t.$getParent = L;
      let R = Symbol();
      t.$getTemplateRoot = R;
      let $ = Symbol();
      t.$globalData = $;
      let j = Symbol();
      t.$hasSettableValue = j;
      let _ = Symbol();
      t.$ids = _;
      let U = Symbol();
      t.$indexOf = U;
      let X = Symbol();
      t.$insertAt = X;
      let H = Symbol();
      t.$isCDATAXml = H;
      let q = Symbol();
      t.$isBindable = q;
      let z = Symbol();
      t.$isDataValue = z;
      let G = Symbol();
      t.$isDescendent = G;
      let W = Symbol();
      t.$isNsAgnostic = W;
      let V = Symbol();
      t.$isSplittable = V;
      let K = Symbol();
      t.$isThereMoreWidth = K;
      let Y = Symbol();
      t.$isTransparent = Y;
      let J = Symbol();
      t.$isUsable = J;
      let Z = Symbol();
      let Q = Symbol("namespaceId");
      t.$namespaceId = Q;
      let ee = Symbol("nodeName");
      t.$nodeName = ee;
      let et = Symbol();
      t.$nsAttributes = et;
      let ea = Symbol();
      t.$onChild = ea;
      let er = Symbol();
      t.$onChildCheck = er;
      let ei = Symbol();
      t.$onText = ei;
      let en = Symbol();
      t.$pushGlyphs = en;
      let es = Symbol();
      t.$popPara = es;
      let eo = Symbol();
      t.$pushPara = eo;
      let el = Symbol();
      t.$removeChild = el;
      let ec = Symbol("root");
      t.$root = ec;
      let eh = Symbol();
      t.$resolvePrototypes = eh;
      let eu = Symbol();
      t.$searchNode = eu;
      let ed = Symbol();
      t.$setId = ed;
      let ef = Symbol();
      t.$setSetAttributes = ef;
      let eg = Symbol();
      t.$setValue = eg;
      let ep = Symbol();
      t.$tabIndex = ep;
      let em = Symbol();
      t.$text = em;
      let eb = Symbol();
      t.$toPages = eb;
      let ey = Symbol();
      t.$toHTML = ey;
      let ew = Symbol();
      t.$toString = ew;
      let ex = Symbol();
      t.$toStyle = ex;
      let eS = Symbol("uid");
      t.$uid = eS;
      let ek = Symbol();
      let eA = Symbol();
      let ev = Symbol();
      let eC = Symbol("_children");
      let eO = Symbol();
      let eF = Symbol();
      let eI = Symbol();
      let eT = Symbol();
      let eM = Symbol();
      let eP = Symbol();
      let eE = Symbol();
      let eN = Symbol();
      let eB = Symbol();
      let eD = Symbol("parent");
      let eL = Symbol();
      let eR = Symbol();
      let e$ = Symbol();
      let ej = 0;
      let e_ = s.NamespaceIds.datasets.id;
      class eU {
        constructor(e, t, a = !1) {
          this[Q] = e;
          this[ee] = t;
          this[eE] = a;
          this[eD] = null;
          this[eC] = [];
          this[eS] = `${t}${ej++}`;
          this[$] = null;
        }
        [ea](e) {
          if (!this[eE] || !this[er](e)) return !1;
          let t = e[ee];
          let a = this[t];
          if (!(a instanceof eX)) {
            null !== a && this[el](a);
            this[t] = e;
            this[h](e);
            return !0;
          }
          if (a.push(e)) {
            this[h](e);
            return !0;
          }
          let r = "";
          this.id ? r = ` (id: ${this.id})` : this.name && (r = ` (name: ${this.name} ${this.h.value})`);
          i.warn(`XFA - node "${this[ee]}"${r} has already enough "${t}"!`);
          return !1;
        }
        [er](e) {
          return this.hasOwnProperty(e[ee]) && e[Q] === this[Q];
        }
        [W]() {
          return !1;
        }
        [l]() {
          return !1;
        }
        [H]() {
          return !1;
        }
        [q]() {
          return !1;
        }
        [es]() {
          this.para && this[R]()[x].paraStack.pop();
        }
        [eo]() {
          this[R]()[x].paraStack.push(this.para);
        }
        [ed](e) {
          this.id && this[Q] === s.NamespaceIds.template.id && e.set(this.id, this);
        }
        [R]() {
          return this[$].template;
        }
        [V]() {
          return !1;
        }
        [K]() {
          return !1;
        }
        [h](e) {
          e[eD] = this;
          this[eC].push(e);
          !e[$] && this[$] && (e[$] = this[$]);
        }
        [el](e) {
          let t = this[eC].indexOf(e);
          this[eC].splice(t, 1);
        }
        [j]() {
          return this.hasOwnProperty("value");
        }
        [eg](e) { }
        [ei](e) { }
        [S]() { }
        [d](e) {
          delete this[eE];
          this[g] && (e.clean(this[g]), delete this[g]);
        }
        [U](e) {
          return this[eC].indexOf(e);
        }
        [X](e, t) {
          t[eD] = this;
          this[eC].splice(e, 0, t);
          !t[$] && this[$] && (t[$] = this[$]);
        }
        [Y]() {
          return !this.name;
        }
        [Z]() {
          return "";
        }
        [em]() {
          return 0 === this[eC].length ? this[b] : this[eC].map(e => e[em]()).join("");
        }
        get [ev]() {
          let e = Object.getPrototypeOf(this);
          if (!e._attributes) {
            let t = e._attributes = new Set();
            for (let e of Object.getOwnPropertyNames(this)) {
              if (null === this[e] || this[e] instanceof eU || this[e] instanceof eX) break;
              t.add(e);
            }
          }
          return i.shadow(this, ev, e._attributes);
        }
        [G](e) {
          let t = this;
          for (; t;) {
            if (t === e) return !0;
            t = t[L]();
          }
          return !1;
        }
        [L]() {
          return this[eD];
        }
        [D]() {
          return this[L]();
        }
        [E](e = null) {
          return e ? this[e] : this[eC];
        }
        [w]() {
          let e = Object.create(null);
          for (let t of (this[b] && (e.$content = this[b]), Object.getOwnPropertyNames(this))) {
            let a = this[t];
            null !== a && (a instanceof eU ? e[t] = a[w]() : a instanceof eX ? a.isEmpty() || (e[t] = a.dump()) : e[t] = a);
          }
          return e;
        }
        [ex]() {
          return null;
        }
        [ey]() {
          return r.HTMLResult.EMPTY;
        }
        *[N]() {
          for (let e of this[E]()) yield e;
        }
        *[eT](e, t) {
          for (let a of this[N]()) if (!e || t === e.has(a[ee])) {
            let e = this[C]();
            let t = a[ey](e);
            t.success || (this[x].failingNode = a);
            yield t;
          }
        }
        [k]() {
          return null;
        }
        [c](e, t) {
          this[x].children.push(e);
        }
        [C]() { }
        [u]({
          filter: e = null,
          include: t = !0
        }) {
          if (this[x].generator) {
            let e = this[C]();
            let t = this[x].failingNode[ey](e);
            if (!t.success) return t;
            t.html && this[c](t.html, t.bbox);
            delete this[x].failingNode;
          } else this[x].generator = this[eT](e, t);
          for (; ;) {
            let e = this[x].generator.next();
            if (e.done) break;
            let t = e.value;
            if (!t.success) return t;
            t.html && this[c](t.html, t.bbox);
          }
          this[x].generator = null;
          return r.HTMLResult.EMPTY;
        }
        [ef](e) {
          this[eR] = new Set(Object.keys(e));
        }
        [eP](e) {
          let t = this[ev];
          let a = this[eR];
          return [...e].filter(e => t.has(e) && !a.has(e));
        }
        [eh](e, t = new Set()) {
          for (let a of this[eC]) a[eL](e, t);
        }
        [eL](e, t) {
          let a = this[eM](e, t);
          a ? this[ek](a, e, t) : this[eh](e, t);
        }
        [eM](e, t) {
          let {
            use,
            usehref
          } = this;
          if (!use && !usehref) return null;
          let n = null;
          let s = null;
          let l = null;
          let c = use;
          if (usehref ? (c = usehref, usehref.startsWith("#som(") && usehref.endsWith(")") ? s = usehref.slice(5, usehref.length - 1) : usehref.startsWith(".#som(") && usehref.endsWith(")") ? s = usehref.slice(6, usehref.length - 1) : usehref.startsWith("#") ? l = usehref.slice(1) : usehref.startsWith(".#") && (l = usehref.slice(2))) : use.startsWith("#") ? l = use.slice(1) : s = use, this.use = this.usehref = "", l ? n = e.get(l) : (n = o.searchNode(e.get(ec), this, s, !0, !1)) && (n = n[0]), !n) {
            i.warn(`XFA - Invalid prototype reference: ${c}.`);
            return null;
          }
          if (n[ee] !== this[ee]) {
            i.warn(`XFA - Incompatible prototype: ${n[ee]} !== ${this[ee]}.`);
            return null;
          }
          if (t.has(n)) {
            i.warn("XFA - Cycle detected in prototypes use.");
            return null;
          }
          t.add(n);
          let h = n[eM](e, t);
          h && n[ek](h, e, t);
          n[eh](e, t);
          t.$$delete(n);
          return n;
        }
        [ek](e, t, a) {
          if (a.has(e)) {
            i.warn("XFA - Cycle detected in prototypes use.");
            return;
          }
          for (let t of (!this[b] && e[b] && (this[b] = e[b]), new Set(a).add(e), this[eP](e[eR]))) {
            this[t] = e[t];
            this[eR] && this[eR].add(t);
          }
          for (let r of Object.getOwnPropertyNames(this)) {
            if (this[ev].has(r)) continue;
            let i = this[r];
            let n = e[r];
            if (i instanceof eX) {
              for (let e of i[eC]) e[eL](t, a);
              for (function () {
                let r = i[eC].length;
                let s = n[eC].length;
              }(); r < s; r++) {
                let n = e[eC][r][p]();
                if (i.push(n)) {
                  n[eD] = this;
                  this[eC].push(n);
                  n[eL](t, a);
                } else break;
              }
              continue;
            }
            if (null !== i) {
              i[eh](t, a);
              n && i[ek](n, t, a);
              continue;
            }
            if (null !== n) {
              let e = n[p]();
              e[eD] = this;
              this[r] = e;
              this[eC].push(e);
              e[eL](t, a);
            }
          }
        }
        static [eO](e) {
          return Array.isArray(e) ? e.map(e => eU[eO](e)) : "object" == typeof e && null !== e ? Object.assign({}, e) : e;
        }
        [p]() {
          let e = Object.create(Object.getPrototypeOf(this));
          for (let t of Object.getOwnPropertySymbols(this)) try {
            e[t] = this[t];
          } catch (a) {
            i.shadow(e, t, this[t]);
          }
          for (let t of (e[eS] = `${e[ee]}${ej++}`, e[eC] = [], Object.getOwnPropertyNames(this))) {
            if (this[ev].has(t)) {
              e[t] = eU[eO](this[t]);
              continue;
            }
            let a = this[t];
            a instanceof eX ? e[t] = new eX(a[eN]) : e[t] = null;
          }
          for (let t of this[eC]) {
            let a = t[ee];
            let r = t[p]();
            e[eC].push(r);
            r[eD] = e;
            e[a]?.[eC].push(r);
          }
          return e;
        }
        [E](e = null) {
          return e ? this[eC].filter(t => t[ee] === e) : this[eC];
        }
        [O](e) {
          return this[e];
        }
        [F](e, t, a = !0) {
          return Array.from(this[I](e, t, a));
        }
        *[I](e, t, a = !0) {
          if ("parent" === e) {
            yield this[eD];
            return;
          }
          for (let a of this[eC]) {
            a[ee] === e && (yield a);
            a.name === e && (yield a);
            (t || a[Y]()) && (yield* a[I](e, t, !1));
          }
          a && this[ev].has(e) && (yield new eH(this, e, this[e]));
        }
      }
      t.XFAObject = eU;
      class eX {
        constructor(e = 1 / 0) {
          this[eN] = e;
          this[eC] = [];
        }
        push(e) {
          return this[eC].length <= this[eN] ? (this[eC].push(e), !0) : (i.warn(`XFA - node "${e[ee]}" accepts no more than ${this[eN]} children`), !1);
        }
        isEmpty() {
          return 0 === this[eC].length;
        }
        dump() {
          return 1 === this[eC].length ? this[eC][0][w]() : this[eC].map(e => e[w]());
        }
        [p]() {
          let e = new eX(this[eN]);
          e[eC] = this[eC].map(e => e[p]());
          return e;
        }
        get children() {
          return this[eC];
        }
        clear() {
          this[eC].length = 0;
        }
      }
      t.XFAObjectArray = eX;
      class eH {
        constructor(e, t, a) {
          this[eD] = e;
          this[ee] = t;
          this[b] = a;
          this[m] = !1;
          this[eS] = `attribute${ej++}`;
        }
        [L]() {
          return this[eD];
        }
        [z]() {
          return !0;
        }
        [T]() {
          return this[b].trim();
        }
        [eg](e) {
          e = e.value || "";
          this[b] = e.toString();
        }
        [em]() {
          return this[b];
        }
        [G](e) {
          return this[eD] === e || this[eD][G](e);
        }
      }
      t.XFAAttribute = eH;
      class eq extends eU {
        constructor(e, t, a = {}) {
          this[b] = "";
          this[eF] = null;
          if (super(e, t), "#text" !== t) {
            let e = new Map();
            for (let [t, r] of (this[eA] = e, Object.entries(a))) e.set(t, new eH(this, t, r));
            if (a.hasOwnProperty(et)) {
              let e = a[et].xfa.dataNode;
              void 0 !== e && ("dataGroup" === e ? this[eF] = !1 : "dataValue" === e && (this[eF] = !0));
            }
          }
          this[m] = !1;
        }
        [ew](e) {
          let t = this[ee];
          if ("#text" === t) {
            e.push(n.encodeToXmlString(this[b]));
            return;
          }
          let a = i.utf8StringToString(t);
          let r = this[Q] === e_ ? "xfa:" : "";
          for (let [t, s] of (e.push(`<${r}${a}`), this[eA].entries())) {
            let a = i.utf8StringToString(t);
            e.push(` ${a}="${n.encodeToXmlString(s[b])}"`);
          }
          if (null !== this[eF] && (this[eF] ? e.push(' xfa:dataNode="dataValue"') : e.push(' xfa:dataNode="dataGroup"')), !this[b] && 0 === this[eC].length) {
            e.push("/>");
            return;
          }
          if (e.push(">"), this[b]) "string" == typeof this[b] ? e.push(n.encodeToXmlString(this[b])) : this[b][ew](e); else for (let t of this[eC]) t[ew](e);
          e.push(`</${r}${a}>`);
        }
        [ea](e) {
          if (this[b]) {
            let e = new eq(this[Q], "#text");
            this[h](e);
            e[b] = this[b];
            this[b] = "";
          }
          this[h](e);
          return !0;
        }
        [ei](e) {
          this[b] += e;
        }
        [S]() {
          if (this[b] && this[eC].length > 0) {
            let e = new eq(this[Q], "#text");
            this[h](e);
            e[b] = this[b];
            delete this[b];
          }
        }
        [ey]() {
          return "#text" === this[ee] ? r.HTMLResult.success({
            name: "#text",
            value: this[b]
          }) : r.HTMLResult.EMPTY;
        }
        [E](e = null) {
          return e ? this[eC].filter(t => t[ee] === e) : this[eC];
        }
        [v]() {
          return this[eA];
        }
        [O](e) {
          let t = this[eA].get(e);
          return void 0 !== t ? t : this[E](e);
        }
        *[I](e, t) {
          let a = this[eA].get(e);
          for (let r of (a && (yield a), this[eC])) {
            r[ee] === e && (yield r);
            t && (yield* r[I](e, t));
          }
        }
        *[A](e, t) {
          let a = this[eA].get(e);
          for (let r of (!a || t && a[m] || (yield a), this[eC])) yield* r[A](e, t);
        }
        *[P](e, t, a) {
          for (let r of this[eC]) {
            r[ee] !== e || a && r[m] || (yield r);
            t && (yield* r[P](e, t, a));
          }
        }
        [z]() {
          return this[eF];
        }
        [T]() {
          return null === this[eF] ? 0 === this[eC].length ? this[b].trim() : this[eC][0][Q] === s.NamespaceIds.xhtml.id ? this[eC][0][em]().trim() : null : this[b].trim();
        }
        [eg](e) {
          e = e.value || "";
          this[b] = e.toString();
        }
        [w](e = !1) {
          let t = Object.create(null);
          for (let a of (e && (t.$ns = this[Q]), this[b] && (t.$content = this[b]), t.$name = this[ee], t.children = [], this[eC])) t.children.push(a[w](e));
          for (let [e, a] of (t.attributes = Object.create(null), this[eA])) t.attributes[e] = a[b];
          return t;
        }
      }
      t.XmlObject = eq;
      class ez extends eU {
        constructor(e, t) {
          super(e, t);
          this[b] = "";
        }
        [ei](e) {
          this[b] += e;
        }
        [S]() { }
      }
      t.ContentObject = ez;
      t.OptionObject = class extends ez {
        constructor(e, t, a) {
          super(e, t);
          this[eB] = a;
        }
        [S]() {
          this[b] = r.getKeyword({
            data: this[b],
            defaultValue: this[eB][0],
            validate: e => this[eB].includes(e)
          });
        }
        [d](e) {
          super[d](e);
          delete this[eB];
        }
      };
      t.StringObject = class extends ez {
        [S]() {
          this[b] = this[b].trim();
        }
      };
      class eG extends ez {
        constructor(e, t, a, r) {
          super(e, t);
          this[eI] = a;
          this[e$] = r;
        }
        [S]() {
          this[b] = r.getInteger({
            data: this[b],
            defaultValue: this[eI],
            validate: this[e$]
          });
        }
        [d](e) {
          super[d](e);
          delete this[eI];
          delete this[e$];
        }
      }
      t.IntegerObject = eG;
      t.Option01 = class extends eG {
        constructor(e, t) {
          super(e, t, 0, e => 1 === e);
        }
      };
      t.Option10 = class extends eG {
        constructor(e, t) {
          super(e, t, 1, e => 0 === e);
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.HTMLResult = void 0;
      t.getBBox = function (e) {
        if (!e) return {
          x: -1,
          y: -1,
          width: -1,
          height: -1
        };
        let t = e.trim().split(/\s*,\s*/).map(e => o(e, "-1"));
        if (t.length < 4 || t[2] < 0 || t[3] < 0) return {
          x: -1,
          y: -1,
          width: -1,
          height: -1
        };
        let [a, r, i, n] = t;
        return {
          x: a,
          y: r,
          width: i,
          height: n
        };
      };
      t.getColor = function (e, t = [0, 0, 0]) {
        let [a, r, i] = t;
        if (!e) return {
          r: a,
          g: r,
          b: i
        };
        let n = e.trim().split(/\s*,\s*/).map(e => Math.min(Math.max(0, parseInt(e.trim(), 10)), 255)).map(e => isNaN(e) ? 0 : e);
        n.length < 3 || ([a, r, i] = n);
        return {
          r: a,
          g: r,
          b: i
        };
      };
      t.getFloat = function ({
        data: e,
        defaultValue: t,
        validate: a
      }) {
        if (!e) return t;
        let r = parseFloat(e = e.trim());
        return !isNaN(r) && a(r) ? r : t;
      };
      t.getInteger = function ({
        data: e,
        defaultValue: t,
        validate: a
      }) {
        if (!e) return t;
        let r = parseInt(e = e.trim(), 10);
        return !isNaN(r) && a(r) ? r : t;
      };
      t.getKeyword = s;
      t.getMeasurement = o;
      t.getRatio = function (e) {
        if (!e) return {
          num: 1,
          den: 1
        };
        let t = e.trim().split(/\s*:\s*/).map(e => parseFloat(e)).filter(e => !isNaN(e));
        if (1 === t.length && t.push(1), 0 === t.length) return {
          num: 1,
          den: 1
        };
        let [a, r] = t;
        return {
          num: a,
          den: r
        };
      };
      t.getRelevant = function (e) {
        return e ? e.trim().split(/\s+/).map(e => ({
          excluded: "-" === e[0],
          viewname: e.substring(1)
        })) : [];
      };
      t.getStringOption = function (e, t) {
        return s({
          data: e,
          defaultValue: t[0],
          validate: e => t.includes(e)
        });
      };
      t.stripQuotes = function (e) {
        return e.startsWith("'") || e.startsWith('"') ? e.slice(1, e.length - 1) : e;
      };
      var r = a(2);
      let i = {
        pt: e => e,
        cm: e => e / 2.54 * 72,
        mm: e => e / 25.4 * 72,
        in: e => 72 * e,
        px: e => e
      };
      let n = /([+-]?\d+\.?\d*)(.*)/;
      function s({
        data: e,
        defaultValue: t,
        validate: a
      }) {
        return e && a(e = e.trim()) ? e : t;
      }
      function o(e, t = "0") {
        if (t = t || "0", !e) return o(t);
        let a = e.trim().match(n);
        if (!a) return o(t);
        let [, r, s] = a;
        let l = parseFloat(r);
        if (isNaN(l)) return o(t);
        if (0 === l) return 0;
        let c = i[s];
        return c ? c(l) : l;
      }
      class l {
        static get FAILURE() {
          return r.shadow(this, "FAILURE", new l(!1, null, null, null));
        }
        static get EMPTY() {
          return r.shadow(this, "EMPTY", new l(!0, null, null, null));
        }
        constructor(e, t, a, r) {
          this.success = e;
          this.html = t;
          this.bbox = a;
          this.breakNode = r;
        }
        isBreak() {
          return !!this.breakNode;
        }
        static breakNode(e) {
          return new l(!1, null, null, e);
        }
        static success(e, t = null) {
          return new l(!0, e, t, null);
        }
      }
      t.HTMLResult = l;
    }, (e, t) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.NamespaceIds = t.$buildXFAObject = void 0;
      let a = Symbol();
      t.$buildXFAObject = a;
      t.NamespaceIds = {
        config: {
          id: 0,
          check: e => e.startsWith("http://www.xfa.org/schema/xci/")
        },
        connectionSet: {
          id: 1,
          check: e => e.startsWith("http://www.xfa.org/schema/xfa-connection-set/")
        },
        datasets: {
          id: 2,
          check: e => e.startsWith("http://www.xfa.org/schema/xfa-data/")
        },
        form: {
          id: 3,
          check: e => e.startsWith("http://www.xfa.org/schema/xfa-form/")
        },
        localeSet: {
          id: 4,
          check: e => e.startsWith("http://www.xfa.org/schema/xfa-locale-set/")
        },
        pdf: {
          id: 5,
          check: e => "http://ns.adobe.com/xdp/pdf/" === e
        },
        signature: {
          id: 6,
          check: e => "http://www.w3.org/2000/09/xmldsig#" === e
        },
        sourceSet: {
          id: 7,
          check: e => e.startsWith("http://www.xfa.org/schema/xfa-source-set/")
        },
        stylesheet: {
          id: 8,
          check: e => "http://www.w3.org/1999/XSL/Transform" === e
        },
        template: {
          id: 9,
          check: e => e.startsWith("http://www.xfa.org/schema/xfa-template/")
        },
        xdc: {
          id: 10,
          check: e => e.startsWith("http://www.xfa.org/schema/xdc/")
        },
        xdp: {
          id: 11,
          check: e => "http://ns.adobe.com/xdp/" === e
        },
        xfdf: {
          id: 12,
          check: e => "http://ns.adobe.com/xfdf/" === e
        },
        xhtml: {
          id: 13,
          check: e => "http://www.w3.org/1999/xhtml" === e
        },
        xmpmeta: {
          id: 14,
          check: e => "http://ns.adobe.com/xmpmeta/" === e
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.createDataNode = function (e, t, a) {
        let i = d(a);
        if (!i || i.some(e => e.operator === l.dotDot)) return null;
        let s = c.get(i[0].name);
        let o = 0;
        s ? (e = s(e, t), o = 1) : e = t || e;
        for (let t = i.length; o < t; o++) {
          let t;
          let {
            name,
            operator,
            index
          } = i[o];
          if (!isFinite(index)) {
            i[o].index = 0;
            return f(e, i.slice(o));
          }
          switch (operator) {
            case l.dot:
              t = e[r.$getChildrenByName](name, !1);
              break;
            case l.dotDot:
              t = e[r.$getChildrenByName](name, !0);
              break;
            case l.dotHash:
              t = (t = e[r.$getChildrenByClass](name)) instanceof r.XFAObjectArray ? t.children : [t];
          }
          if (0 === t.length) return f(e, i.slice(o));
          if (!(index < t.length)) {
            i[o].index = index - t.length;
            return f(e, i.slice(o));
          }
          {
            let a = t[index];
            if (!(a instanceof r.XFAObject)) {
              n.warn("XFA - Cannot create a node.");
              return null;
            }
            e = a;
          }
        }
        return null;
      };
      t.searchNode = function (e, t, a, i = !0, n = !0) {
        let s;
        let o = d(a, i);
        if (!o) return null;
        let u = c.get(o[0].name);
        let f = 0;
        u ? (s = !0, e = [u(e, t)], f = 1) : (s = null === t, e = [t || e]);
        for (let a = o.length; f < a; f++) {
          let {
            name,
            cacheName,
            operator,
            index
          } = o[f];
          let d = [];
          for (let t of e) {
            let e;
            let s;
            if (t instanceof r.XFAObject) {
              if (n && ((s = h.get(t)) || (s = new Map(), h.set(t, s)), e = s.get(cacheName)), !e) {
                switch (operator) {
                  case l.dot:
                    e = t[r.$getChildrenByName](name, !1);
                    break;
                  case l.dotDot:
                    e = t[r.$getChildrenByName](name, !0);
                    break;
                  case l.dotHash:
                    e = (e = t[r.$getChildrenByClass](name)) instanceof r.XFAObjectArray ? e.children : [e];
                }
                n && s.set(cacheName, e);
              }
              e.length > 0 && d.push(e);
            }
          }
          if (0 === d.length && !s && 0 === f) {
            if (!(t = t[r.$getParent]())) return null;
            f = -1;
            e = [t];
            continue;
          }
          e = isFinite(index) ? d.filter(e => index < e.length).map(e => e[index]) : d.reduce((e, t) => e.concat(t), []);
        }
        return 0 === e.length ? null : e;
      };
      var r = a(76);
      var i = a(78);
      var n = a(2);
      let s = /^[^.[]+/;
      let o = /^[^\]]+/;
      let l = {
        dot: 0,
        dotDot: 1,
        dotHash: 2,
        dotBracket: 3,
        dotParen: 4
      };
      let c = new Map([["$data", (e, t) => e.datasets ? e.datasets.data : e], ["$record", (e, t) => (e.datasets ? e.datasets.data : e)[r.$getChildren]()[0]], ["$template", (e, t) => e.template], ["$connectionSet", (e, t) => e.connectionSet], ["$form", (e, t) => e.form], ["$layout", (e, t) => e.layout], ["$host", (e, t) => e.host], ["$dataWindow", (e, t) => e.dataWindow], ["$event", (e, t) => e.event], ["!", (e, t) => e.datasets], ["$xfa", (e, t) => e], ["xfa", (e, t) => e], ["$", (e, t) => t]]);
      let h = new WeakMap();
      let u = i.NamespaceIds.datasets.id;
      function d(e, t, a = !0) {
        let r = e.match(s);
        if (!r) return null;
        let [i] = r;
        let c = [{
          name: i,
          cacheName: "." + i,
          index: 0,
          js: null,
          formCalc: null,
          operator: l.dot
        }];
        let h = i.length;
        for (; h < e.length;) {
          let d;
          let f = h;
          if ("[" === e.charAt(h++)) {
            var u;
            if (!(r = e.slice(h).match(o))) {
              n.warn("XFA - Invalid index in SOM expression");
              return null;
            }
            c[c.length - 1].index = "*" === (u = (u = r[0]).trim()) ? 1 / 0 : parseInt(u, 10) || 0;
            h += r[0].length + 1;
            continue;
          }
          switch (e.charAt(h)) {
            case ".":
              if (!t) return null;
              h++;
              d = l.dotDot;
              break;
            case "#":
              h++;
              d = l.dotHash;
              break;
            case "[":
              if (a) {
                n.warn("XFA - SOM expression contains a FormCalc subexpression which is not supported for now.");
                return null;
              }
              d = l.dotBracket;
              break;
            case "(":
              if (a) {
                n.warn("XFA - SOM expression contains a JavaScript subexpression which is not supported for now.");
                return null;
              }
              d = l.dotParen;
              break;
            default:
              d = l.dot;
          }
          if (!(r = e.slice(h).match(s))) break;
          [i] = r;
          h += i.length;
          c.push({
            name: i,
            cacheName: e.slice(f, h),
            operator: d,
            index: 0,
            js: null,
            formCalc: null
          });
        }
        return c;
      }
      function f(e, t) {
        let a = null;
        for (let {
          name,
          index
        } of t) {
          for (function () {
            let t = 0;
            let s = isFinite(index) ? index : 0;
          }(); t <= s; t++) {
            let t = e[r.$namespaceId] === u ? -1 : e[r.$namespaceId];
            a = new r.XmlObject(t, name);
            e[r.$appendChild](a);
          }
          e = a;
        }
        return a;
      }
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.Binder = void 0;
      var r = a(76);
      var i = a(81);
      var n = a(79);
      var s = a(78);
      var o = a(2);
      let l = s.NamespaceIds.datasets.id;
      function c(e) {
        let t = new i.Text({});
        t[r.$content] = e;
        return t;
      }
      t.Binder = class {
        constructor(e) {
          this.root = e;
          this.datasets = e.datasets;
          e.datasets && e.datasets.data ? this.data = e.datasets.data : this.data = new r.XmlObject(s.NamespaceIds.datasets.id, "data");
          this.emptyMerge = 0 === this.data[r.$getChildren]().length;
          this.root.form = this.form = e.template[r.$clone]();
        }
        _isConsumeData() {
          return !this.emptyMerge && this._mergeMode;
        }
        _isMatchTemplate() {
          return !this._isConsumeData();
        }
        bind() {
          this._bindElement(this.form, this.data);
          return this.form;
        }
        getData() {
          return this.data;
        }
        _bindValue(e, t, a) {
          if (e[r.$data] = t, e[r.$hasSettableValue]()) {
            if (t[r.$isDataValue]()) {
              let a = t[r.$getDataValue]();
              e[r.$setValue](c(a));
            } else if (e instanceof i.Field && e.ui && e.ui.choiceList && "multiSelect" === e.ui.choiceList.open) {
              let a = t[r.$getChildren]().map(e => e[r.$content].trim()).join("\n");
              e[r.$setValue](c(a));
            } else this._isConsumeData() && o.warn("XFA - Nodes haven't the same type.");
          } else !t[r.$isDataValue]() || this._isMatchTemplate() ? this._bindElement(e, t) : o.warn("XFA - Nodes haven't the same type.");
        }
        _findDataByNameToConsume(e, t, a, i) {
          let n;
          let o;
          if (!e) return null;
          for (let i = 0; i < 3; i++) {
            for (n = a[r.$getRealChildrenByNameIt](e, !1, !0); o = n.next().value;) if (t === o[r.$isDataValue]()) return o;
            if (a[r.$namespaceId] === s.NamespaceIds.datasets.id && "data" === a[r.$nodeName]) break;
            a = a[r.$getParent]();
          }
          return i && ((o = (n = this.data[r.$getRealChildrenByNameIt](e, !0, !1)).next().value) || (o = (n = this.data[r.$getAttributeIt](e, !0)).next().value) && o[r.$isDataValue]()) ? o : null;
        }
        _setProperties(e, t) {
          if (e.hasOwnProperty("setProperty")) for (let {
            ref,
            target,
            connection
          } of e.setProperty.children) {
            if (connection || !ref) continue;
            let c = n.searchNode(this.root, t, ref, !1, !1);
            if (!c) {
              o.warn(`XFA - Invalid reference: ${ref}.`);
              continue;
            }
            let [h] = c;
            if (!h[r.$isDescendent](this.data)) {
              o.warn("XFA - Invalid node: must be a data node.");
              continue;
            }
            let u = n.searchNode(this.root, e, target, !1, !1);
            if (!u) {
              o.warn(`XFA - Invalid target: ${target}.`);
              continue;
            }
            let [d] = u;
            if (!d[r.$isDescendent](e)) {
              o.warn("XFA - Invalid target: must be a property or subproperty.");
              continue;
            }
            let f = d[r.$getParent]();
            if (d instanceof i.SetProperty || f instanceof i.SetProperty) {
              o.warn("XFA - Invalid target: cannot be a setProperty or one of its properties.");
              continue;
            }
            if (d instanceof i.BindItems || f instanceof i.BindItems) {
              o.warn("XFA - Invalid target: cannot be a bindItems or one of its properties.");
              continue;
            }
            let g = h[r.$text]();
            let p = d[r.$nodeName];
            if (d instanceof r.XFAAttribute) {
              let e = Object.create(null);
              e[p] = g;
              let t = Reflect.construct(Object.getPrototypeOf(f).constructor, [e]);
              f[p] = t[p];
              continue;
            }
            if (!d.hasOwnProperty(r.$content)) {
              o.warn("XFA - Invalid node to use in setProperty");
              continue;
            }
            d[r.$data] = h;
            d[r.$content] = g;
            d[r.$finalize]();
          }
        }
        _bindItems(e, t) {
          if (!e.hasOwnProperty("items") || !e.hasOwnProperty("bindItems") || e.bindItems.isEmpty()) return;
          for (let t of e.items.children) e[r.$removeChild](t);
          e.items.clear();
          let a = new i.Items({});
          let s = new i.Items({});
          for (let {
            ref,
            labelRef,
            valueRef,
            connection
          } of (e[r.$appendChild](a), e.items.push(a), e[r.$appendChild](s), e.items.push(s), e.bindItems.children)) {
            if (connection || !ref) continue;
            let e = n.searchNode(this.root, t, ref, !1, !1);
            if (!e) {
              o.warn(`XFA - Invalid reference: ${ref}.`);
              continue;
            }
            for (let t of e) {
              if (!t[r.$isDescendent](this.datasets)) {
                o.warn(`XFA - Invalid ref (${ref}): must be a datasets child.`);
                continue;
              }
              let e = n.searchNode(this.root, t, labelRef, !0, !1);
              if (!e) {
                o.warn(`XFA - Invalid label: ${labelRef}.`);
                continue;
              }
              let [u] = e;
              if (!u[r.$isDescendent](this.datasets)) {
                o.warn("XFA - Invalid label: must be a datasets child.");
                continue;
              }
              let d = n.searchNode(this.root, t, valueRef, !0, !1);
              if (!d) {
                o.warn(`XFA - Invalid value: ${valueRef}.`);
                continue;
              }
              let [f] = d;
              if (!f[r.$isDescendent](this.datasets)) {
                o.warn("XFA - Invalid value: must be a datasets child.");
                continue;
              }
              let g = c(u[r.$text]());
              let p = c(f[r.$text]());
              a[r.$appendChild](g);
              a.text.push(g);
              s[r.$appendChild](p);
              s.text.push(p);
            }
          }
        }
        _bindOccurrences(e, t, a) {
          let i;
          if (t.length > 1 && ((i = e[r.$clone]())[r.$removeChild](i.occur), i.occur = null), this._bindValue(e, t[0], a), this._setProperties(e, t[0]), this._bindItems(e, t[0]), 1 === t.length) return;
          let n = e[r.$getParent]();
          let s = e[r.$nodeName];
          let o = n[r.$indexOf](e);
          for (function () {
            let e = 1;
            let l = t.length;
          }(); e < l; e++) {
            let l = t[e];
            let c = i[r.$clone]();
            n[s].push(c);
            n[r.$insertAt](o + e, c);
            this._bindValue(c, l, a);
            this._setProperties(c, l);
            this._bindItems(c, l);
          }
        }
        _createOccurrences(e) {
          let t;
          if (!this.emptyMerge) return;
          let {
            occur
          } = e;
          if (!occur || occur.initial <= 1) return;
          let i = e[r.$getParent]();
          let n = e[r.$nodeName];
          if (!(i[n] instanceof r.XFAObjectArray)) return;
          t = e.name ? i[n].children.filter(t => t.name === e.name).length : i[n].children.length;
          let s = i[r.$indexOf](e) + 1;
          let o = occur.initial - t;
          if (o) {
            let t = e[r.$clone]();
            t[r.$removeChild](t.occur);
            t.occur = null;
            i[n].push(t);
            i[r.$insertAt](s, t);
            for (let e = 1; e < o; e++) {
              let a = t[r.$clone]();
              i[n].push(a);
              i[r.$insertAt](s + e, a);
            }
          }
        }
        _getOccurInfo(e) {
          let {
            name,
            occur
          } = e;
          if (!occur || !name) return [1, 1];
          let r = -1 === occur.max ? 1 / 0 : occur.max;
          return [occur.min, r];
        }
        _setAndBind(e, t) {
          this._setProperties(e, t);
          this._bindItems(e, t);
          this._bindElement(e, t);
        }
        _bindElement(e, t) {
          let a = [];
          for (let i of (this._createOccurrences(e), e[r.$getChildren]())) {
            if (i[r.$data]) continue;
            if (void 0 === this._mergeMode && "subform" === i[r.$nodeName]) {
              this._mergeMode = "consumeData" === i.mergeMode;
              let e = t[r.$getChildren]();
              if (e.length > 0) this._bindOccurrences(i, [e[0]], null); else if (this.emptyMerge) {
                let e = t[r.$namespaceId] === l ? -1 : t[r.$namespaceId];
                let a = i[r.$data] = new r.XmlObject(e, i.name || "root");
                t[r.$appendChild](a);
                this._bindElement(i, a);
              }
              continue;
            }
            if (!i[r.$isBindable]()) continue;
            let e = !1;
            let s = null;
            let c = null;
            let h = null;
            if (i.bind) {
              switch (i.bind.match) {
                case "none":
                  this._setAndBind(i, t);
                  continue;
                case "global":
                  e = !0;
                  break;
                case "dataRef":
                  if (!i.bind.ref) {
                    o.warn(`XFA - ref is empty in node ${i[r.$nodeName]}.`);
                    this._setAndBind(i, t);
                    continue;
                  }
                  c = i.bind.ref;
              }
              i.bind.picture && (s = i.bind.picture[r.$content]);
            }
            let [u, d] = this._getOccurInfo(i);
            if (c) {
              if (null === (h = n.searchNode(this.root, t, c, !0, !1))) {
                if (!(h = n.createDataNode(this.data, t, c))) continue;
                this._isConsumeData() && (h[r.$consumed] = !0);
                this._setAndBind(i, h);
                continue;
              }
              this._isConsumeData() && (h = h.filter(e => !e[r.$consumed]));
              h.length > d ? h = h.slice(0, d) : 0 === h.length && (h = null);
              h && this._isConsumeData() && h.forEach(e => {
                e[r.$consumed] = !0;
              });
            } else {
              if (!i.name) {
                this._setAndBind(i, t);
                continue;
              }
              if (this._isConsumeData()) {
                let a = [];
                for (; a.length < d;) {
                  let n = this._findDataByNameToConsume(i.name, i[r.$hasSettableValue](), t, e);
                  if (!n) break;
                  n[r.$consumed] = !0;
                  a.push(n);
                }
                h = a.length > 0 ? a : null;
              } else {
                if (!(h = t[r.$getRealChildrenByNameIt](i.name, !1, this.emptyMerge).next().value)) {
                  if (0 === u) {
                    a.push(i);
                    continue;
                  }
                  let e = t[r.$namespaceId] === l ? -1 : t[r.$namespaceId];
                  h = i[r.$data] = new r.XmlObject(e, i.name);
                  this.emptyMerge && (h[r.$consumed] = !0);
                  t[r.$appendChild](h);
                  this._setAndBind(i, h);
                  continue;
                }
                this.emptyMerge && (h[r.$consumed] = !0);
                h = [h];
              }
            }
            h ? this._bindOccurrences(i, h, s) : u > 0 ? this._setAndBind(i, t) : a.push(i);
          }
          a.forEach(e => e[r.$getParent]()[r.$removeChild](e));
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.Value = t.Text = t.TemplateNamespace = t.Template = t.SetProperty = t.Items = t.Field = t.BindItems = void 0;
      var r = a(76);
      var i = a(78);
      var n = a(82);
      var s = a(83);
      var o = a(77);
      var l = a(2);
      var c = a(84);
      var h = a(8);
      var u = a(79);
      let d = i.NamespaceIds.template.id;
      let f = "http://www.w3.org/2000/svg";
      let g = /^H(\d+)$/;
      let p = new Set(["image/gif", "image/jpeg", "image/jpg", "image/pjpeg", "image/png", "image/apng", "image/x-png", "image/bmp", "image/x-ms-bmp", "image/tiff", "image/tif", "application/octet-stream"]);
      let m = [[[66, 77], "image/bmp"], [[255, 216, 255], "image/jpeg"], [[73, 73, 42, 0], "image/tiff"], [[77, 77, 0, 42], "image/tiff"], [[71, 73, 70, 56, 57, 97], "image/gif"], [[137, 80, 78, 71, 13, 10, 26, 10], "image/png"]];
      function b(e) {
        if (!e || !e.border) return {
          w: 0,
          h: 0
        };
        let t = e.border[r.$getExtra]();
        return t ? {
          w: t.widths[0] + t.widths[2] + t.insets[0] + t.insets[2],
          h: t.widths[1] + t.widths[3] + t.insets[1] + t.insets[3]
        } : {
          w: 0,
          h: 0
        };
      }
      function y(e) {
        return e.margin && (e.margin.topInset || e.margin.rightInset || e.margin.bottomInset || e.margin.leftInset);
      }
      function w(e, t) {
        if (!e.value) {
          let t = new tk({});
          e[r.$appendChild](t);
          e.value = t;
        }
        e.value[r.$setValue](t);
      }
      function* x(e) {
        for (let t of e[r.$getChildren]()) {
          if (t instanceof tl) {
            yield* t[r.$getContainedChildren]();
            continue;
          }
          yield t;
        }
      }
      function S(e) {
        for (; e;) {
          if (!e.traversal) {
            e[r.$tabIndex] = e[r.$getParent]()[r.$tabIndex];
            return;
          }
          if (e[r.$tabIndex]) return;
          let t = null;
          for (let a of e.traversal[r.$getChildren]()) if ("next" === a.operation) {
            t = a;
            break;
          }
          if (!t || !t.ref) {
            e[r.$tabIndex] = e[r.$getParent]()[r.$tabIndex];
            return;
          }
          let a = e[r.$getTemplateRoot]();
          e[r.$tabIndex] = ++a[r.$tabIndex];
          let i = a[r.$searchNode](t.ref, e);
          if (!i) return;
          e = i[0];
        }
      }
      function k(e, t) {
        let a = e.assist;
        if (a) {
          let e = a[r.$toHTML]();
          e && (t.title = e);
          let i = a.role.match(g);
          if (i) {
            let e = i[1];
            t.role = "heading";
            t["aria-level"] = e;
          }
        }
        if ("table" === e.layout) t.role = "table"; else if ("row" === e.layout) t.role = "row"; else {
          let a = e[r.$getParent]();
          "row" === a.layout && (a.assist && "TH" === a.assist.role ? t.role = "columnheader" : t.role = "cell");
        }
      }
      function A(e) {
        if (!e.assist) return null;
        let t = e.assist;
        return t.speak && "" !== t.speak[r.$content] ? t.speak[r.$content] : t.toolTip ? t.toolTip[r.$content] : null;
      }
      function v(e) {
        return o.HTMLResult.success({
          name: "div",
          attributes: {
            class: ["xfaRich"],
            style: Object.create(null)
          },
          children: [{
            name: "span",
            attributes: {
              style: Object.create(null)
            },
            value: e
          }]
        });
      }
      function C(e) {
        let t = e[r.$getTemplateRoot]();
        null === t[r.$extra].firstUnsplittable && (t[r.$extra].firstUnsplittable = e, t[r.$extra].noLayoutFailure = !0);
      }
      function O(e) {
        let t = e[r.$getTemplateRoot]();
        t[r.$extra].firstUnsplittable === e && (t[r.$extra].noLayoutFailure = !1);
      }
      function F(e) {
        let t;
        if (e[r.$extra] || (e[r.$extra] = Object.create(null), "auto" === e.targetType)) return !1;
        let a = e[r.$getTemplateRoot]();
        let i = null;
        if (e.target) {
          if (!(i = a[r.$searchNode](e.target, e[r.$getParent]()))) return !1;
          i = i[0];
        }
        let {
          currentPageArea,
          currentContentArea
        } = a[r.$extra];
        if ("pageArea" === e.targetType) return (i instanceof eJ || (i = null), e.startNew) ? (e[r.$extra].target = i || currentPageArea, !0) : !!i && i !== currentPageArea && (e[r.$extra].target = i, !0);
        i instanceof Z || (i = null);
        let o = i && i[r.$getParent]();
        let l = o;
        if (e.startNew) {
          if (i) {
            let e = o.contentArea.children;
            let a = e.indexOf(currentContentArea);
            let r = e.indexOf(i);
            -1 !== a && a < r && (l = null);
            t = r - 1;
          } else t = currentPageArea.contentArea.children.indexOf(currentContentArea);
        } else {
          if (!i || i === currentContentArea) return !1;
          t = o.contentArea.children.indexOf(i) - 1;
          l = o === currentPageArea ? null : o;
        }
        e[r.$extra].target = l;
        e[r.$extra].index = t;
        return !0;
      }
      function I(e, t, a) {
        let i = e[r.$getTemplateRoot]();
        let n = i[r.$extra].noLayoutFailure;
        let s = t[r.$getSubformParent];
        t[r.$getSubformParent] = () => e;
        i[r.$extra].noLayoutFailure = !0;
        let o = t[r.$toHTML](a);
        e[r.$addHTML](o.html, o.bbox);
        i[r.$extra].noLayoutFailure = n;
        t[r.$getSubformParent] = s;
      }
      class T extends r.StringObject {
        constructor(e) {
          super(d, "appearanceFilter");
          this.id = e.id || "";
          this.type = o.getStringOption(e.type, ["optional", "required"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class M extends r.XFAObject {
        constructor(e) {
          super(d, "arc", !0);
          this.circular = o.getInteger({
            data: e.circular,
            defaultValue: 0,
            validate: e => 1 === e
          });
          this.hand = o.getStringOption(e.hand, ["even", "left", "right"]);
          this.id = e.id || "";
          this.startAngle = o.getFloat({
            data: e.startAngle,
            defaultValue: 0,
            validate: e => !0
          });
          this.sweepAngle = o.getFloat({
            data: e.sweepAngle,
            defaultValue: 360,
            validate: e => !0
          });
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.edge = null;
          this.fill = null;
        }
        [r.$toHTML]() {
          let e;
          let t = this.edge ? this.edge : new ec({});
          let a = t[r.$toStyle]();
          let i = Object.create(null);
          this.fill && "visible" === this.fill.presence ? Object.assign(i, this.fill[r.$toStyle]()) : i.fill = "transparent";
          i.strokeWidth = s.measureToString("visible" === t.presence ? t.thickness : 0);
          i.stroke = a.color;
          let n = {
            xmlns: f,
            style: {
              width: "100%",
              height: "100%",
              overflow: "visible"
            }
          };
          if (360 === this.sweepAngle) e = {
            name: "ellipse",
            attributes: {
              xmlns: f,
              cx: "50%",
              cy: "50%",
              rx: "50%",
              ry: "50%",
              style: i
            }
          }; else {
            let t = this.startAngle * Math.PI / 180;
            let a = this.sweepAngle * Math.PI / 180;
            let r = this.sweepAngle > 180 ? 1 : 0;
            let [s, o, l, c] = [50 * (1 + Math.cos(t)), 50 * (1 - Math.sin(t)), 50 * (1 + Math.cos(t + a)), 50 * (1 - Math.sin(t + a))];
            e = {
              name: "path",
              attributes: {
                xmlns: f,
                d: `M ${s} ${o} A 50 50 0 ${r} 0 ${l} ${c}`,
                vectorEffect: "non-scaling-stroke",
                style: i
              }
            };
            Object.assign(n, {
              viewBox: "0 0 100 100",
              preserveAspectRatio: "none"
            });
          }
          let l = {
            name: "svg",
            children: [e],
            attributes: n
          };
          return y(this[r.$getParent]()[r.$getParent]()) ? o.HTMLResult.success({
            name: "div",
            attributes: {
              style: {
                display: "inline",
                width: "100%",
                height: "100%"
              }
            },
            children: [l]
          }) : (l.attributes.style.position = "absolute", o.HTMLResult.success(l));
        }
      }
      class P extends r.XFAObject {
        constructor(e) {
          super(d, "area", !0);
          this.colSpan = o.getInteger({
            data: e.colSpan,
            defaultValue: 1,
            validate: e => e >= 1 || -1 === e
          });
          this.id = e.id || "";
          this.name = e.name || "";
          this.relevant = o.getRelevant(e.relevant);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.x = o.getMeasurement(e.x, "0pt");
          this.y = o.getMeasurement(e.y, "0pt");
          this.desc = null;
          this.extras = null;
          this.area = new r.XFAObjectArray();
          this.draw = new r.XFAObjectArray();
          this.exObject = new r.XFAObjectArray();
          this.exclGroup = new r.XFAObjectArray();
          this.field = new r.XFAObjectArray();
          this.subform = new r.XFAObjectArray();
          this.subformSet = new r.XFAObjectArray();
        }
        *[r.$getContainedChildren]() {
          yield* x(this);
        }
        [r.$isTransparent]() {
          return !0;
        }
        [r.$isBindable]() {
          return !0;
        }
        [r.$addHTML](e, t) {
          let [a, i, n, s] = t;
          this[r.$extra].width = Math.max(this[r.$extra].width, a + n);
          this[r.$extra].height = Math.max(this[r.$extra].height, i + s);
          this[r.$extra].children.push(e);
        }
        [r.$getAvailableSpace]() {
          return this[r.$extra].availableSpace;
        }
        [r.$toHTML](e) {
          let t = s.toStyle(this, "position");
          let a = {
            style: t,
            id: this[r.$uid],
            class: ["xfaArea"]
          };
          s.isPrintOnly(this) && a.$$class.push("xfaPrintOnly");
          this.name && (a.xfaName = this.name);
          let i = [];
          this[r.$extra] = {
            children: i,
            width: 0,
            height: 0,
            availableSpace: e
          };
          let n = this[r.$childrenToHTML]({
            filter: new Set(["area", "draw", "field", "exclGroup", "subform", "subformSet"]),
            include: !0
          });
          if (!n.success) return n.isBreak() ? n : (delete this[r.$extra], o.HTMLResult.FAILURE);
          t.width = s.measureToString(this[r.$extra].width);
          t.height = s.measureToString(this[r.$extra].height);
          let l = [this.x, this.y, this[r.$extra].width, this[r.$extra].height];
          delete this[r.$extra];
          return o.HTMLResult.success({
            name: "div",
            attributes: a,
            children: i
          }, l);
        }
      }
      class E extends r.XFAObject {
        constructor(e) {
          super(d, "assist", !0);
          this.id = e.id || "";
          this.role = e.role || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.speak = null;
          this.toolTip = null;
        }
        [r.$toHTML]() {
          return this.toolTip && this.toolTip[r.$content] ? this.toolTip[r.$content] : null;
        }
      }
      class N extends r.XFAObject {
        constructor(e) {
          super(d, "barcode", !0);
          this.charEncoding = o.getKeyword({
            data: e.charEncoding ? e.charEncoding.toLowerCase() : "",
            defaultValue: "",
            validate: e => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(e) || e.match(/iso-8859-\d{2}/)
          });
          this.checksum = o.getStringOption(e.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]);
          this.dataColumnCount = o.getInteger({
            data: e.dataColumnCount,
            defaultValue: -1,
            validate: e => e >= 0
          });
          this.dataLength = o.getInteger({
            data: e.dataLength,
            defaultValue: -1,
            validate: e => e >= 0
          });
          this.dataPrep = o.getStringOption(e.dataPrep, ["none", "flateCompress"]);
          this.dataRowCount = o.getInteger({
            data: e.dataRowCount,
            defaultValue: -1,
            validate: e => e >= 0
          });
          this.endChar = e.endChar || "";
          this.errorCorrectionLevel = o.getInteger({
            data: e.errorCorrectionLevel,
            defaultValue: -1,
            validate: e => e >= 0 && e <= 8
          });
          this.id = e.id || "";
          this.moduleHeight = o.getMeasurement(e.moduleHeight, "5mm");
          this.moduleWidth = o.getMeasurement(e.moduleWidth, "0.25mm");
          this.printCheckDigit = o.getInteger({
            data: e.printCheckDigit,
            defaultValue: 0,
            validate: e => 1 === e
          });
          this.rowColumnRatio = o.getRatio(e.rowColumnRatio);
          this.startChar = e.startChar || "";
          this.textLocation = o.getStringOption(e.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]);
          this.truncate = o.getInteger({
            data: e.truncate,
            defaultValue: 0,
            validate: e => 1 === e
          });
          this.type = o.getStringOption(e.type ? e.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]);
          this.upsMode = o.getStringOption(e.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.wideNarrowRatio = o.getRatio(e.wideNarrowRatio);
          this.encrypt = null;
          this.extras = null;
        }
      }
      class B extends r.XFAObject {
        constructor(e) {
          super(d, "bind", !0);
          this.match = o.getStringOption(e.match, ["once", "dataRef", "global", "none"]);
          this.ref = e.ref || "";
          this.picture = null;
        }
      }
      class D extends r.XFAObject {
        constructor(e) {
          super(d, "bindItems");
          this.connection = e.connection || "";
          this.labelRef = e.labelRef || "";
          this.ref = e.ref || "";
          this.valueRef = e.valueRef || "";
        }
      }
      t.BindItems = D;
      class L extends r.XFAObject {
        constructor(e) {
          super(d, "bookend");
          this.id = e.id || "";
          this.leader = e.leader || "";
          this.trailer = e.trailer || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class R extends r.Option01 {
        constructor(e) {
          super(d, "boolean");
          this.id = e.id || "";
          this.name = e.name || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
        [r.$toHTML](e) {
          return v(1 === this[r.$content] ? "1" : "0");
        }
      }
      class $ extends r.XFAObject {
        constructor(e) {
          super(d, "border", !0);
          this.$$break = o.getStringOption(e.$$break, ["close", "open"]);
          this.hand = o.getStringOption(e.hand, ["even", "left", "right"]);
          this.id = e.id || "";
          this.presence = o.getStringOption(e.presence, ["visible", "hidden", "inactive", "invisible"]);
          this.relevant = o.getRelevant(e.relevant);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.corner = new r.XFAObjectArray(4);
          this.edge = new r.XFAObjectArray(4);
          this.extras = null;
          this.fill = null;
          this.margin = null;
        }
        [r.$getExtra]() {
          if (!this[r.$extra]) {
            let e = this.edge.children.slice();
            if (e.length < 4) {
              let t = e[e.length - 1] || new ec({});
              for (let a = e.length; a < 4; a++) e.push(t);
            }
            let t = e.map(e => e.thickness);
            let a = [0, 0, 0, 0];
            this.margin && (a[0] = this.margin.topInset, a[1] = this.margin.rightInset, a[2] = this.margin.bottomInset, a[3] = this.margin.leftInset);
            this[r.$extra] = {
              widths: t,
              insets: a,
              edges: e
            };
          }
          return this[r.$extra];
        }
        [r.$toStyle]() {
          let {
            edges
          } = this[r.$getExtra]();
          let t = edges.map(e => {
            let t = e[r.$toStyle]();
            t.color = t.color || "#000000";
            return t;
          });
          let a = Object.create(null);
          if (this.margin && Object.assign(a, this.margin[r.$toStyle]()), this.fill && "visible" === this.fill.presence && Object.assign(a, this.fill[r.$toStyle]()), this.corner.children.some(e => 0 !== e.radius)) {
            let e = this.corner.children.map(e => e[r.$toStyle]());
            if (2 === e.length || 3 === e.length) {
              let t = e[e.length - 1];
              for (let a = e.length; a < 4; a++) e.push(t);
            }
            a.borderRadius = e.map(e => e.radius).join(" ");
          }
          switch (this.presence) {
            case "invisible":
            case "hidden":
              a.borderStyle = "";
              break;
            case "inactive":
              a.borderStyle = "none";
              break;
            default:
              a.borderStyle = t.map(e => e.style).join(" ");
          }
          a.borderWidth = t.map(e => e.width).join(" ");
          a.borderColor = t.map(e => e.color).join(" ");
          return a;
        }
      }
      class j extends r.XFAObject {
        constructor(e) {
          super(d, "break", !0);
          this.after = o.getStringOption(e.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
          this.afterTarget = e.afterTarget || "";
          this.before = o.getStringOption(e.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
          this.beforeTarget = e.beforeTarget || "";
          this.bookendLeader = e.bookendLeader || "";
          this.bookendTrailer = e.bookendTrailer || "";
          this.id = e.id || "";
          this.overflowLeader = e.overflowLeader || "";
          this.overflowTarget = e.overflowTarget || "";
          this.overflowTrailer = e.overflowTrailer || "";
          this.startNew = o.getInteger({
            data: e.startNew,
            defaultValue: 0,
            validate: e => 1 === e
          });
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.extras = null;
        }
      }
      class _ extends r.XFAObject {
        constructor(e) {
          super(d, "breakAfter", !0);
          this.id = e.id || "";
          this.leader = e.leader || "";
          this.startNew = o.getInteger({
            data: e.startNew,
            defaultValue: 0,
            validate: e => 1 === e
          });
          this.target = e.target || "";
          this.targetType = o.getStringOption(e.targetType, ["auto", "contentArea", "pageArea"]);
          this.trailer = e.trailer || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.script = null;
        }
      }
      class U extends r.XFAObject {
        constructor(e) {
          super(d, "breakBefore", !0);
          this.id = e.id || "";
          this.leader = e.leader || "";
          this.startNew = o.getInteger({
            data: e.startNew,
            defaultValue: 0,
            validate: e => 1 === e
          });
          this.target = e.target || "";
          this.targetType = o.getStringOption(e.targetType, ["auto", "contentArea", "pageArea"]);
          this.trailer = e.trailer || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.script = null;
        }
        [r.$toHTML](e) {
          this[r.$extra] = {};
          return o.HTMLResult.FAILURE;
        }
      }
      class X extends r.XFAObject {
        constructor(e) {
          super(d, "button", !0);
          this.highlight = o.getStringOption(e.highlight, ["inverted", "none", "outline", "push"]);
          this.id = e.id || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.extras = null;
        }
        [r.$toHTML](e) {
          let t = this[r.$getParent]()[r.$getParent]();
          let a = {
            name: "button",
            attributes: {
              id: this[r.$uid],
              class: ["xfaButton"],
              style: {}
            },
            children: []
          };
          for (let e of t.event.children) {
            if ("click" !== e.activity || !e.script) continue;
            let t = h.recoverJsURL(e.script[r.$content]);
            if (!t) continue;
            let i = s.fixURL(t.url);
            i && a.children.push({
              name: "a",
              attributes: {
                id: "link" + this[r.$uid],
                href: i,
                newWindow: t.newWindow,
                class: ["xfaLink"],
                style: {}
              },
              children: []
            });
          }
          return o.HTMLResult.success(a);
        }
      }
      class H extends r.XFAObject {
        constructor(e) {
          super(d, "calculate", !0);
          this.id = e.id || "";
          this.override = o.getStringOption(e.override, ["disabled", "error", "ignore", "warning"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.extras = null;
          this.message = null;
          this.script = null;
        }
      }
      class q extends r.XFAObject {
        constructor(e) {
          super(d, "caption", !0);
          this.id = e.id || "";
          this.placement = o.getStringOption(e.placement, ["left", "bottom", "inline", "right", "top"]);
          this.presence = o.getStringOption(e.presence, ["visible", "hidden", "inactive", "invisible"]);
          this.reserve = Math.ceil(o.getMeasurement(e.reserve));
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.extras = null;
          this.font = null;
          this.margin = null;
          this.para = null;
          this.value = null;
        }
        [r.$setValue](e) {
          w(this, e);
        }
        [r.$getExtra](e) {
          if (!this[r.$extra]) {
            let {
              width,
              height
            } = e;
            switch (this.placement) {
              case "left":
              case "right":
              case "inline":
                t = this.reserve <= 0 ? width : this.reserve;
                break;
              case "top":
              case "bottom":
                a = this.reserve <= 0 ? height : this.reserve;
            }
            this[r.$extra] = s.layoutNode(this, {
              width,
              height
            });
          }
          return this[r.$extra];
        }
        [r.$toHTML](e) {
          if (!this.value) return o.HTMLResult.EMPTY;
          this[r.$pushPara]();
          let t = this.value[r.$toHTML](e).html;
          if (!t) {
            this[r.$popPara]();
            return o.HTMLResult.EMPTY;
          }
          let a = this.reserve;
          if (this.reserve <= 0) {
            let {
              w,
              h
            } = this[r.$getExtra](e);
            switch (this.placement) {
              case "left":
              case "right":
              case "inline":
                this.reserve = w;
                break;
              case "top":
              case "bottom":
                this.reserve = h;
            }
          }
          let i = [];
          "string" == typeof t ? i.push({
            name: "#text",
            value: t
          }) : i.push(t);
          let n = s.toStyle(this, "font", "margin", "visibility");
          switch (this.placement) {
            case "left":
            case "right":
              this.reserve > 0 && (n.width = s.measureToString(this.reserve));
              break;
            case "top":
            case "bottom":
              this.reserve > 0 && (n.height = s.measureToString(this.reserve));
          }
          s.setPara(this, null, t);
          this[r.$popPara]();
          this.reserve = a;
          return o.HTMLResult.success({
            name: "div",
            attributes: {
              style: n,
              class: ["xfaCaption"]
            },
            children: i
          });
        }
      }
      class z extends r.StringObject {
        constructor(e) {
          super(d, "certificate");
          this.id = e.id || "";
          this.name = e.name || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class G extends r.XFAObject {
        constructor(e) {
          super(d, "certificates", !0);
          this.credentialServerPolicy = o.getStringOption(e.credentialServerPolicy, ["optional", "required"]);
          this.id = e.id || "";
          this.url = e.url || "";
          this.urlPolicy = e.urlPolicy || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.encryption = null;
          this.issuers = null;
          this.keyUsage = null;
          this.oids = null;
          this.signing = null;
          this.subjectDNs = null;
        }
      }
      class W extends r.XFAObject {
        constructor(e) {
          super(d, "checkButton", !0);
          this.id = e.id || "";
          this.mark = o.getStringOption(e.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]);
          this.shape = o.getStringOption(e.shape, ["square", "round"]);
          this.size = o.getMeasurement(e.size, "10pt");
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.border = null;
          this.extras = null;
          this.margin = null;
        }
        [r.$toHTML](e) {
          let t;
          let a;
          let i;
          let n;
          let l = s.toStyle("margin");
          let c = s.measureToString(this.size);
          l.width = l.height = c;
          let h = this[r.$getParent]()[r.$getParent]();
          let u = h.items.children.length && h.items.children[0][r.$toHTML]().html || [];
          let d = {
            on: (void 0 !== u[0] ? u[0] : "on").toString(),
            off: (void 0 !== u[1] ? u[1] : "off").toString()
          };
          let f = (h.value && h.value[r.$text]() || "off") === d.on || void 0;
          let g = h[r.$getSubformParent]();
          let p = h[r.$uid];
          g instanceof ex ? (i = g[r.$uid], t = "radio", a = "xfaRadio", n = g[r.$data] && g[r.$data][r.$uid] || g[r.$uid]) : (t = "checkbox", a = "xfaCheckbox", n = h[r.$data] && h[r.$data][r.$uid] || h[r.$uid]);
          let m = {
            name: "input",
            attributes: {
              class: [a],
              style: l,
              fieldId: p,
              dataId: n,
              type: t,
              checked: f,
              xfaOn: d.on,
              xfaOff: d.off,
              "aria-label": A(h)
            }
          };
          i && (m.attributes.name = i);
          return o.HTMLResult.success({
            name: "label",
            attributes: {
              class: ["xfaLabel"]
            },
            children: [m]
          });
        }
      }
      class V extends r.XFAObject {
        constructor(e) {
          super(d, "choiceList", !0);
          this.commitOn = o.getStringOption(e.commitOn, ["select", "exit"]);
          this.id = e.id || "";
          this.open = o.getStringOption(e.open, ["userControl", "always", "multiSelect", "onEntry"]);
          this.textEntry = o.getInteger({
            data: e.textEntry,
            defaultValue: 0,
            validate: e => 1 === e
          });
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.border = null;
          this.extras = null;
          this.margin = null;
        }
        [r.$toHTML](e) {
          let t = s.toStyle(this, "border", "margin");
          let a = this[r.$getParent]()[r.$getParent]();
          let i = a.font && a.font.size || 10;
          let n = {
            fontSize: `calc(${i}px * var(--zoom-factor))`
          };
          let l = [];
          if (a.items.children.length > 0) {
            let e = a.items;
            let t = 0;
            let i = 0;
            2 === e.children.length && (i = 1 - (t = e.children[0].save));
            let s = e.children[t][r.$toHTML]().html;
            let o = e.children[i][r.$toHTML]().html;
            let c = !1;
            let h = a.value && a.value[r.$text]() || "";
            for (function () {
              let e = 0;
              let t = s.length;
            }(); e < t; e++) {
              let t = {
                name: "option",
                attributes: {
                  value: o[e] || s[e],
                  style: n
                },
                value: s[e]
              };
              o[e] === h && (t.attributes.selected = c = !0);
              l.push(t);
            }
            c || l.splice(0, 0, {
              name: "option",
              attributes: {
                hidden: !0,
                selected: !0
              },
              value: " "
            });
          }
          let c = {
            class: ["xfaSelect"],
            fieldId: a[r.$uid],
            dataId: a[r.$data] && a[r.$data][r.$uid] || a[r.$uid],
            style: t,
            "aria-label": A(a)
          };
          "multiSelect" === this.open && (c.multiple = !0);
          return o.HTMLResult.success({
            name: "label",
            attributes: {
              class: ["xfaLabel"]
            },
            children: [{
              name: "select",
              children: l,
              attributes: c
            }]
          });
        }
      }
      class K extends r.XFAObject {
        constructor(e) {
          super(d, "color", !0);
          this.cSpace = o.getStringOption(e.cSpace, ["SRGB"]);
          this.id = e.id || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.value = e.value ? o.getColor(e.value) : "";
          this.extras = null;
        }
        [r.$hasSettableValue]() {
          return !1;
        }
        [r.$toStyle]() {
          return this.value ? l.Util.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
        }
      }
      class Y extends r.XFAObject {
        constructor(e) {
          super(d, "comb");
          this.id = e.id || "";
          this.numberOfCells = o.getInteger({
            data: e.numberOfCells,
            defaultValue: 0,
            validate: e => e >= 0
          });
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class J extends r.XFAObject {
        constructor(e) {
          super(d, "connect", !0);
          this.connection = e.connection || "";
          this.id = e.id || "";
          this.ref = e.ref || "";
          this.usage = o.getStringOption(e.usage, ["exportAndImport", "exportOnly", "importOnly"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.picture = null;
        }
      }
      class Z extends r.XFAObject {
        constructor(e) {
          super(d, "contentArea", !0);
          this.h = o.getMeasurement(e.h);
          this.id = e.id || "";
          this.name = e.name || "";
          this.relevant = o.getRelevant(e.relevant);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.w = o.getMeasurement(e.w);
          this.x = o.getMeasurement(e.x, "0pt");
          this.y = o.getMeasurement(e.y, "0pt");
          this.desc = null;
          this.extras = null;
        }
        [r.$toHTML](e) {
          let t = {
            left: s.measureToString(this.x),
            top: s.measureToString(this.y),
            width: s.measureToString(this.w),
            height: s.measureToString(this.h)
          };
          let a = ["xfaContentarea"];
          s.isPrintOnly(this) && a.push("xfaPrintOnly");
          return o.HTMLResult.success({
            name: "div",
            children: [],
            attributes: {
              style: t,
              class: a,
              id: this[r.$uid]
            }
          });
        }
      }
      class Q extends r.XFAObject {
        constructor(e) {
          super(d, "corner", !0);
          this.id = e.id || "";
          this.inverted = o.getInteger({
            data: e.inverted,
            defaultValue: 0,
            validate: e => 1 === e
          });
          this.join = o.getStringOption(e.join, ["square", "round"]);
          this.presence = o.getStringOption(e.presence, ["visible", "hidden", "inactive", "invisible"]);
          this.radius = o.getMeasurement(e.radius);
          this.stroke = o.getStringOption(e.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]);
          this.thickness = o.getMeasurement(e.thickness, "0.5pt");
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.color = null;
          this.extras = null;
        }
        [r.$toStyle]() {
          let e = s.toStyle(this, "visibility");
          e.radius = s.measureToString("square" === this.join ? 0 : this.radius);
          return e;
        }
      }
      class ee extends r.ContentObject {
        constructor(e) {
          super(d, "date");
          this.id = e.id || "";
          this.name = e.name || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
        [r.$finalize]() {
          let e = this[r.$content].trim();
          this[r.$content] = e ? new Date(e) : null;
        }
        [r.$toHTML](e) {
          return v(this[r.$content] ? this[r.$content].toString() : "");
        }
      }
      class et extends r.ContentObject {
        constructor(e) {
          super(d, "dateTime");
          this.id = e.id || "";
          this.name = e.name || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
        [r.$finalize]() {
          let e = this[r.$content].trim();
          this[r.$content] = e ? new Date(e) : null;
        }
        [r.$toHTML](e) {
          return v(this[r.$content] ? this[r.$content].toString() : "");
        }
      }
      class ea extends r.XFAObject {
        constructor(e) {
          super(d, "dateTimeEdit", !0);
          this.hScrollPolicy = o.getStringOption(e.hScrollPolicy, ["auto", "off", "on"]);
          this.id = e.id || "";
          this.picker = o.getStringOption(e.picker, ["host", "none"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.border = null;
          this.comb = null;
          this.extras = null;
          this.margin = null;
        }
        [r.$toHTML](e) {
          let t = s.toStyle(this, "border", "font", "margin");
          let a = this[r.$getParent]()[r.$getParent]();
          let i = {
            name: "input",
            attributes: {
              type: "text",
              fieldId: a[r.$uid],
              dataId: a[r.$data] && a[r.$data][r.$uid] || a[r.$uid],
              class: ["xfaTextfield"],
              style: t,
              "aria-label": A(a)
            }
          };
          return o.HTMLResult.success({
            name: "label",
            attributes: {
              class: ["xfaLabel"]
            },
            children: [i]
          });
        }
      }
      class er extends r.ContentObject {
        constructor(e) {
          super(d, "decimal");
          this.fracDigits = o.getInteger({
            data: e.fracDigits,
            defaultValue: 2,
            validate: e => !0
          });
          this.id = e.id || "";
          this.leadDigits = o.getInteger({
            data: e.leadDigits,
            defaultValue: -1,
            validate: e => !0
          });
          this.name = e.name || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
        [r.$finalize]() {
          let e = parseFloat(this[r.$content].trim());
          this[r.$content] = isNaN(e) ? null : e;
        }
        [r.$toHTML](e) {
          return v(null !== this[r.$content] ? this[r.$content].toString() : "");
        }
      }
      class ei extends r.XFAObject {
        constructor(e) {
          super(d, "defaultUi", !0);
          this.id = e.id || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.extras = null;
        }
      }
      class en extends r.XFAObject {
        constructor(e) {
          super(d, "desc", !0);
          this.id = e.id || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.boolean = new r.XFAObjectArray();
          this.date = new r.XFAObjectArray();
          this.dateTime = new r.XFAObjectArray();
          this.decimal = new r.XFAObjectArray();
          this.exData = new r.XFAObjectArray();
          this.$$float = new r.XFAObjectArray();
          this.image = new r.XFAObjectArray();
          this.integer = new r.XFAObjectArray();
          this.text = new r.XFAObjectArray();
          this.time = new r.XFAObjectArray();
        }
      }
      class es extends r.OptionObject {
        constructor(e) {
          super(d, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]);
          this.id = e.id || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class eo extends r.XFAObject {
        constructor(e) {
          super(d, "digestMethods", !0);
          this.id = e.id || "";
          this.type = o.getStringOption(e.type, ["optional", "required"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.digestMethod = new r.XFAObjectArray();
        }
      }
      class el extends r.XFAObject {
        constructor(e) {
          super(d, "draw", !0);
          this.anchorType = o.getStringOption(e.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
          this.colSpan = o.getInteger({
            data: e.colSpan,
            defaultValue: 1,
            validate: e => e >= 1 || -1 === e
          });
          this.h = e.h ? o.getMeasurement(e.h) : "";
          this.hAlign = o.getStringOption(e.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
          this.id = e.id || "";
          this.locale = e.locale || "";
          this.maxH = o.getMeasurement(e.maxH, "0pt");
          this.maxW = o.getMeasurement(e.maxW, "0pt");
          this.minH = o.getMeasurement(e.minH, "0pt");
          this.minW = o.getMeasurement(e.minW, "0pt");
          this.name = e.name || "";
          this.presence = o.getStringOption(e.presence, ["visible", "hidden", "inactive", "invisible"]);
          this.relevant = o.getRelevant(e.relevant);
          this.rotate = o.getInteger({
            data: e.rotate,
            defaultValue: 0,
            validate: e => e % 90 == 0
          });
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.w = e.w ? o.getMeasurement(e.w) : "";
          this.x = o.getMeasurement(e.x, "0pt");
          this.y = o.getMeasurement(e.y, "0pt");
          this.assist = null;
          this.border = null;
          this.caption = null;
          this.desc = null;
          this.extras = null;
          this.font = null;
          this.keep = null;
          this.margin = null;
          this.para = null;
          this.traversal = null;
          this.ui = null;
          this.value = null;
          this.setProperty = new r.XFAObjectArray();
        }
        [r.$setValue](e) {
          w(this, e);
        }
        [r.$toHTML](e) {
          if (S(this), "hidden" === this.presence || "inactive" === this.presence) return o.HTMLResult.EMPTY;
          s.fixDimensions(this);
          this[r.$pushPara]();
          let t = this.w;
          let a = this.h;
          let {
            w,
            h: _h,
            isBroken
          } = s.layoutNode(this, e);
          if (w && "" === this.w) {
            if (isBroken && this[r.$getSubformParent]()[r.$isThereMoreWidth]()) {
              this[r.$popPara]();
              return o.HTMLResult.FAILURE;
            }
            this.w = w;
          }
          if (_h && "" === this.h && (this.h = _h), C(this), !n.checkDimensions(this, e)) {
            this.w = t;
            this.h = a;
            this[r.$popPara]();
            return o.HTMLResult.FAILURE;
          }
          O(this);
          let h = s.toStyle(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
          s.setMinMaxDimensions(this, h);
          h.margin && (h.padding = h.margin, delete h.margin);
          let u = ["xfaDraw"];
          this.font && u.push("xfaFont");
          s.isPrintOnly(this) && u.push("xfaPrintOnly");
          let d = {
            style: h,
            id: this[r.$uid],
            class: u
          };
          this.name && (d.xfaName = this.name);
          let f = {
            name: "div",
            attributes: d,
            children: []
          };
          k(this, d);
          let g = s.computeBbox(this, f, e);
          let p = this.value ? this.value[r.$toHTML](e).html : null;
          null === p || (f.children.push(p), s.setPara(this, h, p));
          this.w = t;
          this.h = a;
          this[r.$popPara]();
          return o.HTMLResult.success(s.createWrapper(this, f), g);
        }
      }
      class ec extends r.XFAObject {
        constructor(e) {
          super(d, "edge", !0);
          this.cap = o.getStringOption(e.cap, ["square", "butt", "round"]);
          this.id = e.id || "";
          this.presence = o.getStringOption(e.presence, ["visible", "hidden", "inactive", "invisible"]);
          this.stroke = o.getStringOption(e.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]);
          this.thickness = o.getMeasurement(e.thickness, "0.5pt");
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.color = null;
          this.extras = null;
        }
        [r.$toStyle]() {
          let e = s.toStyle(this, "visibility");
          if (Object.assign(e, {
            linecap: this.cap,
            width: s.measureToString(this.thickness),
            color: this.color ? this.color[r.$toStyle]() : "#000000",
            style: ""
          }), "visible" !== this.presence) e.style = "none"; else switch (this.stroke) {
            case "solid":
              e.style = "solid";
              break;
            case "dashDot":
            case "dashDotDot":
            case "dashed":
              e.style = "dashed";
              break;
            case "dotted":
              e.style = "dotted";
              break;
            case "embossed":
              e.style = "ridge";
              break;
            case "etched":
              e.style = "groove";
              break;
            case "lowered":
              e.style = "inset";
              break;
            case "raised":
              e.style = "outset";
          }
          return e;
        }
      }
      class eh extends r.OptionObject {
        constructor(e) {
          super(d, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]);
          this.id = e.id || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class eu extends r.XFAObject {
        constructor(e) {
          super(d, "encodings", !0);
          this.id = e.id || "";
          this.type = o.getStringOption(e.type, ["optional", "required"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.encoding = new r.XFAObjectArray();
        }
      }
      class ed extends r.XFAObject {
        constructor(e) {
          super(d, "encrypt", !0);
          this.id = e.id || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.certificate = null;
        }
      }
      class ef extends r.XFAObject {
        constructor(e) {
          super(d, "encryptData", !0);
          this.id = e.id || "";
          this.operation = o.getStringOption(e.operation, ["encrypt", "decrypt"]);
          this.target = e.target || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.filter = null;
          this.manifest = null;
        }
      }
      class eg extends r.XFAObject {
        constructor(e) {
          super(d, "encryption", !0);
          this.id = e.id || "";
          this.type = o.getStringOption(e.type, ["optional", "required"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.certificate = new r.XFAObjectArray();
        }
      }
      class ep extends r.OptionObject {
        constructor(e) {
          super(d, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]);
          this.id = e.id || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class em extends r.XFAObject {
        constructor(e) {
          super(d, "encryptionMethods", !0);
          this.id = e.id || "";
          this.type = o.getStringOption(e.type, ["optional", "required"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.encryptionMethod = new r.XFAObjectArray();
        }
      }
      class eb extends r.XFAObject {
        constructor(e) {
          super(d, "event", !0);
          this.activity = o.getStringOption(e.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]);
          this.id = e.id || "";
          this.listen = o.getStringOption(e.listen, ["refOnly", "refAndDescendents"]);
          this.name = e.name || "";
          this.ref = e.ref || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.extras = null;
          this.encryptData = null;
          this.execute = null;
          this.script = null;
          this.signData = null;
          this.submit = null;
        }
      }
      class ey extends r.ContentObject {
        constructor(e) {
          super(d, "exData");
          this.contentType = e.contentType || "";
          this.href = e.href || "";
          this.id = e.id || "";
          this.maxLength = o.getInteger({
            data: e.maxLength,
            defaultValue: -1,
            validate: e => e >= -1
          });
          this.name = e.name || "";
          this.rid = e.rid || "";
          this.transferEncoding = o.getStringOption(e.transferEncoding, ["none", "base64", "package"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
        [r.$isCDATAXml]() {
          return "text/html" === this.contentType;
        }
        [r.$onChild](e) {
          return ("text/html" === this.contentType && e[r.$namespaceId] === i.NamespaceIds.xhtml.id || "text/xml" === this.contentType) && (this[r.$content] = e, !0);
        }
        [r.$toHTML](e) {
          return "text/html" === this.contentType && this[r.$content] ? this[r.$content][r.$toHTML](e) : o.HTMLResult.EMPTY;
        }
      }
      class ew extends r.XFAObject {
        constructor(e) {
          super(d, "exObject", !0);
          this.archive = e.archive || "";
          this.classId = e.classId || "";
          this.codeBase = e.codeBase || "";
          this.codeType = e.codeType || "";
          this.id = e.id || "";
          this.name = e.name || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.extras = null;
          this.boolean = new r.XFAObjectArray();
          this.date = new r.XFAObjectArray();
          this.dateTime = new r.XFAObjectArray();
          this.decimal = new r.XFAObjectArray();
          this.exData = new r.XFAObjectArray();
          this.exObject = new r.XFAObjectArray();
          this.$$float = new r.XFAObjectArray();
          this.image = new r.XFAObjectArray();
          this.integer = new r.XFAObjectArray();
          this.text = new r.XFAObjectArray();
          this.time = new r.XFAObjectArray();
        }
      }
      class ex extends r.XFAObject {
        constructor(e) {
          super(d, "exclGroup", !0);
          this.access = o.getStringOption(e.access, ["open", "nonInteractive", "protected", "readOnly"]);
          this.accessKey = e.accessKey || "";
          this.anchorType = o.getStringOption(e.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
          this.colSpan = o.getInteger({
            data: e.colSpan,
            defaultValue: 1,
            validate: e => e >= 1 || -1 === e
          });
          this.h = e.h ? o.getMeasurement(e.h) : "";
          this.hAlign = o.getStringOption(e.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
          this.id = e.id || "";
          this.layout = o.getStringOption(e.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]);
          this.maxH = o.getMeasurement(e.maxH, "0pt");
          this.maxW = o.getMeasurement(e.maxW, "0pt");
          this.minH = o.getMeasurement(e.minH, "0pt");
          this.minW = o.getMeasurement(e.minW, "0pt");
          this.name = e.name || "";
          this.presence = o.getStringOption(e.presence, ["visible", "hidden", "inactive", "invisible"]);
          this.relevant = o.getRelevant(e.relevant);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.w = e.w ? o.getMeasurement(e.w) : "";
          this.x = o.getMeasurement(e.x, "0pt");
          this.y = o.getMeasurement(e.y, "0pt");
          this.assist = null;
          this.bind = null;
          this.border = null;
          this.calculate = null;
          this.caption = null;
          this.desc = null;
          this.extras = null;
          this.margin = null;
          this.para = null;
          this.traversal = null;
          this.validate = null;
          this.connect = new r.XFAObjectArray();
          this.event = new r.XFAObjectArray();
          this.field = new r.XFAObjectArray();
          this.setProperty = new r.XFAObjectArray();
        }
        [r.$isBindable]() {
          return !0;
        }
        [r.$hasSettableValue]() {
          return !0;
        }
        [r.$setValue](e) {
          for (let t of this.field.children) {
            if (!t.value) {
              let e = new tk({});
              t[r.$appendChild](e);
              t.value = e;
            }
            t.value[r.$setValue](e);
          }
        }
        [r.$isThereMoreWidth]() {
          return this.layout.endsWith("-tb") && 0 === this[r.$extra].attempt && this[r.$extra].numberInLine > 0 || this[r.$getParent]()[r.$isThereMoreWidth]();
        }
        [r.$isSplittable]() {
          let e = this[r.$getSubformParent]();
          return !!e[r.$isSplittable]() && (void 0 !== this[r.$extra]._isSplittable ? this[r.$extra]._isSplittable : "position" === this.layout || this.layout.includes("row") ? (this[r.$extra]._isSplittable = !1, !1) : (!(e.layout && e.layout.endsWith("-tb")) || 0 === e[r.$extra].numberInLine) && (this[r.$extra]._isSplittable = !0, !0));
        }
        [r.$flushHTML]() {
          return n.flushHTML(this);
        }
        [r.$addHTML](e, t) {
          n.addHTML(this, e, t);
        }
        [r.$getAvailableSpace]() {
          return n.getAvailableSpace(this);
        }
        [r.$toHTML](e) {
          if (S(this), "hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w) return o.HTMLResult.EMPTY;
          s.fixDimensions(this);
          let t = [];
          let a = {
            id: this[r.$uid],
            class: []
          };
          s.setAccess(this, a.$$class);
          this[r.$extra] || (this[r.$extra] = Object.create(null));
          Object.assign(this[r.$extra], {
            children: t,
            attributes: a,
            attempt: 0,
            line: null,
            numberInLine: 0,
            availableSpace: {
              width: Math.min(this.w || 1 / 0, e.width),
              height: Math.min(this.h || 1 / 0, e.height)
            },
            width: 0,
            height: 0,
            prevHeight: 0,
            currentWidth: 0
          });
          let i = this[r.$isSplittable]();
          if (i || C(this), !n.checkDimensions(this, e)) return o.HTMLResult.FAILURE;
          let l = new Set(["field"]);
          if (this.layout.includes("row")) {
            let e = this[r.$getSubformParent]().columnWidths;
            Array.isArray(e) && e.length > 0 && (this[r.$extra].columnWidths = e, this[r.$extra].currentColumn = 0);
          }
          let c = s.toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign");
          let h = ["xfaExclgroup"];
          let u = s.layoutClass(this);
          u && h.push(u);
          s.isPrintOnly(this) && h.push("xfaPrintOnly");
          a.style = c;
          a.$$class = h;
          this.name && (a.xfaName = this.name);
          this[r.$pushPara]();
          let d = "lr-tb" === this.layout || "rl-tb" === this.layout;
          let f = d ? 2 : 1;
          for (; this[r.$extra].attempt < f; this[r.$extra].attempt++) {
            d && 1 === this[r.$extra].attempt && (this[r.$extra].numberInLine = 0);
            let e = this[r.$childrenToHTML]({
              filter: l,
              include: !0
            });
            if (e.success) break;
            if (e.isBreak()) {
              this[r.$popPara]();
              return e;
            }
            if (d && 0 === this[r.$extra].attempt && 0 === this[r.$extra].numberInLine && !this[r.$getTemplateRoot]()[r.$extra].noLayoutFailure) {
              this[r.$extra].attempt = f;
              break;
            }
          }
          if (this[r.$popPara](), i || O(this), this[r.$extra].attempt === f) {
            i || delete this[r.$extra];
            return o.HTMLResult.FAILURE;
          }
          let g = 0;
          let p = 0;
          this.margin && (g = this.margin.leftInset + this.margin.rightInset, p = this.margin.topInset + this.margin.bottomInset);
          let m = Math.max(this[r.$extra].width + g, this.w || 0);
          let b = Math.max(this[r.$extra].height + p, this.h || 0);
          let y = [this.x, this.y, m, b];
          "" === this.w && (c.width = s.measureToString(m));
          "" === this.h && (c.height = s.measureToString(b));
          k(this, a);
          delete this[r.$extra];
          return o.HTMLResult.success(s.createWrapper(this, {
            name: "div",
            attributes: a,
            children: t
          }), y);
        }
      }
      class eS extends r.XFAObject {
        constructor(e) {
          super(d, "execute");
          this.connection = e.connection || "";
          this.executeType = o.getStringOption(e.executeType, ["import", "remerge"]);
          this.id = e.id || "";
          this.runAt = o.getStringOption(e.runAt, ["client", "both", "server"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class ek extends r.XFAObject {
        constructor(e) {
          super(d, "extras", !0);
          this.id = e.id || "";
          this.name = e.name || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.boolean = new r.XFAObjectArray();
          this.date = new r.XFAObjectArray();
          this.dateTime = new r.XFAObjectArray();
          this.decimal = new r.XFAObjectArray();
          this.exData = new r.XFAObjectArray();
          this.extras = new r.XFAObjectArray();
          this.$$float = new r.XFAObjectArray();
          this.image = new r.XFAObjectArray();
          this.integer = new r.XFAObjectArray();
          this.text = new r.XFAObjectArray();
          this.time = new r.XFAObjectArray();
        }
      }
      class eA extends r.XFAObject {
        constructor(e) {
          super(d, "field", !0);
          this.access = o.getStringOption(e.access, ["open", "nonInteractive", "protected", "readOnly"]);
          this.accessKey = e.accessKey || "";
          this.anchorType = o.getStringOption(e.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
          this.colSpan = o.getInteger({
            data: e.colSpan,
            defaultValue: 1,
            validate: e => e >= 1 || -1 === e
          });
          this.h = e.h ? o.getMeasurement(e.h) : "";
          this.hAlign = o.getStringOption(e.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
          this.id = e.id || "";
          this.locale = e.locale || "";
          this.maxH = o.getMeasurement(e.maxH, "0pt");
          this.maxW = o.getMeasurement(e.maxW, "0pt");
          this.minH = o.getMeasurement(e.minH, "0pt");
          this.minW = o.getMeasurement(e.minW, "0pt");
          this.name = e.name || "";
          this.presence = o.getStringOption(e.presence, ["visible", "hidden", "inactive", "invisible"]);
          this.relevant = o.getRelevant(e.relevant);
          this.rotate = o.getInteger({
            data: e.rotate,
            defaultValue: 0,
            validate: e => e % 90 == 0
          });
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.w = e.w ? o.getMeasurement(e.w) : "";
          this.x = o.getMeasurement(e.x, "0pt");
          this.y = o.getMeasurement(e.y, "0pt");
          this.assist = null;
          this.bind = null;
          this.border = null;
          this.calculate = null;
          this.caption = null;
          this.desc = null;
          this.extras = null;
          this.font = null;
          this.format = null;
          this.items = new r.XFAObjectArray(2);
          this.keep = null;
          this.margin = null;
          this.para = null;
          this.traversal = null;
          this.ui = null;
          this.validate = null;
          this.value = null;
          this.bindItems = new r.XFAObjectArray();
          this.connect = new r.XFAObjectArray();
          this.event = new r.XFAObjectArray();
          this.setProperty = new r.XFAObjectArray();
        }
        [r.$isBindable]() {
          return !0;
        }
        [r.$setValue](e) {
          w(this, e);
        }
        [r.$toHTML](e) {
          if (S(this), !this.ui) {
            let e;
            switch (this.ui = new tx({}), this.ui[r.$globalData] = this[r.$globalData], this[r.$appendChild](this.ui), this.items.children.length) {
              case 0:
                e = new tg({});
                this.ui.textEdit = e;
                break;
              case 1:
                e = new W({});
                this.ui.checkButton = e;
                break;
              case 2:
                e = new V({});
                this.ui.choiceList = e;
            }
            this.ui[r.$appendChild](e);
          }
          if (!this.ui || "hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w) return o.HTMLResult.EMPTY;
          this.caption && delete this.caption[r.$extra];
          this[r.$pushPara]();
          let t = this.caption ? this.caption[r.$toHTML](e).html : null;
          let a = this.w;
          let i = this.h;
          let l = 0;
          let h = 0;
          this.margin && (l = this.margin.leftInset + this.margin.rightInset, h = this.margin.topInset + this.margin.bottomInset);
          let u = null;
          if ("" === this.w || "" === this.h) {
            let t = null;
            let a = null;
            let i = 0;
            let n = 0;
            if (this.ui.checkButton) i = n = this.ui.checkButton.size; else {
              let {
                w,
                h
              } = s.layoutNode(this, e);
              null !== w ? (i = w, n = h) : n = c.getMetrics(this.font, !0).lineNoGap;
            }
            if (i += (u = b(this.ui[r.$getExtra]())).w, n += u.h, this.caption) {
              let {
                w,
                h,
                isBroken
              } = this.caption[r.$getExtra](e);
              if (isBroken && this[r.$getSubformParent]()[r.$isThereMoreWidth]()) {
                this[r.$popPara]();
                return o.HTMLResult.FAILURE;
              }
              switch (t = w, a = h, this.caption.placement) {
                case "left":
                case "right":
                case "inline":
                  t += i;
                  break;
                case "top":
                case "bottom":
                  a += n;
              }
            } else {
              t = i;
              a = n;
            }
            t && "" === this.w && (t += l, this.w = Math.min(this.maxW <= 0 ? 1 / 0 : this.maxW, this.minW + 1 < t ? t : this.minW));
            a && "" === this.h && (a += h, this.h = Math.min(this.maxH <= 0 ? 1 / 0 : this.maxH, this.minH + 1 < a ? a : this.minH));
          }
          if (this[r.$popPara](), s.fixDimensions(this), C(this), !n.checkDimensions(this, e)) {
            this.w = a;
            this.h = i;
            this[r.$popPara]();
            return o.HTMLResult.FAILURE;
          }
          O(this);
          let d = s.toStyle(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
          s.setMinMaxDimensions(this, d);
          let f = ["xfaField"];
          this.font && f.push("xfaFont");
          s.isPrintOnly(this) && f.push("xfaPrintOnly");
          let g = {
            style: d,
            id: this[r.$uid],
            class: f
          };
          d.margin && (d.padding = d.margin, delete d.margin);
          s.setAccess(this, f);
          this.name && (g.xfaName = this.name);
          let p = [];
          let m = {
            name: "div",
            attributes: g,
            children: p
          };
          k(this, g);
          let y = this.border ? this.border[r.$toStyle]() : null;
          let w = s.computeBbox(this, m, e);
          let x = this.ui[r.$toHTML]().html;
          if (!x) {
            Object.assign(d, y);
            return o.HTMLResult.success(s.createWrapper(this, m), w);
          }
          this[r.$tabIndex] && (x.children && x.children[0] ? x.children[0].attributes.tabindex = this[r.$tabIndex] : x.attributes.tabindex = this[r.$tabIndex]);
          x.attributes.style || (x.attributes.style = Object.create(null));
          let A = null;
          if (this.ui.button ? (1 === x.children.length && ([A] = x.children.splice(0, 1)), Object.assign(x.attributes.style, y)) : Object.assign(d, y), p.push(x), this.value) {
            if (this.ui.imageEdit) x.children.push(this.value[r.$toHTML]().html); else if (!this.ui.button) {
              let e = "";
              if (this.value.exData) e = this.value.exData[r.$text](); else if (this.value.text) e = this.value.text[r.$getExtra](); else {
                let t = this.value[r.$toHTML]().html;
                null !== t && (e = t.children[0].value);
              }
              this.ui.textEdit && this.value.text && this.value.text.maxChars && (x.children[0].attributes.maxLength = this.value.text.maxChars);
              e && (this.ui.numericEdit && (e = isNaN(e = parseFloat(e)) ? "" : e.toString()), "textarea" === x.children[0].name ? x.children[0].attributes.textContent = e : x.children[0].attributes.value = e);
            }
          }
          if (!this.ui.imageEdit && x.children && x.children[0] && this.h) {
            u = u || b(this.ui[r.$getExtra]());
            let t = 0;
            if (this.caption && ["top", "bottom"].includes(this.caption.placement)) {
              (t = this.caption.reserve) <= 0 && (t = this.caption[r.$getExtra](e).h);
              let a = this.h - t - h - u.h;
              x.children[0].attributes.style.height = s.measureToString(a);
            } else x.children[0].attributes.style.height = "100%";
          }
          if (A && x.children.push(A), !t) {
            x.attributes.$$class && x.attributes.$$class.push("xfaLeft");
            this.w = a;
            this.h = i;
            return o.HTMLResult.success(s.createWrapper(this, m), w);
          }
          if (this.ui.button) {
            d.padding && delete d.padding;
            "div" === t.name && (t.name = "span");
            x.children.push(t);
            return o.HTMLResult.success(m, w);
          }
          switch (this.ui.checkButton && (t.attributes.$$class[0] = "xfaCaptionForCheckButton"), x.attributes.$$class || (x.attributes.$$class = []), x.children.splice(0, 0, t), this.caption.placement) {
            case "left":
            case "inline":
              x.attributes.$$class.push("xfaLeft");
              break;
            case "right":
              x.attributes.$$class.push("xfaRight");
              break;
            case "top":
              x.attributes.$$class.push("xfaTop");
              break;
            case "bottom":
              x.attributes.$$class.push("xfaBottom");
          }
          this.w = a;
          this.h = i;
          return o.HTMLResult.success(s.createWrapper(this, m), w);
        }
      }
      t.Field = eA;
      class ev extends r.XFAObject {
        constructor(e) {
          super(d, "fill", !0);
          this.id = e.id || "";
          this.presence = o.getStringOption(e.presence, ["visible", "hidden", "inactive", "invisible"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.color = null;
          this.extras = null;
          this.linear = null;
          this.pattern = null;
          this.radial = null;
          this.solid = null;
          this.stipple = null;
        }
        [r.$toStyle]() {
          let e = this[r.$getParent]();
          let t = e[r.$getParent]()[r.$getParent]();
          let a = Object.create(null);
          let i = "color";
          let n = i;
          for (let s of (e instanceof $ && (i = "background-color", n = "background", t instanceof tx && (a.backgroundColor = "white")), (e instanceof e7 || e instanceof M) && (i = n = "fill", a.fill = "white"), Object.getOwnPropertyNames(this))) {
            if ("extras" === s || "color" === s) continue;
            let e = this[s];
            if (!(e instanceof r.XFAObject)) continue;
            let t = e[r.$toStyle](this.color);
            t && (a[t.startsWith("#") ? i : n] = t);
            return a;
          }
          if (this.color && this.color.value) {
            let e = this.color[r.$toStyle]();
            a[e.startsWith("#") ? i : n] = e;
          }
          return a;
        }
      }
      class eC extends r.XFAObject {
        constructor(e) {
          super(d, "filter", !0);
          this.addRevocationInfo = o.getStringOption(e.addRevocationInfo, ["", "required", "optional", "none"]);
          this.id = e.id || "";
          this.name = e.name || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.version = o.getInteger({
            data: this.version,
            defaultValue: 5,
            validate: e => e >= 1 && e <= 5
          });
          this.appearanceFilter = null;
          this.certificates = null;
          this.digestMethods = null;
          this.encodings = null;
          this.encryptionMethods = null;
          this.handler = null;
          this.lockDocument = null;
          this.mdp = null;
          this.reasons = null;
          this.timeStamp = null;
        }
      }
      class eO extends r.ContentObject {
        constructor(e) {
          super(d, "float");
          this.id = e.id || "";
          this.name = e.name || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
        [r.$finalize]() {
          let e = parseFloat(this[r.$content].trim());
          this[r.$content] = isNaN(e) ? null : e;
        }
        [r.$toHTML](e) {
          return v(null !== this[r.$content] ? this[r.$content].toString() : "");
        }
      }
      class eF extends r.XFAObject {
        constructor(e) {
          super(d, "font", !0);
          this.baselineShift = o.getMeasurement(e.baselineShift);
          this.fontHorizontalScale = o.getFloat({
            data: e.fontHorizontalScale,
            defaultValue: 100,
            validate: e => e >= 0
          });
          this.fontVerticalScale = o.getFloat({
            data: e.fontVerticalScale,
            defaultValue: 100,
            validate: e => e >= 0
          });
          this.id = e.id || "";
          this.kerningMode = o.getStringOption(e.kerningMode, ["none", "pair"]);
          this.letterSpacing = o.getMeasurement(e.letterSpacing, "0");
          this.lineThrough = o.getInteger({
            data: e.lineThrough,
            defaultValue: 0,
            validate: e => 1 === e || 2 === e
          });
          this.lineThroughPeriod = o.getStringOption(e.lineThroughPeriod, ["all", "word"]);
          this.overline = o.getInteger({
            data: e.overline,
            defaultValue: 0,
            validate: e => 1 === e || 2 === e
          });
          this.overlinePeriod = o.getStringOption(e.overlinePeriod, ["all", "word"]);
          this.posture = o.getStringOption(e.posture, ["normal", "italic"]);
          this.size = o.getMeasurement(e.size, "10pt");
          this.typeface = e.typeface || "Courier";
          this.underline = o.getInteger({
            data: e.underline,
            defaultValue: 0,
            validate: e => 1 === e || 2 === e
          });
          this.underlinePeriod = o.getStringOption(e.underlinePeriod, ["all", "word"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.weight = o.getStringOption(e.weight, ["normal", "bold"]);
          this.extras = null;
          this.fill = null;
        }
        [r.$clean](e) {
          super[r.$clean](e);
          this[r.$globalData].usedTypefaces.add(this.typeface);
        }
        [r.$toStyle]() {
          let e = s.toStyle(this, "fill");
          let t = e.color;
          t && ("#000000" === t ? delete e.color : t.startsWith("#") || (e.background = t, e.backgroundClip = "text", e.color = "transparent"));
          this.baselineShift && (e.verticalAlign = s.measureToString(this.baselineShift));
          e.fontKerning = "none" === this.kerningMode ? "none" : "normal";
          e.letterSpacing = s.measureToString(this.letterSpacing);
          0 !== this.lineThrough && (e.textDecoration = "line-through", 2 === this.lineThrough && (e.textDecorationStyle = "double"));
          0 !== this.overline && (e.textDecoration = "overline", 2 === this.overline && (e.textDecorationStyle = "double"));
          e.fontStyle = this.posture;
          e.fontSize = s.measureToString(.99 * this.size);
          s.setFontFamily(this, this, this[r.$globalData].fontFinder, e);
          0 !== this.underline && (e.textDecoration = "underline", 2 === this.underline && (e.textDecorationStyle = "double"));
          e.fontWeight = this.weight;
          return e;
        }
      }
      class eI extends r.XFAObject {
        constructor(e) {
          super(d, "format", !0);
          this.id = e.id || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.extras = null;
          this.picture = null;
        }
      }
      class eT extends r.StringObject {
        constructor(e) {
          super(d, "handler");
          this.id = e.id || "";
          this.type = o.getStringOption(e.type, ["optional", "required"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class eM extends r.XFAObject {
        constructor(e) {
          super(d, "hyphenation");
          this.excludeAllCaps = o.getInteger({
            data: e.excludeAllCaps,
            defaultValue: 0,
            validate: e => 1 === e
          });
          this.excludeInitialCap = o.getInteger({
            data: e.excludeInitialCap,
            defaultValue: 0,
            validate: e => 1 === e
          });
          this.hyphenate = o.getInteger({
            data: e.hyphenate,
            defaultValue: 0,
            validate: e => 1 === e
          });
          this.id = e.id || "";
          this.pushCharacterCount = o.getInteger({
            data: e.pushCharacterCount,
            defaultValue: 3,
            validate: e => e >= 0
          });
          this.remainCharacterCount = o.getInteger({
            data: e.remainCharacterCount,
            defaultValue: 3,
            validate: e => e >= 0
          });
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.wordCharacterCount = o.getInteger({
            data: e.wordCharacterCount,
            defaultValue: 7,
            validate: e => e >= 0
          });
        }
      }
      class eP extends r.StringObject {
        constructor(e) {
          super(d, "image");
          this.aspect = o.getStringOption(e.aspect, ["fit", "actual", "height", "none", "width"]);
          this.contentType = e.contentType || "";
          this.href = e.href || "";
          this.id = e.id || "";
          this.name = e.name || "";
          this.transferEncoding = o.getStringOption(e.transferEncoding, ["base64", "none", "package"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
        [r.$toHTML]() {
          let e;
          if (this.contentType && !p.has(this.contentType.toLowerCase())) return o.HTMLResult.EMPTY;
          let t = this[r.$globalData].images && this[r.$globalData].images.get(this.href);
          if (!t && (this.href || !this[r.$content]) || (t || "base64" !== this.transferEncoding || (t = l.stringToBytes(atob(this[r.$content]))), !t)) return o.HTMLResult.EMPTY;
          if (!this.contentType) {
            for (let [e, a] of m) if (t.length > e.length && e.every((e, a) => e === t[a])) {
              this.contentType = a;
              break;
            }
            if (!this.contentType) return o.HTMLResult.EMPTY;
          }
          let a = new Blob([t], {
            type: this.contentType
          });
          switch (this.aspect) {
            case "fit":
            case "actual":
              break;
            case "height":
              e = {
                height: "100%",
                objectFit: "fill"
              };
              break;
            case "none":
              e = {
                width: "100%",
                height: "100%",
                objectFit: "fill"
              };
              break;
            case "width":
              e = {
                width: "100%",
                objectFit: "fill"
              };
          }
          let i = this[r.$getParent]();
          return o.HTMLResult.success({
            name: "img",
            attributes: {
              class: ["xfaImage"],
              style: e,
              src: URL.createObjectURL(a),
              alt: i ? A(i[r.$getParent]()) : null
            }
          });
        }
      }
      class eE extends r.XFAObject {
        constructor(e) {
          super(d, "imageEdit", !0);
          this.data = o.getStringOption(e.data, ["link", "embed"]);
          this.id = e.id || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.border = null;
          this.extras = null;
          this.margin = null;
        }
        [r.$toHTML](e) {
          return "embed" === this.data ? o.HTMLResult.success({
            name: "div",
            children: [],
            attributes: {}
          }) : o.HTMLResult.EMPTY;
        }
      }
      class eN extends r.ContentObject {
        constructor(e) {
          super(d, "integer");
          this.id = e.id || "";
          this.name = e.name || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
        [r.$finalize]() {
          let e = parseInt(this[r.$content].trim(), 10);
          this[r.$content] = isNaN(e) ? null : e;
        }
        [r.$toHTML](e) {
          return v(null !== this[r.$content] ? this[r.$content].toString() : "");
        }
      }
      class eB extends r.XFAObject {
        constructor(e) {
          super(d, "issuers", !0);
          this.id = e.id || "";
          this.type = o.getStringOption(e.type, ["optional", "required"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.certificate = new r.XFAObjectArray();
        }
      }
      class eD extends r.XFAObject {
        constructor(e) {
          super(d, "items", !0);
          this.id = e.id || "";
          this.name = e.name || "";
          this.presence = o.getStringOption(e.presence, ["visible", "hidden", "inactive", "invisible"]);
          this.ref = e.ref || "";
          this.save = o.getInteger({
            data: e.save,
            defaultValue: 0,
            validate: e => 1 === e
          });
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.boolean = new r.XFAObjectArray();
          this.date = new r.XFAObjectArray();
          this.dateTime = new r.XFAObjectArray();
          this.decimal = new r.XFAObjectArray();
          this.exData = new r.XFAObjectArray();
          this.$$float = new r.XFAObjectArray();
          this.image = new r.XFAObjectArray();
          this.integer = new r.XFAObjectArray();
          this.text = new r.XFAObjectArray();
          this.time = new r.XFAObjectArray();
        }
        [r.$toHTML]() {
          let e = [];
          for (let t of this[r.$getChildren]()) e.push(t[r.$text]());
          return o.HTMLResult.success(e);
        }
      }
      t.Items = eD;
      class eL extends r.XFAObject {
        constructor(e) {
          super(d, "keep", !0);
          this.id = e.id || "";
          let t = ["none", "contentArea", "pageArea"];
          this.intact = o.getStringOption(e.intact, t);
          this.next = o.getStringOption(e.next, t);
          this.previous = o.getStringOption(e.previous, t);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.extras = null;
        }
      }
      class eR extends r.XFAObject {
        constructor(e) {
          super(d, "keyUsage");
          let t = ["", "yes", "no"];
          this.crlSign = o.getStringOption(e.crlSign, t);
          this.dataEncipherment = o.getStringOption(e.dataEncipherment, t);
          this.decipherOnly = o.getStringOption(e.decipherOnly, t);
          this.digitalSignature = o.getStringOption(e.digitalSignature, t);
          this.encipherOnly = o.getStringOption(e.encipherOnly, t);
          this.id = e.id || "";
          this.keyAgreement = o.getStringOption(e.keyAgreement, t);
          this.keyCertSign = o.getStringOption(e.keyCertSign, t);
          this.keyEncipherment = o.getStringOption(e.keyEncipherment, t);
          this.nonRepudiation = o.getStringOption(e.nonRepudiation, t);
          this.type = o.getStringOption(e.type, ["optional", "required"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class e$ extends r.XFAObject {
        constructor(e) {
          super(d, "line", !0);
          this.hand = o.getStringOption(e.hand, ["even", "left", "right"]);
          this.id = e.id || "";
          this.slope = o.getStringOption(e.slope, ["\\", "/"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.edge = null;
        }
        [r.$toHTML]() {
          let e;
          let t;
          let a;
          let i;
          let n = this[r.$getParent]()[r.$getParent]();
          let l = this.edge ? this.edge : new ec({});
          let c = l[r.$toStyle]();
          let h = Object.create(null);
          let u = "visible" === l.presence ? l.thickness : 0;
          h.strokeWidth = s.measureToString(u);
          h.stroke = c.color;
          let d = "100%";
          let g = "100%";
          n.w <= u ? ([e, t, a, i] = ["50%", 0, "50%", "100%"], d = h.strokeWidth) : n.h <= u ? ([e, t, a, i] = [0, "50%", "100%", "50%"], g = h.strokeWidth) : "\\" === this.slope ? [e, t, a, i] = [0, 0, "100%", "100%"] : [e, t, a, i] = [0, "100%", "100%", 0];
          let p = {
            name: "svg",
            children: [{
              name: "line",
              attributes: {
                xmlns: f,
                x1: e,
                y1: t,
                x2: a,
                y2: i,
                style: h
              }
            }],
            attributes: {
              xmlns: f,
              width: d,
              height: g,
              style: {
                overflow: "visible"
              }
            }
          };
          return y(n) ? o.HTMLResult.success({
            name: "div",
            attributes: {
              style: {
                display: "inline",
                width: "100%",
                height: "100%"
              }
            },
            children: [p]
          }) : (p.attributes.style.position = "absolute", o.HTMLResult.success(p));
        }
      }
      class ej extends r.XFAObject {
        constructor(e) {
          super(d, "linear", !0);
          this.id = e.id || "";
          this.type = o.getStringOption(e.type, ["toRight", "toBottom", "toLeft", "toTop"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.color = null;
          this.extras = null;
        }
        [r.$toStyle](e) {
          e = e ? e[r.$toStyle]() : "#FFFFFF";
          let t = this.type.replace(/([RBLT])/, " $1").toLowerCase();
          let a = this.color ? this.color[r.$toStyle]() : "#000000";
          return `linear-gradient(${t}, ${e}, ${a})`;
        }
      }
      class e_ extends r.ContentObject {
        constructor(e) {
          super(d, "lockDocument");
          this.id = e.id || "";
          this.type = o.getStringOption(e.type, ["optional", "required"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
        [r.$finalize]() {
          this[r.$content] = o.getStringOption(this[r.$content], ["auto", "0", "1"]);
        }
      }
      class eU extends r.XFAObject {
        constructor(e) {
          super(d, "manifest", !0);
          this.action = o.getStringOption(e.action, ["include", "all", "exclude"]);
          this.id = e.id || "";
          this.name = e.name || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.extras = null;
          this.ref = new r.XFAObjectArray();
        }
      }
      class eX extends r.XFAObject {
        constructor(e) {
          super(d, "margin", !0);
          this.bottomInset = o.getMeasurement(e.bottomInset, "0");
          this.id = e.id || "";
          this.leftInset = o.getMeasurement(e.leftInset, "0");
          this.rightInset = o.getMeasurement(e.rightInset, "0");
          this.topInset = o.getMeasurement(e.topInset, "0");
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.extras = null;
        }
        [r.$toStyle]() {
          return {
            margin: s.measureToString(this.topInset) + " " + s.measureToString(this.rightInset) + " " + s.measureToString(this.bottomInset) + " " + s.measureToString(this.leftInset)
          };
        }
      }
      class eH extends r.XFAObject {
        constructor(e) {
          super(d, "mdp");
          this.id = e.id || "";
          this.permissions = o.getInteger({
            data: e.permissions,
            defaultValue: 2,
            validate: e => 1 === e || 3 === e
          });
          this.signatureType = o.getStringOption(e.signatureType, ["filler", "author"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class eq extends r.XFAObject {
        constructor(e) {
          super(d, "medium");
          this.id = e.id || "";
          this.imagingBBox = o.getBBox(e.imagingBBox);
          this.$$long = o.getMeasurement(e.$$long);
          this.orientation = o.getStringOption(e.orientation, ["portrait", "landscape"]);
          this.$$short = o.getMeasurement(e.$$short);
          this.stock = e.stock || "";
          this.trayIn = o.getStringOption(e.trayIn, ["auto", "delegate", "pageFront"]);
          this.trayOut = o.getStringOption(e.trayOut, ["auto", "delegate"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class ez extends r.XFAObject {
        constructor(e) {
          super(d, "message", !0);
          this.id = e.id || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.text = new r.XFAObjectArray();
        }
      }
      class eG extends r.XFAObject {
        constructor(e) {
          super(d, "numericEdit", !0);
          this.hScrollPolicy = o.getStringOption(e.hScrollPolicy, ["auto", "off", "on"]);
          this.id = e.id || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.border = null;
          this.comb = null;
          this.extras = null;
          this.margin = null;
        }
        [r.$toHTML](e) {
          let t = s.toStyle(this, "border", "font", "margin");
          let a = this[r.$getParent]()[r.$getParent]();
          let i = {
            name: "input",
            attributes: {
              type: "text",
              fieldId: a[r.$uid],
              dataId: a[r.$data] && a[r.$data][r.$uid] || a[r.$uid],
              class: ["xfaTextfield"],
              style: t,
              "aria-label": A(a)
            }
          };
          return o.HTMLResult.success({
            name: "label",
            attributes: {
              class: ["xfaLabel"]
            },
            children: [i]
          });
        }
      }
      class eW extends r.XFAObject {
        constructor(e) {
          super(d, "occur", !0);
          this.id = e.id || "";
          this.initial = "" !== e.initial ? o.getInteger({
            data: e.initial,
            defaultValue: "",
            validate: e => !0
          }) : "";
          this.max = "" !== e.max ? o.getInteger({
            data: e.max,
            defaultValue: 1,
            validate: e => !0
          }) : "";
          this.min = "" !== e.min ? o.getInteger({
            data: e.min,
            defaultValue: 1,
            validate: e => !0
          }) : "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.extras = null;
        }
        [r.$clean]() {
          let e = this[r.$getParent]();
          let t = this.min;
          "" === this.min && (this.min = e instanceof eJ || e instanceof eZ ? 0 : 1);
          "" === this.max && ("" === t ? this.max = e instanceof eJ || e instanceof eZ ? -1 : 1 : this.max = this.min);
          -1 !== this.max && this.max < this.min && (this.max = this.min);
          "" === this.initial && (this.initial = e instanceof td ? 1 : this.min);
        }
      }
      class eV extends r.StringObject {
        constructor(e) {
          super(d, "oid");
          this.id = e.id || "";
          this.name = e.name || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class eK extends r.XFAObject {
        constructor(e) {
          super(d, "oids", !0);
          this.id = e.id || "";
          this.type = o.getStringOption(e.type, ["optional", "required"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.oid = new r.XFAObjectArray();
        }
      }
      class eY extends r.XFAObject {
        constructor(e) {
          super(d, "overflow");
          this.id = e.id || "";
          this.leader = e.leader || "";
          this.target = e.target || "";
          this.trailer = e.trailer || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
        [r.$getExtra]() {
          if (!this[r.$extra]) {
            let e = this[r.$getParent]();
            let t = this[r.$getTemplateRoot]();
            let a = t[r.$searchNode](this.target, e);
            let i = t[r.$searchNode](this.leader, e);
            let n = t[r.$searchNode](this.trailer, e);
            this[r.$extra] = {
              target: a && a[0] || null,
              leader: i && i[0] || null,
              trailer: n && n[0] || null,
              addLeader: !1,
              addTrailer: !1
            };
          }
          return this[r.$extra];
        }
      }
      class eJ extends r.XFAObject {
        constructor(e) {
          super(d, "pageArea", !0);
          this.blankOrNotBlank = o.getStringOption(e.blankOrNotBlank, ["any", "blank", "notBlank"]);
          this.id = e.id || "";
          this.initialNumber = o.getInteger({
            data: e.initialNumber,
            defaultValue: 1,
            validate: e => !0
          });
          this.name = e.name || "";
          this.numbered = o.getInteger({
            data: e.numbered,
            defaultValue: 1,
            validate: e => !0
          });
          this.oddOrEven = o.getStringOption(e.oddOrEven, ["any", "even", "odd"]);
          this.pagePosition = o.getStringOption(e.pagePosition, ["any", "first", "last", "only", "rest"]);
          this.relevant = o.getRelevant(e.relevant);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.desc = null;
          this.extras = null;
          this.medium = null;
          this.occur = null;
          this.area = new r.XFAObjectArray();
          this.contentArea = new r.XFAObjectArray();
          this.draw = new r.XFAObjectArray();
          this.exclGroup = new r.XFAObjectArray();
          this.field = new r.XFAObjectArray();
          this.subform = new r.XFAObjectArray();
        }
        [r.$isUsable]() {
          return this[r.$extra] ? !this.occur || -1 === this.occur.max || this[r.$extra].numberOfUse < this.occur.max : (this[r.$extra] = {
            numberOfUse: 0
          }, !0);
        }
        [r.$cleanPage]() {
          delete this[r.$extra];
        }
        [r.$getNextPage]() {
          this[r.$extra] || (this[r.$extra] = {
            numberOfUse: 0
          });
          let e = this[r.$getParent]();
          return "orderedOccurrence" === e.relation && this[r.$isUsable]() ? (this[r.$extra].numberOfUse += 1, this) : e[r.$getNextPage]();
        }
        [r.$getAvailableSpace]() {
          return this[r.$extra].space || {
            width: 0,
            height: 0
          };
        }
        [r.$toHTML]() {
          this[r.$extra] || (this[r.$extra] = {
            numberOfUse: 1
          });
          let e = [];
          this[r.$extra].children = e;
          let t = Object.create(null);
          if (this.medium && this.medium.$$short && this.medium.$$long) {
            if (t.width = s.measureToString(this.medium.$$short), t.height = s.measureToString(this.medium.$$long), this[r.$extra].space = {
              width: this.medium.$$short,
              height: this.medium.$$long
            }, "landscape" === this.medium.orientation) {
              let e = t.width;
              t.width = t.height;
              t.height = e;
              this[r.$extra].space = {
                width: this.medium.$$long,
                height: this.medium.$$short
              };
            }
          } else l.warn("XFA - No medium specified in pageArea: please file a bug.");
          this[r.$childrenToHTML]({
            filter: new Set(["area", "draw", "field", "subform"]),
            include: !0
          });
          this[r.$childrenToHTML]({
            filter: new Set(["contentArea"]),
            include: !0
          });
          return o.HTMLResult.success({
            name: "div",
            children: e,
            attributes: {
              class: ["xfaPage"],
              id: this[r.$uid],
              style: t,
              xfaName: this.name
            }
          });
        }
      }
      class eZ extends r.XFAObject {
        constructor(e) {
          super(d, "pageSet", !0);
          this.duplexImposition = o.getStringOption(e.duplexImposition, ["longEdge", "shortEdge"]);
          this.id = e.id || "";
          this.name = e.name || "";
          this.relation = o.getStringOption(e.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]);
          this.relevant = o.getRelevant(e.relevant);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.extras = null;
          this.occur = null;
          this.pageArea = new r.XFAObjectArray();
          this.pageSet = new r.XFAObjectArray();
        }
        [r.$cleanPage]() {
          for (let e of this.pageArea.children) e[r.$cleanPage]();
          for (let e of this.pageSet.children) e[r.$cleanPage]();
        }
        [r.$isUsable]() {
          return !this.occur || -1 === this.occur.max || this[r.$extra].numberOfUse < this.occur.max;
        }
        [r.$getNextPage]() {
          if (this[r.$extra] || (this[r.$extra] = {
            numberOfUse: 1,
            pageIndex: -1,
            pageSetIndex: -1
          }), "orderedOccurrence" === this.relation) {
            if (this[r.$extra].pageIndex + 1 < this.pageArea.children.length) {
              this[r.$extra].pageIndex += 1;
              return this.pageArea.children[this[r.$extra].pageIndex][r.$getNextPage]();
            }
            if (this[r.$extra].pageSetIndex + 1 < this.pageSet.children.length) {
              this[r.$extra].pageSetIndex += 1;
              return this.pageSet.children[this[r.$extra].pageSetIndex][r.$getNextPage]();
            }
            if (this[r.$isUsable]()) {
              this[r.$extra].numberOfUse += 1;
              this[r.$extra].pageIndex = -1;
              this[r.$extra].pageSetIndex = -1;
              return this[r.$getNextPage]();
            }
            let e = this[r.$getParent]();
            return e instanceof eZ ? e[r.$getNextPage]() : (this[r.$cleanPage](), this[r.$getNextPage]());
          }
          let e = this[r.$getTemplateRoot]()[r.$extra].pageNumber;
          let t = e % 2 == 0 ? "even" : "odd";
          let a = 0 === e ? "first" : "rest";
          let i = this.pageArea.children.find(e => e.oddOrEven === t && e.pagePosition === a);
          return i || (i = this.pageArea.children.find(e => "any" === e.oddOrEven && e.pagePosition === a)) || (i = this.pageArea.children.find(e => "any" === e.oddOrEven && "any" === e.pagePosition)) ? i : this.pageArea.children[0];
        }
      }
      class eQ extends r.XFAObject {
        constructor(e) {
          super(d, "para", !0);
          this.hAlign = o.getStringOption(e.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
          this.id = e.id || "";
          this.lineHeight = e.lineHeight ? o.getMeasurement(e.lineHeight, "0pt") : "";
          this.marginLeft = e.marginLeft ? o.getMeasurement(e.marginLeft, "0pt") : "";
          this.marginRight = e.marginRight ? o.getMeasurement(e.marginRight, "0pt") : "";
          this.orphans = o.getInteger({
            data: e.orphans,
            defaultValue: 0,
            validate: e => e >= 0
          });
          this.preserve = e.preserve || "";
          this.radixOffset = e.radixOffset ? o.getMeasurement(e.radixOffset, "0pt") : "";
          this.spaceAbove = e.spaceAbove ? o.getMeasurement(e.spaceAbove, "0pt") : "";
          this.spaceBelow = e.spaceBelow ? o.getMeasurement(e.spaceBelow, "0pt") : "";
          this.tabDefault = e.tabDefault ? o.getMeasurement(this.tabDefault) : "";
          this.tabStops = (e.tabStops || "").trim().split(/\s+/).map((e, t) => t % 2 == 1 ? o.getMeasurement(e) : e);
          this.textIndent = e.textIndent ? o.getMeasurement(e.textIndent, "0pt") : "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.vAlign = o.getStringOption(e.vAlign, ["top", "bottom", "middle"]);
          this.widows = o.getInteger({
            data: e.widows,
            defaultValue: 0,
            validate: e => e >= 0
          });
          this.hyphenation = null;
        }
        [r.$toStyle]() {
          let e = s.toStyle(this, "hAlign");
          "" !== this.marginLeft && (e.paddingLeft = s.measureToString(this.marginLeft));
          "" !== this.marginRight && (e.paddingight = s.measureToString(this.marginRight));
          "" !== this.spaceAbove && (e.paddingTop = s.measureToString(this.spaceAbove));
          "" !== this.spaceBelow && (e.paddingBottom = s.measureToString(this.spaceBelow));
          "" !== this.textIndent && (e.textIndent = s.measureToString(this.textIndent), s.fixTextIndent(e));
          this.lineHeight > 0 && (e.lineHeight = s.measureToString(this.lineHeight));
          "" !== this.tabDefault && (e.tabSize = s.measureToString(this.tabDefault));
          this.tabStops.length;
          this.hyphenatation && Object.assign(e, this.hyphenatation[r.$toStyle]());
          return e;
        }
      }
      class e1 extends r.XFAObject {
        constructor(e) {
          super(d, "passwordEdit", !0);
          this.hScrollPolicy = o.getStringOption(e.hScrollPolicy, ["auto", "off", "on"]);
          this.id = e.id || "";
          this.passwordChar = e.passwordChar || "*";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.border = null;
          this.extras = null;
          this.margin = null;
        }
      }
      class e0 extends r.XFAObject {
        constructor(e) {
          super(d, "pattern", !0);
          this.id = e.id || "";
          this.type = o.getStringOption(e.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.color = null;
          this.extras = null;
        }
        [r.$toStyle](e) {
          e = e ? e[r.$toStyle]() : "#FFFFFF";
          let t = this.color ? this.color[r.$toStyle]() : "#000000";
          let a = "repeating-linear-gradient";
          let i = `${e},${e} 5px,${t} 5px,${t} 10px`;
          switch (this.type) {
            case "crossHatch":
              return `${a}(to top,${i}) ${a}(to right,${i})`;
            case "crossDiagonal":
              return `${a}(45deg,${i}) ${a}(-45deg,${i})`;
            case "diagonalLeft":
              return `${a}(45deg,${i})`;
            case "diagonalRight":
              return `${a}(-45deg,${i})`;
            case "horizontal":
              return `${a}(to top,${i})`;
            case "vertical":
              return `${a}(to right,${i})`;
          }
          return "";
        }
      }
      class e2 extends r.StringObject {
        constructor(e) {
          super(d, "picture");
          this.id = e.id || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class e9 extends r.XFAObject {
        constructor(e) {
          super(d, "proto", !0);
          this.appearanceFilter = new r.XFAObjectArray();
          this.arc = new r.XFAObjectArray();
          this.area = new r.XFAObjectArray();
          this.assist = new r.XFAObjectArray();
          this.barcode = new r.XFAObjectArray();
          this.bindItems = new r.XFAObjectArray();
          this.bookend = new r.XFAObjectArray();
          this.boolean = new r.XFAObjectArray();
          this.border = new r.XFAObjectArray();
          this.$$break = new r.XFAObjectArray();
          this.breakAfter = new r.XFAObjectArray();
          this.breakBefore = new r.XFAObjectArray();
          this.button = new r.XFAObjectArray();
          this.calculate = new r.XFAObjectArray();
          this.caption = new r.XFAObjectArray();
          this.certificate = new r.XFAObjectArray();
          this.certificates = new r.XFAObjectArray();
          this.checkButton = new r.XFAObjectArray();
          this.choiceList = new r.XFAObjectArray();
          this.color = new r.XFAObjectArray();
          this.comb = new r.XFAObjectArray();
          this.connect = new r.XFAObjectArray();
          this.contentArea = new r.XFAObjectArray();
          this.corner = new r.XFAObjectArray();
          this.date = new r.XFAObjectArray();
          this.dateTime = new r.XFAObjectArray();
          this.dateTimeEdit = new r.XFAObjectArray();
          this.decimal = new r.XFAObjectArray();
          this.defaultUi = new r.XFAObjectArray();
          this.desc = new r.XFAObjectArray();
          this.digestMethod = new r.XFAObjectArray();
          this.digestMethods = new r.XFAObjectArray();
          this.draw = new r.XFAObjectArray();
          this.edge = new r.XFAObjectArray();
          this.encoding = new r.XFAObjectArray();
          this.encodings = new r.XFAObjectArray();
          this.encrypt = new r.XFAObjectArray();
          this.encryptData = new r.XFAObjectArray();
          this.encryption = new r.XFAObjectArray();
          this.encryptionMethod = new r.XFAObjectArray();
          this.encryptionMethods = new r.XFAObjectArray();
          this.event = new r.XFAObjectArray();
          this.exData = new r.XFAObjectArray();
          this.exObject = new r.XFAObjectArray();
          this.exclGroup = new r.XFAObjectArray();
          this.execute = new r.XFAObjectArray();
          this.extras = new r.XFAObjectArray();
          this.field = new r.XFAObjectArray();
          this.fill = new r.XFAObjectArray();
          this.filter = new r.XFAObjectArray();
          this.$$float = new r.XFAObjectArray();
          this.font = new r.XFAObjectArray();
          this.format = new r.XFAObjectArray();
          this.handler = new r.XFAObjectArray();
          this.hyphenation = new r.XFAObjectArray();
          this.image = new r.XFAObjectArray();
          this.imageEdit = new r.XFAObjectArray();
          this.integer = new r.XFAObjectArray();
          this.issuers = new r.XFAObjectArray();
          this.items = new r.XFAObjectArray();
          this.keep = new r.XFAObjectArray();
          this.keyUsage = new r.XFAObjectArray();
          this.line = new r.XFAObjectArray();
          this.linear = new r.XFAObjectArray();
          this.lockDocument = new r.XFAObjectArray();
          this.manifest = new r.XFAObjectArray();
          this.margin = new r.XFAObjectArray();
          this.mdp = new r.XFAObjectArray();
          this.medium = new r.XFAObjectArray();
          this.message = new r.XFAObjectArray();
          this.numericEdit = new r.XFAObjectArray();
          this.occur = new r.XFAObjectArray();
          this.oid = new r.XFAObjectArray();
          this.oids = new r.XFAObjectArray();
          this.overflow = new r.XFAObjectArray();
          this.pageArea = new r.XFAObjectArray();
          this.pageSet = new r.XFAObjectArray();
          this.para = new r.XFAObjectArray();
          this.passwordEdit = new r.XFAObjectArray();
          this.pattern = new r.XFAObjectArray();
          this.picture = new r.XFAObjectArray();
          this.radial = new r.XFAObjectArray();
          this.reason = new r.XFAObjectArray();
          this.reasons = new r.XFAObjectArray();
          this.rectangle = new r.XFAObjectArray();
          this.ref = new r.XFAObjectArray();
          this.script = new r.XFAObjectArray();
          this.setProperty = new r.XFAObjectArray();
          this.signData = new r.XFAObjectArray();
          this.signature = new r.XFAObjectArray();
          this.signing = new r.XFAObjectArray();
          this.solid = new r.XFAObjectArray();
          this.speak = new r.XFAObjectArray();
          this.stipple = new r.XFAObjectArray();
          this.subform = new r.XFAObjectArray();
          this.subformSet = new r.XFAObjectArray();
          this.subjectDN = new r.XFAObjectArray();
          this.subjectDNs = new r.XFAObjectArray();
          this.submit = new r.XFAObjectArray();
          this.text = new r.XFAObjectArray();
          this.textEdit = new r.XFAObjectArray();
          this.time = new r.XFAObjectArray();
          this.timeStamp = new r.XFAObjectArray();
          this.toolTip = new r.XFAObjectArray();
          this.traversal = new r.XFAObjectArray();
          this.traverse = new r.XFAObjectArray();
          this.ui = new r.XFAObjectArray();
          this.validate = new r.XFAObjectArray();
          this.value = new r.XFAObjectArray();
          this.variables = new r.XFAObjectArray();
        }
      }
      class e5 extends r.XFAObject {
        constructor(e) {
          super(d, "radial", !0);
          this.id = e.id || "";
          this.type = o.getStringOption(e.type, ["toEdge", "toCenter"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.color = null;
          this.extras = null;
        }
        [r.$toStyle](e) {
          e = e ? e[r.$toStyle]() : "#FFFFFF";
          let t = this.color ? this.color[r.$toStyle]() : "#000000";
          let a = "toEdge" === this.type ? `${e},${t}` : `${t},${e}`;
          return `radial-gradient(circle at center, ${a})`;
        }
      }
      class e3 extends r.StringObject {
        constructor(e) {
          super(d, "reason");
          this.id = e.id || "";
          this.name = e.name || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class e6 extends r.XFAObject {
        constructor(e) {
          super(d, "reasons", !0);
          this.id = e.id || "";
          this.type = o.getStringOption(e.type, ["optional", "required"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.reason = new r.XFAObjectArray();
        }
      }
      class e7 extends r.XFAObject {
        constructor(e) {
          super(d, "rectangle", !0);
          this.hand = o.getStringOption(e.hand, ["even", "left", "right"]);
          this.id = e.id || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.corner = new r.XFAObjectArray(4);
          this.edge = new r.XFAObjectArray(4);
          this.fill = null;
        }
        [r.$toHTML]() {
          let e = this.edge.children.length ? this.edge.children[0] : new ec({});
          let t = e[r.$toStyle]();
          let a = Object.create(null);
          this.fill && "visible" === this.fill.presence ? Object.assign(a, this.fill[r.$toStyle]()) : a.fill = "transparent";
          a.strokeWidth = s.measureToString("visible" === e.presence ? e.thickness : 0);
          a.stroke = t.color;
          let i = (this.corner.children.length ? this.corner.children[0] : new Q({}))[r.$toStyle]();
          let n = {
            name: "svg",
            children: [{
              name: "rect",
              attributes: {
                xmlns: f,
                width: "100%",
                height: "100%",
                x: 0,
                y: 0,
                rx: i.radius,
                ry: i.radius,
                style: a
              }
            }],
            attributes: {
              xmlns: f,
              style: {
                overflow: "visible"
              },
              width: "100%",
              height: "100%"
            }
          };
          return y(this[r.$getParent]()[r.$getParent]()) ? o.HTMLResult.success({
            name: "div",
            attributes: {
              style: {
                display: "inline",
                width: "100%",
                height: "100%"
              }
            },
            children: [n]
          }) : (n.attributes.style.position = "absolute", o.HTMLResult.success(n));
        }
      }
      class e8 extends r.StringObject {
        constructor(e) {
          super(d, "ref");
          this.id = e.id || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class e4 extends r.StringObject {
        constructor(e) {
          super(d, "script");
          this.binding = e.binding || "";
          this.contentType = e.contentType || "";
          this.id = e.id || "";
          this.name = e.name || "";
          this.runAt = o.getStringOption(e.runAt, ["client", "both", "server"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class te extends r.XFAObject {
        constructor(e) {
          super(d, "setProperty");
          this.connection = e.connection || "";
          this.ref = e.ref || "";
          this.target = e.target || "";
        }
      }
      t.SetProperty = te;
      class tt extends r.XFAObject {
        constructor(e) {
          super(d, "signData", !0);
          this.id = e.id || "";
          this.operation = o.getStringOption(e.operation, ["sign", "clear", "verify"]);
          this.ref = e.ref || "";
          this.target = e.target || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.filter = null;
          this.manifest = null;
        }
      }
      class ta extends r.XFAObject {
        constructor(e) {
          super(d, "signature", !0);
          this.id = e.id || "";
          this.type = o.getStringOption(e.type, ["PDF1.3", "PDF1.6"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.border = null;
          this.extras = null;
          this.filter = null;
          this.manifest = null;
          this.margin = null;
        }
      }
      class tr extends r.XFAObject {
        constructor(e) {
          super(d, "signing", !0);
          this.id = e.id || "";
          this.type = o.getStringOption(e.type, ["optional", "required"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.certificate = new r.XFAObjectArray();
        }
      }
      class ti extends r.XFAObject {
        constructor(e) {
          super(d, "solid", !0);
          this.id = e.id || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.extras = null;
        }
        [r.$toStyle](e) {
          return e ? e[r.$toStyle]() : "#FFFFFF";
        }
      }
      class tn extends r.StringObject {
        constructor(e) {
          super(d, "speak");
          this.disable = o.getInteger({
            data: e.disable,
            defaultValue: 0,
            validate: e => 1 === e
          });
          this.id = e.id || "";
          this.priority = o.getStringOption(e.priority, ["custom", "caption", "name", "toolTip"]);
          this.rid = e.rid || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class ts extends r.XFAObject {
        constructor(e) {
          super(d, "stipple", !0);
          this.id = e.id || "";
          this.rate = o.getInteger({
            data: e.rate,
            defaultValue: 50,
            validate: e => e >= 0 && e <= 100
          });
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.color = null;
          this.extras = null;
        }
        [r.$toStyle](e) {
          let t = this.rate / 100;
          return l.Util.makeHexColor(Math.round(e.value.r * (1 - t) + this.value.r * t), Math.round(e.value.g * (1 - t) + this.value.g * t), Math.round(e.value.b * (1 - t) + this.value.b * t));
        }
      }
      class to extends r.XFAObject {
        constructor(e) {
          super(d, "subform", !0);
          this.access = o.getStringOption(e.access, ["open", "nonInteractive", "protected", "readOnly"]);
          this.allowMacro = o.getInteger({
            data: e.allowMacro,
            defaultValue: 0,
            validate: e => 1 === e
          });
          this.anchorType = o.getStringOption(e.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
          this.colSpan = o.getInteger({
            data: e.colSpan,
            defaultValue: 1,
            validate: e => e >= 1 || -1 === e
          });
          this.columnWidths = (e.columnWidths || "").trim().split(/\s+/).map(e => "-1" === e ? -1 : o.getMeasurement(e));
          this.h = e.h ? o.getMeasurement(e.h) : "";
          this.hAlign = o.getStringOption(e.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
          this.id = e.id || "";
          this.layout = o.getStringOption(e.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]);
          this.locale = e.locale || "";
          this.maxH = o.getMeasurement(e.maxH, "0pt");
          this.maxW = o.getMeasurement(e.maxW, "0pt");
          this.mergeMode = o.getStringOption(e.mergeMode, ["consumeData", "matchTemplate"]);
          this.minH = o.getMeasurement(e.minH, "0pt");
          this.minW = o.getMeasurement(e.minW, "0pt");
          this.name = e.name || "";
          this.presence = o.getStringOption(e.presence, ["visible", "hidden", "inactive", "invisible"]);
          this.relevant = o.getRelevant(e.relevant);
          this.restoreState = o.getStringOption(e.restoreState, ["manual", "auto"]);
          this.scope = o.getStringOption(e.scope, ["name", "none"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.w = e.w ? o.getMeasurement(e.w) : "";
          this.x = o.getMeasurement(e.x, "0pt");
          this.y = o.getMeasurement(e.y, "0pt");
          this.assist = null;
          this.bind = null;
          this.bookend = null;
          this.border = null;
          this.$$break = null;
          this.calculate = null;
          this.desc = null;
          this.extras = null;
          this.keep = null;
          this.margin = null;
          this.occur = null;
          this.overflow = null;
          this.pageSet = null;
          this.para = null;
          this.traversal = null;
          this.validate = null;
          this.variables = null;
          this.area = new r.XFAObjectArray();
          this.breakAfter = new r.XFAObjectArray();
          this.breakBefore = new r.XFAObjectArray();
          this.connect = new r.XFAObjectArray();
          this.draw = new r.XFAObjectArray();
          this.event = new r.XFAObjectArray();
          this.exObject = new r.XFAObjectArray();
          this.exclGroup = new r.XFAObjectArray();
          this.field = new r.XFAObjectArray();
          this.proto = new r.XFAObjectArray();
          this.setProperty = new r.XFAObjectArray();
          this.subform = new r.XFAObjectArray();
          this.subformSet = new r.XFAObjectArray();
        }
        [r.$getSubformParent]() {
          let e = this[r.$getParent]();
          return e instanceof tl ? e[r.$getSubformParent]() : e;
        }
        [r.$isBindable]() {
          return !0;
        }
        [r.$isThereMoreWidth]() {
          return this.layout.endsWith("-tb") && 0 === this[r.$extra].attempt && this[r.$extra].numberInLine > 0 || this[r.$getParent]()[r.$isThereMoreWidth]();
        }
        *[r.$getContainedChildren]() {
          yield* x(this);
        }
        [r.$flushHTML]() {
          return n.flushHTML(this);
        }
        [r.$addHTML](e, t) {
          n.addHTML(this, e, t);
        }
        [r.$getAvailableSpace]() {
          return n.getAvailableSpace(this);
        }
        [r.$isSplittable]() {
          let e = this[r.$getSubformParent]();
          return !!e[r.$isSplittable]() && (void 0 !== this[r.$extra]._isSplittable ? this[r.$extra]._isSplittable : "position" === this.layout || this.layout.includes("row") || this.keep && "none" !== this.keep.intact ? (this[r.$extra]._isSplittable = !1, !1) : (!(e.layout && e.layout.endsWith("-tb")) || 0 === e[r.$extra].numberInLine) && (this[r.$extra]._isSplittable = !0, !0));
        }
        [r.$toHTML](e) {
          if (S(this), this.$$break) {
            if ("auto" !== this.$$break.after || "" !== this.$$break.afterTarget) {
              let e = new _({
                targetType: this.$$break.after,
                target: this.$$break.afterTarget,
                startNew: this.$$break.startNew.toString()
              });
              e[r.$globalData] = this[r.$globalData];
              this[r.$appendChild](e);
              this.breakAfter.push(e);
            }
            if ("auto" !== this.$$break.before || "" !== this.$$break.beforeTarget) {
              let e = new U({
                targetType: this.$$break.before,
                target: this.$$break.beforeTarget,
                startNew: this.$$break.startNew.toString()
              });
              e[r.$globalData] = this[r.$globalData];
              this[r.$appendChild](e);
              this.breakBefore.push(e);
            }
            if ("" !== this.$$break.overflowTarget) {
              let e = new eY({
                target: this.$$break.overflowTarget,
                leader: this.$$break.overflowLeader,
                trailer: this.$$break.overflowTrailer
              });
              e[r.$globalData] = this[r.$globalData];
              this[r.$appendChild](e);
              this.overflow.push(e);
            }
            this[r.$removeChild](this.$$break);
            this.$$break = null;
          }
          if ("hidden" === this.presence || "inactive" === this.presence) return o.HTMLResult.EMPTY;
          if ((this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) && l.warn("XFA - Several breakBefore or breakAfter in subforms: please file a bug."), this.breakBefore.children.length >= 1) {
            let e = this.breakBefore.children[0];
            if (F(e)) return o.HTMLResult.breakNode(e);
          }
          if (this[r.$extra] && this[r.$extra].afterBreakAfter) return o.HTMLResult.EMPTY;
          s.fixDimensions(this);
          let t = [];
          let a = {
            id: this[r.$uid],
            class: []
          };
          s.setAccess(this, a.$$class);
          this[r.$extra] || (this[r.$extra] = Object.create(null));
          Object.assign(this[r.$extra], {
            children: t,
            line: null,
            attributes: a,
            attempt: 0,
            numberInLine: 0,
            availableSpace: {
              width: Math.min(this.w || 1 / 0, e.width),
              height: Math.min(this.h || 1 / 0, e.height)
            },
            width: 0,
            height: 0,
            prevHeight: 0,
            currentWidth: 0
          });
          let i = this[r.$getTemplateRoot]();
          let c = i[r.$extra].noLayoutFailure;
          let h = this[r.$isSplittable]();
          if (h || C(this), !n.checkDimensions(this, e)) return o.HTMLResult.FAILURE;
          let u = new Set(["area", "draw", "exclGroup", "field", "subform", "subformSet"]);
          if (this.layout.includes("row")) {
            let e = this[r.$getSubformParent]().columnWidths;
            Array.isArray(e) && e.length > 0 && (this[r.$extra].columnWidths = e, this[r.$extra].currentColumn = 0);
          }
          let d = s.toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign");
          let f = ["xfaSubform"];
          let g = s.layoutClass(this);
          if (g && f.push(g), a.style = d, a.$$class = f, this.name && (a.xfaName = this.name), this.overflow) {
            let t = this.overflow[r.$getExtra]();
            t.addLeader && (t.addLeader = !1, I(this, t.leader, e));
          }
          this[r.$pushPara]();
          let p = "lr-tb" === this.layout || "rl-tb" === this.layout;
          let m = p ? 2 : 1;
          for (; this[r.$extra].attempt < m; this[r.$extra].attempt++) {
            p && 1 === this[r.$extra].attempt && (this[r.$extra].numberInLine = 0);
            let e = this[r.$childrenToHTML]({
              filter: u,
              include: !0
            });
            if (e.success) break;
            if (e.isBreak()) {
              this[r.$popPara]();
              return e;
            }
            if (p && 0 === this[r.$extra].attempt && 0 === this[r.$extra].numberInLine && !i[r.$extra].noLayoutFailure) {
              this[r.$extra].attempt = m;
              break;
            }
          }
          if (this[r.$popPara](), h || O(this), i[r.$extra].noLayoutFailure = c, this[r.$extra].attempt === m) {
            this.overflow && (this[r.$getTemplateRoot]()[r.$extra].overflowNode = this.overflow);
            h || delete this[r.$extra];
            return o.HTMLResult.FAILURE;
          }
          if (this.overflow) {
            let t = this.overflow[r.$getExtra]();
            t.addTrailer && (t.addTrailer = !1, I(this, t.trailer, e));
          }
          let b = 0;
          let y = 0;
          this.margin && (b = this.margin.leftInset + this.margin.rightInset, y = this.margin.topInset + this.margin.bottomInset);
          let w = Math.max(this[r.$extra].width + b, this.w || 0);
          let x = Math.max(this[r.$extra].height + y, this.h || 0);
          let A = [this.x, this.y, w, x];
          if ("" === this.w && (d.width = s.measureToString(w)), "" === this.h && (d.height = s.measureToString(x)), ("0px" === d.width || "0px" === d.height) && 0 === t.length) return o.HTMLResult.EMPTY;
          k(this, a);
          let v = o.HTMLResult.success(s.createWrapper(this, {
            name: "div",
            attributes: a,
            children: t
          }), A);
          if (this.breakAfter.children.length >= 1) {
            let e = this.breakAfter.children[0];
            if (F(e)) {
              this[r.$extra].afterBreakAfter = v;
              return o.HTMLResult.breakNode(e);
            }
          }
          delete this[r.$extra];
          return v;
        }
      }
      class tl extends r.XFAObject {
        constructor(e) {
          super(d, "subformSet", !0);
          this.id = e.id || "";
          this.name = e.name || "";
          this.relation = o.getStringOption(e.relation, ["ordered", "choice", "unordered"]);
          this.relevant = o.getRelevant(e.relevant);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.bookend = null;
          this.$$break = null;
          this.desc = null;
          this.extras = null;
          this.occur = null;
          this.overflow = null;
          this.breakAfter = new r.XFAObjectArray();
          this.breakBefore = new r.XFAObjectArray();
          this.subform = new r.XFAObjectArray();
          this.subformSet = new r.XFAObjectArray();
        }
        *[r.$getContainedChildren]() {
          yield* x(this);
        }
        [r.$getSubformParent]() {
          let e = this[r.$getParent]();
          for (; !(e instanceof to);) e = e[r.$getParent]();
          return e;
        }
        [r.$isBindable]() {
          return !0;
        }
      }
      class tc extends r.ContentObject {
        constructor(e) {
          super(d, "subjectDN");
          this.delimiter = e.delimiter || ",";
          this.id = e.id || "";
          this.name = e.name || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
        [r.$finalize]() {
          this[r.$content] = new Map(this[r.$content].split(this.delimiter).map(e => ((e = e.split("=", 2))[0] = e[0].trim(), e)));
        }
      }
      class th extends r.XFAObject {
        constructor(e) {
          super(d, "subjectDNs", !0);
          this.id = e.id || "";
          this.type = o.getStringOption(e.type, ["optional", "required"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.subjectDN = new r.XFAObjectArray();
        }
      }
      class tu extends r.XFAObject {
        constructor(e) {
          super(d, "submit", !0);
          this.embedPDF = o.getInteger({
            data: e.embedPDF,
            defaultValue: 0,
            validate: e => 1 === e
          });
          this.format = o.getStringOption(e.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]);
          this.id = e.id || "";
          this.target = e.target || "";
          this.textEncoding = o.getKeyword({
            data: e.textEncoding ? e.textEncoding.toLowerCase() : "",
            defaultValue: "",
            validate: e => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(e) || e.match(/iso-8859-\d{2}/)
          });
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.xdpContent = e.xdpContent || "";
          this.encrypt = null;
          this.encryptData = new r.XFAObjectArray();
          this.signData = new r.XFAObjectArray();
        }
      }
      class td extends r.XFAObject {
        constructor(e) {
          super(d, "template", !0);
          this.baseProfile = o.getStringOption(e.baseProfile, ["full", "interactiveForms"]);
          this.extras = null;
          this.subform = new r.XFAObjectArray();
        }
        [r.$finalize]() {
          0 === this.subform.children.length && l.warn("XFA - No subforms in template node.");
          this.subform.children.length >= 2 && l.warn("XFA - Several subforms in template node: please file a bug.");
          this[r.$tabIndex] = 5e3;
        }
        [r.$isSplittable]() {
          return !0;
        }
        [r.$searchNode](e, t) {
          return e.startsWith("#") ? [this[r.$ids].get(e.slice(1))] : u.searchNode(this, t, e, !0, !0);
        }
        *[r.$toPages]() {
          let e;
          if (!this.subform.children.length) return o.HTMLResult.success({
            name: "div",
            children: []
          });
          this[r.$extra] = {
            overflowNode: null,
            firstUnsplittable: null,
            currentContentArea: null,
            currentPageArea: null,
            noLayoutFailure: !1,
            pageNumber: 1,
            pagePosition: "first",
            oddOrEven: "odd",
            blankOrNotBlank: "nonBlank",
            paraStack: []
          };
          let t = this.subform.children[0];
          t.pageSet[r.$cleanPage]();
          let a = t.pageSet.pageArea.children;
          let i = {
            name: "div",
            children: []
          };
          let n = null;
          let s = null;
          let c = null;
          if (t.breakBefore.children.length >= 1 ? c = (s = t.breakBefore.children[0]).target : t.subform.children.length >= 1 && t.subform.children[0].breakBefore.children.length >= 1 ? c = (s = t.subform.children[0].breakBefore.children[0]).target : t.$$break && t.$$break.beforeTarget ? c = (s = t.$$break).beforeTarget : t.subform.children.length >= 1 && t.subform.children[0].$$break && t.subform.children[0].$$break.beforeTarget && (c = (s = t.subform.children[0].$$break).beforeTarget), s) {
            let e = this[r.$searchNode](c, s[r.$getParent]());
            e instanceof eJ && (n = e, s[r.$extra] = {});
          }
          n || (n = a[0]);
          n[r.$extra] = {
            numberOfUse: 1
          };
          let h = n[r.$getParent]();
          h[r.$extra] = {
            numberOfUse: 1,
            pageIndex: h.pageArea.children.indexOf(n),
            pageSetIndex: 0
          };
          let u = null;
          let d = null;
          let f = !0;
          let g = 0;
          let p = 0;
          for (; ;) {
            if (f) g = 0; else if (i.children.pop(), 3 == ++g) {
              l.warn("XFA - Something goes wrong: please file a bug.");
              return i;
            }
            e = null;
            this[r.$extra].currentPageArea = n;
            let a = n[r.$toHTML]().html;
            i.children.push(a);
            u && (this[r.$extra].noLayoutFailure = !0, a.children.push(u[r.$toHTML](n[r.$extra].space).html), u = null);
            d && (this[r.$extra].noLayoutFailure = !0, a.children.push(d[r.$toHTML](n[r.$extra].space).html), d = null);
            let s = n.contentArea.children;
            let o = a.children.filter(e => e.attributes.$$class.includes("xfaContentarea"));
            f = !1;
            this[r.$extra].firstUnsplittable = null;
            this[r.$extra].noLayoutFailure = !1;
            let c = e => {
              let a = t[r.$flushHTML]();
              a && (f = f || a.children && 0 !== a.children.length, o[e].children.push(a));
            };
            for (function () {
              let a = p;
              let n = s.length;
            }(); a < n; a++) {
              let n = this[r.$extra].currentContentArea = s[a];
              let l = {
                width: n.w,
                height: n.h
              };
              p = 0;
              u && (o[a].children.push(u[r.$toHTML](l).html), u = null);
              d && (o[a].children.push(d[r.$toHTML](l).html), d = null);
              let h = t[r.$toHTML](l);
              if (h.success) {
                h.html ? (f = f || h.html.children && 0 !== h.html.children.length, o[a].children.push(h.html)) : !f && i.children.length > 1 && i.children.pop();
                return i;
              }
              if (h.isBreak()) {
                let t = h.breakNode;
                if (c(a), "auto" === t.targetType) continue;
                t.leader && (u = (u = this[r.$searchNode](t.leader, t[r.$getParent]())) ? u[0] : null);
                t.trailer && (d = (d = this[r.$searchNode](t.trailer, t[r.$getParent]())) ? d[0] : null);
                "pageArea" === t.targetType ? (e = t[r.$extra].target, a = 1 / 0) : t[r.$extra].target ? (e = t[r.$extra].target, p = t[r.$extra].index + 1, a = 1 / 0) : a = t[r.$extra].index;
                continue;
              }
              if (this[r.$extra].overflowNode) {
                let t = this[r.$extra].overflowNode;
                this[r.$extra].overflowNode = null;
                let i = t[r.$getExtra]();
                let n = i.target;
                i.addLeader = null !== i.leader;
                i.addTrailer = null !== i.trailer;
                c(a);
                let o = a;
                if (a = 1 / 0, n instanceof eJ) e = n; else if (n instanceof Z) {
                  let t = s.findIndex(e => e === n);
                  -1 !== t ? t > o ? a = t - 1 : p = t : p = (e = n[r.$getParent]()).contentArea.children.findIndex(e => e === n);
                }
                continue;
              }
              c(a);
            }
            this[r.$extra].pageNumber += 1;
            e && (e[r.$isUsable]() ? e[r.$extra].numberOfUse += 1 : e = null);
            n = e || n[r.$getNextPage]();
            yield null;
          }
        }
      }
      t.Template = td;
      class tf extends r.ContentObject {
        constructor(e) {
          super(d, "text");
          this.id = e.id || "";
          this.maxChars = o.getInteger({
            data: e.maxChars,
            defaultValue: 0,
            validate: e => e >= 0
          });
          this.name = e.name || "";
          this.rid = e.rid || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
        [r.$acceptWhitespace]() {
          return !0;
        }
        [r.$onChild](e) {
          return e[r.$namespaceId] === i.NamespaceIds.xhtml.id ? (this[r.$content] = e, !0) : (l.warn(`XFA - Invalid content in Text: ${e[r.$nodeName]}.`), !1);
        }
        [r.$onText](e) {
          this[r.$content] instanceof r.XFAObject || super[r.$onText](e);
        }
        [r.$finalize]() {
          "string" == typeof this[r.$content] && (this[r.$content] = this[r.$content].replace(/\r\n/g, "\n"));
        }
        [r.$getExtra]() {
          return "string" == typeof this[r.$content] ? this[r.$content].split(/[\u2029\u2028\n]/).reduce((e, t) => (t && e.push(t), e), []).join("\n") : this[r.$content][r.$text]();
        }
        [r.$toHTML](e) {
          if ("string" == typeof this[r.$content]) {
            let e = v(this[r.$content]).html;
            this[r.$content].includes("\u2029") ? (e.name = "div", e.children = [], this[r.$content].split("\u2029").map(e => e.split(/[\u2028\n]/).reduce((e, t) => (e.push({
              name: "span",
              value: t
            }, {
              name: "br"
            }), e), [])).forEach(t => {
              e.children.push({
                name: "p",
                children: t
              });
            })) : /[\u2028\n]/.test(this[r.$content]) && (e.name = "div", e.children = [], this[r.$content].split(/[\u2028\n]/).forEach(t => {
              e.children.push({
                name: "span",
                value: t
              }, {
                name: "br"
              });
            }));
            return o.HTMLResult.success(e);
          }
          return this[r.$content][r.$toHTML](e);
        }
      }
      t.Text = tf;
      class tg extends r.XFAObject {
        constructor(e) {
          super(d, "textEdit", !0);
          this.allowRichText = o.getInteger({
            data: e.allowRichText,
            defaultValue: 0,
            validate: e => 1 === e
          });
          this.hScrollPolicy = o.getStringOption(e.hScrollPolicy, ["auto", "off", "on"]);
          this.id = e.id || "";
          this.multiLine = o.getInteger({
            data: e.multiLine,
            defaultValue: "",
            validate: e => 0 === e || 1 === e
          });
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.vScrollPolicy = o.getStringOption(e.vScrollPolicy, ["auto", "off", "on"]);
          this.border = null;
          this.comb = null;
          this.extras = null;
          this.margin = null;
        }
        [r.$toHTML](e) {
          let t;
          let a = s.toStyle(this, "border", "font", "margin");
          let i = this[r.$getParent]()[r.$getParent]();
          "" === this.multiLine && (this.multiLine = i instanceof el ? 1 : 0);
          t = 1 === this.multiLine ? {
            name: "textarea",
            attributes: {
              dataId: i[r.$data] && i[r.$data][r.$uid] || i[r.$uid],
              fieldId: i[r.$uid],
              class: ["xfaTextfield"],
              style: a,
              "aria-label": A(i)
            }
          } : {
            name: "input",
            attributes: {
              type: "text",
              dataId: i[r.$data] && i[r.$data][r.$uid] || i[r.$uid],
              fieldId: i[r.$uid],
              class: ["xfaTextfield"],
              style: a,
              "aria-label": A(i)
            }
          };
          return o.HTMLResult.success({
            name: "label",
            attributes: {
              class: ["xfaLabel"]
            },
            children: [t]
          });
        }
      }
      class tp extends r.StringObject {
        constructor(e) {
          super(d, "time");
          this.id = e.id || "";
          this.name = e.name || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
        [r.$finalize]() {
          let e = this[r.$content].trim();
          this[r.$content] = e ? new Date(e) : null;
        }
        [r.$toHTML](e) {
          return v(this[r.$content] ? this[r.$content].toString() : "");
        }
      }
      class tm extends r.XFAObject {
        constructor(e) {
          super(d, "timeStamp");
          this.id = e.id || "";
          this.server = e.server || "";
          this.type = o.getStringOption(e.type, ["optional", "required"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class tb extends r.StringObject {
        constructor(e) {
          super(d, "toolTip");
          this.id = e.id || "";
          this.rid = e.rid || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class ty extends r.XFAObject {
        constructor(e) {
          super(d, "traversal", !0);
          this.id = e.id || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.extras = null;
          this.traverse = new r.XFAObjectArray();
        }
      }
      class tw extends r.XFAObject {
        constructor(e) {
          super(d, "traverse", !0);
          this.id = e.id || "";
          this.operation = o.getStringOption(e.operation, ["next", "back", "down", "first", "left", "right", "up"]);
          this.ref = e.ref || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.extras = null;
          this.script = null;
        }
        get name() {
          return this.operation;
        }
        [r.$isTransparent]() {
          return !1;
        }
      }
      class tx extends r.XFAObject {
        constructor(e) {
          super(d, "ui", !0);
          this.id = e.id || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.extras = null;
          this.picture = null;
          this.barcode = null;
          this.button = null;
          this.checkButton = null;
          this.choiceList = null;
          this.dateTimeEdit = null;
          this.defaultUi = null;
          this.imageEdit = null;
          this.numericEdit = null;
          this.passwordEdit = null;
          this.signature = null;
          this.textEdit = null;
        }
        [r.$getExtra]() {
          if (void 0 === this[r.$extra]) {
            for (let e of Object.getOwnPropertyNames(this)) {
              if ("extras" === e || "picture" === e) continue;
              let t = this[e];
              if (t instanceof r.XFAObject) {
                this[r.$extra] = t;
                return t;
              }
            }
            this[r.$extra] = null;
          }
          return this[r.$extra];
        }
        [r.$toHTML](e) {
          let t = this[r.$getExtra]();
          return t ? t[r.$toHTML](e) : o.HTMLResult.EMPTY;
        }
      }
      class tS extends r.XFAObject {
        constructor(e) {
          super(d, "validate", !0);
          this.formatTest = o.getStringOption(e.formatTest, ["warning", "disabled", "error"]);
          this.id = e.id || "";
          this.nullTest = o.getStringOption(e.nullTest, ["disabled", "error", "warning"]);
          this.scriptTest = o.getStringOption(e.scriptTest, ["error", "disabled", "warning"]);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.extras = null;
          this.message = null;
          this.picture = null;
          this.script = null;
        }
      }
      class tk extends r.XFAObject {
        constructor(e) {
          super(d, "value", !0);
          this.id = e.id || "";
          this.override = o.getInteger({
            data: e.override,
            defaultValue: 0,
            validate: e => 1 === e
          });
          this.relevant = o.getRelevant(e.relevant);
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.arc = null;
          this.boolean = null;
          this.date = null;
          this.dateTime = null;
          this.decimal = null;
          this.exData = null;
          this.$$float = null;
          this.image = null;
          this.integer = null;
          this.line = null;
          this.rectangle = null;
          this.text = null;
          this.time = null;
        }
        [r.$setValue](e) {
          let t = this[r.$getParent]();
          if (t instanceof eA && t.ui && t.ui.imageEdit) {
            this.image || (this.image = new eP({}), this[r.$appendChild](this.image));
            this.image[r.$content] = e[r.$content];
            return;
          }
          let a = e[r.$nodeName];
          if (null !== this[a]) {
            this[a][r.$content] = e[r.$content];
            return;
          }
          for (let e of Object.getOwnPropertyNames(this)) {
            let t = this[e];
            t instanceof r.XFAObject && (this[e] = null, this[r.$removeChild](t));
          }
          this[e[r.$nodeName]] = e;
          this[r.$appendChild](e);
        }
        [r.$text]() {
          if (this.exData) return "string" == typeof this.exData[r.$content] ? this.exData[r.$content].trim() : this.exData[r.$content][r.$text]().trim();
          for (let e of Object.getOwnPropertyNames(this)) {
            if ("image" === e) continue;
            let t = this[e];
            if (t instanceof r.XFAObject) return (t[r.$content] || "").toString().trim();
          }
          return null;
        }
        [r.$toHTML](e) {
          for (let t of Object.getOwnPropertyNames(this)) {
            let a = this[t];
            if (a instanceof r.XFAObject) return a[r.$toHTML](e);
          }
          return o.HTMLResult.EMPTY;
        }
      }
      t.Value = tk;
      class tA extends r.XFAObject {
        constructor(e) {
          super(d, "variables", !0);
          this.id = e.id || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
          this.boolean = new r.XFAObjectArray();
          this.date = new r.XFAObjectArray();
          this.dateTime = new r.XFAObjectArray();
          this.decimal = new r.XFAObjectArray();
          this.exData = new r.XFAObjectArray();
          this.$$float = new r.XFAObjectArray();
          this.image = new r.XFAObjectArray();
          this.integer = new r.XFAObjectArray();
          this.manifest = new r.XFAObjectArray();
          this.script = new r.XFAObjectArray();
          this.text = new r.XFAObjectArray();
          this.time = new r.XFAObjectArray();
        }
        [r.$isTransparent]() {
          return !0;
        }
      }
      class tv {
        static [i.$buildXFAObject](e, t) {
          if (tv.hasOwnProperty(e)) {
            let a = tv[e](t);
            a[r.$setSetAttributes](t);
            return a;
          }
        }
        static appearanceFilter(e) {
          return new T(e);
        }
        static arc(e) {
          return new M(e);
        }
        static area(e) {
          return new P(e);
        }
        static assist(e) {
          return new E(e);
        }
        static barcode(e) {
          return new N(e);
        }
        static bind(e) {
          return new B(e);
        }
        static bindItems(e) {
          return new D(e);
        }
        static bookend(e) {
          return new L(e);
        }
        static boolean(e) {
          return new R(e);
        }
        static border(e) {
          return new $(e);
        }
        static break(e) {
          return new j(e);
        }
        static breakAfter(e) {
          return new _(e);
        }
        static breakBefore(e) {
          return new U(e);
        }
        static button(e) {
          return new X(e);
        }
        static calculate(e) {
          return new H(e);
        }
        static caption(e) {
          return new q(e);
        }
        static certificate(e) {
          return new z(e);
        }
        static certificates(e) {
          return new G(e);
        }
        static checkButton(e) {
          return new W(e);
        }
        static choiceList(e) {
          return new V(e);
        }
        static color(e) {
          return new K(e);
        }
        static comb(e) {
          return new Y(e);
        }
        static connect(e) {
          return new J(e);
        }
        static contentArea(e) {
          return new Z(e);
        }
        static corner(e) {
          return new Q(e);
        }
        static date(e) {
          return new ee(e);
        }
        static dateTime(e) {
          return new et(e);
        }
        static dateTimeEdit(e) {
          return new ea(e);
        }
        static decimal(e) {
          return new er(e);
        }
        static defaultUi(e) {
          return new ei(e);
        }
        static desc(e) {
          return new en(e);
        }
        static digestMethod(e) {
          return new es(e);
        }
        static digestMethods(e) {
          return new eo(e);
        }
        static draw(e) {
          return new el(e);
        }
        static edge(e) {
          return new ec(e);
        }
        static encoding(e) {
          return new eh(e);
        }
        static encodings(e) {
          return new eu(e);
        }
        static encrypt(e) {
          return new ed(e);
        }
        static encryptData(e) {
          return new ef(e);
        }
        static encryption(e) {
          return new eg(e);
        }
        static encryptionMethod(e) {
          return new ep(e);
        }
        static encryptionMethods(e) {
          return new em(e);
        }
        static event(e) {
          return new eb(e);
        }
        static exData(e) {
          return new ey(e);
        }
        static exObject(e) {
          return new ew(e);
        }
        static exclGroup(e) {
          return new ex(e);
        }
        static execute(e) {
          return new eS(e);
        }
        static extras(e) {
          return new ek(e);
        }
        static field(e) {
          return new eA(e);
        }
        static fill(e) {
          return new ev(e);
        }
        static filter(e) {
          return new eC(e);
        }
        static float(e) {
          return new eO(e);
        }
        static font(e) {
          return new eF(e);
        }
        static format(e) {
          return new eI(e);
        }
        static handler(e) {
          return new eT(e);
        }
        static hyphenation(e) {
          return new eM(e);
        }
        static image(e) {
          return new eP(e);
        }
        static imageEdit(e) {
          return new eE(e);
        }
        static integer(e) {
          return new eN(e);
        }
        static issuers(e) {
          return new eB(e);
        }
        static items(e) {
          return new eD(e);
        }
        static keep(e) {
          return new eL(e);
        }
        static keyUsage(e) {
          return new eR(e);
        }
        static line(e) {
          return new e$(e);
        }
        static linear(e) {
          return new ej(e);
        }
        static lockDocument(e) {
          return new e_(e);
        }
        static manifest(e) {
          return new eU(e);
        }
        static margin(e) {
          return new eX(e);
        }
        static mdp(e) {
          return new eH(e);
        }
        static medium(e) {
          return new eq(e);
        }
        static message(e) {
          return new ez(e);
        }
        static numericEdit(e) {
          return new eG(e);
        }
        static occur(e) {
          return new eW(e);
        }
        static oid(e) {
          return new eV(e);
        }
        static oids(e) {
          return new eK(e);
        }
        static overflow(e) {
          return new eY(e);
        }
        static pageArea(e) {
          return new eJ(e);
        }
        static pageSet(e) {
          return new eZ(e);
        }
        static para(e) {
          return new eQ(e);
        }
        static passwordEdit(e) {
          return new e1(e);
        }
        static pattern(e) {
          return new e0(e);
        }
        static picture(e) {
          return new e2(e);
        }
        static proto(e) {
          return new e9(e);
        }
        static radial(e) {
          return new e5(e);
        }
        static reason(e) {
          return new e3(e);
        }
        static reasons(e) {
          return new e6(e);
        }
        static rectangle(e) {
          return new e7(e);
        }
        static ref(e) {
          return new e8(e);
        }
        static script(e) {
          return new e4(e);
        }
        static setProperty(e) {
          return new te(e);
        }
        static signData(e) {
          return new tt(e);
        }
        static signature(e) {
          return new ta(e);
        }
        static signing(e) {
          return new tr(e);
        }
        static solid(e) {
          return new ti(e);
        }
        static speak(e) {
          return new tn(e);
        }
        static stipple(e) {
          return new ts(e);
        }
        static subform(e) {
          return new to(e);
        }
        static subformSet(e) {
          return new tl(e);
        }
        static subjectDN(e) {
          return new tc(e);
        }
        static subjectDNs(e) {
          return new th(e);
        }
        static submit(e) {
          return new tu(e);
        }
        static template(e) {
          return new td(e);
        }
        static text(e) {
          return new tf(e);
        }
        static textEdit(e) {
          return new tg(e);
        }
        static time(e) {
          return new tp(e);
        }
        static timeStamp(e) {
          return new tm(e);
        }
        static toolTip(e) {
          return new tb(e);
        }
        static traversal(e) {
          return new ty(e);
        }
        static traverse(e) {
          return new tw(e);
        }
        static ui(e) {
          return new tx(e);
        }
        static validate(e) {
          return new tS(e);
        }
        static value(e) {
          return new tk(e);
        }
        static variables(e) {
          return new tA(e);
        }
      }
      t.TemplateNamespace = tv;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.addHTML = function (e, t, a) {
        let s = e[r.$extra];
        let o = s.availableSpace;
        let [l, c, h, u] = a;
        switch (e.layout) {
          case "position":
            s.width = Math.max(s.width, l + h);
            s.height = Math.max(s.height, c + u);
            s.children.push(t);
            break;
          case "lr-tb":
          case "rl-tb":
            s.line && 1 !== s.attempt || (s.line = n(e, []), s.children.push(s.line), s.numberInLine = 0);
            s.numberInLine += 1;
            s.line.children.push(t);
            0 === s.attempt ? (s.currentWidth += h, s.height = Math.max(s.height, s.prevHeight + u)) : (s.currentWidth = h, s.prevHeight = s.height, s.height += u, s.attempt = 0);
            s.width = Math.max(s.width, s.currentWidth);
            break;
          case "rl-row":
          case "row":
            {
              s.children.push(t);
              s.width += h;
              s.height = Math.max(s.height, u);
              let e = i.measureToString(s.height);
              for (let t of s.children) t.attributes.style.height = e;
              break;
            }
          case "table":
          case "tb":
            s.width = Math.min(o.width, Math.max(s.width, h));
            s.height += u;
            s.children.push(t);
        }
      };
      t.checkDimensions = function (e, t) {
        if (null === e[r.$getTemplateRoot]()[r.$extra].firstUnsplittable || 0 === e.w || 0 === e.h) return !0;
        let a = e[r.$getSubformParent]();
        let i = a[r.$extra] && a[r.$extra].attempt || 0;
        let [, n, s, o] = function (e) {
          let t;
          let a;
          let r = "" === e.w ? NaN : e.w;
          let i = "" === e.h ? NaN : e.h;
          let [n, s] = [0, 0];
          switch (e.anchorType || "") {
            case "bottomCenter":
              [n, s] = [r / 2, i];
              break;
            case "bottomLeft":
              [n, s] = [0, i];
              break;
            case "bottomRight":
              [n, s] = [r, i];
              break;
            case "middleCenter":
              [n, s] = [r / 2, i / 2];
              break;
            case "middleLeft":
              [n, s] = [0, i / 2];
              break;
            case "middleRight":
              [n, s] = [r, i / 2];
              break;
            case "topCenter":
              [n, s] = [r / 2, 0];
              break;
            case "topRight":
              [n, s] = [r, 0];
          }
          switch (e.rotate || 0) {
            case 0:
              [t, a] = [-n, -s];
              break;
            case 90:
              [t, a] = [-s, n];
              [r, i] = [i, -r];
              break;
            case 180:
              [t, a] = [n, s];
              [r, i] = [-r, -i];
              break;
            case 270:
              [t, a] = [s, -n];
              [r, i] = [-i, r];
          }
          return [e.x + t + Math.min(0, r), e.y + a + Math.min(0, i), Math.abs(r), Math.abs(i)];
        }(e);
        switch (a.layout) {
          case "lr-tb":
          case "rl-tb":
            if (0 === i) {
              if (!e[r.$getTemplateRoot]()[r.$extra].noLayoutFailure) {
                if ("" !== e.h && Math.round(o - t.height) > 2) return !1;
                if ("" !== e.w) {
                  if (2 >= Math.round(s - t.width)) return !0;
                  if (0 === a[r.$extra].numberInLine) return t.height > 2;
                  return !1;
                }
                return t.width > 2;
              }
              if ("" !== e.w) return 2 >= Math.round(s - t.width);
              return t.width > 2;
            }
            if (e[r.$getTemplateRoot]()[r.$extra].noLayoutFailure) return !0;
            if ("" !== e.h && Math.round(o - t.height) > 2) return !1;
            if ("" === e.w || 2 >= Math.round(s - t.width)) return t.height > 2;
            if (a[r.$isThereMoreWidth]()) return !1;
            return t.height > 2;
          case "table":
          case "tb":
            if (e[r.$getTemplateRoot]()[r.$extra].noLayoutFailure) return !0;
            if ("" !== e.h && !e[r.$isSplittable]()) return 2 >= Math.round(o - t.height);
            if ("" === e.w || 2 >= Math.round(s - t.width)) return t.height > 2;
            if (a[r.$isThereMoreWidth]()) return !1;
            return t.height > 2;
          case "position":
            if (e[r.$getTemplateRoot]()[r.$extra].noLayoutFailure || "" === e.h || 2 >= Math.round(o + n - t.height)) return !0;
            return o + n > e[r.$getTemplateRoot]()[r.$extra].currentContentArea.h;
          case "rl-row":
          case "row":
            if (e[r.$getTemplateRoot]()[r.$extra].noLayoutFailure) return !0;
            if ("" !== e.h) return 2 >= Math.round(o - t.height);
            return !0;
          default:
            return !0;
        }
      };
      t.flushHTML = function (e) {
        if (!e[r.$extra]) return null;
        let t = {
          name: "div",
          attributes: e[r.$extra].attributes,
          children: e[r.$extra].children
        };
        if (e[r.$extra].failingNode) {
          let a = e[r.$extra].failingNode[r.$flushHTML]();
          a && (e.layout.endsWith("-tb") ? t.children.push(n(e, [a])) : t.children.push(a));
        }
        return 0 === t.children.length ? null : t;
      };
      t.getAvailableSpace = function (e) {
        let t = e[r.$extra].availableSpace;
        let a = e.margin ? e.margin.topInset + e.margin.bottomInset : 0;
        let i = e.margin ? e.margin.leftInset + e.margin.rightInset : 0;
        switch (e.layout) {
          case "lr-tb":
          case "rl-tb":
            if (0 === e[r.$extra].attempt) return {
              width: t.width - i - e[r.$extra].currentWidth,
              height: t.height - a - e[r.$extra].prevHeight
            };
            return {
              width: t.width - i,
              height: t.height - a - e[r.$extra].height
            };
          case "rl-row":
          case "row":
            return {
              width: e[r.$extra].columnWidths.slice(e[r.$extra].currentColumn).reduce((e, t) => e + t),
              height: t.height - i
            };
          case "table":
          case "tb":
            return {
              width: t.width - i,
              height: t.height - a - e[r.$extra].height
            };
          default:
            return t;
        }
      };
      var r = a(76);
      var i = a(83);
      function n(e, t) {
        return {
          name: "div",
          attributes: {
            class: ["lr-tb" === e.layout ? "xfaLr" : "xfaRl"]
          },
          children: t
        };
      }
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.computeBbox = function (e, t, a) {
        let i;
        if ("" !== e.w && "" !== e.h) i = [e.x, e.y, e.w, e.h]; else {
          if (!a) return null;
          let n = e.w;
          if ("" === n) {
            if (0 === e.maxW) {
              let t = e[r.$getSubformParent]();
              n = "position" === t.layout && "" !== t.w ? 0 : e.minW;
            } else n = Math.min(e.maxW, a.width);
            t.attributes.style.width = l(n);
          }
          let s = e.h;
          if ("" === s) {
            if (0 === e.maxH) {
              let t = e[r.$getSubformParent]();
              s = "position" === t.layout && "" !== t.h ? 0 : e.minH;
            } else s = Math.min(e.maxH, a.height);
            t.attributes.style.height = l(s);
          }
          i = [e.x, e.y, n, s];
        }
        return i;
      };
      t.createWrapper = function (e, t) {
        let {
          attributes
        } = t;
        let {
          style
        } = a;
        let n = {
          name: "div",
          attributes: {
            class: ["xfaWrapper"],
            style: Object.create(null)
          },
          children: []
        };
        if (attributes.$$class.push("xfaWrapped"), e.border) {
          let a;
          let s;
          let {
            widths,
            insets
          } = e.border[r.$extra];
          let c = insets[0];
          let h = insets[3];
          let d = insets[0] + insets[2];
          let f = insets[1] + insets[3];
          switch (e.border.hand) {
            case "even":
              c -= widths[0] / 2;
              h -= widths[3] / 2;
              a = `calc(100% + ${(widths[1] + widths[3]) / 2 - f}px)`;
              s = `calc(100% + ${(widths[0] + widths[2]) / 2 - d}px)`;
              break;
            case "left":
              c -= widths[0];
              h -= widths[3];
              a = `calc(100% + ${widths[1] + widths[3] - f}px)`;
              s = `calc(100% + ${widths[0] + widths[2] - d}px)`;
              break;
            case "right":
              a = f ? `calc(100% - ${f}px)` : "100%";
              s = d ? `calc(100% - ${d}px)` : "100%";
          }
          let g = ["xfaBorder"];
          u(e.border) && g.push("xfaPrintOnly");
          let p = {
            name: "div",
            attributes: {
              class: g,
              style: {
                top: `${c}px`,
                left: `${h}px`,
                width: a,
                height: s
              }
            },
            children: []
          };
          for (let e of ["border", "borderWidth", "borderColor", "borderRadius", "borderStyle"]) void 0 !== style[e] && (p.attributes.style[e] = style[e], delete style[e]);
          n.children.push(p, t);
        } else n.children.push(t);
        for (let e of ["background", "backgroundClip", "top", "left", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "transform", "transformOrigin", "visibility"]) void 0 !== style[e] && (n.attributes.style[e] = style[e], delete style[e]);
        "absolute" === style.position ? n.attributes.style.position = "absolute" : n.attributes.style.position = "relative";
        delete style.position;
        style.alignSelf && (n.attributes.style.alignSelf = style.alignSelf, delete style.alignSelf);
        return n;
      };
      t.fixDimensions = function (e) {
        let t = e[r.$getSubformParent]();
        if (t.layout && t.layout.includes("row")) {
          let a;
          let i = t[r.$extra];
          let n = e.colSpan;
          isNaN(a = -1 === n ? i.columnWidths.slice(i.currentColumn).reduce((e, t) => e + t, 0) : i.columnWidths.slice(i.currentColumn, i.currentColumn + n).reduce((e, t) => e + t, 0)) || (e.w = a);
        }
        t.layout && "position" !== t.layout && (e.x = e.y = 0);
        "table" === e.layout && "" === e.w && Array.isArray(e.columnWidths) && (e.w = e.columnWidths.reduce((e, t) => e + t, 0));
      };
      t.fixTextIndent = function (e) {
        let t = n.getMeasurement(e.textIndent, "0px");
        if (t >= 0) return;
        let a = "padding" + ("left" == ("right" === e.textAlign ? "right" : "left") ? "Left" : "Right");
        let r = n.getMeasurement(e[a], "0px");
        e[a] = `${r - t}px`;
      };
      t.fixURL = function (e) {
        let t = i.createValidAbsoluteUrl(e, null, {
          addDefaultProtocol: !0,
          tryConvertEncoding: !0
        });
        return t ? t.href : null;
      };
      t.isPrintOnly = u;
      t.layoutClass = function (e) {
        switch (e.layout) {
          case "position":
          default:
            return "xfaPosition";
          case "lr-tb":
            return "xfaLrTb";
          case "rl-row":
            return "xfaRlRow";
          case "rl-tb":
            return "xfaRlTb";
          case "row":
            return "xfaRow";
          case "table":
            return "xfaTable";
          case "tb":
            return "xfaTb";
        }
      };
      t.layoutNode = function (e, t) {
        let a = null;
        let i = null;
        let n = !1;
        if ((!e.w || !e.h) && e.value) {
          let s = 0;
          let o = 0;
          e.margin && (s = e.margin.leftInset + e.margin.rightInset, o = e.margin.topInset + e.margin.bottomInset);
          let l = null;
          let c = null;
          e.para && (c = Object.create(null), l = "" === e.para.lineHeight ? null : e.para.lineHeight, c.top = "" === e.para.spaceAbove ? 0 : e.para.spaceAbove, c.bottom = "" === e.para.spaceBelow ? 0 : e.para.spaceBelow, c.left = "" === e.para.marginLeft ? 0 : e.para.marginLeft, c.right = "" === e.para.marginRight ? 0 : e.para.marginRight);
          let u = e.font;
          if (!u) {
            let t = e[r.$getTemplateRoot]();
            let a = e[r.$getParent]();
            for (; a && a !== t;) {
              if (a.font) {
                u = a.font;
                break;
              }
              a = a[r.$getParent]();
            }
          }
          let d = (e.w ? e.w : t.width) - s;
          let f = e[r.$globalData].fontFinder;
          if (e.value.exData && e.value.exData[r.$content] && "text/html" === e.value.exData.contentType) {
            let t = h(e.value.exData[r.$content], u, c, l, f, d);
            i = t.width;
            a = t.height;
            n = t.isBroken;
          } else {
            let t = e.value[r.$text]();
            if (t) {
              let e = h(t, u, c, l, f, d);
              i = e.width;
              a = e.height;
              n = e.isBroken;
            }
          }
          null === i || e.w || (i += s);
          null === a || e.h || (a += o);
        }
        return {
          w: i,
          h: a,
          isBroken: n
        };
      };
      t.measureToString = l;
      t.setAccess = function (e, t) {
        switch (e.access) {
          case "nonInteractive":
            t.push("xfaNonInteractive");
            break;
          case "readOnly":
            t.push("xfaReadOnly");
            break;
          case "protected":
            t.push("xfaDisabled");
        }
      };
      t.setFontFamily = function (e, t, a, r) {
        if (!a) {
          delete r.fontFamily;
          return;
        }
        let i = n.stripQuotes(e.typeface);
        r.fontFamily = `"${i}"`;
        let o = a.find(i);
        if (o) {
          let {
            fontFamily
          } = o.regular.cssFontInfo;
          fontFamily !== i && (r.fontFamily = `"${fontFamily}"`);
          let n = d(t);
          if (n && "" !== n.lineHeight || r.lineHeight) return;
          let l = s.selectFont(e, o);
          l && (r.lineHeight = Math.max(1.2, l.lineHeight));
        }
      };
      t.setMinMaxDimensions = function (e, t) {
        "position" === e[r.$getSubformParent]().layout && (e.minW > 0 && (t.minWidth = l(e.minW)), e.maxW > 0 && (t.maxWidth = l(e.maxW)), e.minH > 0 && (t.minHeight = l(e.minH)), e.maxH > 0 && (t.maxHeight = l(e.maxH)));
      };
      t.setPara = function (e, t, a) {
        if (a.attributes.$$class && a.attributes.$$class.includes("xfaRich")) {
          t && ("" === e.h && (t.height = "auto"), "" === e.w && (t.width = "auto"));
          let i = d(e);
          if (i) {
            let e = a.attributes.style;
            switch (e.display = "flex", e.flexDirection = "column", i.vAlign) {
              case "top":
                e.justifyContent = "start";
                break;
              case "bottom":
                e.justifyContent = "end";
                break;
              case "middle":
                e.justifyContent = "center";
            }
            for (let [t, a] of Object.entries(i[r.$toStyle]())) t in e || (e[t] = a);
          }
        }
      };
      t.toStyle = function (e, ...t) {
        let a = Object.create(null);
        for (let n of t) {
          let t = e[n];
          if (null !== t) {
            if (c.hasOwnProperty(n)) {
              c[n](e, a);
              continue;
            }
            if (t instanceof r.XFAObject) {
              let e = t[r.$toStyle]();
              e ? Object.assign(a, e) : i.warn(`(DEBUG) - XFA - style for ${n} not implemented yet`);
            }
          }
        }
        return a;
      };
      var r = a(76);
      var i = a(2);
      var n = a(77);
      var s = a(84);
      var o = a(85);
      function l(e) {
        return "string" == typeof e ? "0px" : Number.isInteger(e) ? `${e}px` : `${e.toFixed(2)}px`;
      }
      let c = {
        anchorType(e, t) {
          let a = e[r.$getSubformParent]();
          if (a && (!a.layout || "position" === a.layout)) switch ("transform" in t || (t.transform = ""), e.anchorType) {
            case "bottomCenter":
              t.transform += "translate(-50%, -100%)";
              break;
            case "bottomLeft":
              t.transform += "translate(0,-100%)";
              break;
            case "bottomRight":
              t.transform += "translate(-100%,-100%)";
              break;
            case "middleCenter":
              t.transform += "translate(-50%,-50%)";
              break;
            case "middleLeft":
              t.transform += "translate(0,-50%)";
              break;
            case "middleRight":
              t.transform += "translate(-100%,-50%)";
              break;
            case "topCenter":
              t.transform += "translate(-50%,0)";
              break;
            case "topRight":
              t.transform += "translate(-100%,0)";
          }
        },
        dimensions(e, t) {
          let a = e[r.$getSubformParent]();
          let i = e.w;
          let n = e.h;
          if (a.layout && a.layout.includes("row")) {
            let t;
            let n = a[r.$extra];
            let s = e.colSpan;
            -1 === s ? (t = n.columnWidths.slice(n.currentColumn).reduce((e, t) => e + t, 0), n.currentColumn = 0) : (t = n.columnWidths.slice(n.currentColumn, n.currentColumn + s).reduce((e, t) => e + t, 0), n.currentColumn = (n.currentColumn + e.colSpan) % n.columnWidths.length);
            isNaN(t) || (i = e.w = t);
          }
          "" !== i ? t.width = l(i) : t.width = "auto";
          "" !== n ? t.height = l(n) : t.height = "auto";
        },
        position(e, t) {
          let a = e[r.$getSubformParent]();
          a && a.layout && "position" !== a.layout || (t.position = "absolute", t.left = l(e.x), t.top = l(e.y));
        },
        rotate(e, t) {
          e.rotate && ("transform" in t || (t.transform = ""), t.transform += `rotate(-${e.rotate}deg)`, t.transformOrigin = "top left");
        },
        presence(e, t) {
          switch (e.presence) {
            case "invisible":
              t.visibility = "hidden";
              break;
            case "hidden":
            case "inactive":
              t.display = "none";
          }
        },
        hAlign(e, t) {
          if ("para" === e[r.$nodeName]) switch (e.hAlign) {
            case "justifyAll":
              t.textAlign = "justify-all";
              break;
            case "radix":
              t.textAlign = "left";
              break;
            default:
              t.textAlign = e.hAlign;
          } else switch (e.hAlign) {
            case "left":
              t.alignSelf = "start";
              break;
            case "center":
              t.alignSelf = "center";
              break;
            case "right":
              t.alignSelf = "end";
          }
        },
        margin(e, t) {
          e.margin && (t.margin = e.margin[r.$toStyle]().margin);
        }
      };
      function h(e, t, a, i, n, s) {
        let l = new o.TextMeasure(t, a, i, n);
        "string" == typeof e ? l.addString(e) : e[r.$pushGlyphs](l);
        return l.compute(s);
      }
      function u(e) {
        return e.relevant.length > 0 && !e.relevant[0].excluded && "print" === e.relevant[0].viewname;
      }
      function d(e) {
        let t = e[r.$getTemplateRoot]()[r.$extra].paraStack;
        return t.length ? t[t.length - 1] : null;
      }
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.FontFinder = void 0;
      t.getMetrics = function (e, t = !1) {
        let a = null;
        if (e) {
          let t = i.stripQuotes(e.typeface);
          let n = e[r.$globalData].fontFinder.find(t);
          a = s(e, n);
        }
        if (!a) return {
          lineHeight: 12,
          lineGap: 2,
          lineNoGap: 10
        };
        let n = e.size || 10;
        let o = a.lineHeight ? Math.max(t ? 0 : 1.2, a.lineHeight) : 1.2;
        let l = void 0 === a.lineGap ? .2 : a.lineGap;
        return {
          lineHeight: o * n,
          lineGap: l * n,
          lineNoGap: Math.max(1, o - l) * n
        };
      };
      t.selectFont = s;
      var r = a(76);
      var i = a(77);
      var n = a(2);
      function s(e, t) {
        return "italic" === e.posture ? "bold" === e.weight ? t.bolditalic : t.italic : "bold" === e.weight ? t.bold : t.regular;
      }
      t.FontFinder = class {
        constructor(e) {
          this.fonts = new Map();
          this.cache = new Map();
          this.warned = new Set();
          this.defaultFont = null;
          this.add(e);
        }
        add(e, t = null) {
          for (let t of e) this.addPdfFont(t);
          for (let e of this.fonts.values()) e.regular || (e.regular = e.italic || e.bold || e.bolditalic);
          if (!t || 0 === t.size) return;
          let a = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
          for (let e of t) this.fonts.set(e, a);
        }
        addPdfFont(e) {
          let t = e.cssFontInfo;
          let a = t.fontFamily;
          let r = this.fonts.get(a);
          r || (r = Object.create(null), this.fonts.set(a, r), this.defaultFont || (this.defaultFont = r));
          let i = "";
          let n = parseFloat(t.fontWeight);
          0 !== parseFloat(t.italicAngle) ? i = n >= 700 ? "bolditalic" : "italic" : n >= 700 && (i = "bold");
          !i && ((e.name.includes("Bold") || e.psName && e.psName.includes("Bold")) && (i = "bold"), (e.name.includes("Italic") || e.name.endsWith("It") || e.psName && (e.psName.includes("Italic") || e.psName.endsWith("It"))) && (i += "italic"));
          i || (i = "regular");
          r[i] = e;
        }
        getDefault() {
          return this.defaultFont;
        }
        find(e, t = !0) {
          let a = this.fonts.get(e) || this.cache.get(e);
          if (a) return a;
          let r = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
          let i = e.replace(r, "");
          if (a = this.fonts.get(i)) {
            this.cache.set(e, a);
            return a;
          }
          i = i.toLowerCase();
          let s = [];
          for (let [e, t] of this.fonts.entries()) e.replace(r, "").toLowerCase().startsWith(i) && s.push(t);
          if (0 === s.length) for (let [, e] of this.fonts.entries()) e.regular.name && e.regular.name.replace(r, "").toLowerCase().startsWith(i) && s.push(e);
          if (0 === s.length) for (let [e, t] of (i = i.replace(/psmt|mt/gi, ""), this.fonts.entries())) e.replace(r, "").toLowerCase().startsWith(i) && s.push(t);
          if (0 === s.length) for (let e of this.fonts.values()) e.regular.name && e.regular.name.replace(r, "").toLowerCase().startsWith(i) && s.push(e);
          return s.length >= 1 ? (1 !== s.length && t && n.warn(`XFA - Too many choices to guess the correct font: ${e}`), this.cache.set(e, s[0]), s[0]) : (t && !this.warned.has(e) && (this.warned.add(e), n.warn(`XFA - Cannot find the font: ${e}`)), null);
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.TextMeasure = void 0;
      var r = a(84);
      class i {
        constructor(e, t, a, i) {
          this.lineHeight = a;
          this.paraMargin = t || {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0
          };
          if (!e) {
            [this.pdfFont, this.xfaFont] = this.defaultFont(i);
            return;
          }
          this.xfaFont = {
            typeface: e.typeface,
            posture: e.posture,
            weight: e.weight,
            size: e.size,
            letterSpacing: e.letterSpacing
          };
          let n = i.find(e.typeface);
          if (!n) {
            [this.pdfFont, this.xfaFont] = this.defaultFont(i);
            return;
          }
          this.pdfFont = r.selectFont(e, n);
          this.pdfFont || ([this.pdfFont, this.xfaFont] = this.defaultFont(i));
        }
        defaultFont(e) {
          let t = e.find("Helvetica", !1) || e.find("Myriad Pro", !1) || e.find("Arial", !1) || e.getDefault();
          if (t && t.regular) {
            let e = t.regular;
            let a = {
              typeface: e.cssFontInfo.fontFamily,
              posture: "normal",
              weight: "normal",
              size: 10,
              letterSpacing: 0
            };
            return [e, a];
          }
          return [null, {
            typeface: "Courier",
            posture: "normal",
            weight: "normal",
            size: 10,
            letterSpacing: 0
          }];
        }
      }
      class n {
        constructor(e, t, a, r) {
          this.fontFinder = r;
          this.stack = [new i(e, t, a, r)];
        }
        pushData(e, t, a) {
          let r = this.stack[this.stack.length - 1];
          for (let t of ["typeface", "posture", "weight", "size", "letterSpacing"]) e[t] || (e[t] = r.xfaFont[t]);
          for (let e of ["top", "bottom", "left", "right"]) isNaN(t[e]) && (t[e] = r.paraMargin[e]);
          let n = new i(e, t, a || r.lineHeight, this.fontFinder);
          n.pdfFont || (n.pdfFont = r.pdfFont);
          this.stack.push(n);
        }
        popFont() {
          this.stack.pop();
        }
        topFont() {
          return this.stack[this.stack.length - 1];
        }
      }
      t.TextMeasure = class {
        constructor(e, t, a, r) {
          this.glyphs = [];
          this.fontSelector = new n(e, t, a, r);
          this.extraHeight = 0;
        }
        pushData(e, t, a) {
          this.fontSelector.pushData(e, t, a);
        }
        popFont(e) {
          return this.fontSelector.popFont();
        }
        addPara() {
          let e = this.fontSelector.topFont();
          this.extraHeight += e.paraMargin.top + e.paraMargin.bottom;
        }
        addString(e) {
          if (!e) return;
          let t = this.fontSelector.topFont();
          let a = t.xfaFont.size;
          if (t.pdfFont) {
            let r = t.xfaFont.letterSpacing;
            let i = t.pdfFont;
            let n = i.lineHeight || 1.2;
            let s = t.lineHeight || Math.max(1.2, n) * a;
            let o = Math.max(1, n - (void 0 === i.lineGap ? .2 : i.lineGap)) * a;
            let l = a / 1e3;
            let c = i.defaultWidth || i.charsToGlyphs(" ")[0].width;
            for (let t of e.split(/[\u2029\n]/)) {
              let e = i.encodeString(t).join("");
              for (let t of i.charsToGlyphs(e)) {
                let e = t.width || c;
                this.glyphs.push([e * l + r, s, o, t.unicode, !1]);
              }
              this.glyphs.push([0, 0, 0, "\n", !0]);
            }
            this.glyphs.pop();
            return;
          }
          for (let t of e.split(/[\u2029\n]/)) {
            for (let e of t.split("")) this.glyphs.push([a, 1.2 * a, a, e, !1]);
            this.glyphs.push([0, 0, 0, "\n", !0]);
          }
          this.glyphs.pop();
        }
        compute(e) {
          var _this9 = this;
          let t = -1;
          let a = 0;
          let r = 0;
          let i = 0;
          let n = 0;
          let s = 0;
          let o = !1;
          let l = !0;
          for (function () {
            let c = 0;
            let h = _this9.glyphs.length;
          }(); c < h; c++) {
            let [h, u, d, f, g] = this.glyphs[c];
            let p = " " === f;
            let m = l ? d : u;
            if (g) {
              r = Math.max(r, n);
              n = 0;
              i += s;
              s = m;
              t = -1;
              a = 0;
              l = !1;
              continue;
            }
            if (p) {
              n + h > e ? (r = Math.max(r, n), n = 0, i += s, s = m, t = -1, a = 0, o = !0, l = !1) : (s = Math.max(m, s), a = n, n += h, t = c);
              continue;
            }
            if (n + h > e) {
              i += s;
              s = m;
              -1 !== t ? (c = t, r = Math.max(r, a), n = 0, t = -1, a = 0) : (r = Math.max(r, n), n = h);
              o = !0;
              l = !1;
              continue;
            }
            n += h;
            s = Math.max(m, s);
          }
          return {
            width: 1.02 * (r = Math.max(r, n)),
            height: i += s + this.extraHeight,
            isBroken: o
          };
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.DataHandler = void 0;
      var r = a(76);
      t.DataHandler = class {
        constructor(e, t) {
          this.data = t;
          this.dataset = e.datasets || null;
        }
        serialize(e) {
          let t = [[-1, this.data[r.$getChildren]()]];
          for (; t.length > 0;) {
            let a = t[t.length - 1];
            let [i, n] = a;
            if (i + 1 === n.length) {
              t.pop();
              continue;
            }
            let s = n[++a[0]];
            let o = e.get(s[r.$uid]);
            if (o) s[r.$setValue](o); else for (let t of s[r.$getAttributes]().values()) {
              let a = e.get(t[r.$uid]);
              if (a) {
                t[r.$setValue](a);
                break;
              }
            }
            let l = s[r.$getChildren]();
            l.length > 0 && t.push([-1, l]);
          }
          let a = ['<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">'];
          if (this.dataset) for (let e of this.dataset[r.$getChildren]()) "data" !== e[r.$nodeName] && e[r.$toString](a);
          this.data[r.$toString](a);
          a.push("</xfa:datasets>");
          return a.join("");
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.XFAParser = void 0;
      var r = a(76);
      var i = a(69);
      var n = a(88);
      var s = a(2);
      class o extends i.XMLParserBase {
        constructor(e = null, t = !1) {
          super();
          this._builder = new n.Builder(e);
          this._stack = [];
          this._globalData = {
            usedTypefaces: new Set()
          };
          this._ids = new Map();
          this._current = this._builder.buildRoot(this._ids);
          this._errorCode = i.XMLParserErrorCode.NoError;
          this._whiteRegex = /^\s+$/;
          this._nbsps = /\xa0+/g;
          this._richText = t;
        }
        parse(e) {
          if (this.parseXml(e), this._errorCode === i.XMLParserErrorCode.NoError) {
            this._current[r.$finalize]();
            return this._current.element;
          }
        }
        onText(e) {
          if (e = e.replace(this._nbsps, e => e.slice(1) + " "), this._richText || this._current[r.$acceptWhitespace]()) {
            this._current[r.$onText](e, this._richText);
            return;
          }
          this._whiteRegex.test(e) || this._current[r.$onText](e.trim());
        }
        onCdata(e) {
          this._current[r.$onText](e);
        }
        _mkAttributes(e, t) {
          let a = null;
          let i = null;
          let n = Object.create({});
          for (let {
            name,
            value
          } of e) if ("xmlns" === name) a ? s.warn(`XFA - multiple namespace definition in <${t}>`) : a = value; else if (name.startsWith("xmlns:")) {
            let e = name.substring(6);
            i || (i = []);
            i.push({
              prefix: e,
              value
            });
          } else {
            let e = name.indexOf(":");
            if (-1 === e) n[name] = value; else {
              let t = n[r.$nsAttributes];
              t || (t = n[r.$nsAttributes] = Object.create(null));
              let [a, i] = [name.slice(0, e), name.slice(e + 1)];
              let s = t[a];
              s || (s = t[a] = Object.create(null));
              s[i] = value;
            }
          }
          return [a, i, n];
        }
        _getNameAndPrefix(e, t) {
          let a = e.indexOf(":");
          return -1 === a ? [e, null] : [e.substring(a + 1), t ? "" : e.substring(0, a)];
        }
        onBeginElement(e, t, a) {
          let [i, n, s] = this._mkAttributes(t, e);
          let [o, l] = this._getNameAndPrefix(e, this._builder.isNsAgnostic());
          let c = this._builder.build({
            nsPrefix: l,
            name: o,
            attributes: s,
            namespace: i,
            prefixes: n
          });
          if (c[r.$globalData] = this._globalData, a) {
            c[r.$finalize]();
            this._current[r.$onChild](c) && c[r.$setId](this._ids);
            c[r.$clean](this._builder);
            return;
          }
          this._stack.push(this._current);
          this._current = c;
        }
        onEndElement(e) {
          let t = this._current;
          if (t[r.$isCDATAXml]() && "string" == typeof t[r.$content]) {
            let e = new o();
            e._globalData = this._globalData;
            let a = e.parse(t[r.$content]);
            t[r.$content] = null;
            t[r.$onChild](a);
          }
          t[r.$finalize]();
          this._current = this._stack.pop();
          this._current[r.$onChild](t) && t[r.$setId](this._ids);
          t[r.$clean](this._builder);
        }
        onError(e) {
          this._errorCode = e;
        }
      }
      t.XFAParser = o;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.Builder = void 0;
      var r = a(78);
      var i = a(76);
      var n = a(89);
      var s = a(81);
      var o = a(98);
      var l = a(2);
      class c extends i.XFAObject {
        constructor(e) {
          super(-1, "root", Object.create(null));
          this.element = null;
          this[i.$ids] = e;
        }
        [i.$onChild](e) {
          this.element = e;
          return !0;
        }
        [i.$finalize]() {
          super[i.$finalize]();
          this.element.template instanceof s.Template && (this[i.$ids].set(i.$root, this.element), this.element.template[i.$resolvePrototypes](this[i.$ids]), this.element.template[i.$ids] = this[i.$ids]);
        }
      }
      class h extends i.XFAObject {
        constructor() {
          super(-1, "", Object.create(null));
        }
        [i.$onChild](e) {
          return !1;
        }
      }
      t.Builder = class {
        constructor(e = null) {
          this._namespaceStack = [];
          this._nsAgnosticLevel = 0;
          this._namespacePrefixes = new Map();
          this._namespaces = new Map();
          this._nextNsId = Math.max(...Object.values(r.NamespaceIds).map(({
            id: e
          }) => e));
          this._currentNamespace = e || new o.UnknownNamespace(++this._nextNsId);
        }
        buildRoot(e) {
          return new c(e);
        }
        build({
          nsPrefix: e,
          name: t,
          attributes: a,
          namespace: s,
          prefixes: o
        }) {
          let l = null !== s;
          if (l && (this._namespaceStack.push(this._currentNamespace), this._currentNamespace = this._searchNamespace(s)), o && this._addNamespacePrefix(o), a.hasOwnProperty(i.$nsAttributes)) {
            let e = n.NamespaceSetUp.datasets;
            let t = a[i.$nsAttributes];
            let r = null;
            for (let [a, i] of Object.entries(t)) if (this._getNamespaceToUse(a) === e) {
              r = {
                xfa: i
              };
              break;
            }
            r ? a[i.$nsAttributes] = r : delete a[i.$nsAttributes];
          }
          let c = this._getNamespaceToUse(e);
          let u = c && c[r.$buildXFAObject](t, a) || new h();
          u[i.$isNsAgnostic]() && this._nsAgnosticLevel++;
          (l || o || u[i.$isNsAgnostic]()) && (u[i.$cleanup] = {
            hasNamespace: l,
            prefixes: o,
            nsAgnostic: u[i.$isNsAgnostic]()
          });
          return u;
        }
        isNsAgnostic() {
          return this._nsAgnosticLevel > 0;
        }
        _searchNamespace(e) {
          let t = this._namespaces.get(e);
          if (t) return t;
          for (let [a, {
            check: i
          }] of Object.entries(r.NamespaceIds)) if (i(e)) {
            if (t = n.NamespaceSetUp[a]) {
              this._namespaces.set(e, t);
              return t;
            }
            break;
          }
          t = new o.UnknownNamespace(++this._nextNsId);
          this._namespaces.set(e, t);
          return t;
        }
        _addNamespacePrefix(e) {
          for (let {
            prefix,
            value
          } of e) {
            let e = this._searchNamespace(value);
            let r = this._namespacePrefixes.get(prefix);
            r || (r = [], this._namespacePrefixes.set(prefix, r));
            r.push(e);
          }
        }
        _getNamespaceToUse(e) {
          if (!e) return this._currentNamespace;
          let t = this._namespacePrefixes.get(e);
          return t && t.length > 0 ? t[t.length - 1] : (l.warn(`Unknown namespace prefix: ${e}.`), null);
        }
        clean(e) {
          let {
            hasNamespace,
            prefixes,
            nsAgnostic
          } = e;
          hasNamespace && (this._currentNamespace = this._namespaceStack.pop());
          prefixes && prefixes.forEach(({
            prefix: e
          }) => {
            this._namespacePrefixes.get(e).pop();
          });
          nsAgnostic && this._nsAgnosticLevel--;
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.NamespaceSetUp = void 0;
      var r = a(90);
      var i = a(91);
      var n = a(92);
      var s = a(93);
      var o = a(94);
      var l = a(95);
      var c = a(81);
      var h = a(96);
      var u = a(97);
      let d = {
        config: r.ConfigNamespace,
        connection: i.ConnectionSetNamespace,
        datasets: n.DatasetsNamespace,
        localeSet: s.LocaleSetNamespace,
        signature: o.SignatureNamespace,
        stylesheet: l.StylesheetNamespace,
        template: c.TemplateNamespace,
        xdp: h.XdpNamespace,
        xhtml: u.XhtmlNamespace
      };
      t.NamespaceSetUp = d;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.ConfigNamespace = void 0;
      var r = a(78);
      var i = a(76);
      var n = a(77);
      var s = a(2);
      let o = r.NamespaceIds.config.id;
      class l extends i.XFAObject {
        constructor(e) {
          super(o, "acrobat", !0);
          this.acrobat7 = null;
          this.autoSave = null;
          this.common = null;
          this.validate = null;
          this.validateApprovalSignatures = null;
          this.submitUrl = new i.XFAObjectArray();
        }
      }
      class c extends i.XFAObject {
        constructor(e) {
          super(o, "acrobat7", !0);
          this.dynamicRender = null;
        }
      }
      class h extends i.OptionObject {
        constructor(e) {
          super(o, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
        }
      }
      class u extends i.OptionObject {
        constructor(e) {
          super(o, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
        }
      }
      class d extends i.Option01 {
        constructor(e) {
          super(o, "addSilentPrint");
        }
      }
      class f extends i.Option01 {
        constructor(e) {
          super(o, "addViewerPreferences");
        }
      }
      class g extends i.Option10 {
        constructor(e) {
          super(o, "adjustData");
        }
      }
      class p extends i.IntegerObject {
        constructor(e) {
          super(o, "adobeExtensionLevel", 0, e => e >= 1 && e <= 8);
        }
      }
      class m extends i.XFAObject {
        constructor(e) {
          super(o, "agent", !0);
          this.name = e.name ? e.name.trim() : "";
          this.common = new i.XFAObjectArray();
        }
      }
      class b extends i.ContentObject {
        constructor(e) {
          super(o, "alwaysEmbed");
        }
      }
      class y extends i.StringObject {
        constructor(e) {
          super(o, "amd");
        }
      }
      class w extends i.XFAObject {
        constructor(e) {
          super(o, "area");
          this.level = n.getInteger({
            data: e.level,
            defaultValue: 0,
            validate: e => e >= 1 && e <= 3
          });
          this.name = n.getStringOption(e.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
        }
      }
      class x extends i.OptionObject {
        constructor(e) {
          super(o, "attributes", ["preserve", "delegate", "ignore"]);
        }
      }
      class S extends i.OptionObject {
        constructor(e) {
          super(o, "autoSave", ["disabled", "enabled"]);
        }
      }
      class k extends i.StringObject {
        constructor(e) {
          super(o, "base");
        }
      }
      class A extends i.XFAObject {
        constructor(e) {
          super(o, "batchOutput");
          this.format = n.getStringOption(e.format, ["none", "concat", "zip", "zipCompress"]);
        }
      }
      class v extends i.ContentObject {
        constructor(e) {
          super(o, "behaviorOverride");
        }
        [i.$finalize]() {
          this[i.$content] = new Map(this[i.$content].trim().split(/\s+/).filter(e => e.includes(":")).map(e => e.split(":", 2)));
        }
      }
      class C extends i.XFAObject {
        constructor(e) {
          super(o, "cache", !0);
          this.templateCache = null;
        }
      }
      class O extends i.Option01 {
        constructor(e) {
          super(o, "change");
        }
      }
      class F extends i.XFAObject {
        constructor(e) {
          super(o, "common", !0);
          this.data = null;
          this.locale = null;
          this.localeSet = null;
          this.messaging = null;
          this.suppressBanner = null;
          this.template = null;
          this.validationMessaging = null;
          this.versionControl = null;
          this.log = new i.XFAObjectArray();
        }
      }
      class I extends i.XFAObject {
        constructor(e) {
          super(o, "compress");
          this.scope = n.getStringOption(e.scope, ["imageOnly", "document"]);
        }
      }
      class T extends i.Option01 {
        constructor(e) {
          super(o, "compressLogicalStructure");
        }
      }
      class M extends i.Option10 {
        constructor(e) {
          super(o, "compressObjectStream");
        }
      }
      class P extends i.XFAObject {
        constructor(e) {
          super(o, "compression", !0);
          this.compressLogicalStructure = null;
          this.compressObjectStream = null;
          this.level = null;
          this.type = null;
        }
      }
      class E extends i.XFAObject {
        constructor(e) {
          super(o, "config", !0);
          this.acrobat = null;
          this.present = null;
          this.trace = null;
          this.agent = new i.XFAObjectArray();
        }
      }
      class N extends i.OptionObject {
        constructor(e) {
          super(o, "conformance", ["A", "B"]);
        }
      }
      class B extends i.Option01 {
        constructor(e) {
          super(o, "contentCopy");
        }
      }
      class D extends i.IntegerObject {
        constructor(e) {
          super(o, "copies", 1, e => e >= 1);
        }
      }
      class L extends i.StringObject {
        constructor(e) {
          super(o, "creator");
        }
      }
      class R extends i.IntegerObject {
        constructor(e) {
          super(o, "currentPage", 0, e => e >= 0);
        }
      }
      class $ extends i.XFAObject {
        constructor(e) {
          super(o, "data", !0);
          this.adjustData = null;
          this.attributes = null;
          this.incrementalLoad = null;
          this.outputXSL = null;
          this.range = null;
          this.record = null;
          this.startNode = null;
          this.uri = null;
          this.window = null;
          this.xsl = null;
          this.excludeNS = new i.XFAObjectArray();
          this.transform = new i.XFAObjectArray();
        }
      }
      class j extends i.XFAObject {
        constructor(e) {
          super(o, "debug", !0);
          this.uri = null;
        }
      }
      class _ extends i.ContentObject {
        constructor(e) {
          super(o, "defaultTypeface");
          this.writingScript = n.getStringOption(e.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
        }
      }
      class U extends i.OptionObject {
        constructor(e) {
          super(o, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
        }
      }
      class X extends i.Option01 {
        constructor(e) {
          super(o, "documentAssembly");
        }
      }
      class H extends i.XFAObject {
        constructor(e) {
          super(o, "driver", !0);
          this.name = e.name ? e.name.trim() : "";
          this.fontInfo = null;
          this.xdc = null;
        }
      }
      class q extends i.OptionObject {
        constructor(e) {
          super(o, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
        }
      }
      class z extends i.OptionObject {
        constructor(e) {
          super(o, "dynamicRender", ["forbidden", "required"]);
        }
      }
      class G extends i.Option01 {
        constructor(e) {
          super(o, "embed");
        }
      }
      class W extends i.Option01 {
        constructor(e) {
          super(o, "encrypt");
        }
      }
      class V extends i.XFAObject {
        constructor(e) {
          super(o, "encryption", !0);
          this.encrypt = null;
          this.encryptionLevel = null;
          this.permissions = null;
        }
      }
      class K extends i.OptionObject {
        constructor(e) {
          super(o, "encryptionLevel", ["40bit", "128bit"]);
        }
      }
      class Y extends i.StringObject {
        constructor(e) {
          super(o, "enforce");
        }
      }
      class J extends i.XFAObject {
        constructor(e) {
          super(o, "equate");
          this.force = n.getInteger({
            data: e.force,
            defaultValue: 1,
            validate: e => 0 === e
          });
          this.from = e.from || "";
          this.to = e.to || "";
        }
      }
      class Z extends i.XFAObject {
        constructor(e) {
          super(o, "equateRange");
          this.from = e.from || "";
          this.to = e.to || "";
          this._unicodeRange = e.unicodeRange || "";
        }
        get unicodeRange() {
          let e = [];
          let t = /U\+([0-9a-fA-F]+)/;
          for (let a of this._unicodeRange.split(",").map(e => e.trim()).filter(e => !!e)) {
            1 === (a = a.split("-", 2).map(e => {
              let a = e.match(t);
              return a ? parseInt(a[1], 16) : 0;
            })).length && a.push(a[0]);
            e.push(a);
          }
          return s.shadow(this, "unicodeRange", e);
        }
      }
      class Q extends i.ContentObject {
        constructor(e) {
          super(o, "exclude");
        }
        [i.$finalize]() {
          this[i.$content] = this[i.$content].trim().split(/\s+/).filter(e => e && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(e));
        }
      }
      class ee extends i.StringObject {
        constructor(e) {
          super(o, "excludeNS");
        }
      }
      class et extends i.OptionObject {
        constructor(e) {
          super(o, "flipLabel", ["usePrinterSetting", "on", "off"]);
        }
      }
      class ea extends i.XFAObject {
        constructor(e) {
          super(o, "fontInfo", !0);
          this.embed = null;
          this.map = null;
          this.subsetBelow = null;
          this.alwaysEmbed = new i.XFAObjectArray();
          this.defaultTypeface = new i.XFAObjectArray();
          this.neverEmbed = new i.XFAObjectArray();
        }
      }
      class er extends i.Option01 {
        constructor(e) {
          super(o, "formFieldFilling");
        }
      }
      class ei extends i.StringObject {
        constructor(e) {
          super(o, "groupParent");
        }
      }
      class en extends i.OptionObject {
        constructor(e) {
          super(o, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
        }
      }
      class es extends i.StringObject {
        constructor(e) {
          super(o, "includeXDPContent");
        }
      }
      class eo extends i.OptionObject {
        constructor(e) {
          super(o, "incrementalLoad", ["none", "forwardOnly"]);
        }
      }
      class el extends i.Option01 {
        constructor(e) {
          super(o, "incrementalMerge");
        }
      }
      class ec extends i.Option01 {
        constructor(e) {
          super(o, "interactive");
        }
      }
      class eh extends i.OptionObject {
        constructor(e) {
          super(o, "jog", ["usePrinterSetting", "none", "pageSet"]);
        }
      }
      class eu extends i.XFAObject {
        constructor(e) {
          super(o, "labelPrinter", !0);
          this.name = n.getStringOption(e.name, ["zpl", "dpl", "ipl", "tcpl"]);
          this.batchOutput = null;
          this.flipLabel = null;
          this.fontInfo = null;
          this.xdc = null;
        }
      }
      class ed extends i.OptionObject {
        constructor(e) {
          super(o, "layout", ["paginate", "panel"]);
        }
      }
      class ef extends i.IntegerObject {
        constructor(e) {
          super(o, "level", 0, e => e > 0);
        }
      }
      class eg extends i.Option01 {
        constructor(e) {
          super(o, "linearized");
        }
      }
      class ep extends i.StringObject {
        constructor(e) {
          super(o, "locale");
        }
      }
      class em extends i.StringObject {
        constructor(e) {
          super(o, "localeSet");
        }
      }
      class eb extends i.XFAObject {
        constructor(e) {
          super(o, "log", !0);
          this.mode = null;
          this.threshold = null;
          this.to = null;
          this.uri = null;
        }
      }
      class ey extends i.XFAObject {
        constructor(e) {
          super(o, "map", !0);
          this.equate = new i.XFAObjectArray();
          this.equateRange = new i.XFAObjectArray();
        }
      }
      class ew extends i.XFAObject {
        constructor(e) {
          super(o, "mediumInfo", !0);
          this.map = null;
        }
      }
      class ex extends i.XFAObject {
        constructor(e) {
          super(o, "message", !0);
          this.msgId = null;
          this.severity = null;
        }
      }
      class eS extends i.XFAObject {
        constructor(e) {
          super(o, "messaging", !0);
          this.message = new i.XFAObjectArray();
        }
      }
      class ek extends i.OptionObject {
        constructor(e) {
          super(o, "mode", ["append", "overwrite"]);
        }
      }
      class eA extends i.Option01 {
        constructor(e) {
          super(o, "modifyAnnots");
        }
      }
      class ev extends i.IntegerObject {
        constructor(e) {
          super(o, "msgId", 1, e => e >= 1);
        }
      }
      class eC extends i.StringObject {
        constructor(e) {
          super(o, "nameAttr");
        }
      }
      class eO extends i.ContentObject {
        constructor(e) {
          super(o, "neverEmbed");
        }
      }
      class eF extends i.IntegerObject {
        constructor(e) {
          super(o, "numberOfCopies", null, e => e >= 2 && e <= 5);
        }
      }
      class eI extends i.XFAObject {
        constructor(e) {
          super(o, "openAction", !0);
          this.destination = null;
        }
      }
      class eT extends i.XFAObject {
        constructor(e) {
          super(o, "output", !0);
          this.to = null;
          this.type = null;
          this.uri = null;
        }
      }
      class eM extends i.StringObject {
        constructor(e) {
          super(o, "outputBin");
        }
      }
      class eP extends i.XFAObject {
        constructor(e) {
          super(o, "outputXSL", !0);
          this.uri = null;
        }
      }
      class eE extends i.OptionObject {
        constructor(e) {
          super(o, "overprint", ["none", "both", "draw", "field"]);
        }
      }
      class eN extends i.StringObject {
        constructor(e) {
          super(o, "packets");
        }
        [i.$finalize]() {
          "*" !== this[i.$content] && (this[i.$content] = this[i.$content].trim().split(/\s+/).filter(e => ["config", "datasets", "template", "xfdf", "xslt"].includes(e)));
        }
      }
      class eB extends i.XFAObject {
        constructor(e) {
          super(o, "pageOffset");
          this.x = n.getInteger({
            data: e.x,
            defaultValue: "useXDCSetting",
            validate: e => !0
          });
          this.y = n.getInteger({
            data: e.y,
            defaultValue: "useXDCSetting",
            validate: e => !0
          });
        }
      }
      class eD extends i.StringObject {
        constructor(e) {
          super(o, "pageRange");
        }
        [i.$finalize]() {
          let e = this[i.$content].trim().split(/\s+/).map(e => parseInt(e, 10));
          let t = [];
          for (function () {
            let a = 0;
            let r = e.length;
          }(); a < r; a += 2) t.push(e.slice(a, a + 2));
          this[i.$content] = t;
        }
      }
      class eL extends i.OptionObject {
        constructor(e) {
          super(o, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
        }
      }
      class eR extends i.OptionObject {
        constructor(e) {
          super(o, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
        }
      }
      class e$ extends i.IntegerObject {
        constructor(e) {
          super(o, "part", 1, e => !1);
        }
      }
      class ej extends i.XFAObject {
        constructor(e) {
          super(o, "pcl", !0);
          this.name = e.name || "";
          this.batchOutput = null;
          this.fontInfo = null;
          this.jog = null;
          this.mediumInfo = null;
          this.outputBin = null;
          this.pageOffset = null;
          this.staple = null;
          this.xdc = null;
        }
      }
      class e_ extends i.XFAObject {
        constructor(e) {
          super(o, "pdf", !0);
          this.name = e.name || "";
          this.adobeExtensionLevel = null;
          this.batchOutput = null;
          this.compression = null;
          this.creator = null;
          this.encryption = null;
          this.fontInfo = null;
          this.interactive = null;
          this.linearized = null;
          this.openAction = null;
          this.pdfa = null;
          this.producer = null;
          this.renderPolicy = null;
          this.scriptModel = null;
          this.silentPrint = null;
          this.submitFormat = null;
          this.tagged = null;
          this.version = null;
          this.viewerPreferences = null;
          this.xdc = null;
        }
      }
      class eU extends i.XFAObject {
        constructor(e) {
          super(o, "pdfa", !0);
          this.amd = null;
          this.conformance = null;
          this.includeXDPContent = null;
          this.part = null;
        }
      }
      class eX extends i.XFAObject {
        constructor(e) {
          super(o, "permissions", !0);
          this.accessibleContent = null;
          this.change = null;
          this.contentCopy = null;
          this.documentAssembly = null;
          this.formFieldFilling = null;
          this.modifyAnnots = null;
          this.plaintextMetadata = null;
          this.print = null;
          this.printHighQuality = null;
        }
      }
      class eH extends i.Option01 {
        constructor(e) {
          super(o, "pickTrayByPDFSize");
        }
      }
      class eq extends i.StringObject {
        constructor(e) {
          super(o, "picture");
        }
      }
      class ez extends i.Option01 {
        constructor(e) {
          super(o, "plaintextMetadata");
        }
      }
      class eG extends i.OptionObject {
        constructor(e) {
          super(o, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
        }
      }
      class eW extends i.XFAObject {
        constructor(e) {
          super(o, "present", !0);
          this.behaviorOverride = null;
          this.cache = null;
          this.common = null;
          this.copies = null;
          this.destination = null;
          this.incrementalMerge = null;
          this.layout = null;
          this.output = null;
          this.overprint = null;
          this.pagination = null;
          this.paginationOverride = null;
          this.script = null;
          this.validate = null;
          this.xdp = null;
          this.driver = new i.XFAObjectArray();
          this.labelPrinter = new i.XFAObjectArray();
          this.pcl = new i.XFAObjectArray();
          this.pdf = new i.XFAObjectArray();
          this.ps = new i.XFAObjectArray();
          this.submitUrl = new i.XFAObjectArray();
          this.webClient = new i.XFAObjectArray();
          this.zpl = new i.XFAObjectArray();
        }
      }
      class eV extends i.Option01 {
        constructor(e) {
          super(o, "print");
        }
      }
      class eK extends i.Option01 {
        constructor(e) {
          super(o, "printHighQuality");
        }
      }
      class eY extends i.OptionObject {
        constructor(e) {
          super(o, "printScaling", ["appdefault", "noScaling"]);
        }
      }
      class eJ extends i.StringObject {
        constructor(e) {
          super(o, "printerName");
        }
      }
      class eZ extends i.StringObject {
        constructor(e) {
          super(o, "producer");
        }
      }
      class eQ extends i.XFAObject {
        constructor(e) {
          super(o, "ps", !0);
          this.name = e.name || "";
          this.batchOutput = null;
          this.fontInfo = null;
          this.jog = null;
          this.mediumInfo = null;
          this.outputBin = null;
          this.staple = null;
          this.xdc = null;
        }
      }
      class e1 extends i.ContentObject {
        constructor(e) {
          super(o, "range");
        }
        [i.$finalize]() {
          this[i.$content] = this[i.$content].trim().split(/\s*,\s*/, 2).map(e => e.split("-").map(e => parseInt(e.trim(), 10))).filter(e => e.every(e => !isNaN(e))).map(e => (1 === e.length && e.push(e[0]), e));
        }
      }
      class e0 extends i.ContentObject {
        constructor(e) {
          super(o, "record");
        }
        [i.$finalize]() {
          this[i.$content] = this[i.$content].trim();
          let e = parseInt(this[i.$content], 10);
          !isNaN(e) && e >= 0 && (this[i.$content] = e);
        }
      }
      class e2 extends i.ContentObject {
        constructor(e) {
          super(o, "relevant");
        }
        [i.$finalize]() {
          this[i.$content] = this[i.$content].trim().split(/\s+/);
        }
      }
      class e9 extends i.ContentObject {
        constructor(e) {
          super(o, "rename");
        }
        [i.$finalize]() {
          this[i.$content] = this[i.$content].trim();
          (this[i.$content].toLowerCase().startsWith("xml") || this[i.$content].match(RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u"))) && s.warn("XFA - Rename: invalid XFA name");
        }
      }
      class e5 extends i.OptionObject {
        constructor(e) {
          super(o, "renderPolicy", ["server", "client"]);
        }
      }
      class e3 extends i.OptionObject {
        constructor(e) {
          super(o, "runScripts", ["both", "client", "none", "server"]);
        }
      }
      class e6 extends i.XFAObject {
        constructor(e) {
          super(o, "script", !0);
          this.currentPage = null;
          this.exclude = null;
          this.runScripts = null;
        }
      }
      class e7 extends i.OptionObject {
        constructor(e) {
          super(o, "scriptModel", ["XFA", "none"]);
        }
      }
      class e8 extends i.OptionObject {
        constructor(e) {
          super(o, "severity", ["ignore", "error", "information", "trace", "warning"]);
        }
      }
      class e4 extends i.XFAObject {
        constructor(e) {
          super(o, "silentPrint", !0);
          this.addSilentPrint = null;
          this.printerName = null;
        }
      }
      class te extends i.XFAObject {
        constructor(e) {
          super(o, "staple");
          this.mode = n.getStringOption(e.mode, ["usePrinterSetting", "on", "off"]);
        }
      }
      class tt extends i.StringObject {
        constructor(e) {
          super(o, "startNode");
        }
      }
      class ta extends i.IntegerObject {
        constructor(e) {
          super(o, "startPage", 0, e => !0);
        }
      }
      class tr extends i.OptionObject {
        constructor(e) {
          super(o, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
        }
      }
      class ti extends i.StringObject {
        constructor(e) {
          super(o, "submitUrl");
        }
      }
      class tn extends i.IntegerObject {
        constructor(e) {
          super(o, "subsetBelow", 100, e => e >= 0 && e <= 100);
        }
      }
      class ts extends i.Option01 {
        constructor(e) {
          super(o, "suppressBanner");
        }
      }
      class to extends i.Option01 {
        constructor(e) {
          super(o, "tagged");
        }
      }
      class tl extends i.XFAObject {
        constructor(e) {
          super(o, "template", !0);
          this.base = null;
          this.relevant = null;
          this.startPage = null;
          this.uri = null;
          this.xsl = null;
        }
      }
      class tc extends i.OptionObject {
        constructor(e) {
          super(o, "threshold", ["trace", "error", "information", "warning"]);
        }
      }
      class th extends i.OptionObject {
        constructor(e) {
          super(o, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
        }
      }
      class tu extends i.XFAObject {
        constructor(e) {
          super(o, "templateCache");
          this.maxEntries = n.getInteger({
            data: e.maxEntries,
            defaultValue: 5,
            validate: e => e >= 0
          });
        }
      }
      class td extends i.XFAObject {
        constructor(e) {
          super(o, "trace", !0);
          this.area = new i.XFAObjectArray();
        }
      }
      class tf extends i.XFAObject {
        constructor(e) {
          super(o, "transform", !0);
          this.groupParent = null;
          this.ifEmpty = null;
          this.nameAttr = null;
          this.picture = null;
          this.presence = null;
          this.rename = null;
          this.whitespace = null;
        }
      }
      class tg extends i.OptionObject {
        constructor(e) {
          super(o, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
        }
      }
      class tp extends i.StringObject {
        constructor(e) {
          super(o, "uri");
        }
      }
      class tm extends i.OptionObject {
        constructor(e) {
          super(o, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
        }
      }
      class tb extends i.ContentObject {
        constructor(e) {
          super(o, "validateApprovalSignatures");
        }
        [i.$finalize]() {
          this[i.$content] = this[i.$content].trim().split(/\s+/).filter(e => ["docReady", "postSign"].includes(e));
        }
      }
      class ty extends i.OptionObject {
        constructor(e) {
          super(o, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
        }
      }
      class tw extends i.OptionObject {
        constructor(e) {
          super(o, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
        }
      }
      class tx extends i.XFAObject {
        constructor(e) {
          super(o, "VersionControl");
          this.outputBelow = n.getStringOption(e.outputBelow, ["warn", "error", "update"]);
          this.sourceAbove = n.getStringOption(e.sourceAbove, ["warn", "error"]);
          this.sourceBelow = n.getStringOption(e.sourceBelow, ["update", "maintain"]);
        }
      }
      class tS extends i.XFAObject {
        constructor(e) {
          super(o, "viewerPreferences", !0);
          this.ADBE_JSConsole = null;
          this.ADBE_JSDebugger = null;
          this.addViewerPreferences = null;
          this.duplexOption = null;
          this.enforce = null;
          this.numberOfCopies = null;
          this.pageRange = null;
          this.pickTrayByPDFSize = null;
          this.printScaling = null;
        }
      }
      class tk extends i.XFAObject {
        constructor(e) {
          super(o, "webClient", !0);
          this.name = e.name ? e.name.trim() : "";
          this.fontInfo = null;
          this.xdc = null;
        }
      }
      class tA extends i.OptionObject {
        constructor(e) {
          super(o, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
        }
      }
      class tv extends i.ContentObject {
        constructor(e) {
          super(o, "window");
        }
        [i.$finalize]() {
          let e = this[i.$content].trim().split(/\s*,\s*/, 2).map(e => parseInt(e, 10));
          if (e.some(e => isNaN(e))) {
            this[i.$content] = [0, 0];
            return;
          }
          1 === e.length && e.push(e[0]);
          this[i.$content] = e;
        }
      }
      class tC extends i.XFAObject {
        constructor(e) {
          super(o, "xdc", !0);
          this.uri = new i.XFAObjectArray();
          this.xsl = new i.XFAObjectArray();
        }
      }
      class tO extends i.XFAObject {
        constructor(e) {
          super(o, "xdp", !0);
          this.packets = null;
        }
      }
      class tF extends i.XFAObject {
        constructor(e) {
          super(o, "xsl", !0);
          this.debug = null;
          this.uri = null;
        }
      }
      class tI extends i.XFAObject {
        constructor(e) {
          super(o, "zpl", !0);
          this.name = e.name ? e.name.trim() : "";
          this.batchOutput = null;
          this.flipLabel = null;
          this.fontInfo = null;
          this.xdc = null;
        }
      }
      class tT {
        static [r.$buildXFAObject](e, t) {
          if (tT.hasOwnProperty(e)) return tT[e](t);
        }
        static acrobat(e) {
          return new l(e);
        }
        static acrobat7(e) {
          return new c(e);
        }
        static ADBE_JSConsole(e) {
          return new h(e);
        }
        static ADBE_JSDebugger(e) {
          return new u(e);
        }
        static addSilentPrint(e) {
          return new d(e);
        }
        static addViewerPreferences(e) {
          return new f(e);
        }
        static adjustData(e) {
          return new g(e);
        }
        static adobeExtensionLevel(e) {
          return new p(e);
        }
        static agent(e) {
          return new m(e);
        }
        static alwaysEmbed(e) {
          return new b(e);
        }
        static amd(e) {
          return new y(e);
        }
        static area(e) {
          return new w(e);
        }
        static attributes(e) {
          return new x(e);
        }
        static autoSave(e) {
          return new S(e);
        }
        static base(e) {
          return new k(e);
        }
        static batchOutput(e) {
          return new A(e);
        }
        static behaviorOverride(e) {
          return new v(e);
        }
        static cache(e) {
          return new C(e);
        }
        static change(e) {
          return new O(e);
        }
        static common(e) {
          return new F(e);
        }
        static compress(e) {
          return new I(e);
        }
        static compressLogicalStructure(e) {
          return new T(e);
        }
        static compressObjectStream(e) {
          return new M(e);
        }
        static compression(e) {
          return new P(e);
        }
        static config(e) {
          return new E(e);
        }
        static conformance(e) {
          return new N(e);
        }
        static contentCopy(e) {
          return new B(e);
        }
        static copies(e) {
          return new D(e);
        }
        static creator(e) {
          return new L(e);
        }
        static currentPage(e) {
          return new R(e);
        }
        static data(e) {
          return new $(e);
        }
        static debug(e) {
          return new j(e);
        }
        static defaultTypeface(e) {
          return new _(e);
        }
        static destination(e) {
          return new U(e);
        }
        static documentAssembly(e) {
          return new X(e);
        }
        static driver(e) {
          return new H(e);
        }
        static duplexOption(e) {
          return new q(e);
        }
        static dynamicRender(e) {
          return new z(e);
        }
        static embed(e) {
          return new G(e);
        }
        static encrypt(e) {
          return new W(e);
        }
        static encryption(e) {
          return new V(e);
        }
        static encryptionLevel(e) {
          return new K(e);
        }
        static enforce(e) {
          return new Y(e);
        }
        static equate(e) {
          return new J(e);
        }
        static equateRange(e) {
          return new Z(e);
        }
        static exclude(e) {
          return new Q(e);
        }
        static excludeNS(e) {
          return new ee(e);
        }
        static flipLabel(e) {
          return new et(e);
        }
        static fontInfo(e) {
          return new ea(e);
        }
        static formFieldFilling(e) {
          return new er(e);
        }
        static groupParent(e) {
          return new ei(e);
        }
        static ifEmpty(e) {
          return new en(e);
        }
        static includeXDPContent(e) {
          return new es(e);
        }
        static incrementalLoad(e) {
          return new eo(e);
        }
        static incrementalMerge(e) {
          return new el(e);
        }
        static interactive(e) {
          return new ec(e);
        }
        static jog(e) {
          return new eh(e);
        }
        static labelPrinter(e) {
          return new eu(e);
        }
        static layout(e) {
          return new ed(e);
        }
        static level(e) {
          return new ef(e);
        }
        static linearized(e) {
          return new eg(e);
        }
        static locale(e) {
          return new ep(e);
        }
        static localeSet(e) {
          return new em(e);
        }
        static log(e) {
          return new eb(e);
        }
        static map(e) {
          return new ey(e);
        }
        static mediumInfo(e) {
          return new ew(e);
        }
        static message(e) {
          return new ex(e);
        }
        static messaging(e) {
          return new eS(e);
        }
        static mode(e) {
          return new ek(e);
        }
        static modifyAnnots(e) {
          return new eA(e);
        }
        static msgId(e) {
          return new ev(e);
        }
        static nameAttr(e) {
          return new eC(e);
        }
        static neverEmbed(e) {
          return new eO(e);
        }
        static numberOfCopies(e) {
          return new eF(e);
        }
        static openAction(e) {
          return new eI(e);
        }
        static output(e) {
          return new eT(e);
        }
        static outputBin(e) {
          return new eM(e);
        }
        static outputXSL(e) {
          return new eP(e);
        }
        static overprint(e) {
          return new eE(e);
        }
        static packets(e) {
          return new eN(e);
        }
        static pageOffset(e) {
          return new eB(e);
        }
        static pageRange(e) {
          return new eD(e);
        }
        static pagination(e) {
          return new eL(e);
        }
        static paginationOverride(e) {
          return new eR(e);
        }
        static part(e) {
          return new e$(e);
        }
        static pcl(e) {
          return new ej(e);
        }
        static pdf(e) {
          return new e_(e);
        }
        static pdfa(e) {
          return new eU(e);
        }
        static permissions(e) {
          return new eX(e);
        }
        static pickTrayByPDFSize(e) {
          return new eH(e);
        }
        static picture(e) {
          return new eq(e);
        }
        static plaintextMetadata(e) {
          return new ez(e);
        }
        static presence(e) {
          return new eG(e);
        }
        static present(e) {
          return new eW(e);
        }
        static print(e) {
          return new eV(e);
        }
        static printHighQuality(e) {
          return new eK(e);
        }
        static printScaling(e) {
          return new eY(e);
        }
        static printerName(e) {
          return new eJ(e);
        }
        static producer(e) {
          return new eZ(e);
        }
        static ps(e) {
          return new eQ(e);
        }
        static range(e) {
          return new e1(e);
        }
        static record(e) {
          return new e0(e);
        }
        static relevant(e) {
          return new e2(e);
        }
        static rename(e) {
          return new e9(e);
        }
        static renderPolicy(e) {
          return new e5(e);
        }
        static runScripts(e) {
          return new e3(e);
        }
        static script(e) {
          return new e6(e);
        }
        static scriptModel(e) {
          return new e7(e);
        }
        static severity(e) {
          return new e8(e);
        }
        static silentPrint(e) {
          return new e4(e);
        }
        static staple(e) {
          return new te(e);
        }
        static startNode(e) {
          return new tt(e);
        }
        static startPage(e) {
          return new ta(e);
        }
        static submitFormat(e) {
          return new tr(e);
        }
        static submitUrl(e) {
          return new ti(e);
        }
        static subsetBelow(e) {
          return new tn(e);
        }
        static suppressBanner(e) {
          return new ts(e);
        }
        static tagged(e) {
          return new to(e);
        }
        static template(e) {
          return new tl(e);
        }
        static templateCache(e) {
          return new tu(e);
        }
        static threshold(e) {
          return new tc(e);
        }
        static to(e) {
          return new th(e);
        }
        static trace(e) {
          return new td(e);
        }
        static transform(e) {
          return new tf(e);
        }
        static type(e) {
          return new tg(e);
        }
        static uri(e) {
          return new tp(e);
        }
        static validate(e) {
          return new tm(e);
        }
        static validateApprovalSignatures(e) {
          return new tb(e);
        }
        static validationMessaging(e) {
          return new ty(e);
        }
        static version(e) {
          return new tw(e);
        }
        static versionControl(e) {
          return new tx(e);
        }
        static viewerPreferences(e) {
          return new tS(e);
        }
        static webClient(e) {
          return new tk(e);
        }
        static whitespace(e) {
          return new tA(e);
        }
        static window(e) {
          return new tv(e);
        }
        static xdc(e) {
          return new tC(e);
        }
        static xdp(e) {
          return new tO(e);
        }
        static xsl(e) {
          return new tF(e);
        }
        static zpl(e) {
          return new tI(e);
        }
      }
      t.ConfigNamespace = tT;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.ConnectionSetNamespace = void 0;
      var r = a(78);
      var i = a(76);
      let n = r.NamespaceIds.connectionSet.id;
      class s extends i.XFAObject {
        constructor(e) {
          super(n, "connectionSet", !0);
          this.wsdlConnection = new i.XFAObjectArray();
          this.xmlConnection = new i.XFAObjectArray();
          this.xsdConnection = new i.XFAObjectArray();
        }
      }
      class o extends i.XFAObject {
        constructor(e) {
          super(n, "effectiveInputPolicy");
          this.id = e.id || "";
          this.name = e.name || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class l extends i.XFAObject {
        constructor(e) {
          super(n, "effectiveOutputPolicy");
          this.id = e.id || "";
          this.name = e.name || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class c extends i.StringObject {
        constructor(e) {
          super(n, "operation");
          this.id = e.id || "";
          this.input = e.input || "";
          this.name = e.name || "";
          this.output = e.output || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class h extends i.StringObject {
        constructor(e) {
          super(n, "rootElement");
          this.id = e.id || "";
          this.name = e.name || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class u extends i.StringObject {
        constructor(e) {
          super(n, "soapAction");
          this.id = e.id || "";
          this.name = e.name || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class d extends i.StringObject {
        constructor(e) {
          super(n, "soapAddress");
          this.id = e.id || "";
          this.name = e.name || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class f extends i.StringObject {
        constructor(e) {
          super(n, "uri");
          this.id = e.id || "";
          this.name = e.name || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class g extends i.StringObject {
        constructor(e) {
          super(n, "wsdlAddress");
          this.id = e.id || "";
          this.name = e.name || "";
          this.use = e.use || "";
          this.usehref = e.usehref || "";
        }
      }
      class p extends i.XFAObject {
        constructor(e) {
          super(n, "wsdlConnection", !0);
          this.dataDescription = e.dataDescription || "";
          this.name = e.name || "";
          this.effectiveInputPolicy = null;
          this.effectiveOutputPolicy = null;
          this.operation = null;
          this.soapAction = null;
          this.soapAddress = null;
          this.wsdlAddress = null;
        }
      }
      class m extends i.XFAObject {
        constructor(e) {
          super(n, "xmlConnection", !0);
          this.dataDescription = e.dataDescription || "";
          this.name = e.name || "";
          this.uri = null;
        }
      }
      class b extends i.XFAObject {
        constructor(e) {
          super(n, "xsdConnection", !0);
          this.dataDescription = e.dataDescription || "";
          this.name = e.name || "";
          this.rootElement = null;
          this.uri = null;
        }
      }
      class y {
        static [r.$buildXFAObject](e, t) {
          if (y.hasOwnProperty(e)) return y[e](t);
        }
        static connectionSet(e) {
          return new s(e);
        }
        static effectiveInputPolicy(e) {
          return new o(e);
        }
        static effectiveOutputPolicy(e) {
          return new l(e);
        }
        static operation(e) {
          return new c(e);
        }
        static rootElement(e) {
          return new h(e);
        }
        static soapAction(e) {
          return new u(e);
        }
        static soapAddress(e) {
          return new d(e);
        }
        static uri(e) {
          return new f(e);
        }
        static wsdlAddress(e) {
          return new g(e);
        }
        static wsdlConnection(e) {
          return new p(e);
        }
        static xmlConnection(e) {
          return new m(e);
        }
        static xsdConnection(e) {
          return new b(e);
        }
      }
      t.ConnectionSetNamespace = y;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.DatasetsNamespace = void 0;
      var r = a(76);
      var i = a(78);
      let n = i.NamespaceIds.datasets.id;
      class s extends r.XmlObject {
        constructor(e) {
          super(n, "data", e);
        }
        [r.$isNsAgnostic]() {
          return !0;
        }
      }
      class o extends r.XFAObject {
        constructor(e) {
          super(n, "datasets", !0);
          this.data = null;
          this.Signature = null;
        }
        [r.$onChild](e) {
          let t = e[r.$nodeName];
          ("data" === t && e[r.$namespaceId] === n || "Signature" === t && e[r.$namespaceId] === i.NamespaceIds.signature.id) && (this[t] = e);
          this[r.$appendChild](e);
        }
      }
      class l {
        static [i.$buildXFAObject](e, t) {
          if (l.hasOwnProperty(e)) return l[e](t);
        }
        static datasets(e) {
          return new o(e);
        }
        static data(e) {
          return new s(e);
        }
      }
      t.DatasetsNamespace = l;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.LocaleSetNamespace = void 0;
      var r = a(78);
      var i = a(76);
      var n = a(77);
      let s = r.NamespaceIds.localeSet.id;
      class o extends i.XFAObject {
        constructor(e) {
          super(s, "calendarSymbols", !0);
          this.name = "gregorian";
          this.dayNames = new i.XFAObjectArray(2);
          this.eraNames = null;
          this.meridiemNames = null;
          this.monthNames = new i.XFAObjectArray(2);
        }
      }
      class l extends i.StringObject {
        constructor(e) {
          super(s, "currencySymbol");
          this.name = n.getStringOption(e.name, ["symbol", "isoname", "decimal"]);
        }
      }
      class c extends i.XFAObject {
        constructor(e) {
          super(s, "currencySymbols", !0);
          this.currencySymbol = new i.XFAObjectArray(3);
        }
      }
      class h extends i.StringObject {
        constructor(e) {
          super(s, "datePattern");
          this.name = n.getStringOption(e.name, ["full", "long", "med", "short"]);
        }
      }
      class u extends i.XFAObject {
        constructor(e) {
          super(s, "datePatterns", !0);
          this.datePattern = new i.XFAObjectArray(4);
        }
      }
      class d extends i.ContentObject {
        constructor(e) {
          super(s, "dateTimeSymbols");
        }
      }
      class f extends i.StringObject {
        constructor(e) {
          super(s, "day");
        }
      }
      class g extends i.XFAObject {
        constructor(e) {
          super(s, "dayNames", !0);
          this.abbr = n.getInteger({
            data: e.abbr,
            defaultValue: 0,
            validate: e => 1 === e
          });
          this.day = new i.XFAObjectArray(7);
        }
      }
      class p extends i.StringObject {
        constructor(e) {
          super(s, "era");
        }
      }
      class m extends i.XFAObject {
        constructor(e) {
          super(s, "eraNames", !0);
          this.era = new i.XFAObjectArray(2);
        }
      }
      class b extends i.XFAObject {
        constructor(e) {
          super(s, "locale", !0);
          this.desc = e.desc || "";
          this.name = "isoname";
          this.calendarSymbols = null;
          this.currencySymbols = null;
          this.datePatterns = null;
          this.dateTimeSymbols = null;
          this.numberPatterns = null;
          this.numberSymbols = null;
          this.timePatterns = null;
          this.typeFaces = null;
        }
      }
      class y extends i.XFAObject {
        constructor(e) {
          super(s, "localeSet", !0);
          this.locale = new i.XFAObjectArray();
        }
      }
      class w extends i.StringObject {
        constructor(e) {
          super(s, "meridiem");
        }
      }
      class x extends i.XFAObject {
        constructor(e) {
          super(s, "meridiemNames", !0);
          this.meridiem = new i.XFAObjectArray(2);
        }
      }
      class S extends i.StringObject {
        constructor(e) {
          super(s, "month");
        }
      }
      class k extends i.XFAObject {
        constructor(e) {
          super(s, "monthNames", !0);
          this.abbr = n.getInteger({
            data: e.abbr,
            defaultValue: 0,
            validate: e => 1 === e
          });
          this.month = new i.XFAObjectArray(12);
        }
      }
      class A extends i.StringObject {
        constructor(e) {
          super(s, "numberPattern");
          this.name = n.getStringOption(e.name, ["full", "long", "med", "short"]);
        }
      }
      class v extends i.XFAObject {
        constructor(e) {
          super(s, "numberPatterns", !0);
          this.numberPattern = new i.XFAObjectArray(4);
        }
      }
      class C extends i.StringObject {
        constructor(e) {
          super(s, "numberSymbol");
          this.name = n.getStringOption(e.name, ["decimal", "grouping", "percent", "minus", "zero"]);
        }
      }
      class O extends i.XFAObject {
        constructor(e) {
          super(s, "numberSymbols", !0);
          this.numberSymbol = new i.XFAObjectArray(5);
        }
      }
      class F extends i.StringObject {
        constructor(e) {
          super(s, "timePattern");
          this.name = n.getStringOption(e.name, ["full", "long", "med", "short"]);
        }
      }
      class I extends i.XFAObject {
        constructor(e) {
          super(s, "timePatterns", !0);
          this.timePattern = new i.XFAObjectArray(4);
        }
      }
      class T extends i.XFAObject {
        constructor(e) {
          super(s, "typeFace", !0);
          this.name = "" | e.name;
        }
      }
      class M extends i.XFAObject {
        constructor(e) {
          super(s, "typeFaces", !0);
          this.typeFace = new i.XFAObjectArray();
        }
      }
      class P {
        static [r.$buildXFAObject](e, t) {
          if (P.hasOwnProperty(e)) return P[e](t);
        }
        static calendarSymbols(e) {
          return new o(e);
        }
        static currencySymbol(e) {
          return new l(e);
        }
        static currencySymbols(e) {
          return new c(e);
        }
        static datePattern(e) {
          return new h(e);
        }
        static datePatterns(e) {
          return new u(e);
        }
        static dateTimeSymbols(e) {
          return new d(e);
        }
        static day(e) {
          return new f(e);
        }
        static dayNames(e) {
          return new g(e);
        }
        static era(e) {
          return new p(e);
        }
        static eraNames(e) {
          return new m(e);
        }
        static locale(e) {
          return new b(e);
        }
        static localeSet(e) {
          return new y(e);
        }
        static meridiem(e) {
          return new w(e);
        }
        static meridiemNames(e) {
          return new x(e);
        }
        static month(e) {
          return new S(e);
        }
        static monthNames(e) {
          return new k(e);
        }
        static numberPattern(e) {
          return new A(e);
        }
        static numberPatterns(e) {
          return new v(e);
        }
        static numberSymbol(e) {
          return new C(e);
        }
        static numberSymbols(e) {
          return new O(e);
        }
        static timePattern(e) {
          return new F(e);
        }
        static timePatterns(e) {
          return new I(e);
        }
        static typeFace(e) {
          return new T(e);
        }
        static typeFaces(e) {
          return new M(e);
        }
      }
      t.LocaleSetNamespace = P;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.SignatureNamespace = void 0;
      var r = a(78);
      var i = a(76);
      let n = r.NamespaceIds.signature.id;
      class s extends i.XFAObject {
        constructor(e) {
          super(n, "signature", !0);
        }
      }
      class o {
        static [r.$buildXFAObject](e, t) {
          if (o.hasOwnProperty(e)) return o[e](t);
        }
        static signature(e) {
          return new s(e);
        }
      }
      t.SignatureNamespace = o;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.StylesheetNamespace = void 0;
      var r = a(78);
      var i = a(76);
      let n = r.NamespaceIds.stylesheet.id;
      class s extends i.XFAObject {
        constructor(e) {
          super(n, "stylesheet", !0);
        }
      }
      class o {
        static [r.$buildXFAObject](e, t) {
          if (o.hasOwnProperty(e)) return o[e](t);
        }
        static stylesheet(e) {
          return new s(e);
        }
      }
      t.StylesheetNamespace = o;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.XdpNamespace = void 0;
      var r = a(78);
      var i = a(76);
      let n = r.NamespaceIds.xdp.id;
      class s extends i.XFAObject {
        constructor(e) {
          super(n, "xdp", !0);
          this.uuid = e.uuid || "";
          this.timeStamp = e.timeStamp || "";
          this.config = null;
          this.connectionSet = null;
          this.datasets = null;
          this.localeSet = null;
          this.stylesheet = new i.XFAObjectArray();
          this.template = null;
        }
        [i.$onChildCheck](e) {
          let t = r.NamespaceIds[e[i.$nodeName]];
          return t && e[i.$namespaceId] === t.id;
        }
      }
      class o {
        static [r.$buildXFAObject](e, t) {
          if (o.hasOwnProperty(e)) return o[e](t);
        }
        static xdp(e) {
          return new s(e);
        }
      }
      t.XdpNamespace = o;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.XhtmlNamespace = void 0;
      var r = a(76);
      var i = a(78);
      var n = a(83);
      var s = a(77);
      let o = i.NamespaceIds.xhtml.id;
      let l = Symbol();
      let c = new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]);
      let h = new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", e => "none" === e ? "none" : "normal"], ["xfa-font-horizontal-scale", e => `scaleX(${Math.max(0, Math.min(parseInt(e) / 100)).toFixed(2)})`], ["xfa-font-vertical-scale", e => `scaleY(${Math.max(0, Math.min(parseInt(e) / 100)).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", (e, t) => (e = t.fontSize = s.getMeasurement(e), n.measureToString(.99 * e))], ["letter-spacing", e => n.measureToString(s.getMeasurement(e))], ["line-height", e => n.measureToString(s.getMeasurement(e))], ["margin", e => n.measureToString(s.getMeasurement(e))], ["margin-bottom", e => n.measureToString(s.getMeasurement(e))], ["margin-left", e => n.measureToString(s.getMeasurement(e))], ["margin-right", e => n.measureToString(s.getMeasurement(e))], ["margin-top", e => n.measureToString(s.getMeasurement(e))], ["text-indent", e => n.measureToString(s.getMeasurement(e))], ["font-family", e => e], ["vertical-align", e => n.measureToString(s.getMeasurement(e))]]);
      let u = /\s+/g;
      let d = /[\r\n]+/g;
      let f = /\r\n?/g;
      let g = new Set(["body", "html"]);
      class p extends r.XmlObject {
        constructor(e, t) {
          super(o, t);
          this[l] = !1;
          this.style = e.style || "";
        }
        [r.$clean](e) {
          var t;
          super[r.$clean](e);
          this.style = (t = this, t.style ? t.style.trim().split(/\s*;\s*/).filter(e => !!e).map(e => e.split(/\s*:\s*/, 2)).filter(([e, a]) => ("font-family" === e && t[r.$globalData].usedTypefaces.add(a), c.has(e))).map(e => e.join(":")).join(";") : "");
        }
        [r.$acceptWhitespace]() {
          return !g.has(this[r.$nodeName]);
        }
        [r.$onText](e, t = !1) {
          t ? this[l] = !0 : (e = e.replace(d, ""), this.style.includes("xfa-spacerun:yes") || (e = e.replace(u, " ")));
          e && (this[r.$content] += e);
        }
        [r.$pushGlyphs](e, t = !0) {
          let a = Object.create(null);
          let i = {
            top: NaN,
            bottom: NaN,
            left: NaN,
            right: NaN
          };
          let n = null;
          for (let [e, t] of this.style.split(";").map(e => e.split(":", 2))) switch (e) {
            case "font-family":
              a.typeface = s.stripQuotes(t);
              break;
            case "font-size":
              a.size = s.getMeasurement(t);
              break;
            case "font-weight":
              a.weight = t;
              break;
            case "font-style":
              a.posture = t;
              break;
            case "letter-spacing":
              a.letterSpacing = s.getMeasurement(t);
              break;
            case "margin":
              let r = t.split(/ \t/).map(e => s.getMeasurement(e));
              switch (r.length) {
                case 1:
                  i.top = i.bottom = i.left = i.right = r[0];
                  break;
                case 2:
                  i.top = i.bottom = r[0];
                  i.left = i.right = r[1];
                  break;
                case 3:
                  i.top = r[0];
                  i.bottom = r[2];
                  i.left = i.right = r[1];
                  break;
                case 4:
                  i.top = r[0];
                  i.left = r[1];
                  i.bottom = r[2];
                  i.right = r[3];
              }
              break;
            case "margin-top":
              i.top = s.getMeasurement(t);
              break;
            case "margin-bottom":
              i.bottom = s.getMeasurement(t);
              break;
            case "margin-left":
              i.left = s.getMeasurement(t);
              break;
            case "margin-right":
              i.right = s.getMeasurement(t);
              break;
            case "line-height":
              n = s.getMeasurement(t);
          }
          if (e.pushData(a, i, n), this[r.$content]) e.addString(this[r.$content]); else for (let t of this[r.$getChildren]()) {
            if ("#text" === t[r.$nodeName]) {
              e.addString(t[r.$content]);
              continue;
            }
            t[r.$pushGlyphs](e);
          }
          t && e.popFont();
        }
        [r.$toHTML](e) {
          let t;
          let a = [];
          return (this[r.$extra] = {
            children: a
          }, this[r.$childrenToHTML]({}), 0 !== a.length || this[r.$content]) ? (t = this[l] ? this[r.$content] ? this[r.$content].replace(f, "\n") : void 0 : this[r.$content] || void 0, s.HTMLResult.success({
            name: this[r.$nodeName],
            attributes: {
              href: this.href,
              style: function (e, t, a) {
                let i = Object.create(null);
                if (!e) return i;
                let o = Object.create(null);
                for (let [t, a] of e.split(";").map(e => e.split(":", 2))) {
                  let e = h.get(t);
                  if ("" === e) continue;
                  let r = a;
                  e && (r = "string" == typeof e ? e : e(a, o));
                  t.endsWith("scale") ? i.transform ? i.transform = `${i[t]} ${r}` : i.transform = r : i[t.replaceAll(/-([a-zA-Z])/g, (e, t) => t.toUpperCase())] = r;
                }
                if (i.fontFamily && n.setFontFamily({
                  typeface: i.fontFamily,
                  weight: i.fontWeight || "normal",
                  posture: i.fontStyle || "normal",
                  size: o.fontSize || 0
                }, t, t[r.$globalData].fontFinder, i), a && i.verticalAlign && "0px" !== i.verticalAlign && i.fontSize) {
                  let e = s.getMeasurement(i.fontSize);
                  i.fontSize = n.measureToString(.583 * e);
                  i.verticalAlign = n.measureToString(Math.sign(s.getMeasurement(i.verticalAlign)) * e * .333);
                }
                n.fixTextIndent(i);
                return i;
              }(this.style, this, this[l])
            },
            children: a,
            value: t
          })) : s.HTMLResult.EMPTY;
        }
      }
      class m extends p {
        constructor(e) {
          super(e, "a");
          this.href = n.fixURL(e.href) || "";
        }
      }
      class b extends p {
        constructor(e) {
          super(e, "b");
        }
        [r.$pushGlyphs](e) {
          e.pushFont({
            weight: "bold"
          });
          super[r.$pushGlyphs](e);
          e.popFont();
        }
      }
      class y extends p {
        constructor(e) {
          super(e, "body");
        }
        [r.$toHTML](e) {
          let t = super[r.$toHTML](e);
          let {
            html
          } = t;
          return html ? (html.name = "div", html.attributes.$$class = ["xfaRich"], t) : s.HTMLResult.EMPTY;
        }
      }
      class w extends p {
        constructor(e) {
          super(e, "br");
        }
        [r.$text]() {
          return "\n";
        }
        [r.$pushGlyphs](e) {
          e.addString("\n");
        }
        [r.$toHTML](e) {
          return s.HTMLResult.success({
            name: "br"
          });
        }
      }
      class x extends p {
        constructor(e) {
          super(e, "html");
        }
        [r.$toHTML](e) {
          let t = [];
          if (this[r.$extra] = {
            children: t
          }, this[r.$childrenToHTML]({}), 0 === t.length) return s.HTMLResult.success({
            name: "div",
            attributes: {
              class: ["xfaRich"],
              style: {}
            },
            value: this[r.$content] || ""
          });
          if (1 === t.length) {
            let e = t[0];
            if (e.attributes && e.attributes.$$class.includes("xfaRich")) return s.HTMLResult.success(e);
          }
          return s.HTMLResult.success({
            name: "div",
            attributes: {
              class: ["xfaRich"],
              style: {}
            },
            children: t
          });
        }
      }
      class S extends p {
        constructor(e) {
          super(e, "i");
        }
        [r.$pushGlyphs](e) {
          e.pushFont({
            posture: "italic"
          });
          super[r.$pushGlyphs](e);
          e.popFont();
        }
      }
      class k extends p {
        constructor(e) {
          super(e, "li");
        }
      }
      class A extends p {
        constructor(e) {
          super(e, "ol");
        }
      }
      class v extends p {
        constructor(e) {
          super(e, "p");
        }
        [r.$pushGlyphs](e) {
          super[r.$pushGlyphs](e, !1);
          e.addString("\n");
          e.addPara();
          e.popFont();
        }
        [r.$text]() {
          let e = this[r.$getParent]()[r.$getChildren]();
          return e[e.length - 1] === this ? super[r.$text]() : super[r.$text]() + "\n";
        }
      }
      class C extends p {
        constructor(e) {
          super(e, "span");
        }
      }
      class O extends p {
        constructor(e) {
          super(e, "sub");
        }
      }
      class F extends p {
        constructor(e) {
          super(e, "sup");
        }
      }
      class I extends p {
        constructor(e) {
          super(e, "ul");
        }
      }
      class T {
        static [i.$buildXFAObject](e, t) {
          if (T.hasOwnProperty(e)) return T[e](t);
        }
        static a(e) {
          return new m(e);
        }
        static b(e) {
          return new b(e);
        }
        static body(e) {
          return new y(e);
        }
        static br(e) {
          return new w(e);
        }
        static html(e) {
          return new x(e);
        }
        static i(e) {
          return new S(e);
        }
        static li(e) {
          return new k(e);
        }
        static ol(e) {
          return new A(e);
        }
        static p(e) {
          return new v(e);
        }
        static span(e) {
          return new C(e);
        }
        static sub(e) {
          return new O(e);
        }
        static sup(e) {
          return new F(e);
        }
        static ul(e) {
          return new I(e);
        }
      }
      t.XhtmlNamespace = T;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.UnknownNamespace = void 0;
      var r = a(78);
      var i = a(76);
      class n {
        constructor(e) {
          this.namespaceId = e;
        }
        [r.$buildXFAObject](e, t) {
          return new i.XmlObject(this.namespaceId, e, t);
        }
      }
      t.UnknownNamespace = n;
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.XRef = void 0;
      var r = a(2);
      var i = a(5);
      var n = a(8);
      var s = a(27);
      var o = a(9);
      var l = a(73);
      t.XRef = class {
        constructor(e, t) {
          this.stream = e;
          this.pdfManager = t;
          this.entries = [];
          this.xrefstms = Object.create(null);
          this._cacheMap = new Map();
          this._pendingRefs = new i.RefSet();
          this.stats = new n.DocStats(t.msgHandler);
          this._newRefNum = null;
        }
        getNewRef() {
          null === this._newRefNum && (this._newRefNum = this.entries.length);
          return i.Ref.get(this._newRefNum++, 0);
        }
        resetNewRef() {
          this._newRefNum = null;
        }
        setStartXRef(e) {
          this.startXRefQueue = [e];
        }
        parse(e = !1) {
          let t;
          let a;
          let s;
          e ? (r.warn("Indexing all PDF objects"), t = this.indexObjects()) : t = this.readXRef();
          t.assignXref(this);
          this.trailer = t;
          try {
            a = t.get("Encrypt");
          } catch (e) {
            if (e instanceof n.MissingDataException) throw e;
            r.warn(`XRef.parse - Invalid "Encrypt" reference: "${e}".`);
          }
          if (a instanceof i.Dict) {
            let e = t.get("ID");
            let r = e && e.length ? e[0] : "";
            a.suppressEncryption = !0;
            this.encrypt = new l.CipherTransformFactory(a, r, this.pdfManager.password);
          }
          try {
            s = t.get("Root");
          } catch (e) {
            if (e instanceof n.MissingDataException) throw e;
            r.warn(`XRef.parse - Invalid "Root" reference: "${e}".`);
          }
          if (s instanceof i.Dict) try {
            if (s.get("Pages") instanceof i.Dict) {
              this.root = s;
              return;
            }
          } catch (e) {
            if (e instanceof n.MissingDataException) throw e;
            r.warn(`XRef.parse - Invalid "Pages" reference: "${e}".`);
          }
          if (!e) throw new n.XRefParseException();
          throw new r.InvalidPDFException("Invalid Root reference.");
        }
        processXRefTable(e) {
          "tableState" in this || (this.tableState = {
            entryNum: 0,
            streamPos: e.lexer.stream.pos,
            parserBuf1: e.buf1,
            parserBuf2: e.buf2
          });
          let t = this.readXRefTable(e);
          if (!i.isCmd(t, "trailer")) throw new r.FormatError("Invalid XRef table: could not find trailer dictionary");
          let a = e.getObj();
          if (a instanceof i.Dict || !a.dict || (a = a.dict), !(a instanceof i.Dict)) throw new r.FormatError("Invalid XRef table: could not parse trailer dictionary");
          delete this.tableState;
          return a;
        }
        readXRefTable(e) {
          let t;
          let a = e.lexer.stream;
          let n = this.tableState;
          for (a.pos = n.streamPos, e.buf1 = n.parserBuf1, e.buf2 = n.parserBuf2; ;) {
            if (!("firstEntryNum" in n) || !("entryCount" in n)) {
              if (i.isCmd(t = e.getObj(), "trailer")) break;
              n.firstEntryNum = t;
              n.entryCount = e.getObj();
            }
            let s = n.firstEntryNum;
            let o = n.entryCount;
            if (!Number.isInteger(s) || !Number.isInteger(o)) throw new r.FormatError("Invalid XRef table: wrong types in subsection header");
            for (let t = n.entryNum; t < o; t++) {
              n.streamPos = a.pos;
              n.entryNum = t;
              n.parserBuf1 = e.buf1;
              n.parserBuf2 = e.buf2;
              let l = {};
              l.offset = e.getObj();
              l.gen = e.getObj();
              let c = e.getObj();
              if (c instanceof i.Cmd) switch (c.cmd) {
                case "f":
                  l.free = !0;
                  break;
                case "n":
                  l.uncompressed = !0;
              }
              if (!Number.isInteger(l.offset) || !Number.isInteger(l.gen) || !(l.free || l.uncompressed)) throw new r.FormatError(`Invalid entry in XRef subsection: ${s}, ${o}`);
              0 === t && l.free && 1 === s && (s = 0);
              this.entries[t + s] || (this.entries[t + s] = l);
            }
            n.entryNum = 0;
            n.streamPos = a.pos;
            n.parserBuf1 = e.buf1;
            n.parserBuf2 = e.buf2;
            delete n.firstEntryNum;
            delete n.entryCount;
          }
          if (this.entries[0] && !this.entries[0].free) throw new r.FormatError("Invalid XRef table: unexpected first object");
          return t;
        }
        processXRefStream(e) {
          if (!("streamState" in this)) {
            let t = e.dict;
            let a = t.get("W");
            let r = t.get("Index");
            r || (r = [0, t.get("Size")]);
            this.streamState = {
              entryRanges: r,
              byteWidths: a,
              entryNum: 0,
              streamPos: e.pos
            };
          }
          this.readXRefStream(e);
          delete this.streamState;
          return e.dict;
        }
        readXRefStream(e) {
          let t = this.streamState;
          e.pos = t.streamPos;
          let [a, i, n] = t.byteWidths;
          let s = t.entryRanges;
          for (; s.length > 0;) {
            let [o, l] = s;
            if (!Number.isInteger(o) || !Number.isInteger(l)) throw new r.FormatError(`Invalid XRef range fields: ${o}, ${l}`);
            if (!Number.isInteger(a) || !Number.isInteger(i) || !Number.isInteger(n)) throw new r.FormatError(`Invalid XRef entry fields length: ${o}, ${l}`);
            for (let s = t.entryNum; s < l; ++s) {
              t.entryNum = s;
              t.streamPos = e.pos;
              let l = 0;
              let c = 0;
              let h = 0;
              for (let t = 0; t < a; ++t) {
                let t = e.getByte();
                if (-1 === t) throw new r.FormatError("Invalid XRef byteWidths 'type'.");
                l = l << 8 | t;
              }
              0 === a && (l = 1);
              for (let t = 0; t < i; ++t) {
                let t = e.getByte();
                if (-1 === t) throw new r.FormatError("Invalid XRef byteWidths 'offset'.");
                c = c << 8 | t;
              }
              for (let t = 0; t < n; ++t) {
                let t = e.getByte();
                if (-1 === t) throw new r.FormatError("Invalid XRef byteWidths 'generation'.");
                h = h << 8 | t;
              }
              let u = {};
              switch (u.offset = c, u.gen = h, l) {
                case 0:
                  u.free = !0;
                  break;
                case 1:
                  u.uncompressed = !0;
                  break;
                case 2:
                  break;
                default:
                  throw new r.FormatError(`Invalid XRef entry type: ${l}`);
              }
              this.entries[o + s] || (this.entries[o + s] = u);
            }
            t.entryNum = 0;
            t.streamPos = e.pos;
            s.splice(0, 2);
          }
        }
        indexObjects() {
          let e;
          function t(e, t, a) {
            let r = a.length;
            let i = e.length;
            let n = 0;
            for (; t < i;) {
              let i = 0;
              for (; i < r && e[t + i] === a[i];) ++i;
              if (i >= r) break;
              t++;
              n++;
            }
            return n;
          }
          let a = /^(\d+)\s+(\d+)\s+obj\b/;
          let o = /\bendobj[\b\s]$/;
          let l = /\s+(\d+\s+\d+\s+obj[\b\s<])$/;
          let c = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);
          let h = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
          let u = new Uint8Array([111, 98, 106]);
          let d = new Uint8Array([47, 88, 82, 101, 102]);
          this.entries.length = 0;
          this._cacheMap.clear();
          let f = this.stream;
          f.pos = 0;
          let g = f.getBytes();
          let p = g.length;
          let m = f.start;
          let b = [];
          let y = [];
          for (; m < p;) {
            let e;
            let i = g[m];
            if (9 === i || 10 === i || 13 === i || 32 === i) {
              ++m;
              continue;
            }
            if (37 === i) {
              do {
                if (++m >= p) break;
                i = g[m];
              } while (10 !== i && 13 !== i);
              continue;
            }
            let w = function (e, t) {
              let a = "";
              let r = e[t];
              for (; 10 !== r && 13 !== r && 60 !== r && !(++t >= e.length);) {
                a += String.fromCharCode(r);
                r = e[t];
              }
              return a;
            }(g, m);
            if (w.startsWith("xref") && (4 === w.length || /\s/.test(w[4]))) {
              m += t(g, m, c);
              b.push(m);
              m += t(g, m, h);
            } else if (e = a.exec(w)) {
              let a = 0 | e[1];
              let i = 0 | e[2];
              let c;
              let h = m + w.length;
              let p = !1;
              if (this.entries[a]) {
                if (this.entries[a].gen === i) try {
                  new s.Parser({
                    lexer: new s.Lexer(f.makeSubStream(h))
                  }).getObj();
                  p = !0;
                } catch (e) {
                  e instanceof n.ParserEOFException ? r.warn(`indexObjects -- checking object (${w}): "${e}".`) : p = !0;
                }
              } else p = !0;
              for (p && (this.entries[a] = {
                offset: m - f.start,
                gen: i,
                uncompressed: !0
              }); h < g.length;) {
                let e = h + t(g, h, u) + 4;
                c = e - m;
                let a = Math.max(e - 25, h);
                let i = r.bytesToString(g.subarray(a, e));
                if (o.test(i)) break;
                {
                  let e = l.exec(i);
                  if (e && e[1]) {
                    r.warn('indexObjects: Found new "obj" inside of another "obj", caused by missing "endobj" -- trying to recover.');
                    c -= e[1].length;
                    break;
                  }
                }
                h = e;
              }
              let b = g.subarray(m, m + c);
              let x = t(b, 0, d);
              x < c && b[x + 5] < 64 && (y.push(m - f.start), this.xrefstms[m - f.start] = 1);
              m += c;
            } else w.startsWith("trailer") && (7 === w.length || /\s/.test(w[7])) ? (b.push(m), m += t(g, m, h)) : m += w.length + 1;
          }
          for (function () {
            let e = 0;
            let t = y.length;
          }(); e < t; ++e) {
            this.startXRefQueue.push(y[e]);
            this.readXRef(!0);
          }
          for (function () {
            let t = 0;
            let a = b.length;
          }(); t < a; ++t) {
            f.pos = b[t];
            let a = new s.Parser({
              lexer: new s.Lexer(f),
              xref: this,
              allowStreams: !0,
              recoveryMode: !0
            });
            let r = a.getObj();
            if (!i.isCmd(r, "trailer")) continue;
            let n = a.getObj();
            if (n instanceof i.Dict) {
              try {
                let e = n.get("Root");
                if (!(e instanceof i.Dict)) continue;
                let t = e.get("Pages");
                if (!(t instanceof i.Dict)) continue;
                let a = t.get("Count");
                if (!Number.isInteger(a)) continue;
              } catch (e) {
                continue;
              }
              if (n.has("ID")) return n;
              e = n;
            }
          }
          if (e) return e;
          if (this.topDict) return this.topDict;
          throw new r.InvalidPDFException("Invalid PDF structure.");
        }
        readXRef(e = !1) {
          let t = this.stream;
          let a = new Set();
          try {
            for (; this.startXRefQueue.length;) {
              let e;
              let n = this.startXRefQueue[0];
              if (a.has(n)) {
                r.warn("readXRef - skipping XRef table since it was already parsed.");
                this.startXRefQueue.shift();
                continue;
              }
              a.add(n);
              t.pos = n + t.start;
              let l = new s.Parser({
                lexer: new s.Lexer(t),
                xref: this,
                allowStreams: !0
              });
              let c = l.getObj();
              if (i.isCmd(c, "xref")) {
                if (e = this.processXRefTable(l), this.topDict || (this.topDict = e), c = e.get("XRefStm"), Number.isInteger(c)) {
                  let e = c;
                  e in this.xrefstms || (this.xrefstms[e] = 1, this.startXRefQueue.push(e));
                }
              } else if (Number.isInteger(c)) {
                if (!Number.isInteger(l.getObj()) || !i.isCmd(l.getObj(), "obj") || !((c = l.getObj()) instanceof o.BaseStream)) throw new r.FormatError("Invalid XRef stream");
                if (e = this.processXRefStream(c), this.topDict || (this.topDict = e), !e) throw new r.FormatError("Failed to read XRef stream");
              } else throw new r.FormatError("Invalid XRef stream header");
              c = e.get("Prev");
              Number.isInteger(c) ? this.startXRefQueue.push(c) : c instanceof i.Ref && this.startXRefQueue.push(c.num);
              this.startXRefQueue.shift();
            }
            return this.topDict;
          } catch (e) {
            if (e instanceof n.MissingDataException) throw e;
            r.info("(while reading XRef): " + e);
            this.startXRefQueue.shift();
          }
          if (!e) throw new n.XRefParseException();
        }
        getEntry(e) {
          let t = this.entries[e];
          return t && !t.free && t.offset ? t : null;
        }
        fetchIfRef(e, t = !1) {
          return e instanceof i.Ref ? this.fetch(e, t) : e;
        }
        fetch(e, t = !1) {
          if (!(e instanceof i.Ref)) throw Error("ref object is not a reference");
          let a = e.num;
          let n = this._cacheMap.get(a);
          if (void 0 !== n) {
            n instanceof i.Dict && !n.objId && (n.objId = e.toString());
            return n;
          }
          let s = this.getEntry(a);
          if (null === s) {
            this._cacheMap.set(a, s);
            return s;
          }
          if (this._pendingRefs.has(e)) {
            this._pendingRefs.remove(e);
            r.warn(`Ignoring circular reference: ${e}.`);
            return i.CIRCULAR_REF;
          }
          this._pendingRefs.put(e);
          try {
            s = s.uncompressed ? this.fetchUncompressed(e, s, t) : this.fetchCompressed(e, s, t);
            this._pendingRefs.remove(e);
          } catch (t) {
            this._pendingRefs.remove(e);
            return t;
          }
          s instanceof i.Dict ? s.objId = e.toString() : s instanceof o.BaseStream && (s.dict.objId = e.toString());
          return s;
        }
        fetchUncompressed(e, t, a = !1) {
          let r = e.gen;
          let l = e.num;
          if (t.gen !== r) throw new n.XRefEntryException(`Inconsistent generation in XRef: ${e}`);
          let c = this.stream.makeSubStream(t.offset + this.stream.start);
          let h = new s.Parser({
            lexer: new s.Lexer(c),
            xref: this,
            allowStreams: !0
          });
          let u = h.getObj();
          let d = h.getObj();
          let f = h.getObj();
          if (u !== l || d !== r || !(f instanceof i.Cmd)) throw new n.XRefEntryException(`Bad (uncompressed) XRef entry: ${e}`);
          if ("obj" !== f.cmd) {
            if (f.cmd.startsWith("obj") && !Number.isNaN(l = parseInt(f.cmd.substring(3), 10))) return l;
            throw new n.XRefEntryException(`Bad (uncompressed) XRef entry: ${e}`);
          }
          (t = this.encrypt && !a ? h.getObj(this.encrypt.createCipherTransform(l, r)) : h.getObj()) instanceof o.BaseStream || this._cacheMap.set(l, t);
          return t;
        }
        fetchCompressed(e, t, a = !1) {
          let l = t.offset;
          let c = this.fetch(i.Ref.get(l, 0));
          if (!(c instanceof o.BaseStream)) throw new r.FormatError("bad ObjStm stream");
          let h = c.dict.get("First");
          let u = c.dict.get("N");
          if (!Number.isInteger(h) || !Number.isInteger(u)) throw new r.FormatError("invalid first and n parameters for ObjStm stream");
          let d = new s.Parser({
            lexer: new s.Lexer(c),
            xref: this,
            allowStreams: !0
          });
          let f = Array(u);
          let g = Array(u);
          for (let e = 0; e < u; ++e) {
            let t = d.getObj();
            if (!Number.isInteger(t)) throw new r.FormatError(`invalid object number in the ObjStm stream: ${t}`);
            let a = d.getObj();
            if (!Number.isInteger(a)) throw new r.FormatError(`invalid object offset in the ObjStm stream: ${a}`);
            f[e] = t;
            g[e] = a;
          }
          let p = (c.start || 0) + h;
          let m = Array(u);
          for (let e = 0; e < u; ++e) {
            let t = e < u - 1 ? g[e + 1] - g[e] : void 0;
            if (t < 0) throw new r.FormatError("Invalid offset in the ObjStm stream.");
            let a = (d = new s.Parser({
              lexer: new s.Lexer(c.makeSubStream(p + g[e], t, c.dict)),
              xref: this,
              allowStreams: !0
            })).getObj();
            if (m[e] = a, a instanceof o.BaseStream) continue;
            let i = f[e];
            let n = this.entries[i];
            n && n.offset === l && n.gen === e && this._cacheMap.set(i, a);
          }
          if (void 0 === (t = m[t.gen])) throw new n.XRefEntryException(`Bad (compressed) XRef entry: ${e}`);
          return t;
        }
        async fetchIfRefAsync(e, t) {
          return e instanceof i.Ref ? this.fetchAsync(e, t) : e;
        }
        async fetchAsync(e, t) {
          try {
            return this.fetch(e, t);
          } catch (a) {
            if (!(a instanceof n.MissingDataException)) throw a;
            await this.pdfManager.requestRange(a.begin, a.end);
            return this.fetchAsync(e, t);
          }
        }
        getCatalogObj() {
          return this.root;
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.MessageHandler = void 0;
      var r = a(2);
      let i = {
        DATA: 1,
        ERROR: 2
      };
      let n = {
        CANCEL: 1,
        CANCEL_COMPLETE: 2,
        CLOSE: 3,
        ENQUEUE: 4,
        ERROR: 5,
        PULL: 6,
        PULL_COMPLETE: 7,
        START_COMPLETE: 8
      };
      function s(e) {
        switch (e instanceof Error || "object" == typeof e && null !== e || r.unreachable('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), e.name) {
          case "AbortException":
            return new r.AbortException(e.message);
          case "MissingPDFException":
            return new r.MissingPDFException(e.message);
          case "PasswordException":
            return new r.PasswordException(e.message, e.code);
          case "UnexpectedResponseException":
            return new r.UnexpectedResponseException(e.message, e.status);
          case "UnknownErrorException":
            return new r.UnknownErrorException(e.message, e.details);
          default:
            return new r.UnknownErrorException(e.message, e.toString());
        }
      }
      t.MessageHandler = class {
        constructor(e, t, a) {
          this.sourceName = e;
          this.targetName = t;
          this.comObj = a;
          this.callbackId = 1;
          this.streamId = 1;
          this.streamSinks = Object.create(null);
          this.streamControllers = Object.create(null);
          this.callbackCapabilities = Object.create(null);
          this.actionHandler = Object.create(null);
          this._onComObjOnMessage = e => {
            let t = e.data;
            if (t.targetName !== this.sourceName) return;
            if (t.stream) {
              this._processStreamMessage(t);
              return;
            }
            if (t.callback) {
              let e = t.callbackId;
              let a = this.callbackCapabilities[e];
              if (!a) throw Error(`Cannot resolve callback ${e}`);
              if (delete this.callbackCapabilities[e], t.callback === i.DATA) a.resolve(t.data); else if (t.callback === i.ERROR) a.reject(s(t.reason)); else throw Error("Unexpected callback case");
              return;
            }
            let r = this.actionHandler[t.action];
            if (!r) throw Error(`Unknown action from worker: ${t.action}`);
            if (t.callbackId) {
              let e = this.sourceName;
              let n = t.sourceName;
              new Promise(function (e) {
                e(r(t.data));
              }).then(function (r) {
                a.postMessage({
                  sourceName: e,
                  targetName: n,
                  callback: i.DATA,
                  callbackId: t.callbackId,
                  data: r
                });
              }, function (r) {
                a.postMessage({
                  sourceName: e,
                  targetName: n,
                  callback: i.ERROR,
                  callbackId: t.callbackId,
                  reason: s(r)
                });
              });
              return;
            }
            if (t.streamId) {
              this._createStreamSink(t);
              return;
            }
            r(t.data);
          };
          a.addEventListener("message", this._onComObjOnMessage);
        }
        on(e, t) {
          let a = this.actionHandler;
          if (a[e]) throw Error(`There is already an actionName called "${e}"`);
          a[e] = t;
        }
        send(e, t, a) {
          this.comObj.postMessage({
            sourceName: this.sourceName,
            targetName: this.targetName,
            action: e,
            data: t
          }, a);
        }
        sendWithPromise(e, t, a) {
          let i = this.callbackId++;
          let n = r.createPromiseCapability();
          this.callbackCapabilities[i] = n;
          try {
            this.comObj.postMessage({
              sourceName: this.sourceName,
              targetName: this.targetName,
              action: e,
              callbackId: i,
              data: t
            }, a);
          } catch (e) {
            n.reject(e);
          }
          return n.promise;
        }
        sendWithStream(e, t, a, i) {
          let o = this.streamId++;
          let l = this.sourceName;
          let c = this.targetName;
          let h = this.comObj;
          return new ReadableStream({
            start: a => {
              let n = r.createPromiseCapability();
              this.streamControllers[o] = {
                controller: a,
                startCall: n,
                pullCall: null,
                cancelCall: null,
                isClosed: !1
              };
              h.postMessage({
                sourceName: l,
                targetName: c,
                action: e,
                streamId: o,
                data: t,
                desiredSize: a.desiredSize
              }, i);
              return n.promise;
            },
            pull: e => {
              let t = r.createPromiseCapability();
              this.streamControllers[o].pullCall = t;
              h.postMessage({
                sourceName: l,
                targetName: c,
                stream: n.PULL,
                streamId: o,
                desiredSize: e.desiredSize
              });
              return t.promise;
            },
            cancel: e => {
              r.assert(e instanceof Error, "cancel must have a valid reason");
              let t = r.createPromiseCapability();
              this.streamControllers[o].cancelCall = t;
              this.streamControllers[o].isClosed = !0;
              h.postMessage({
                sourceName: l,
                targetName: c,
                stream: n.CANCEL,
                streamId: o,
                reason: s(e)
              });
              return t.promise;
            }
          }, a);
        }
        _createStreamSink(e) {
          let t = e.streamId;
          let a = this.sourceName;
          let i = e.sourceName;
          let o = this.comObj;
          let l = this;
          let c = this.actionHandler[e.action];
          let h = {
            enqueue(e, s = 1, l) {
              if (this.isCancelled) return;
              let c = this.desiredSize;
              this.desiredSize -= s;
              c > 0 && this.desiredSize <= 0 && (this.sinkCapability = r.createPromiseCapability(), this.ready = this.sinkCapability.promise);
              o.postMessage({
                sourceName: a,
                targetName: i,
                stream: n.ENQUEUE,
                streamId: t,
                chunk: e
              }, l);
            },
            close() {
              this.isCancelled || (this.isCancelled = !0, o.postMessage({
                sourceName: a,
                targetName: i,
                stream: n.CLOSE,
                streamId: t
              }), delete l.streamSinks[t]);
            },
            error(e) {
              r.assert(e instanceof Error, "error must have a valid reason");
              this.isCancelled || (this.isCancelled = !0, o.postMessage({
                sourceName: a,
                targetName: i,
                stream: n.ERROR,
                streamId: t,
                reason: s(e)
              }));
            },
            sinkCapability: r.createPromiseCapability(),
            onPull: null,
            onCancel: null,
            isCancelled: !1,
            desiredSize: e.desiredSize,
            ready: null
          };
          h.sinkCapability.resolve();
          h.ready = h.sinkCapability.promise;
          this.streamSinks[t] = h;
          new Promise(function (t) {
            t(c(e.data, h));
          }).then(function () {
            o.postMessage({
              sourceName: a,
              targetName: i,
              stream: n.START_COMPLETE,
              streamId: t,
              success: !0
            });
          }, function (e) {
            o.postMessage({
              sourceName: a,
              targetName: i,
              stream: n.START_COMPLETE,
              streamId: t,
              reason: s(e)
            });
          });
        }
        _processStreamMessage(e) {
          let t = e.streamId;
          let a = this.sourceName;
          let i = e.sourceName;
          let o = this.comObj;
          let l = this.streamControllers[t];
          let c = this.streamSinks[t];
          switch (e.stream) {
            case n.START_COMPLETE:
              e.success ? l.startCall.resolve() : l.startCall.reject(s(e.reason));
              break;
            case n.PULL_COMPLETE:
              e.success ? l.pullCall.resolve() : l.pullCall.reject(s(e.reason));
              break;
            case n.PULL:
              if (!c) {
                o.postMessage({
                  sourceName: a,
                  targetName: i,
                  stream: n.PULL_COMPLETE,
                  streamId: t,
                  success: !0
                });
                break;
              }
              c.desiredSize <= 0 && e.desiredSize > 0 && c.sinkCapability.resolve();
              c.desiredSize = e.desiredSize;
              new Promise(function (e) {
                e(c.onPull && c.onPull());
              }).then(function () {
                o.postMessage({
                  sourceName: a,
                  targetName: i,
                  stream: n.PULL_COMPLETE,
                  streamId: t,
                  success: !0
                });
              }, function (e) {
                o.postMessage({
                  sourceName: a,
                  targetName: i,
                  stream: n.PULL_COMPLETE,
                  streamId: t,
                  reason: s(e)
                });
              });
              break;
            case n.ENQUEUE:
              if (r.assert(l, "enqueue should have stream controller"), l.isClosed) break;
              l.controller.enqueue(e.chunk);
              break;
            case n.CLOSE:
              if (r.assert(l, "close should have stream controller"), l.isClosed) break;
              l.isClosed = !0;
              l.controller.close();
              this._deleteStreamController(l, t);
              break;
            case n.ERROR:
              r.assert(l, "error should have stream controller");
              l.controller.error(s(e.reason));
              this._deleteStreamController(l, t);
              break;
            case n.CANCEL_COMPLETE:
              e.success ? l.cancelCall.resolve() : l.cancelCall.reject(s(e.reason));
              this._deleteStreamController(l, t);
              break;
            case n.CANCEL:
              if (!c) break;
              new Promise(function (t) {
                t(c.onCancel && c.onCancel(s(e.reason)));
              }).then(function () {
                o.postMessage({
                  sourceName: a,
                  targetName: i,
                  stream: n.CANCEL_COMPLETE,
                  streamId: t,
                  success: !0
                });
              }, function (e) {
                o.postMessage({
                  sourceName: a,
                  targetName: i,
                  stream: n.CANCEL_COMPLETE,
                  streamId: t,
                  reason: s(e)
                });
              });
              c.sinkCapability.reject(s(e.reason));
              c.isCancelled = !0;
              delete this.streamSinks[t];
              break;
            default:
              throw Error("Unexpected stream case");
          }
        }
        async _deleteStreamController(e, t) {
          await Promise.allSettled([e.startCall && e.startCall.promise, e.pullCall && e.pullCall.promise, e.cancelCall && e.cancelCall.promise]);
          delete this.streamControllers[t];
        }
        destroy() {
          this.comObj.removeEventListener("message", this._onComObjOnMessage);
        }
      };
    }, (e, t, a) => {
      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      t.PDFWorkerStream = void 0;
      var r = a(2);
      t.PDFWorkerStream = class {
        constructor(e) {
          this._msgHandler = e;
          this._contentLength = null;
          this._fullRequestReader = null;
          this._rangeRequestReaders = [];
        }
        getFullReader() {
          r.assert(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once.");
          this._fullRequestReader = new i(this._msgHandler);
          return this._fullRequestReader;
        }
        getRangeReader(e, t) {
          let a = new n(e, t, this._msgHandler);
          this._rangeRequestReaders.push(a);
          return a;
        }
        cancelAllRequests(e) {
          for (let t of (this._fullRequestReader && this._fullRequestReader.cancel(e), this._rangeRequestReaders.slice(0))) t.cancel(e);
        }
      };
      class i {
        constructor(e) {
          this._msgHandler = e;
          this.onProgress = null;
          this._contentLength = null;
          this._isRangeSupported = !1;
          this._isStreamingSupported = !1;
          let t = this._msgHandler.sendWithStream("GetReader");
          this._reader = t.getReader();
          this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then(e => {
            this._isStreamingSupported = e.isStreamingSupported;
            this._isRangeSupported = e.isRangeSupported;
            this._contentLength = e.contentLength;
          });
        }
        get headersReady() {
          return this._headersReady;
        }
        get contentLength() {
          return this._contentLength;
        }
        get isStreamingSupported() {
          return this._isStreamingSupported;
        }
        get isRangeSupported() {
          return this._isRangeSupported;
        }
        async read() {
          let {
            value,
            done
          } = await this._reader.read();
          return done ? {
            value: void 0,
            done: !0
          } : {
            value: value.buffer,
            done: !1
          };
        }
        cancel(e) {
          this._reader.cancel(e);
        }
      }
      class n {
        constructor(e, t, a) {
          this._msgHandler = a;
          this.onProgress = null;
          let r = this._msgHandler.sendWithStream("GetRangeReader", {
            begin: e,
            end: t
          });
          this._reader = r.getReader();
        }
        get isStreamingSupported() {
          return !1;
        }
        async read() {
          let {
            value,
            done
          } = await this._reader.read();
          return done ? {
            value: void 0,
            done: !0
          } : {
            value: value.buffer,
            done: !1
          };
        }
        cancel(e) {
          this._reader.cancel(e);
        }
      }
    }];
    var a = {};
    function r(e) {
      var i = a[e];
      if (void 0 !== i) return i.exports;
      var n = a[e] = {
        exports: {}
      };
      t[e](n, n.exports, r);
      return n.exports;
    }
    r.d = (e, t) => {
      for (var a in t) r.o(t, a) && !r.o(e, a) && Object.defineProperty(e, a, {
        enumerable: !0,
        get: t[a]
      });
    };
    r.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
    r.r = e => {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
      });
      Object.defineProperty(e, "__esModule", {
        value: !0
      });
    };
    var i = {};
    Object.defineProperty(i, "__esModule", {
      value: !0
    });
    Object.defineProperty(i, "WorkerMessageHandler", {
      enumerable: !0,
      get: function () {
        return e.WorkerMessageHandler;
      }
    });
    e = r(1);
    return i;
  })();
};
module.exports = t(); 
